/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 45);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var g;

// This works in non-strict mode
g = function () {
	return this;
}();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
	// This works if the window reference is available
	if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
    return [];
};

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () {
    return '/';
};
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function () {
    return 0;
};

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __webpack_require__(67);
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome && 'undefined' != typeof chrome.storage ? chrome.storage.local : localstorage();

/**
 * Colors.
 */

exports.colors = ['lightseagreen', 'forestgreen', 'goldenrod', 'dodgerblue', 'darkorchid', 'crimson'];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance ||
  // is firebug? http://stackoverflow.com/a/398120/376773
  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) ||
  // is firefox >= v31?
  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 ||
  // double check webkit in userAgent just in case we are in a worker
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function (v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit');

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function (match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === (typeof console === 'undefined' ? 'undefined' : _typeof(console)) && console.log && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch (e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch (e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

if (process.env.NODE_ENV === 'production') {
  module.exports = __webpack_require__(47);
} else {
  module.exports = __webpack_require__(48);
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
var emptyFunction = function emptyFunction() {};

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function () {
  return this;
};
emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

module.exports = emptyFunction;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function (useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if (item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function (modules, mediaQuery) {
		if (typeof modules === "string") modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for (var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if (typeof id === "number") alreadyImportedModules[id] = true;
		}
		for (i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if (typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if (mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if (mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */';
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getElement = (function (fn) {
	var memo = {};

	return function(selector) {
		if (typeof memo[selector] === "undefined") {
			var styleTarget = fn.call(this, selector);
			// Special case to return head of iframe instead of iframe itself
			if (styleTarget instanceof window.HTMLIFrameElement) {
				try {
					// This will throw an exception if access to iframe is blocked
					// due to cross-origin restrictions
					styleTarget = styleTarget.contentDocument.head;
				} catch(e) {
					styleTarget = null;
				}
			}
			memo[selector] = styleTarget;
		}
		return memo[selector]
	};
})(function (target) {
	return document.querySelector(target)
});

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(60);

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
	if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else if (typeof options.insertAt === "object" && options.insertAt.before) {
		var nextSibling = getElement(options.insertInto + " " + options.insertAt.before);
		target.insertBefore(style, nextSibling);
	} else {
		throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	options.attrs.type = "text/css";

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	options.attrs.type = "text/css";
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = options.transform(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Expose `Emitter`.
 */

if (true) {
  module.exports = Emitter;
}

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on = Emitter.prototype.addEventListener = function (event, fn) {
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || []).push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function (event, fn) {
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function (event, fn) {
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function (event) {
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1),
      callbacks = this._callbacks['$' + event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function (event) {
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function (event) {
  return !!this.listeners(event).length;
};

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

/**
 * Module dependencies.
 */

var keys = __webpack_require__(76);
var hasBinary = __webpack_require__(30);
var sliceBuffer = __webpack_require__(77);
var after = __webpack_require__(78);
var utf8 = __webpack_require__(79);

var base64encoder;
if (global && global.ArrayBuffer) {
  base64encoder = __webpack_require__(81);
}

/**
 * Check if we are running an android browser. That requires us to use
 * ArrayBuffer with polling transports...
 *
 * http://ghinda.net/jpeg-blob-ajax-android/
 */

var isAndroid = typeof navigator !== 'undefined' && /Android/i.test(navigator.userAgent);

/**
 * Check if we are running in PhantomJS.
 * Uploading a Blob with PhantomJS does not work correctly, as reported here:
 * https://github.com/ariya/phantomjs/issues/11395
 * @type boolean
 */
var isPhantomJS = typeof navigator !== 'undefined' && /PhantomJS/i.test(navigator.userAgent);

/**
 * When true, avoids using Blobs to encode payloads.
 * @type boolean
 */
var dontSendBlobs = isAndroid || isPhantomJS;

/**
 * Current protocol version.
 */

exports.protocol = 3;

/**
 * Packet types.
 */

var packets = exports.packets = {
  open: 0 // non-ws
  , close: 1 // non-ws
  , ping: 2,
  pong: 3,
  message: 4,
  upgrade: 5,
  noop: 6
};

var packetslist = keys(packets);

/**
 * Premade error packet.
 */

var err = { type: 'error', data: 'parser error' };

/**
 * Create a blob api even for blob builder when vendor prefixes exist
 */

var Blob = __webpack_require__(82);

/**
 * Encodes a packet.
 *
 *     <packet type id> [ <data> ]
 *
 * Example:
 *
 *     5hello world
 *     3
 *     4
 *
 * Binary is encoded in an identical principle
 *
 * @api private
 */

exports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {
  if (typeof supportsBinary === 'function') {
    callback = supportsBinary;
    supportsBinary = false;
  }

  if (typeof utf8encode === 'function') {
    callback = utf8encode;
    utf8encode = null;
  }

  var data = packet.data === undefined ? undefined : packet.data.buffer || packet.data;

  if (global.ArrayBuffer && data instanceof ArrayBuffer) {
    return encodeArrayBuffer(packet, supportsBinary, callback);
  } else if (Blob && data instanceof global.Blob) {
    return encodeBlob(packet, supportsBinary, callback);
  }

  // might be an object with { base64: true, data: dataAsBase64String }
  if (data && data.base64) {
    return encodeBase64Object(packet, callback);
  }

  // Sending data as a utf-8 string
  var encoded = packets[packet.type];

  // data fragment is optional
  if (undefined !== packet.data) {
    encoded += utf8encode ? utf8.encode(String(packet.data), { strict: false }) : String(packet.data);
  }

  return callback('' + encoded);
};

function encodeBase64Object(packet, callback) {
  // packet data is an object { base64: true, data: dataAsBase64String }
  var message = 'b' + exports.packets[packet.type] + packet.data.data;
  return callback(message);
}

/**
 * Encode packet helpers for binary types
 */

function encodeArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var data = packet.data;
  var contentArray = new Uint8Array(data);
  var resultBuffer = new Uint8Array(1 + data.byteLength);

  resultBuffer[0] = packets[packet.type];
  for (var i = 0; i < contentArray.length; i++) {
    resultBuffer[i + 1] = contentArray[i];
  }

  return callback(resultBuffer.buffer);
}

function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var fr = new FileReader();
  fr.onload = function () {
    packet.data = fr.result;
    exports.encodePacket(packet, supportsBinary, true, callback);
  };
  return fr.readAsArrayBuffer(packet.data);
}

function encodeBlob(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  if (dontSendBlobs) {
    return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
  }

  var length = new Uint8Array(1);
  length[0] = packets[packet.type];
  var blob = new Blob([length.buffer, packet.data]);

  return callback(blob);
}

/**
 * Encodes a packet with binary data in a base64 string
 *
 * @param {Object} packet, has `type` and `data`
 * @return {String} base64 encoded message
 */

exports.encodeBase64Packet = function (packet, callback) {
  var message = 'b' + exports.packets[packet.type];
  if (Blob && packet.data instanceof global.Blob) {
    var fr = new FileReader();
    fr.onload = function () {
      var b64 = fr.result.split(',')[1];
      callback(message + b64);
    };
    return fr.readAsDataURL(packet.data);
  }

  var b64data;
  try {
    b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
  } catch (e) {
    // iPhone Safari doesn't let you apply with typed arrays
    var typed = new Uint8Array(packet.data);
    var basic = new Array(typed.length);
    for (var i = 0; i < typed.length; i++) {
      basic[i] = typed[i];
    }
    b64data = String.fromCharCode.apply(null, basic);
  }
  message += global.btoa(b64data);
  return callback(message);
};

/**
 * Decodes a packet. Changes format to Blob if requested.
 *
 * @return {Object} with `type` and `data` (if any)
 * @api private
 */

exports.decodePacket = function (data, binaryType, utf8decode) {
  if (data === undefined) {
    return err;
  }
  // String data
  if (typeof data === 'string') {
    if (data.charAt(0) === 'b') {
      return exports.decodeBase64Packet(data.substr(1), binaryType);
    }

    if (utf8decode) {
      data = tryDecode(data);
      if (data === false) {
        return err;
      }
    }
    var type = data.charAt(0);

    if (Number(type) != type || !packetslist[type]) {
      return err;
    }

    if (data.length > 1) {
      return { type: packetslist[type], data: data.substring(1) };
    } else {
      return { type: packetslist[type] };
    }
  }

  var asArray = new Uint8Array(data);
  var type = asArray[0];
  var rest = sliceBuffer(data, 1);
  if (Blob && binaryType === 'blob') {
    rest = new Blob([rest]);
  }
  return { type: packetslist[type], data: rest };
};

function tryDecode(data) {
  try {
    data = utf8.decode(data, { strict: false });
  } catch (e) {
    return false;
  }
  return data;
}

/**
 * Decodes a packet encoded in a base64 string
 *
 * @param {String} base64 encoded message
 * @return {Object} with `type` and `data` (if any)
 */

exports.decodeBase64Packet = function (msg, binaryType) {
  var type = packetslist[msg.charAt(0)];
  if (!base64encoder) {
    return { type: type, data: { base64: true, data: msg.substr(1) } };
  }

  var data = base64encoder.decode(msg.substr(1));

  if (binaryType === 'blob' && Blob) {
    data = new Blob([data]);
  }

  return { type: type, data: data };
};

/**
 * Encodes multiple messages (payload).
 *
 *     <length>:data
 *
 * Example:
 *
 *     11:hello world2:hi
 *
 * If any contents are binary, they will be encoded as base64 strings. Base64
 * encoded strings are marked with a b before the length specifier
 *
 * @param {Array} packets
 * @api private
 */

exports.encodePayload = function (packets, supportsBinary, callback) {
  if (typeof supportsBinary === 'function') {
    callback = supportsBinary;
    supportsBinary = null;
  }

  var isBinary = hasBinary(packets);

  if (supportsBinary && isBinary) {
    if (Blob && !dontSendBlobs) {
      return exports.encodePayloadAsBlob(packets, callback);
    }

    return exports.encodePayloadAsArrayBuffer(packets, callback);
  }

  if (!packets.length) {
    return callback('0:');
  }

  function setLengthHeader(message) {
    return message.length + ':' + message;
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, !isBinary ? false : supportsBinary, false, function (message) {
      doneCallback(null, setLengthHeader(message));
    });
  }

  map(packets, encodeOne, function (err, results) {
    return callback(results.join(''));
  });
};

/**
 * Async array map using after
 */

function map(ary, each, done) {
  var result = new Array(ary.length);
  var next = after(ary.length, done);

  var eachWithIndex = function eachWithIndex(i, el, cb) {
    each(el, function (error, msg) {
      result[i] = msg;
      cb(error, result);
    });
  };

  for (var i = 0; i < ary.length; i++) {
    eachWithIndex(i, ary[i], next);
  }
}

/*
 * Decodes data when a payload is maybe expected. Possible binary contents are
 * decoded from their base64 representation
 *
 * @param {String} data, callback method
 * @api public
 */

exports.decodePayload = function (data, binaryType, callback) {
  if (typeof data !== 'string') {
    return exports.decodePayloadAsBinary(data, binaryType, callback);
  }

  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var packet;
  if (data === '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

  var length = '',
      n,
      msg;

  for (var i = 0, l = data.length; i < l; i++) {
    var chr = data.charAt(i);

    if (chr !== ':') {
      length += chr;
      continue;
    }

    if (length === '' || length != (n = Number(length))) {
      // parser error - ignoring payload
      return callback(err, 0, 1);
    }

    msg = data.substr(i + 1, n);

    if (length != msg.length) {
      // parser error - ignoring payload
      return callback(err, 0, 1);
    }

    if (msg.length) {
      packet = exports.decodePacket(msg, binaryType, false);

      if (err.type === packet.type && err.data === packet.data) {
        // parser error in individual packet - ignoring payload
        return callback(err, 0, 1);
      }

      var ret = callback(packet, i + n, l);
      if (false === ret) return;
    }

    // advance cursor
    i += n;
    length = '';
  }

  if (length !== '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }
};

/**
 * Encodes multiple messages (payload) as binary.
 *
 * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number
 * 255><data>
 *
 * Example:
 * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
 *
 * @param {Array} packets
 * @return {ArrayBuffer} encoded payload
 * @api private
 */

exports.encodePayloadAsArrayBuffer = function (packets, callback) {
  if (!packets.length) {
    return callback(new ArrayBuffer(0));
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, true, function (data) {
      return doneCallback(null, data);
    });
  }

  map(packets, encodeOne, function (err, encodedPackets) {
    var totalLength = encodedPackets.reduce(function (acc, p) {
      var len;
      if (typeof p === 'string') {
        len = p.length;
      } else {
        len = p.byteLength;
      }
      return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2
    }, 0);

    var resultArray = new Uint8Array(totalLength);

    var bufferIndex = 0;
    encodedPackets.forEach(function (p) {
      var isString = typeof p === 'string';
      var ab = p;
      if (isString) {
        var view = new Uint8Array(p.length);
        for (var i = 0; i < p.length; i++) {
          view[i] = p.charCodeAt(i);
        }
        ab = view.buffer;
      }

      if (isString) {
        // not true binary
        resultArray[bufferIndex++] = 0;
      } else {
        // true binary
        resultArray[bufferIndex++] = 1;
      }

      var lenStr = ab.byteLength.toString();
      for (var i = 0; i < lenStr.length; i++) {
        resultArray[bufferIndex++] = parseInt(lenStr[i]);
      }
      resultArray[bufferIndex++] = 255;

      var view = new Uint8Array(ab);
      for (var i = 0; i < view.length; i++) {
        resultArray[bufferIndex++] = view[i];
      }
    });

    return callback(resultArray.buffer);
  });
};

/**
 * Encode as Blob
 */

exports.encodePayloadAsBlob = function (packets, callback) {
  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, true, function (encoded) {
      var binaryIdentifier = new Uint8Array(1);
      binaryIdentifier[0] = 1;
      if (typeof encoded === 'string') {
        var view = new Uint8Array(encoded.length);
        for (var i = 0; i < encoded.length; i++) {
          view[i] = encoded.charCodeAt(i);
        }
        encoded = view.buffer;
        binaryIdentifier[0] = 0;
      }

      var len = encoded instanceof ArrayBuffer ? encoded.byteLength : encoded.size;

      var lenStr = len.toString();
      var lengthAry = new Uint8Array(lenStr.length + 1);
      for (var i = 0; i < lenStr.length; i++) {
        lengthAry[i] = parseInt(lenStr[i]);
      }
      lengthAry[lenStr.length] = 255;

      if (Blob) {
        var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);
        doneCallback(null, blob);
      }
    });
  }

  map(packets, encodeOne, function (err, results) {
    return callback(new Blob(results));
  });
};

/*
 * Decodes data when a payload is maybe expected. Strings are decoded by
 * interpreting each byte as a key code for entries marked to start with 0. See
 * description of encodePayloadAsBinary
 *
 * @param {ArrayBuffer} data, callback method
 * @api public
 */

exports.decodePayloadAsBinary = function (data, binaryType, callback) {
  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var bufferTail = data;
  var buffers = [];

  while (bufferTail.byteLength > 0) {
    var tailArray = new Uint8Array(bufferTail);
    var isString = tailArray[0] === 0;
    var msgLength = '';

    for (var i = 1;; i++) {
      if (tailArray[i] === 255) break;

      // 310 = char length of Number.MAX_VALUE
      if (msgLength.length > 310) {
        return callback(err, 0, 1);
      }

      msgLength += tailArray[i];
    }

    bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);
    msgLength = parseInt(msgLength);

    var msg = sliceBuffer(bufferTail, 0, msgLength);
    if (isString) {
      try {
        msg = String.fromCharCode.apply(null, new Uint8Array(msg));
      } catch (e) {
        // iPhone Safari doesn't let you apply to typed arrays
        var typed = new Uint8Array(msg);
        msg = '';
        for (var i = 0; i < typed.length; i++) {
          msg += String.fromCharCode(typed[i]);
        }
      }
    }

    buffers.push(msg);
    bufferTail = sliceBuffer(bufferTail, msgLength);
  }

  var total = buffers.length;
  buffers.forEach(function (buffer, i) {
    callback(exports.decodePacket(buffer, binaryType, true), i, total);
  });
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */

var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc'); // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var emptyObject = {};

if (process.env.NODE_ENV !== 'production') {
  Object.freeze(emptyObject);
}

module.exports = emptyObject;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Compiles a querystring
 * Returns string representation of the object
 *
 * @param {Object}
 * @api private
 */

exports.encode = function (obj) {
  var str = '';

  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      if (str.length) str += '&';
      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
    }
  }

  return str;
};

/**
 * Parses a simple querystring into an object
 *
 * @param {String} qs
 * @api private
 */

exports.decode = function (qs) {
  var qry = {};
  var pairs = qs.split('&');
  for (var i = 0, l = pairs.length; i < l; i++) {
    var pair = pairs[i].split('=');
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
};

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (a, b) {
  var fn = function fn() {};
  fn.prototype = b.prototype;
  a.prototype = new fn();
  a.prototype.constructor = a;
};

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var validateFormat = function validateFormat(format) {};

if (process.env.NODE_ENV !== 'production') {
  validateFormat = function validateFormat(format) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  };
}

function invariant(condition, format, a, b, c, d, e, f) {
  validateFormat(format);

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
}

module.exports = invariant;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var emptyFunction = __webpack_require__(4);

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = emptyFunction;

if (process.env.NODE_ENV !== 'production') {
  var printWarning = function printWarning(format) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  warning = function warning(condition, format) {
    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }

    if (format.indexOf('Failed Composite propType: ') === 0) {
      return; // Ignore CompositeComponent proptype check.
    }

    if (!condition) {
      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(undefined, [format].concat(args));
    }
  };
}

module.exports = warning;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _socket = __webpack_require__(65);

var _socket2 = _interopRequireDefault(_socket);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ConnectionManager = function () {
  function ConnectionManager() {
    _classCallCheck(this, ConnectionManager);
  }

  _createClass(ConnectionManager, null, [{
    key: 'open',
    value: function open() {
      ConnectionManager.socket = _socket2.default.connect('http://localhost:3000');
    }
  }, {
    key: 'getConnection',
    value: function getConnection() {
      return ConnectionManager.socket;
    }
  }, {
    key: 'close',
    value: function close() {
      // TODO connectionをcloseするAPIを叩く
      ConnectionManager.socket.disconnect();
    }
  }]);

  return ConnectionManager;
}();

exports.default = ConnectionManager;


ConnectionManager.socket = null;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Module dependencies.
 */

var debug = __webpack_require__(2)('socket.io-parser');
var Emitter = __webpack_require__(7);
var hasBin = __webpack_require__(30);
var binary = __webpack_require__(70);
var isBuf = __webpack_require__(31);

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = 4;

/**
 * Packet types.
 *
 * @api public
 */

exports.types = ['CONNECT', 'DISCONNECT', 'EVENT', 'ACK', 'ERROR', 'BINARY_EVENT', 'BINARY_ACK'];

/**
 * Packet type `connect`.
 *
 * @api public
 */

exports.CONNECT = 0;

/**
 * Packet type `disconnect`.
 *
 * @api public
 */

exports.DISCONNECT = 1;

/**
 * Packet type `event`.
 *
 * @api public
 */

exports.EVENT = 2;

/**
 * Packet type `ack`.
 *
 * @api public
 */

exports.ACK = 3;

/**
 * Packet type `error`.
 *
 * @api public
 */

exports.ERROR = 4;

/**
 * Packet type 'binary event'
 *
 * @api public
 */

exports.BINARY_EVENT = 5;

/**
 * Packet type `binary ack`. For acks with binary arguments.
 *
 * @api public
 */

exports.BINARY_ACK = 6;

/**
 * Encoder constructor.
 *
 * @api public
 */

exports.Encoder = Encoder;

/**
 * Decoder constructor.
 *
 * @api public
 */

exports.Decoder = Decoder;

/**
 * A socket.io Encoder instance
 *
 * @api public
 */

function Encoder() {}

/**
 * Encode a packet as a single string if non-binary, or as a
 * buffer sequence, depending on packet type.
 *
 * @param {Object} obj - packet object
 * @param {Function} callback - function to handle encodings (likely engine.write)
 * @return Calls callback with Array of encodings
 * @api public
 */

Encoder.prototype.encode = function (obj, callback) {
  if ((obj.type === exports.EVENT || obj.type === exports.ACK) && hasBin(obj.data)) {
    obj.type = obj.type === exports.EVENT ? exports.BINARY_EVENT : exports.BINARY_ACK;
  }

  debug('encoding packet %j', obj);

  if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {
    encodeAsBinary(obj, callback);
  } else {
    var encoding = encodeAsString(obj);
    callback([encoding]);
  }
};

/**
 * Encode packet as string.
 *
 * @param {Object} packet
 * @return {String} encoded
 * @api private
 */

function encodeAsString(obj) {

  // first is type
  var str = '' + obj.type;

  // attachments if we have them
  if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {
    str += obj.attachments + '-';
  }

  // if we have a namespace other than `/`
  // we append it followed by a comma `,`
  if (obj.nsp && '/' !== obj.nsp) {
    str += obj.nsp + ',';
  }

  // immediately followed by the id
  if (null != obj.id) {
    str += obj.id;
  }

  // json data
  if (null != obj.data) {
    str += JSON.stringify(obj.data);
  }

  debug('encoded %j as %s', obj, str);
  return str;
}

/**
 * Encode packet as 'buffer sequence' by removing blobs, and
 * deconstructing packet into object with placeholders and
 * a list of buffers.
 *
 * @param {Object} packet
 * @return {Buffer} encoded
 * @api private
 */

function encodeAsBinary(obj, callback) {

  function writeEncoding(bloblessData) {
    var deconstruction = binary.deconstructPacket(bloblessData);
    var pack = encodeAsString(deconstruction.packet);
    var buffers = deconstruction.buffers;

    buffers.unshift(pack); // add packet info to beginning of data list
    callback(buffers); // write all the buffers
  }

  binary.removeBlobs(obj, writeEncoding);
}

/**
 * A socket.io Decoder instance
 *
 * @return {Object} decoder
 * @api public
 */

function Decoder() {
  this.reconstructor = null;
}

/**
 * Mix in `Emitter` with Decoder.
 */

Emitter(Decoder.prototype);

/**
 * Decodes an ecoded packet string into packet JSON.
 *
 * @param {String} obj - encoded packet
 * @return {Object} packet
 * @api public
 */

Decoder.prototype.add = function (obj) {
  var packet;
  if (typeof obj === 'string') {
    packet = decodeString(obj);
    if (exports.BINARY_EVENT === packet.type || exports.BINARY_ACK === packet.type) {
      // binary packet's json
      this.reconstructor = new BinaryReconstructor(packet);

      // no attachments, labeled binary but no binary data to follow
      if (this.reconstructor.reconPack.attachments === 0) {
        this.emit('decoded', packet);
      }
    } else {
      // non-binary full packet
      this.emit('decoded', packet);
    }
  } else if (isBuf(obj) || obj.base64) {
    // raw binary data
    if (!this.reconstructor) {
      throw new Error('got binary data when not reconstructing a packet');
    } else {
      packet = this.reconstructor.takeBinaryData(obj);
      if (packet) {
        // received final buffer
        this.reconstructor = null;
        this.emit('decoded', packet);
      }
    }
  } else {
    throw new Error('Unknown type: ' + obj);
  }
};

/**
 * Decode a packet String (JSON data)
 *
 * @param {String} str
 * @return {Object} packet
 * @api private
 */

function decodeString(str) {
  var i = 0;
  // look up type
  var p = {
    type: Number(str.charAt(0))
  };

  if (null == exports.types[p.type]) return error();

  // look up attachments if type binary
  if (exports.BINARY_EVENT === p.type || exports.BINARY_ACK === p.type) {
    var buf = '';
    while (str.charAt(++i) !== '-') {
      buf += str.charAt(i);
      if (i == str.length) break;
    }
    if (buf != Number(buf) || str.charAt(i) !== '-') {
      throw new Error('Illegal attachments');
    }
    p.attachments = Number(buf);
  }

  // look up namespace (if any)
  if ('/' === str.charAt(i + 1)) {
    p.nsp = '';
    while (++i) {
      var c = str.charAt(i);
      if (',' === c) break;
      p.nsp += c;
      if (i === str.length) break;
    }
  } else {
    p.nsp = '/';
  }

  // look up id
  var next = str.charAt(i + 1);
  if ('' !== next && Number(next) == next) {
    p.id = '';
    while (++i) {
      var c = str.charAt(i);
      if (null == c || Number(c) != c) {
        --i;
        break;
      }
      p.id += str.charAt(i);
      if (i === str.length) break;
    }
    p.id = Number(p.id);
  }

  // look up json data
  if (str.charAt(++i)) {
    p = tryParse(p, str.substr(i));
  }

  debug('decoded %s as %j', str, p);
  return p;
}

function tryParse(p, str) {
  try {
    p.data = JSON.parse(str);
  } catch (e) {
    return error();
  }
  return p;
}

/**
 * Deallocates a parser's resources
 *
 * @api public
 */

Decoder.prototype.destroy = function () {
  if (this.reconstructor) {
    this.reconstructor.finishedReconstruction();
  }
};

/**
 * A manager of a binary event's 'buffer sequence'. Should
 * be constructed whenever a packet of type BINARY_EVENT is
 * decoded.
 *
 * @param {Object} packet
 * @return {BinaryReconstructor} initialized reconstructor
 * @api private
 */

function BinaryReconstructor(packet) {
  this.reconPack = packet;
  this.buffers = [];
}

/**
 * Method to be called when binary data received from connection
 * after a BINARY_EVENT packet.
 *
 * @param {Buffer | ArrayBuffer} binData - the raw binary data received
 * @return {null | Object} returns null if more binary data is expected or
 *   a reconstructed packet object if all buffers have been received.
 * @api private
 */

BinaryReconstructor.prototype.takeBinaryData = function (binData) {
  this.buffers.push(binData);
  if (this.buffers.length === this.reconPack.attachments) {
    // done with buffer list
    var packet = binary.reconstructPacket(this.reconPack, this.buffers);
    this.finishedReconstruction();
    return packet;
  }
  return null;
};

/**
 * Cleans up binary packet reconstruction variables.
 *
 * @api private
 */

BinaryReconstructor.prototype.finishedReconstruction = function () {
  this.reconPack = null;
  this.buffers = [];
};

function error() {
  return {
    type: exports.ERROR,
    data: 'parser error'
  };
}

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

// browser shim for xmlhttprequest module

var hasCORS = __webpack_require__(74);

module.exports = function (opts) {
  var xdomain = opts.xdomain;

  // scheme must be same when usign XDomainRequest
  // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx
  var xscheme = opts.xscheme;

  // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.
  // https://github.com/Automattic/engine.io-client/pull/217
  var enablesXDR = opts.enablesXDR;

  // XMLHttpRequest can be disabled on IE
  try {
    if ('undefined' !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {
      return new XMLHttpRequest();
    }
  } catch (e) {}

  // Use XDomainRequest for IE8 if enablesXDR is true
  // because loading bar keeps flashing when using jsonp-polling
  // https://github.com/yujiosaka/socke.io-ie8-loading-example
  try {
    if ('undefined' !== typeof XDomainRequest && !xscheme && enablesXDR) {
      return new XDomainRequest();
    }
  } catch (e) {}

  if (!xdomain) {
    try {
      return new global[['Active'].concat('Object').join('X')]('Microsoft.XMLHTTP');
    } catch (e) {}
  }
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Module dependencies.
 */

var parser = __webpack_require__(8);
var Emitter = __webpack_require__(7);

/**
 * Module exports.
 */

module.exports = Transport;

/**
 * Transport abstract constructor.
 *
 * @param {Object} options.
 * @api private
 */

function Transport(opts) {
  this.path = opts.path;
  this.hostname = opts.hostname;
  this.port = opts.port;
  this.secure = opts.secure;
  this.query = opts.query;
  this.timestampParam = opts.timestampParam;
  this.timestampRequests = opts.timestampRequests;
  this.readyState = '';
  this.agent = opts.agent || false;
  this.socket = opts.socket;
  this.enablesXDR = opts.enablesXDR;

  // SSL options for Node.js client
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;
  this.forceNode = opts.forceNode;

  // other options for Node.js client
  this.extraHeaders = opts.extraHeaders;
  this.localAddress = opts.localAddress;
}

/**
 * Mix in `Emitter`.
 */

Emitter(Transport.prototype);

/**
 * Emits an error.
 *
 * @param {String} str
 * @return {Transport} for chaining
 * @api public
 */

Transport.prototype.onError = function (msg, desc) {
  var err = new Error(msg);
  err.type = 'TransportError';
  err.description = desc;
  this.emit('error', err);
  return this;
};

/**
 * Opens the transport.
 *
 * @api public
 */

Transport.prototype.open = function () {
  if ('closed' === this.readyState || '' === this.readyState) {
    this.readyState = 'opening';
    this.doOpen();
  }

  return this;
};

/**
 * Closes the transport.
 *
 * @api private
 */

Transport.prototype.close = function () {
  if ('opening' === this.readyState || 'open' === this.readyState) {
    this.doClose();
    this.onClose();
  }

  return this;
};

/**
 * Sends multiple packets.
 *
 * @param {Array} packets
 * @api private
 */

Transport.prototype.send = function (packets) {
  if ('open' === this.readyState) {
    this.write(packets);
  } else {
    throw new Error('Transport not open');
  }
};

/**
 * Called upon open
 *
 * @api private
 */

Transport.prototype.onOpen = function () {
  this.readyState = 'open';
  this.writable = true;
  this.emit('open');
};

/**
 * Called with data.
 *
 * @param {String} data
 * @api private
 */

Transport.prototype.onData = function (data) {
  var packet = parser.decodePacket(data, this.socket.binaryType);
  this.onPacket(packet);
};

/**
 * Called with a decoded packet.
 */

Transport.prototype.onPacket = function (packet) {
  this.emit('packet', packet);
};

/**
 * Called upon close.
 *
 * @api private
 */

Transport.prototype.onClose = function () {
  this.readyState = 'closed';
  this.emit('close');
};

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

if (process.env.NODE_ENV !== 'production') {
  var invariant = __webpack_require__(13);
  var warning = __webpack_require__(14);
  var ReactPropTypesSecret = __webpack_require__(49);
  var loggedTypeFailures = {};
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (process.env.NODE_ENV !== 'production') {
    for (var typeSpecName in typeSpecs) {
      if (typeSpecs.hasOwnProperty(typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          invariant(typeof typeSpecs[typeSpecName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'the `prop-types` package, but received `%s`.', componentName || 'React class', location, typeSpecName, _typeof(typeSpecs[typeSpecName]));
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error === 'undefined' ? 'undefined' : _typeof(error));
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          warning(false, 'Failed %s type: %s%s', location, error.message, stack != null ? stack : '');
        }
      }
    }
  }
}

module.exports = checkPropTypes;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

function checkDCE() {
  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function') {
    return;
  }
  if (process.env.NODE_ENV !== 'production') {
    // This branch is unreachable because this function is only called
    // in production, but the condition is true only in development.
    // Therefore if the branch is still here, dead code elimination wasn't
    // properly applied.
    // Don't change the message. React DevTools relies on it. Also make sure
    // this message doesn't occur elsewhere in this function, or it will cause
    // a false positive.
    throw new Error('^_^');
  }
  try {
    // Verify that the code above has been dead code eliminated (DCE'd).
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    // DevTools shouldn't crash React, no matter what.
    // We should still report in case we break this code.
    console.error(err);
  }
}

if (process.env.NODE_ENV === 'production') {
  // DCE check should happen before ReactDOM bundle executes so that
  // DevTools can report bad minification during injection.
  checkDCE();
  module.exports = __webpack_require__(50);
} else {
  module.exports = __webpack_require__(53);
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

/**
 * Simple, lightweight module assisting with the detection and context of
 * Worker. Helps avoid circular dependencies and allows code to reason about
 * whether or not they are in a Worker, even if they never include the main
 * `ReactWorker` dependency.
 */
var ExecutionEnvironment = {

  canUseDOM: canUseDOM,

  canUseWorkers: typeof Worker !== 'undefined',

  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),

  canUseViewport: canUseDOM && !!window.screen,

  isInWorker: !canUseDOM // For now, this is true - might change in the future.

};

module.exports = ExecutionEnvironment;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var emptyFunction = __webpack_require__(4);

/**
 * Upstream version of event listener. Does not take into account specific
 * nature of platform.
 */
var EventListener = {
  /**
   * Listen to DOM events during the bubble phase.
   *
   * @param {DOMEventTarget} target DOM element to register listener on.
   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
   * @param {function} callback Callback function.
   * @return {object} Object with a `remove` method.
   */
  listen: function listen(target, eventType, callback) {
    if (target.addEventListener) {
      target.addEventListener(eventType, callback, false);
      return {
        remove: function remove() {
          target.removeEventListener(eventType, callback, false);
        }
      };
    } else if (target.attachEvent) {
      target.attachEvent('on' + eventType, callback);
      return {
        remove: function remove() {
          target.detachEvent('on' + eventType, callback);
        }
      };
    }
  },

  /**
   * Listen to DOM events during the capture phase.
   *
   * @param {DOMEventTarget} target DOM element to register listener on.
   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
   * @param {function} callback Callback function.
   * @return {object} Object with a `remove` method.
   */
  capture: function capture(target, eventType, callback) {
    if (target.addEventListener) {
      target.addEventListener(eventType, callback, true);
      return {
        remove: function remove() {
          target.removeEventListener(eventType, callback, true);
        }
      };
    } else {
      if (process.env.NODE_ENV !== 'production') {
        console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
      }
      return {
        remove: emptyFunction
      };
    }
  },

  registerDefault: function registerDefault() {}
};

module.exports = EventListener;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

/* eslint-disable fb-www/typeof-undefined */

/**
 * Same as document.activeElement but wraps in a try-catch block. In IE it is
 * not safe to call document.activeElement if there is nothing focused.
 *
 * The activeElement will be null only if the document or document body is not
 * yet defined.
 *
 * @param {?DOMDocument} doc Defaults to current document.
 * @return {?DOMElement}
 */

function getActiveElement(doc) /*?DOMElement*/{
  doc = doc || (typeof document !== 'undefined' ? document : undefined);
  if (typeof doc === 'undefined') {
    return null;
  }
  try {
    return doc.activeElement || doc.body;
  } catch (e) {
    return doc.body;
  }
}

module.exports = getActiveElement;

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 * 
 */

/*eslint-disable no-self-compare */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var hasOwnProperty = Object.prototype.hasOwnProperty;

/**
 * inlined Object.is polyfill to avoid requiring consumers ship their own
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 */
function is(x, y) {
  // SameValue algorithm
  if (x === y) {
    // Steps 1-5, 7-10
    // Steps 6.b-6.e: +0 != -0
    // Added the nonzero y check to make Flow happy, but it is redundant
    return x !== 0 || y !== 0 || 1 / x === 1 / y;
  } else {
    // Step 6.a: NaN == NaN
    return x !== x && y !== y;
  }
}

/**
 * Performs equality by iterating through keys on an object and returning false
 * when any key has values which are not strictly equal between the arguments.
 * Returns true when the values of all keys are strictly equal.
 */
function shallowEqual(objA, objB) {
  if (is(objA, objB)) {
    return true;
  }

  if ((typeof objA === 'undefined' ? 'undefined' : _typeof(objA)) !== 'object' || objA === null || (typeof objB === 'undefined' ? 'undefined' : _typeof(objB)) !== 'object' || objB === null) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  }

  // Test for A's keys different from B.
  for (var i = 0; i < keysA.length; i++) {
    if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }

  return true;
}

module.exports = shallowEqual;

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

var isTextNode = __webpack_require__(51);

/*eslint-disable no-bitwise */

/**
 * Checks if a given DOM node contains or is another DOM node.
 */
function containsNode(outerNode, innerNode) {
  if (!outerNode || !innerNode) {
    return false;
  } else if (outerNode === innerNode) {
    return true;
  } else if (isTextNode(outerNode)) {
    return false;
  } else if (isTextNode(innerNode)) {
    return containsNode(outerNode, innerNode.parentNode);
  } else if ('contains' in outerNode) {
    return outerNode.contains(innerNode);
  } else if (outerNode.compareDocumentPosition) {
    return !!(outerNode.compareDocumentPosition(innerNode) & 16);
  } else {
    return false;
  }
}

module.exports = containsNode;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



/**
 * @param {DOMElement} node input/textarea to focus
 */

function focusNode(node) {
  // IE8 can throw "Can't move focus to the control because it is invisible,
  // not enabled, or of a type that does not accept the focus." for all kinds of
  // reasons that are too expensive and fragile to test.
  try {
    node.focus();
  } catch (e) {}
}

module.exports = focusNode;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(3);

var _react2 = _interopRequireDefault(_react);

__webpack_require__(61);

var _Header = __webpack_require__(28);

var _Header2 = _interopRequireDefault(_Header);

var _ChatArea = __webpack_require__(42);

var _ChatArea2 = _interopRequireDefault(_ChatArea);

var _ConnectionManager = __webpack_require__(15);

var _ConnectionManager2 = _interopRequireDefault(_ConnectionManager);

var _MessageHolder = __webpack_require__(94);

var _MessageHolder2 = _interopRequireDefault(_MessageHolder);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ChatApp = function (_Component) {
  _inherits(ChatApp, _Component);

  function ChatApp(props) {
    _classCallCheck(this, ChatApp);

    var _this = _possibleConstructorReturn(this, (ChatApp.__proto__ || Object.getPrototypeOf(ChatApp)).call(this, props));

    _this.state = {
      isJoin: false,
      messages: _MessageHolder2.default.getMessages(),
      users: []
    };
    _ConnectionManager2.default.open();
    _this.socket = null;
    return _this;
  }

  _createClass(ChatApp, [{
    key: 'onJoin',
    value: function onJoin() {
      this.socket = _ConnectionManager2.default.getConnection();
      this.establishWS();
      this.setState({
        isJoin: true
      });
    }
  }, {
    key: 'establishWS',
    value: function establishWS() {
      var _this2 = this;

      if (this.socket) {
        this.socket.on('message', function (message) {
          console.log('debug msg ' + message.body);
          _MessageHolder2.default.addMessage(message.name, message.colorCode, message.body);
          _this2.setState({
            messages: _MessageHolder2.default.getMessages()
          });
        });

        this.socket.on('users', function (data) {
          _this2.setState({
            users: data.users
          });
        });
      }
    }
  }, {
    key: 'onLeave',
    value: function onLeave() {
      this.socket = null;
      this.setState({
        isJoin: false,
        messages: [],
        users: []
      });
    }
  }, {
    key: 'render',
    value: function render() {
      var _this3 = this;

      return _react2.default.createElement(
        'div',
        null,
        _react2.default.createElement(_Header2.default, { onJoin: function onJoin(e) {
            return _this3.onJoin(e);
          }, onLeave: function onLeave(e) {
            return _this3.onLeave(e);
          } }),
        _react2.default.createElement(_ChatArea2.default, { isJoin: this.state.isJoin, messages: this.state.messages, users: this.state.users })
      );
    }
  }]);

  return ChatApp;
}(_react.Component);

exports.default = ChatApp;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(3);

var _react2 = _interopRequireDefault(_react);

__webpack_require__(63);

var _ConnectionManager = __webpack_require__(15);

var _ConnectionManager2 = _interopRequireDefault(_ConnectionManager);

var _User = __webpack_require__(41);

var _User2 = _interopRequireDefault(_User);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Header = function (_Component) {
  _inherits(Header, _Component);

  function Header(props) {
    _classCallCheck(this, Header);

    var _this = _possibleConstructorReturn(this, (Header.__proto__ || Object.getPrototypeOf(Header)).call(this, props));

    _this.state = {
      label: 'Join',
      login: false,
      username: ''
    };
    _this.socket = _ConnectionManager2.default.getConnection();
    return _this;
  }

  _createClass(Header, [{
    key: 'update',
    value: function update(e) {
      this.setState({ username: e.target.value });
    }
  }, {
    key: 'onStateClick',
    value: function onStateClick(e) {
      var name = this.state.username;
      if (this.state.login) {
        this.socket.emit('leave', {
          id: this.socket.id,
          name: name
        });

        this.props.onLeave();
        this.setState({
          label: 'Join',
          login: false,
          username: ''
        });
      } else {
        this.socket.emit('join', {
          id: this.socket.id,
          name: name
        });
        _User2.default.setName(name);
        this.props.onJoin();
        this.setState({
          label: 'Leave',
          login: true
        });
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      return _react2.default.createElement(
        'nav',
        { className: 'navbar navbar-inverse', role: 'navigation' },
        _react2.default.createElement(
          'div',
          { className: 'container' },
          _react2.default.createElement(
            'div',
            { className: 'navbar-header' },
            _react2.default.createElement('img', { className: 'navbar-brand app-logo', src: './favicon.ico' }),
            _react2.default.createElement(
              'span',
              { className: 'navbar-brand' },
              'React Chat'
            ),
            _react2.default.createElement('img', { className: 'navbar-brand app-logo', src: './favicon.ico' })
          ),
          _react2.default.createElement(
            'ul',
            { className: 'nav navbar-nav navbar-right' },
            function () {
              if (!_this2.state.login) {
                return _react2.default.createElement(
                  'li',
                  null,
                  _react2.default.createElement('input', { className: 'form-control username', type: 'text',
                    placeholder: 'username', onChange: function onChange(e) {
                      return _this2.update(e);
                    },
                    value: _this2.state.username })
                );
              } else {
                return _react2.default.createElement(
                  'li',
                  null,
                  _react2.default.createElement(
                    'span',
                    { className: 'navbar-brand' },
                    _this2.state.username
                  )
                );
              }
            }(),
            _react2.default.createElement(
              'li',
              null,
              _react2.default.createElement(
                'button',
                { className: 'btn btn-success navbar-btn', onClick: function onClick(e) {
                    return _this2.onStateClick(e);
                  } },
                this.state.label
              )
            )
          )
        )
      );
    }
  }]);

  return Header;
}(_react.Component);

exports.default = Header;

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Parses an URI
 *
 * @author Steven Levithan <stevenlevithan.com> (MIT license)
 * @api private
 */

var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

var parts = ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'];

module.exports = function parseuri(str) {
    var src = str,
        b = str.indexOf('['),
        e = str.indexOf(']');

    if (b != -1 && e != -1) {
        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
    }

    var m = re.exec(str || ''),
        uri = {},
        i = 14;

    while (i--) {
        uri[parts[i]] = m[i] || '';
    }

    if (b != -1 && e != -1) {
        uri.source = src;
        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
        uri.ipv6uri = true;
    }

    return uri;
};

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/* global Blob File */

/*
 * Module requirements.
 */

var isArray = __webpack_require__(69);

var toString = Object.prototype.toString;
var withNativeBlob = typeof global.Blob === 'function' || toString.call(global.Blob) === '[object BlobConstructor]';
var withNativeFile = typeof global.File === 'function' || toString.call(global.File) === '[object FileConstructor]';

/**
 * Module exports.
 */

module.exports = hasBinary;

/**
 * Checks for binary data.
 *
 * Supports Buffer, ArrayBuffer, Blob and File.
 *
 * @param {Object} anything
 * @api public
 */

function hasBinary(obj) {
  if (!obj || (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object') {
    return false;
  }

  if (isArray(obj)) {
    for (var i = 0, l = obj.length; i < l; i++) {
      if (hasBinary(obj[i])) {
        return true;
      }
    }
    return false;
  }

  if (typeof global.Buffer === 'function' && global.Buffer.isBuffer && global.Buffer.isBuffer(obj) || typeof global.ArrayBuffer === 'function' && obj instanceof ArrayBuffer || withNativeBlob && obj instanceof Blob || withNativeFile && obj instanceof File) {
    return true;
  }

  // see: https://github.com/Automattic/has-binary/pull/4
  if (obj.toJSON && typeof obj.toJSON === 'function' && arguments.length === 1) {
    return hasBinary(obj.toJSON(), true);
  }

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
      return true;
    }
  }

  return false;
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

module.exports = isBuf;

/**
 * Returns true if obj is a buffer or an arraybuffer.
 *
 * @api private
 */

function isBuf(obj) {
  return global.Buffer && global.Buffer.isBuffer(obj) || global.ArrayBuffer && obj instanceof ArrayBuffer;
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * Module dependencies.
 */

var eio = __webpack_require__(72);
var Socket = __webpack_require__(38);
var Emitter = __webpack_require__(7);
var parser = __webpack_require__(16);
var on = __webpack_require__(39);
var bind = __webpack_require__(40);
var debug = __webpack_require__(2)('socket.io-client:manager');
var indexOf = __webpack_require__(37);
var Backoff = __webpack_require__(87);

/**
 * IE6+ hasOwnProperty
 */

var has = Object.prototype.hasOwnProperty;

/**
 * Module exports
 */

module.exports = Manager;

/**
 * `Manager` constructor.
 *
 * @param {String} engine instance or engine uri/opts
 * @param {Object} options
 * @api public
 */

function Manager(uri, opts) {
  if (!(this instanceof Manager)) return new Manager(uri, opts);
  if (uri && 'object' === (typeof uri === 'undefined' ? 'undefined' : _typeof(uri))) {
    opts = uri;
    uri = undefined;
  }
  opts = opts || {};

  opts.path = opts.path || '/socket.io';
  this.nsps = {};
  this.subs = [];
  this.opts = opts;
  this.reconnection(opts.reconnection !== false);
  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
  this.reconnectionDelay(opts.reconnectionDelay || 1000);
  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
  this.randomizationFactor(opts.randomizationFactor || 0.5);
  this.backoff = new Backoff({
    min: this.reconnectionDelay(),
    max: this.reconnectionDelayMax(),
    jitter: this.randomizationFactor()
  });
  this.timeout(null == opts.timeout ? 20000 : opts.timeout);
  this.readyState = 'closed';
  this.uri = uri;
  this.connecting = [];
  this.lastPing = null;
  this.encoding = false;
  this.packetBuffer = [];
  var _parser = opts.parser || parser;
  this.encoder = new _parser.Encoder();
  this.decoder = new _parser.Decoder();
  this.autoConnect = opts.autoConnect !== false;
  if (this.autoConnect) this.open();
}

/**
 * Propagate given event to sockets and emit on `this`
 *
 * @api private
 */

Manager.prototype.emitAll = function () {
  this.emit.apply(this, arguments);
  for (var nsp in this.nsps) {
    if (has.call(this.nsps, nsp)) {
      this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
    }
  }
};

/**
 * Update `socket.id` of all sockets
 *
 * @api private
 */

Manager.prototype.updateSocketIds = function () {
  for (var nsp in this.nsps) {
    if (has.call(this.nsps, nsp)) {
      this.nsps[nsp].id = this.generateId(nsp);
    }
  }
};

/**
 * generate `socket.id` for the given `nsp`
 *
 * @param {String} nsp
 * @return {String}
 * @api private
 */

Manager.prototype.generateId = function (nsp) {
  return (nsp === '/' ? '' : nsp + '#') + this.engine.id;
};

/**
 * Mix in `Emitter`.
 */

Emitter(Manager.prototype);

/**
 * Sets the `reconnection` config.
 *
 * @param {Boolean} true/false if it should automatically reconnect
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnection = function (v) {
  if (!arguments.length) return this._reconnection;
  this._reconnection = !!v;
  return this;
};

/**
 * Sets the reconnection attempts config.
 *
 * @param {Number} max reconnection attempts before giving up
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionAttempts = function (v) {
  if (!arguments.length) return this._reconnectionAttempts;
  this._reconnectionAttempts = v;
  return this;
};

/**
 * Sets the delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelay = function (v) {
  if (!arguments.length) return this._reconnectionDelay;
  this._reconnectionDelay = v;
  this.backoff && this.backoff.setMin(v);
  return this;
};

Manager.prototype.randomizationFactor = function (v) {
  if (!arguments.length) return this._randomizationFactor;
  this._randomizationFactor = v;
  this.backoff && this.backoff.setJitter(v);
  return this;
};

/**
 * Sets the maximum delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelayMax = function (v) {
  if (!arguments.length) return this._reconnectionDelayMax;
  this._reconnectionDelayMax = v;
  this.backoff && this.backoff.setMax(v);
  return this;
};

/**
 * Sets the connection timeout. `false` to disable
 *
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.timeout = function (v) {
  if (!arguments.length) return this._timeout;
  this._timeout = v;
  return this;
};

/**
 * Starts trying to reconnect if reconnection is enabled and we have not
 * started reconnecting yet
 *
 * @api private
 */

Manager.prototype.maybeReconnectOnOpen = function () {
  // Only try to reconnect if it's the first time we're connecting
  if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {
    // keeps reconnection from firing twice for the same reconnection loop
    this.reconnect();
  }
};

/**
 * Sets the current transport `socket`.
 *
 * @param {Function} optional, callback
 * @return {Manager} self
 * @api public
 */

Manager.prototype.open = Manager.prototype.connect = function (fn, opts) {
  debug('readyState %s', this.readyState);
  if (~this.readyState.indexOf('open')) return this;

  debug('opening %s', this.uri);
  this.engine = eio(this.uri, this.opts);
  var socket = this.engine;
  var self = this;
  this.readyState = 'opening';
  this.skipReconnect = false;

  // emit `open`
  var openSub = on(socket, 'open', function () {
    self.onopen();
    fn && fn();
  });

  // emit `connect_error`
  var errorSub = on(socket, 'error', function (data) {
    debug('connect_error');
    self.cleanup();
    self.readyState = 'closed';
    self.emitAll('connect_error', data);
    if (fn) {
      var err = new Error('Connection error');
      err.data = data;
      fn(err);
    } else {
      // Only do this if there is no fn to handle the error
      self.maybeReconnectOnOpen();
    }
  });

  // emit `connect_timeout`
  if (false !== this._timeout) {
    var timeout = this._timeout;
    debug('connect attempt will timeout after %d', timeout);

    // set timer
    var timer = setTimeout(function () {
      debug('connect attempt timed out after %d', timeout);
      openSub.destroy();
      socket.close();
      socket.emit('error', 'timeout');
      self.emitAll('connect_timeout', timeout);
    }, timeout);

    this.subs.push({
      destroy: function destroy() {
        clearTimeout(timer);
      }
    });
  }

  this.subs.push(openSub);
  this.subs.push(errorSub);

  return this;
};

/**
 * Called upon transport open.
 *
 * @api private
 */

Manager.prototype.onopen = function () {
  debug('open');

  // clear old subs
  this.cleanup();

  // mark as open
  this.readyState = 'open';
  this.emit('open');

  // add new subs
  var socket = this.engine;
  this.subs.push(on(socket, 'data', bind(this, 'ondata')));
  this.subs.push(on(socket, 'ping', bind(this, 'onping')));
  this.subs.push(on(socket, 'pong', bind(this, 'onpong')));
  this.subs.push(on(socket, 'error', bind(this, 'onerror')));
  this.subs.push(on(socket, 'close', bind(this, 'onclose')));
  this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));
};

/**
 * Called upon a ping.
 *
 * @api private
 */

Manager.prototype.onping = function () {
  this.lastPing = new Date();
  this.emitAll('ping');
};

/**
 * Called upon a packet.
 *
 * @api private
 */

Manager.prototype.onpong = function () {
  this.emitAll('pong', new Date() - this.lastPing);
};

/**
 * Called with data.
 *
 * @api private
 */

Manager.prototype.ondata = function (data) {
  this.decoder.add(data);
};

/**
 * Called when parser fully decodes a packet.
 *
 * @api private
 */

Manager.prototype.ondecoded = function (packet) {
  this.emit('packet', packet);
};

/**
 * Called upon socket error.
 *
 * @api private
 */

Manager.prototype.onerror = function (err) {
  debug('error', err);
  this.emitAll('error', err);
};

/**
 * Creates a new socket for the given `nsp`.
 *
 * @return {Socket}
 * @api public
 */

Manager.prototype.socket = function (nsp, opts) {
  var socket = this.nsps[nsp];
  if (!socket) {
    socket = new Socket(this, nsp, opts);
    this.nsps[nsp] = socket;
    var self = this;
    socket.on('connecting', onConnecting);
    socket.on('connect', function () {
      socket.id = self.generateId(nsp);
    });

    if (this.autoConnect) {
      // manually call here since connecting event is fired before listening
      onConnecting();
    }
  }

  function onConnecting() {
    if (!~indexOf(self.connecting, socket)) {
      self.connecting.push(socket);
    }
  }

  return socket;
};

/**
 * Called upon a socket close.
 *
 * @param {Socket} socket
 */

Manager.prototype.destroy = function (socket) {
  var index = indexOf(this.connecting, socket);
  if (~index) this.connecting.splice(index, 1);
  if (this.connecting.length) return;

  this.close();
};

/**
 * Writes a packet.
 *
 * @param {Object} packet
 * @api private
 */

Manager.prototype.packet = function (packet) {
  debug('writing packet %j', packet);
  var self = this;
  if (packet.query && packet.type === 0) packet.nsp += '?' + packet.query;

  if (!self.encoding) {
    // encode, then write to engine with result
    self.encoding = true;
    this.encoder.encode(packet, function (encodedPackets) {
      for (var i = 0; i < encodedPackets.length; i++) {
        self.engine.write(encodedPackets[i], packet.options);
      }
      self.encoding = false;
      self.processPacketQueue();
    });
  } else {
    // add packet to the queue
    self.packetBuffer.push(packet);
  }
};

/**
 * If packet buffer is non-empty, begins encoding the
 * next packet in line.
 *
 * @api private
 */

Manager.prototype.processPacketQueue = function () {
  if (this.packetBuffer.length > 0 && !this.encoding) {
    var pack = this.packetBuffer.shift();
    this.packet(pack);
  }
};

/**
 * Clean up transport subscriptions and packet buffer.
 *
 * @api private
 */

Manager.prototype.cleanup = function () {
  debug('cleanup');

  var subsLength = this.subs.length;
  for (var i = 0; i < subsLength; i++) {
    var sub = this.subs.shift();
    sub.destroy();
  }

  this.packetBuffer = [];
  this.encoding = false;
  this.lastPing = null;

  this.decoder.destroy();
};

/**
 * Close the current socket.
 *
 * @api private
 */

Manager.prototype.close = Manager.prototype.disconnect = function () {
  debug('disconnect');
  this.skipReconnect = true;
  this.reconnecting = false;
  if ('opening' === this.readyState) {
    // `onclose` will not fire because
    // an open event never happened
    this.cleanup();
  }
  this.backoff.reset();
  this.readyState = 'closed';
  if (this.engine) this.engine.close();
};

/**
 * Called upon engine close.
 *
 * @api private
 */

Manager.prototype.onclose = function (reason) {
  debug('onclose');

  this.cleanup();
  this.backoff.reset();
  this.readyState = 'closed';
  this.emit('close', reason);

  if (this._reconnection && !this.skipReconnect) {
    this.reconnect();
  }
};

/**
 * Attempt a reconnection.
 *
 * @api private
 */

Manager.prototype.reconnect = function () {
  if (this.reconnecting || this.skipReconnect) return this;

  var self = this;

  if (this.backoff.attempts >= this._reconnectionAttempts) {
    debug('reconnect failed');
    this.backoff.reset();
    this.emitAll('reconnect_failed');
    this.reconnecting = false;
  } else {
    var delay = this.backoff.duration();
    debug('will wait %dms before reconnect attempt', delay);

    this.reconnecting = true;
    var timer = setTimeout(function () {
      if (self.skipReconnect) return;

      debug('attempting reconnect');
      self.emitAll('reconnect_attempt', self.backoff.attempts);
      self.emitAll('reconnecting', self.backoff.attempts);

      // check again for the case socket closed in above events
      if (self.skipReconnect) return;

      self.open(function (err) {
        if (err) {
          debug('reconnect attempt error');
          self.reconnecting = false;
          self.reconnect();
          self.emitAll('reconnect_error', err.data);
        } else {
          debug('reconnect success');
          self.onreconnect();
        }
      });
    }, delay);

    this.subs.push({
      destroy: function destroy() {
        clearTimeout(timer);
      }
    });
  }
};

/**
 * Called upon successful reconnect.
 *
 * @api private
 */

Manager.prototype.onreconnect = function () {
  var attempt = this.backoff.attempts;
  this.reconnecting = false;
  this.backoff.reset();
  this.updateSocketIds();
  this.emitAll('reconnect', attempt);
};

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

/**
 * Module dependencies
 */

var XMLHttpRequest = __webpack_require__(17);
var XHR = __webpack_require__(75);
var JSONP = __webpack_require__(83);
var websocket = __webpack_require__(84);

/**
 * Export transports.
 */

exports.polling = polling;
exports.websocket = websocket;

/**
 * Polling transport polymorphic constructor.
 * Decides on xhr vs jsonp based on feature detection.
 *
 * @api private
 */

function polling(opts) {
  var xhr;
  var xd = false;
  var xs = false;
  var jsonp = false !== opts.jsonp;

  if (global.location) {
    var isSSL = 'https:' === location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    xd = opts.hostname !== location.hostname || port !== opts.port;
    xs = opts.secure !== isSSL;
  }

  opts.xdomain = xd;
  opts.xscheme = xs;
  xhr = new XMLHttpRequest(opts);

  if ('open' in xhr && !opts.forceJSONP) {
    return new XHR(opts);
  } else {
    if (!jsonp) throw new Error('JSONP disabled');
    return new JSONP(opts);
  }
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Module dependencies.
 */

var Transport = __webpack_require__(18);
var parseqs = __webpack_require__(11);
var parser = __webpack_require__(8);
var inherit = __webpack_require__(12);
var yeast = __webpack_require__(36);
var debug = __webpack_require__(2)('engine.io-client:polling');

/**
 * Module exports.
 */

module.exports = Polling;

/**
 * Is XHR2 supported?
 */

var hasXHR2 = function () {
  var XMLHttpRequest = __webpack_require__(17);
  var xhr = new XMLHttpRequest({ xdomain: false });
  return null != xhr.responseType;
}();

/**
 * Polling interface.
 *
 * @param {Object} opts
 * @api private
 */

function Polling(opts) {
  var forceBase64 = opts && opts.forceBase64;
  if (!hasXHR2 || forceBase64) {
    this.supportsBinary = false;
  }
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(Polling, Transport);

/**
 * Transport name.
 */

Polling.prototype.name = 'polling';

/**
 * Opens the socket (triggers polling). We write a PING message to determine
 * when the transport is open.
 *
 * @api private
 */

Polling.prototype.doOpen = function () {
  this.poll();
};

/**
 * Pauses polling.
 *
 * @param {Function} callback upon buffers are flushed and transport is paused
 * @api private
 */

Polling.prototype.pause = function (onPause) {
  var self = this;

  this.readyState = 'pausing';

  function pause() {
    debug('paused');
    self.readyState = 'paused';
    onPause();
  }

  if (this.polling || !this.writable) {
    var total = 0;

    if (this.polling) {
      debug('we are currently polling - waiting to pause');
      total++;
      this.once('pollComplete', function () {
        debug('pre-pause polling complete');
        --total || pause();
      });
    }

    if (!this.writable) {
      debug('we are currently writing - waiting to pause');
      total++;
      this.once('drain', function () {
        debug('pre-pause writing complete');
        --total || pause();
      });
    }
  } else {
    pause();
  }
};

/**
 * Starts polling cycle.
 *
 * @api public
 */

Polling.prototype.poll = function () {
  debug('polling');
  this.polling = true;
  this.doPoll();
  this.emit('poll');
};

/**
 * Overloads onData to detect payloads.
 *
 * @api private
 */

Polling.prototype.onData = function (data) {
  var self = this;
  debug('polling got data %s', data);
  var callback = function callback(packet, index, total) {
    // if its the first message we consider the transport open
    if ('opening' === self.readyState) {
      self.onOpen();
    }

    // if its a close packet, we close the ongoing requests
    if ('close' === packet.type) {
      self.onClose();
      return false;
    }

    // otherwise bypass onData and handle the message
    self.onPacket(packet);
  };

  // decode payload
  parser.decodePayload(data, this.socket.binaryType, callback);

  // if an event did not trigger closing
  if ('closed' !== this.readyState) {
    // if we got data we're not polling
    this.polling = false;
    this.emit('pollComplete');

    if ('open' === this.readyState) {
      this.poll();
    } else {
      debug('ignoring poll - transport state "%s"', this.readyState);
    }
  }
};

/**
 * For polling, send a close packet.
 *
 * @api private
 */

Polling.prototype.doClose = function () {
  var self = this;

  function close() {
    debug('writing close packet');
    self.write([{ type: 'close' }]);
  }

  if ('open' === this.readyState) {
    debug('transport open - closing');
    close();
  } else {
    // in case we're trying to close while
    // handshaking is in progress (GH-164)
    debug('transport not open - deferring close');
    this.once('open', close);
  }
};

/**
 * Writes a packets payload.
 *
 * @param {Array} data packets
 * @param {Function} drain callback
 * @api private
 */

Polling.prototype.write = function (packets) {
  var self = this;
  this.writable = false;
  var callbackfn = function callbackfn() {
    self.writable = true;
    self.emit('drain');
  };

  parser.encodePayload(packets, this.supportsBinary, function (data) {
    self.doWrite(data, callbackfn);
  });
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

Polling.prototype.uri = function () {
  var query = this.query || {};
  var schema = this.secure ? 'https' : 'http';
  var port = '';

  // cache busting is forced
  if (false !== this.timestampRequests) {
    query[this.timestampParam] = yeast();
  }

  if (!this.supportsBinary && !query.sid) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // avoid port if default for schema
  if (this.port && ('https' === schema && Number(this.port) !== 443 || 'http' === schema && Number(this.port) !== 80)) {
    port = ':' + this.port;
  }

  // prepend ? to query
  if (query.length) {
    query = '?' + query;
  }

  var ipv6 = this.hostname.indexOf(':') !== -1;
  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
};

/***/ }),
/* 35 */
/***/ (function(module, exports) {

/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */
module.exports = __webpack_amd_options__;

/* WEBPACK VAR INJECTION */}.call(exports, {}))

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split(''),
    length = 64,
    map = {},
    seed = 0,
    i = 0,
    prev;

/**
 * Return a string representing the specified number.
 *
 * @param {Number} num The number to convert.
 * @returns {String} The string representation of the number.
 * @api public
 */
function encode(num) {
  var encoded = '';

  do {
    encoded = alphabet[num % length] + encoded;
    num = Math.floor(num / length);
  } while (num > 0);

  return encoded;
}

/**
 * Return the integer value specified by the given string.
 *
 * @param {String} str The string to convert.
 * @returns {Number} The integer value represented by the string.
 * @api public
 */
function decode(str) {
  var decoded = 0;

  for (i = 0; i < str.length; i++) {
    decoded = decoded * length + map[str.charAt(i)];
  }

  return decoded;
}

/**
 * Yeast: A tiny growing id generator.
 *
 * @returns {String} A unique id.
 * @api public
 */
function yeast() {
  var now = encode(+new Date());

  if (now !== prev) return seed = 0, prev = now;
  return now + '.' + encode(seed++);
}

//
// Map each character to its index.
//
for (; i < length; i++) {
  map[alphabet[i]] = i;
} //
// Expose the `yeast`, `encode` and `decode` functions.
//
yeast.encode = encode;
yeast.decode = decode;
module.exports = yeast;

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var indexOf = [].indexOf;

module.exports = function (arr, obj) {
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * Module dependencies.
 */

var parser = __webpack_require__(16);
var Emitter = __webpack_require__(7);
var toArray = __webpack_require__(86);
var on = __webpack_require__(39);
var bind = __webpack_require__(40);
var debug = __webpack_require__(2)('socket.io-client:socket');
var parseqs = __webpack_require__(11);

/**
 * Module exports.
 */

module.exports = exports = Socket;

/**
 * Internal events (blacklisted).
 * These events can't be emitted by the user.
 *
 * @api private
 */

var events = {
  connect: 1,
  connect_error: 1,
  connect_timeout: 1,
  connecting: 1,
  disconnect: 1,
  error: 1,
  reconnect: 1,
  reconnect_attempt: 1,
  reconnect_failed: 1,
  reconnect_error: 1,
  reconnecting: 1,
  ping: 1,
  pong: 1
};

/**
 * Shortcut to `Emitter#emit`.
 */

var emit = Emitter.prototype.emit;

/**
 * `Socket` constructor.
 *
 * @api public
 */

function Socket(io, nsp, opts) {
  this.io = io;
  this.nsp = nsp;
  this.json = this; // compat
  this.ids = 0;
  this.acks = {};
  this.receiveBuffer = [];
  this.sendBuffer = [];
  this.connected = false;
  this.disconnected = true;
  if (opts && opts.query) {
    this.query = opts.query;
  }
  if (this.io.autoConnect) this.open();
}

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Subscribe to open, close and packet events
 *
 * @api private
 */

Socket.prototype.subEvents = function () {
  if (this.subs) return;

  var io = this.io;
  this.subs = [on(io, 'open', bind(this, 'onopen')), on(io, 'packet', bind(this, 'onpacket')), on(io, 'close', bind(this, 'onclose'))];
};

/**
 * "Opens" the socket.
 *
 * @api public
 */

Socket.prototype.open = Socket.prototype.connect = function () {
  if (this.connected) return this;

  this.subEvents();
  this.io.open(); // ensure open
  if ('open' === this.io.readyState) this.onopen();
  this.emit('connecting');
  return this;
};

/**
 * Sends a `message` event.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.send = function () {
  var args = toArray(arguments);
  args.unshift('message');
  this.emit.apply(this, args);
  return this;
};

/**
 * Override `emit`.
 * If the event is in `events`, it's emitted normally.
 *
 * @param {String} event name
 * @return {Socket} self
 * @api public
 */

Socket.prototype.emit = function (ev) {
  if (events.hasOwnProperty(ev)) {
    emit.apply(this, arguments);
    return this;
  }

  var args = toArray(arguments);
  var packet = { type: parser.EVENT, data: args };

  packet.options = {};
  packet.options.compress = !this.flags || false !== this.flags.compress;

  // event ack callback
  if ('function' === typeof args[args.length - 1]) {
    debug('emitting packet with ack id %d', this.ids);
    this.acks[this.ids] = args.pop();
    packet.id = this.ids++;
  }

  if (this.connected) {
    this.packet(packet);
  } else {
    this.sendBuffer.push(packet);
  }

  delete this.flags;

  return this;
};

/**
 * Sends a packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.packet = function (packet) {
  packet.nsp = this.nsp;
  this.io.packet(packet);
};

/**
 * Called upon engine `open`.
 *
 * @api private
 */

Socket.prototype.onopen = function () {
  debug('transport is open - connecting');

  // write connect packet if necessary
  if ('/' !== this.nsp) {
    if (this.query) {
      var query = _typeof(this.query) === 'object' ? parseqs.encode(this.query) : this.query;
      debug('sending connect packet with query %s', query);
      this.packet({ type: parser.CONNECT, query: query });
    } else {
      this.packet({ type: parser.CONNECT });
    }
  }
};

/**
 * Called upon engine `close`.
 *
 * @param {String} reason
 * @api private
 */

Socket.prototype.onclose = function (reason) {
  debug('close (%s)', reason);
  this.connected = false;
  this.disconnected = true;
  delete this.id;
  this.emit('disconnect', reason);
};

/**
 * Called with socket packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onpacket = function (packet) {
  if (packet.nsp !== this.nsp) return;

  switch (packet.type) {
    case parser.CONNECT:
      this.onconnect();
      break;

    case parser.EVENT:
      this.onevent(packet);
      break;

    case parser.BINARY_EVENT:
      this.onevent(packet);
      break;

    case parser.ACK:
      this.onack(packet);
      break;

    case parser.BINARY_ACK:
      this.onack(packet);
      break;

    case parser.DISCONNECT:
      this.ondisconnect();
      break;

    case parser.ERROR:
      this.emit('error', packet.data);
      break;
  }
};

/**
 * Called upon a server event.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onevent = function (packet) {
  var args = packet.data || [];
  debug('emitting event %j', args);

  if (null != packet.id) {
    debug('attaching ack callback to event');
    args.push(this.ack(packet.id));
  }

  if (this.connected) {
    emit.apply(this, args);
  } else {
    this.receiveBuffer.push(args);
  }
};

/**
 * Produces an ack callback to emit with an event.
 *
 * @api private
 */

Socket.prototype.ack = function (id) {
  var self = this;
  var sent = false;
  return function () {
    // prevent double callbacks
    if (sent) return;
    sent = true;
    var args = toArray(arguments);
    debug('sending ack %j', args);

    self.packet({
      type: parser.ACK,
      id: id,
      data: args
    });
  };
};

/**
 * Called upon a server acknowlegement.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onack = function (packet) {
  var ack = this.acks[packet.id];
  if ('function' === typeof ack) {
    debug('calling ack %s with %j', packet.id, packet.data);
    ack.apply(this, packet.data);
    delete this.acks[packet.id];
  } else {
    debug('bad ack %s', packet.id);
  }
};

/**
 * Called upon server connect.
 *
 * @api private
 */

Socket.prototype.onconnect = function () {
  this.connected = true;
  this.disconnected = false;
  this.emit('connect');
  this.emitBuffered();
};

/**
 * Emit buffered events (received and emitted).
 *
 * @api private
 */

Socket.prototype.emitBuffered = function () {
  var i;
  for (i = 0; i < this.receiveBuffer.length; i++) {
    emit.apply(this, this.receiveBuffer[i]);
  }
  this.receiveBuffer = [];

  for (i = 0; i < this.sendBuffer.length; i++) {
    this.packet(this.sendBuffer[i]);
  }
  this.sendBuffer = [];
};

/**
 * Called upon server disconnect.
 *
 * @api private
 */

Socket.prototype.ondisconnect = function () {
  debug('server disconnect (%s)', this.nsp);
  this.destroy();
  this.onclose('io server disconnect');
};

/**
 * Called upon forced client/server side disconnections,
 * this method ensures the manager stops tracking us and
 * that reconnections don't get triggered for this.
 *
 * @api private.
 */

Socket.prototype.destroy = function () {
  if (this.subs) {
    // clean subscriptions to avoid reconnections
    for (var i = 0; i < this.subs.length; i++) {
      this.subs[i].destroy();
    }
    this.subs = null;
  }

  this.io.destroy(this);
};

/**
 * Disconnects the socket manually.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.close = Socket.prototype.disconnect = function () {
  if (this.connected) {
    debug('performing disconnect (%s)', this.nsp);
    this.packet({ type: parser.DISCONNECT });
  }

  // remove socket from pool
  this.destroy();

  if (this.connected) {
    // fire events
    this.onclose('io client disconnect');
  }
  return this;
};

/**
 * Sets the compress flag.
 *
 * @param {Boolean} if `true`, compresses the sending data
 * @return {Socket} self
 * @api public
 */

Socket.prototype.compress = function (compress) {
  this.flags = this.flags || {};
  this.flags.compress = compress;
  return this;
};

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Module exports.
 */

module.exports = on;

/**
 * Helper for subscriptions.
 *
 * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`
 * @param {String} event name
 * @param {Function} callback
 * @api public
 */

function on(obj, ev, fn) {
  obj.on(ev, fn);
  return {
    destroy: function destroy() {
      obj.removeListener(ev, fn);
    }
  };
}

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Slice reference.
 */

var slice = [].slice;

/**
 * Bind `obj` to `fn`.
 *
 * @param {Object} obj
 * @param {Function|String} fn or string
 * @return {Function}
 * @api public
 */

module.exports = function (obj, fn) {
  if ('string' == typeof fn) fn = obj[fn];
  if ('function' != typeof fn) throw new Error('bind() requires a function');
  var args = slice.call(arguments, 2);
  return function () {
    return fn.apply(obj, args.concat(slice.call(arguments)));
  };
};

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var User = function () {
  function User() {
    _classCallCheck(this, User);
  }

  _createClass(User, null, [{
    key: 'setName',
    value: function setName(name) {
      User.info.name = name;
    }
  }, {
    key: 'getName',
    value: function getName() {
      return User.info.name;
    }
  }]);

  return User;
}();

exports.default = User;


User.info = {
  name: ''
};

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(3);

var _react2 = _interopRequireDefault(_react);

__webpack_require__(88);

var _ChatLog = __webpack_require__(43);

var _ChatLog2 = _interopRequireDefault(_ChatLog);

var _ChatUsers = __webpack_require__(44);

var _ChatUsers2 = _interopRequireDefault(_ChatUsers);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ChatArea = function (_Component) {
  _inherits(ChatArea, _Component);

  function ChatArea() {
    _classCallCheck(this, ChatArea);

    return _possibleConstructorReturn(this, (ChatArea.__proto__ || Object.getPrototypeOf(ChatArea)).apply(this, arguments));
  }

  _createClass(ChatArea, [{
    key: 'render',
    value: function render() {
      return _react2.default.createElement(
        'div',
        { className: 'container' },
        _react2.default.createElement(_ChatLog2.default, { isJoin: this.props.isJoin, messages: this.props.messages }),
        _react2.default.createElement(_ChatUsers2.default, { isJoin: this.props.isJoin, users: this.props.users })
      );
    }
  }]);

  return ChatArea;
}(_react.Component);

exports.default = ChatArea;

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(3);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(20);

var _reactDom2 = _interopRequireDefault(_reactDom);

__webpack_require__(90);

var _ConnectionManager = __webpack_require__(15);

var _ConnectionManager2 = _interopRequireDefault(_ConnectionManager);

var _User = __webpack_require__(41);

var _User2 = _interopRequireDefault(_User);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ChatLog = function (_Component) {
  _inherits(ChatLog, _Component);

  function ChatLog(props) {
    _classCallCheck(this, ChatLog);

    var _this = _possibleConstructorReturn(this, (ChatLog.__proto__ || Object.getPrototypeOf(ChatLog)).call(this, props));

    _this.state = {
      disabled: !_this.props.isJoin,
      messages: _this.props.messages,
      tmpmessage: ''
    };
    _this.socket = null;
    return _this;
  }

  _createClass(ChatLog, [{
    key: 'componentDidUpdate',
    value: function componentDidUpdate() {
      var node = _reactDom2.default.findDOMNode(this.refs.log);
      node.scrollTop = node.scrollHeight;
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      if (nextProps.isJoin !== undefined) {
        this.setState({
          disabled: !nextProps.isJoin
        });
        if (nextProps.isJoin) {
          this.socket = _ConnectionManager2.default.getConnection();
        }
      } else if (nextProps.messages) {
        this.setState({
          messages: nextProps.messages
        });
      }
    }
  }, {
    key: 'onInput',
    value: function onInput(e) {
      var value = e.target.value;
      this.setState({ tmpmessage: value });
      this.socket.emit('tmpmessage', {
        id: this.socket.id,
        body: value
      });
    }
  }, {
    key: 'onKeyPress',
    value: function onKeyPress(e) {
      if (e.which === 13 && this.state.tmpmessage.length !== 0) {
        this.socket.emit('message', {
          id: this.socket.id,
          name: _User2.default.getName(),
          body: this.state.tmpmessage
        });
        this.setState({ tmpmessage: '' });
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      return _react2.default.createElement(
        'div',
        { className: 'col-md-8' },
        _react2.default.createElement(
          'div',
          { className: 'panel panel-info' },
          _react2.default.createElement(
            'div',
            { className: 'panel-heading' },
            'CHAT LOG'
          ),
          _react2.default.createElement(
            'div',
            { className: 'panel-body' },
            _react2.default.createElement(
              'div',
              { className: 'chatlog', ref: 'log' },
              function () {
                return _this2.props.isJoin && _this2.state.messages.map(function (e) {
                  return _react2.default.createElement(
                    'div',
                    null,
                    _react2.default.createElement(
                      'font',
                      { color: e.colorCode },
                      e.name
                    ),
                    ':',
                    e.body
                  );
                });
              }()
            )
          ),
          _react2.default.createElement(
            'div',
            { className: 'panel-footer' },
            _react2.default.createElement('input', { type: 'text',
              className: 'form-control',
              placeholder: 'your message',
              value: this.state.tmpmessage,
              disabled: this.state.disabled,
              onInput: function onInput(e) {
                return _this2.onInput(e);
              },
              onKeyPress: function onKeyPress(e) {
                return _this2.onKeyPress(e);
              }
            })
          )
        )
      );
    }
  }]);

  return ChatLog;
}(_react.Component);

exports.default = ChatLog;

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(3);

var _react2 = _interopRequireDefault(_react);

__webpack_require__(92);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ChatUsers = function (_Component) {
  _inherits(ChatUsers, _Component);

  function ChatUsers(props) {
    _classCallCheck(this, ChatUsers);

    var _this = _possibleConstructorReturn(this, (ChatUsers.__proto__ || Object.getPrototypeOf(ChatUsers)).call(this, props));

    _this.state = {
      users: _this.props.users
    };
    return _this;
  }

  _createClass(ChatUsers, [{
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      this.setState({
        users: nextProps.users
      });
    }
  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      return _react2.default.createElement(
        'div',
        { className: 'col-md-4' },
        _react2.default.createElement(
          'div',
          { className: 'panel panel-primary' },
          _react2.default.createElement(
            'div',
            { className: 'panel-heading' },
            'ONLINE USERS'
          ),
          _react2.default.createElement(
            'div',
            { className: 'panel-body' },
            _react2.default.createElement(
              'div',
              { className: 'chatusers' },
              _react2.default.createElement(
                'ul',
                null,
                function () {
                  return _this2.props.isJoin && _this2.state.users.map(function (e) {
                    return _react2.default.createElement(
                      'li',
                      { key: e.id },
                      _react2.default.createElement(
                        'div',
                        { className: 'user' },
                        _react2.default.createElement(
                          'font',
                          { color: e.colorCode },
                          e.name
                        )
                      ),
                      e.tmpmessage.length !== 0 && _react2.default.createElement(
                        'div',
                        { className: 'tmpmessage' },
                        e.tmpmessage
                      )
                    );
                  });
                }()
              )
            )
          )
        )
      );
    }
  }]);

  return ChatUsers;
}(_react.Component);

exports.default = ChatUsers;

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(46);
__webpack_require__(27);
__webpack_require__(28);
__webpack_require__(42);
__webpack_require__(43);
module.exports = __webpack_require__(44);


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _react = __webpack_require__(3);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(20);

var _reactDom2 = _interopRequireDefault(_reactDom);

__webpack_require__(58);

var _ChatApp = __webpack_require__(27);

var _ChatApp2 = _interopRequireDefault(_ChatApp);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_reactDom2.default.render(_react2.default.createElement(_ChatApp2.default, null), document.getElementById('root'));

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.2.0
 * react.production.min.js
 *
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var m = __webpack_require__(9),
    n = __webpack_require__(10),
    p = __webpack_require__(4),
    q = "function" === typeof Symbol && Symbol["for"],
    r = q ? Symbol["for"]("react.element") : 60103,
    t = q ? Symbol["for"]("react.call") : 60104,
    u = q ? Symbol["for"]("react.return") : 60105,
    v = q ? Symbol["for"]("react.portal") : 60106,
    w = q ? Symbol["for"]("react.fragment") : 60107,
    x = "function" === typeof Symbol && Symbol.iterator;
function y(a) {
  for (var b = arguments.length - 1, e = "Minified React error #" + a + "; visit http://facebook.github.io/react/docs/error-decoder.html?invariant\x3d" + a, c = 0; c < b; c++) {
    e += "\x26args[]\x3d" + encodeURIComponent(arguments[c + 1]);
  }b = Error(e + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.");b.name = "Invariant Violation";b.framesToPop = 1;throw b;
}
var z = { isMounted: function isMounted() {
    return !1;
  }, enqueueForceUpdate: function enqueueForceUpdate() {}, enqueueReplaceState: function enqueueReplaceState() {}, enqueueSetState: function enqueueSetState() {} };function A(a, b, e) {
  this.props = a;this.context = b;this.refs = n;this.updater = e || z;
}A.prototype.isReactComponent = {};A.prototype.setState = function (a, b) {
  "object" !== (typeof a === "undefined" ? "undefined" : _typeof(a)) && "function" !== typeof a && null != a ? y("85") : void 0;this.updater.enqueueSetState(this, a, b, "setState");
};A.prototype.forceUpdate = function (a) {
  this.updater.enqueueForceUpdate(this, a, "forceUpdate");
};
function B(a, b, e) {
  this.props = a;this.context = b;this.refs = n;this.updater = e || z;
}function C() {}C.prototype = A.prototype;var D = B.prototype = new C();D.constructor = B;m(D, A.prototype);D.isPureReactComponent = !0;function E(a, b, e) {
  this.props = a;this.context = b;this.refs = n;this.updater = e || z;
}var F = E.prototype = new C();F.constructor = E;m(F, A.prototype);F.unstable_isAsyncReactComponent = !0;F.render = function () {
  return this.props.children;
};var G = { current: null },
    H = Object.prototype.hasOwnProperty,
    I = { key: !0, ref: !0, __self: !0, __source: !0 };
function J(a, b, e) {
  var c,
      d = {},
      g = null,
      k = null;if (null != b) for (c in void 0 !== b.ref && (k = b.ref), void 0 !== b.key && (g = "" + b.key), b) {
    H.call(b, c) && !I.hasOwnProperty(c) && (d[c] = b[c]);
  }var f = arguments.length - 2;if (1 === f) d.children = e;else if (1 < f) {
    for (var h = Array(f), l = 0; l < f; l++) {
      h[l] = arguments[l + 2];
    }d.children = h;
  }if (a && a.defaultProps) for (c in f = a.defaultProps, f) {
    void 0 === d[c] && (d[c] = f[c]);
  }return { $$typeof: r, type: a, key: g, ref: k, props: d, _owner: G.current };
}function K(a) {
  return "object" === (typeof a === "undefined" ? "undefined" : _typeof(a)) && null !== a && a.$$typeof === r;
}
function escape(a) {
  var b = { "\x3d": "\x3d0", ":": "\x3d2" };return "$" + ("" + a).replace(/[=:]/g, function (a) {
    return b[a];
  });
}var L = /\/+/g,
    M = [];function N(a, b, e, c) {
  if (M.length) {
    var d = M.pop();d.result = a;d.keyPrefix = b;d.func = e;d.context = c;d.count = 0;return d;
  }return { result: a, keyPrefix: b, func: e, context: c, count: 0 };
}function O(a) {
  a.result = null;a.keyPrefix = null;a.func = null;a.context = null;a.count = 0;10 > M.length && M.push(a);
}
function P(a, b, e, c) {
  var d = typeof a === "undefined" ? "undefined" : _typeof(a);if ("undefined" === d || "boolean" === d) a = null;var g = !1;if (null === a) g = !0;else switch (d) {case "string":case "number":
      g = !0;break;case "object":
      switch (a.$$typeof) {case r:case t:case u:case v:
          g = !0;}}if (g) return e(c, a, "" === b ? "." + Q(a, 0) : b), 1;g = 0;b = "" === b ? "." : b + ":";if (Array.isArray(a)) for (var k = 0; k < a.length; k++) {
    d = a[k];var f = b + Q(d, k);g += P(d, f, e, c);
  } else if (null === a || "undefined" === typeof a ? f = null : (f = x && a[x] || a["@@iterator"], f = "function" === typeof f ? f : null), "function" === typeof f) for (a = f.call(a), k = 0; !(d = a.next()).done;) {
    d = d.value, f = b + Q(d, k++), g += P(d, f, e, c);
  } else "object" === d && (e = "" + a, y("31", "[object Object]" === e ? "object with keys {" + Object.keys(a).join(", ") + "}" : e, ""));return g;
}function Q(a, b) {
  return "object" === (typeof a === "undefined" ? "undefined" : _typeof(a)) && null !== a && null != a.key ? escape(a.key) : b.toString(36);
}function R(a, b) {
  a.func.call(a.context, b, a.count++);
}
function S(a, b, e) {
  var c = a.result,
      d = a.keyPrefix;a = a.func.call(a.context, b, a.count++);Array.isArray(a) ? T(a, c, e, p.thatReturnsArgument) : null != a && (K(a) && (b = d + (!a.key || b && b.key === a.key ? "" : ("" + a.key).replace(L, "$\x26/") + "/") + e, a = { $$typeof: r, type: a.type, key: b, ref: a.ref, props: a.props, _owner: a._owner }), c.push(a));
}function T(a, b, e, c, d) {
  var g = "";null != e && (g = ("" + e).replace(L, "$\x26/") + "/");b = N(b, g, c, d);null == a || P(a, "", S, b);O(b);
}
var U = { Children: { map: function map(a, b, e) {
      if (null == a) return a;var c = [];T(a, c, null, b, e);return c;
    }, forEach: function forEach(a, b, e) {
      if (null == a) return a;b = N(null, null, b, e);null == a || P(a, "", R, b);O(b);
    }, count: function count(a) {
      return null == a ? 0 : P(a, "", p.thatReturnsNull, null);
    }, toArray: function toArray(a) {
      var b = [];T(a, b, null, p.thatReturnsArgument);return b;
    }, only: function only(a) {
      K(a) ? void 0 : y("143");return a;
    } }, Component: A, PureComponent: B, unstable_AsyncComponent: E, Fragment: w, createElement: J, cloneElement: function cloneElement(a, b, e) {
    var c = m({}, a.props),
        d = a.key,
        g = a.ref,
        k = a._owner;if (null != b) {
      void 0 !== b.ref && (g = b.ref, k = G.current);void 0 !== b.key && (d = "" + b.key);if (a.type && a.type.defaultProps) var f = a.type.defaultProps;for (h in b) {
        H.call(b, h) && !I.hasOwnProperty(h) && (c[h] = void 0 === b[h] && void 0 !== f ? f[h] : b[h]);
      }
    }var h = arguments.length - 2;if (1 === h) c.children = e;else if (1 < h) {
      f = Array(h);for (var l = 0; l < h; l++) {
        f[l] = arguments[l + 2];
      }c.children = f;
    }return { $$typeof: r, type: a.type, key: d, ref: g, props: c, _owner: k };
  }, createFactory: function createFactory(a) {
    var b = J.bind(null, a);b.type = a;return b;
  },
  isValidElement: K, version: "16.2.0", __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: { ReactCurrentOwner: G, assign: m } },
    V = Object.freeze({ default: U }),
    W = V && U || V;module.exports = W["default"] ? W["default"] : W;

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/** @license React v16.2.0
 * react.development.js
 *
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

if (process.env.NODE_ENV !== "production") {
  (function () {
    'use strict';

    var _assign = __webpack_require__(9);
    var emptyObject = __webpack_require__(10);
    var invariant = __webpack_require__(13);
    var warning = __webpack_require__(14);
    var emptyFunction = __webpack_require__(4);
    var checkPropTypes = __webpack_require__(19);

    // TODO: this is special because it gets imported during build.

    var ReactVersion = '16.2.0';

    // The Symbol used to tag the ReactElement-like types. If there is no native Symbol
    // nor polyfill, then a plain number is used for performance.
    var hasSymbol = typeof Symbol === 'function' && Symbol['for'];

    var REACT_ELEMENT_TYPE = hasSymbol ? Symbol['for']('react.element') : 0xeac7;
    var REACT_CALL_TYPE = hasSymbol ? Symbol['for']('react.call') : 0xeac8;
    var REACT_RETURN_TYPE = hasSymbol ? Symbol['for']('react.return') : 0xeac9;
    var REACT_PORTAL_TYPE = hasSymbol ? Symbol['for']('react.portal') : 0xeaca;
    var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol['for']('react.fragment') : 0xeacb;

    var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
    var FAUX_ITERATOR_SYMBOL = '@@iterator';

    function getIteratorFn(maybeIterable) {
      if (maybeIterable === null || typeof maybeIterable === 'undefined') {
        return null;
      }
      var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
      if (typeof maybeIterator === 'function') {
        return maybeIterator;
      }
      return null;
    }

    /**
     * WARNING: DO NOT manually require this module.
     * This is a replacement for `invariant(...)` used by the error code system
     * and will _only_ be required by the corresponding babel pass.
     * It always throws.
     */

    /**
     * Forked from fbjs/warning:
     * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js
     *
     * Only change is we use console.warn instead of console.error,
     * and do nothing when 'console' is not supported.
     * This really simplifies the code.
     * ---
     * Similar to invariant but only logs a warning if the condition is not met.
     * This can be used to log issues in development environments in critical
     * paths. Removing the logging code for production environments will keep the
     * same logic and follow the same code paths.
     */

    var lowPriorityWarning = function lowPriorityWarning() {};

    {
      var printWarning = function printWarning(format) {
        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        var argIndex = 0;
        var message = 'Warning: ' + format.replace(/%s/g, function () {
          return args[argIndex++];
        });
        if (typeof console !== 'undefined') {
          console.warn(message);
        }
        try {
          // --- Welcome to debugging React ---
          // This error was thrown as a convenience so that you can use this stack
          // to find the callsite that caused this warning to fire.
          throw new Error(message);
        } catch (x) {}
      };

      lowPriorityWarning = function lowPriorityWarning(condition, format) {
        if (format === undefined) {
          throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
        }
        if (!condition) {
          for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
            args[_key2 - 2] = arguments[_key2];
          }

          printWarning.apply(undefined, [format].concat(args));
        }
      };
    }

    var lowPriorityWarning$1 = lowPriorityWarning;

    var didWarnStateUpdateForUnmountedComponent = {};

    function warnNoop(publicInstance, callerName) {
      {
        var constructor = publicInstance.constructor;
        var componentName = constructor && (constructor.displayName || constructor.name) || 'ReactClass';
        var warningKey = componentName + '.' + callerName;
        if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
          return;
        }
        warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op.\n\nPlease check the code for the %s component.', callerName, callerName, componentName);
        didWarnStateUpdateForUnmountedComponent[warningKey] = true;
      }
    }

    /**
     * This is the abstract API for an update queue.
     */
    var ReactNoopUpdateQueue = {
      /**
       * Checks whether or not this composite component is mounted.
       * @param {ReactClass} publicInstance The instance we want to test.
       * @return {boolean} True if mounted, false otherwise.
       * @protected
       * @final
       */
      isMounted: function isMounted(publicInstance) {
        return false;
      },

      /**
       * Forces an update. This should only be invoked when it is known with
       * certainty that we are **not** in a DOM transaction.
       *
       * You may want to call this when you know that some deeper aspect of the
       * component's state has changed but `setState` was not called.
       *
       * This will not invoke `shouldComponentUpdate`, but it will invoke
       * `componentWillUpdate` and `componentDidUpdate`.
       *
       * @param {ReactClass} publicInstance The instance that should rerender.
       * @param {?function} callback Called after component is updated.
       * @param {?string} callerName name of the calling function in the public API.
       * @internal
       */
      enqueueForceUpdate: function enqueueForceUpdate(publicInstance, callback, callerName) {
        warnNoop(publicInstance, 'forceUpdate');
      },

      /**
       * Replaces all of the state. Always use this or `setState` to mutate state.
       * You should treat `this.state` as immutable.
       *
       * There is no guarantee that `this.state` will be immediately updated, so
       * accessing `this.state` after calling this method may return the old value.
       *
       * @param {ReactClass} publicInstance The instance that should rerender.
       * @param {object} completeState Next state.
       * @param {?function} callback Called after component is updated.
       * @param {?string} callerName name of the calling function in the public API.
       * @internal
       */
      enqueueReplaceState: function enqueueReplaceState(publicInstance, completeState, callback, callerName) {
        warnNoop(publicInstance, 'replaceState');
      },

      /**
       * Sets a subset of the state. This only exists because _pendingState is
       * internal. This provides a merging strategy that is not available to deep
       * properties which is confusing. TODO: Expose pendingState or don't use it
       * during the merge.
       *
       * @param {ReactClass} publicInstance The instance that should rerender.
       * @param {object} partialState Next partial state to be merged with state.
       * @param {?function} callback Called after component is updated.
       * @param {?string} Name of the calling function in the public API.
       * @internal
       */
      enqueueSetState: function enqueueSetState(publicInstance, partialState, callback, callerName) {
        warnNoop(publicInstance, 'setState');
      }
    };

    /**
     * Base class helpers for the updating state of a component.
     */
    function Component(props, context, updater) {
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      // We initialize the default updater but the real one gets injected by the
      // renderer.
      this.updater = updater || ReactNoopUpdateQueue;
    }

    Component.prototype.isReactComponent = {};

    /**
     * Sets a subset of the state. Always use this to mutate
     * state. You should treat `this.state` as immutable.
     *
     * There is no guarantee that `this.state` will be immediately updated, so
     * accessing `this.state` after calling this method may return the old value.
     *
     * There is no guarantee that calls to `setState` will run synchronously,
     * as they may eventually be batched together.  You can provide an optional
     * callback that will be executed when the call to setState is actually
     * completed.
     *
     * When a function is provided to setState, it will be called at some point in
     * the future (not synchronously). It will be called with the up to date
     * component arguments (state, props, context). These values can be different
     * from this.* because your function may be called after receiveProps but before
     * shouldComponentUpdate, and this new state, props, and context will not yet be
     * assigned to this.
     *
     * @param {object|function} partialState Next partial state or function to
     *        produce next partial state to be merged with current state.
     * @param {?function} callback Called after state is updated.
     * @final
     * @protected
     */
    Component.prototype.setState = function (partialState, callback) {
      !((typeof partialState === 'undefined' ? 'undefined' : _typeof(partialState)) === 'object' || typeof partialState === 'function' || partialState == null) ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : void 0;
      this.updater.enqueueSetState(this, partialState, callback, 'setState');
    };

    /**
     * Forces an update. This should only be invoked when it is known with
     * certainty that we are **not** in a DOM transaction.
     *
     * You may want to call this when you know that some deeper aspect of the
     * component's state has changed but `setState` was not called.
     *
     * This will not invoke `shouldComponentUpdate`, but it will invoke
     * `componentWillUpdate` and `componentDidUpdate`.
     *
     * @param {?function} callback Called after update is complete.
     * @final
     * @protected
     */
    Component.prototype.forceUpdate = function (callback) {
      this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');
    };

    /**
     * Deprecated APIs. These APIs used to exist on classic React classes but since
     * we would like to deprecate them, we're not going to move them over to this
     * modern base class. Instead, we define a getter that warns if it's accessed.
     */
    {
      var deprecatedAPIs = {
        isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
        replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
      };
      var defineDeprecationWarning = function defineDeprecationWarning(methodName, info) {
        Object.defineProperty(Component.prototype, methodName, {
          get: function get() {
            lowPriorityWarning$1(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);
            return undefined;
          }
        });
      };
      for (var fnName in deprecatedAPIs) {
        if (deprecatedAPIs.hasOwnProperty(fnName)) {
          defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
        }
      }
    }

    /**
     * Base class helpers for the updating state of a component.
     */
    function PureComponent(props, context, updater) {
      // Duplicated from Component.
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      // We initialize the default updater but the real one gets injected by the
      // renderer.
      this.updater = updater || ReactNoopUpdateQueue;
    }

    function ComponentDummy() {}
    ComponentDummy.prototype = Component.prototype;
    var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
    pureComponentPrototype.constructor = PureComponent;
    // Avoid an extra prototype jump for these methods.
    _assign(pureComponentPrototype, Component.prototype);
    pureComponentPrototype.isPureReactComponent = true;

    function AsyncComponent(props, context, updater) {
      // Duplicated from Component.
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      // We initialize the default updater but the real one gets injected by the
      // renderer.
      this.updater = updater || ReactNoopUpdateQueue;
    }

    var asyncComponentPrototype = AsyncComponent.prototype = new ComponentDummy();
    asyncComponentPrototype.constructor = AsyncComponent;
    // Avoid an extra prototype jump for these methods.
    _assign(asyncComponentPrototype, Component.prototype);
    asyncComponentPrototype.unstable_isAsyncReactComponent = true;
    asyncComponentPrototype.render = function () {
      return this.props.children;
    };

    /**
     * Keeps track of the current owner.
     *
     * The current owner is the component who should own any components that are
     * currently being constructed.
     */
    var ReactCurrentOwner = {
      /**
       * @internal
       * @type {ReactComponent}
       */
      current: null
    };

    var hasOwnProperty = Object.prototype.hasOwnProperty;

    var RESERVED_PROPS = {
      key: true,
      ref: true,
      __self: true,
      __source: true
    };

    var specialPropKeyWarningShown;
    var specialPropRefWarningShown;

    function hasValidRef(config) {
      {
        if (hasOwnProperty.call(config, 'ref')) {
          var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
          if (getter && getter.isReactWarning) {
            return false;
          }
        }
      }
      return config.ref !== undefined;
    }

    function hasValidKey(config) {
      {
        if (hasOwnProperty.call(config, 'key')) {
          var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
          if (getter && getter.isReactWarning) {
            return false;
          }
        }
      }
      return config.key !== undefined;
    }

    function defineKeyPropWarningGetter(props, displayName) {
      var warnAboutAccessingKey = function warnAboutAccessingKey() {
        if (!specialPropKeyWarningShown) {
          specialPropKeyWarningShown = true;
          warning(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);
        }
      };
      warnAboutAccessingKey.isReactWarning = true;
      Object.defineProperty(props, 'key', {
        get: warnAboutAccessingKey,
        configurable: true
      });
    }

    function defineRefPropWarningGetter(props, displayName) {
      var warnAboutAccessingRef = function warnAboutAccessingRef() {
        if (!specialPropRefWarningShown) {
          specialPropRefWarningShown = true;
          warning(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);
        }
      };
      warnAboutAccessingRef.isReactWarning = true;
      Object.defineProperty(props, 'ref', {
        get: warnAboutAccessingRef,
        configurable: true
      });
    }

    /**
     * Factory method to create a new React element. This no longer adheres to
     * the class pattern, so do not use new to call it. Also, no instanceof check
     * will work. Instead test $$typeof field against Symbol.for('react.element') to check
     * if something is a React Element.
     *
     * @param {*} type
     * @param {*} key
     * @param {string|object} ref
     * @param {*} self A *temporary* helper to detect places where `this` is
     * different from the `owner` when React.createElement is called, so that we
     * can warn. We want to get rid of owner and replace string `ref`s with arrow
     * functions, and as long as `this` and owner are the same, there will be no
     * change in behavior.
     * @param {*} source An annotation object (added by a transpiler or otherwise)
     * indicating filename, line number, and/or other information.
     * @param {*} owner
     * @param {*} props
     * @internal
     */
    var ReactElement = function ReactElement(type, key, ref, self, source, owner, props) {
      var element = {
        // This tag allow us to uniquely identify this as a React Element
        $$typeof: REACT_ELEMENT_TYPE,

        // Built-in properties that belong on the element
        type: type,
        key: key,
        ref: ref,
        props: props,

        // Record the component responsible for creating this element.
        _owner: owner
      };

      {
        // The validation flag is currently mutative. We put it on
        // an external backing store so that we can freeze the whole object.
        // This can be replaced with a WeakMap once they are implemented in
        // commonly used development environments.
        element._store = {};

        // To make comparing ReactElements easier for testing purposes, we make
        // the validation flag non-enumerable (where possible, which should
        // include every environment we run tests in), so the test framework
        // ignores it.
        Object.defineProperty(element._store, 'validated', {
          configurable: false,
          enumerable: false,
          writable: true,
          value: false
        });
        // self and source are DEV only properties.
        Object.defineProperty(element, '_self', {
          configurable: false,
          enumerable: false,
          writable: false,
          value: self
        });
        // Two elements created in two different places should be considered
        // equal for testing purposes and therefore we hide it from enumeration.
        Object.defineProperty(element, '_source', {
          configurable: false,
          enumerable: false,
          writable: false,
          value: source
        });
        if (Object.freeze) {
          Object.freeze(element.props);
          Object.freeze(element);
        }
      }

      return element;
    };

    /**
     * Create and return a new ReactElement of the given type.
     * See https://reactjs.org/docs/react-api.html#createelement
     */
    function createElement(type, config, children) {
      var propName;

      // Reserved names are extracted
      var props = {};

      var key = null;
      var ref = null;
      var self = null;
      var source = null;

      if (config != null) {
        if (hasValidRef(config)) {
          ref = config.ref;
        }
        if (hasValidKey(config)) {
          key = '' + config.key;
        }

        self = config.__self === undefined ? null : config.__self;
        source = config.__source === undefined ? null : config.__source;
        // Remaining properties are added to a new props object
        for (propName in config) {
          if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
            props[propName] = config[propName];
          }
        }
      }

      // Children can be more than one argument, and those are transferred onto
      // the newly allocated props object.
      var childrenLength = arguments.length - 2;
      if (childrenLength === 1) {
        props.children = children;
      } else if (childrenLength > 1) {
        var childArray = Array(childrenLength);
        for (var i = 0; i < childrenLength; i++) {
          childArray[i] = arguments[i + 2];
        }
        {
          if (Object.freeze) {
            Object.freeze(childArray);
          }
        }
        props.children = childArray;
      }

      // Resolve default props
      if (type && type.defaultProps) {
        var defaultProps = type.defaultProps;
        for (propName in defaultProps) {
          if (props[propName] === undefined) {
            props[propName] = defaultProps[propName];
          }
        }
      }
      {
        if (key || ref) {
          if (typeof props.$$typeof === 'undefined' || props.$$typeof !== REACT_ELEMENT_TYPE) {
            var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
            if (key) {
              defineKeyPropWarningGetter(props, displayName);
            }
            if (ref) {
              defineRefPropWarningGetter(props, displayName);
            }
          }
        }
      }
      return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
    }

    /**
     * Return a function that produces ReactElements of a given type.
     * See https://reactjs.org/docs/react-api.html#createfactory
     */

    function cloneAndReplaceKey(oldElement, newKey) {
      var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);

      return newElement;
    }

    /**
     * Clone and return a new ReactElement using element as the starting point.
     * See https://reactjs.org/docs/react-api.html#cloneelement
     */
    function cloneElement(element, config, children) {
      var propName;

      // Original props are copied
      var props = _assign({}, element.props);

      // Reserved names are extracted
      var key = element.key;
      var ref = element.ref;
      // Self is preserved since the owner is preserved.
      var self = element._self;
      // Source is preserved since cloneElement is unlikely to be targeted by a
      // transpiler, and the original source is probably a better indicator of the
      // true owner.
      var source = element._source;

      // Owner will be preserved, unless ref is overridden
      var owner = element._owner;

      if (config != null) {
        if (hasValidRef(config)) {
          // Silently steal the ref from the parent.
          ref = config.ref;
          owner = ReactCurrentOwner.current;
        }
        if (hasValidKey(config)) {
          key = '' + config.key;
        }

        // Remaining properties override existing props
        var defaultProps;
        if (element.type && element.type.defaultProps) {
          defaultProps = element.type.defaultProps;
        }
        for (propName in config) {
          if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
            if (config[propName] === undefined && defaultProps !== undefined) {
              // Resolve default props
              props[propName] = defaultProps[propName];
            } else {
              props[propName] = config[propName];
            }
          }
        }
      }

      // Children can be more than one argument, and those are transferred onto
      // the newly allocated props object.
      var childrenLength = arguments.length - 2;
      if (childrenLength === 1) {
        props.children = children;
      } else if (childrenLength > 1) {
        var childArray = Array(childrenLength);
        for (var i = 0; i < childrenLength; i++) {
          childArray[i] = arguments[i + 2];
        }
        props.children = childArray;
      }

      return ReactElement(element.type, key, ref, self, source, owner, props);
    }

    /**
     * Verifies the object is a ReactElement.
     * See https://reactjs.org/docs/react-api.html#isvalidelement
     * @param {?object} object
     * @return {boolean} True if `object` is a valid component.
     * @final
     */
    function isValidElement(object) {
      return (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
    }

    var ReactDebugCurrentFrame = {};

    {
      // Component that is being worked on
      ReactDebugCurrentFrame.getCurrentStack = null;

      ReactDebugCurrentFrame.getStackAddendum = function () {
        var impl = ReactDebugCurrentFrame.getCurrentStack;
        if (impl) {
          return impl();
        }
        return null;
      };
    }

    var SEPARATOR = '.';
    var SUBSEPARATOR = ':';

    /**
     * Escape and wrap key so it is safe to use as a reactid
     *
     * @param {string} key to be escaped.
     * @return {string} the escaped key.
     */
    function escape(key) {
      var escapeRegex = /[=:]/g;
      var escaperLookup = {
        '=': '=0',
        ':': '=2'
      };
      var escapedString = ('' + key).replace(escapeRegex, function (match) {
        return escaperLookup[match];
      });

      return '$' + escapedString;
    }

    /**
     * TODO: Test that a single child and an array with one item have the same key
     * pattern.
     */

    var didWarnAboutMaps = false;

    var userProvidedKeyEscapeRegex = /\/+/g;
    function escapeUserProvidedKey(text) {
      return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');
    }

    var POOL_SIZE = 10;
    var traverseContextPool = [];
    function getPooledTraverseContext(mapResult, keyPrefix, mapFunction, mapContext) {
      if (traverseContextPool.length) {
        var traverseContext = traverseContextPool.pop();
        traverseContext.result = mapResult;
        traverseContext.keyPrefix = keyPrefix;
        traverseContext.func = mapFunction;
        traverseContext.context = mapContext;
        traverseContext.count = 0;
        return traverseContext;
      } else {
        return {
          result: mapResult,
          keyPrefix: keyPrefix,
          func: mapFunction,
          context: mapContext,
          count: 0
        };
      }
    }

    function releaseTraverseContext(traverseContext) {
      traverseContext.result = null;
      traverseContext.keyPrefix = null;
      traverseContext.func = null;
      traverseContext.context = null;
      traverseContext.count = 0;
      if (traverseContextPool.length < POOL_SIZE) {
        traverseContextPool.push(traverseContext);
      }
    }

    /**
     * @param {?*} children Children tree container.
     * @param {!string} nameSoFar Name of the key path so far.
     * @param {!function} callback Callback to invoke with each child found.
     * @param {?*} traverseContext Used to pass information throughout the traversal
     * process.
     * @return {!number} The number of children in this subtree.
     */
    function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
      var type = typeof children === 'undefined' ? 'undefined' : _typeof(children);

      if (type === 'undefined' || type === 'boolean') {
        // All of the above are perceived as null.
        children = null;
      }

      var invokeCallback = false;

      if (children === null) {
        invokeCallback = true;
      } else {
        switch (type) {
          case 'string':
          case 'number':
            invokeCallback = true;
            break;
          case 'object':
            switch (children.$$typeof) {
              case REACT_ELEMENT_TYPE:
              case REACT_CALL_TYPE:
              case REACT_RETURN_TYPE:
              case REACT_PORTAL_TYPE:
                invokeCallback = true;
            }
        }
      }

      if (invokeCallback) {
        callback(traverseContext, children,
        // If it's the only child, treat the name as if it was wrapped in an array
        // so that it's consistent if the number of children grows.
        nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
        return 1;
      }

      var child;
      var nextName;
      var subtreeCount = 0; // Count of children found in the current subtree.
      var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

      if (Array.isArray(children)) {
        for (var i = 0; i < children.length; i++) {
          child = children[i];
          nextName = nextNamePrefix + getComponentKey(child, i);
          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
        }
      } else {
        var iteratorFn = getIteratorFn(children);
        if (typeof iteratorFn === 'function') {
          {
            // Warn about using Maps as children
            if (iteratorFn === children.entries) {
              warning(didWarnAboutMaps, 'Using Maps as children is unsupported and will likely yield ' + 'unexpected results. Convert it to a sequence/iterable of keyed ' + 'ReactElements instead.%s', ReactDebugCurrentFrame.getStackAddendum());
              didWarnAboutMaps = true;
            }
          }

          var iterator = iteratorFn.call(children);
          var step;
          var ii = 0;
          while (!(step = iterator.next()).done) {
            child = step.value;
            nextName = nextNamePrefix + getComponentKey(child, ii++);
            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
          }
        } else if (type === 'object') {
          var addendum = '';
          {
            addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + ReactDebugCurrentFrame.getStackAddendum();
          }
          var childrenString = '' + children;
          invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum);
        }
      }

      return subtreeCount;
    }

    /**
     * Traverses children that are typically specified as `props.children`, but
     * might also be specified through attributes:
     *
     * - `traverseAllChildren(this.props.children, ...)`
     * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
     *
     * The `traverseContext` is an optional argument that is passed through the
     * entire traversal. It can be used to store accumulations or anything else that
     * the callback might find relevant.
     *
     * @param {?*} children Children tree object.
     * @param {!function} callback To invoke upon traversing each child.
     * @param {?*} traverseContext Context for traversal.
     * @return {!number} The number of children in this subtree.
     */
    function traverseAllChildren(children, callback, traverseContext) {
      if (children == null) {
        return 0;
      }

      return traverseAllChildrenImpl(children, '', callback, traverseContext);
    }

    /**
     * Generate a key string that identifies a component within a set.
     *
     * @param {*} component A component that could contain a manual key.
     * @param {number} index Index that is used if a manual key is not provided.
     * @return {string}
     */
    function getComponentKey(component, index) {
      // Do some typechecking here since we call this blindly. We want to ensure
      // that we don't block potential future ES APIs.
      if ((typeof component === 'undefined' ? 'undefined' : _typeof(component)) === 'object' && component !== null && component.key != null) {
        // Explicit key
        return escape(component.key);
      }
      // Implicit key determined by the index in the set
      return index.toString(36);
    }

    function forEachSingleChild(bookKeeping, child, name) {
      var func = bookKeeping.func,
          context = bookKeeping.context;

      func.call(context, child, bookKeeping.count++);
    }

    /**
     * Iterates through children that are typically specified as `props.children`.
     *
     * See https://reactjs.org/docs/react-api.html#react.children.foreach
     *
     * The provided forEachFunc(child, index) will be called for each
     * leaf child.
     *
     * @param {?*} children Children tree container.
     * @param {function(*, int)} forEachFunc
     * @param {*} forEachContext Context for forEachContext.
     */
    function forEachChildren(children, forEachFunc, forEachContext) {
      if (children == null) {
        return children;
      }
      var traverseContext = getPooledTraverseContext(null, null, forEachFunc, forEachContext);
      traverseAllChildren(children, forEachSingleChild, traverseContext);
      releaseTraverseContext(traverseContext);
    }

    function mapSingleChildIntoContext(bookKeeping, child, childKey) {
      var result = bookKeeping.result,
          keyPrefix = bookKeeping.keyPrefix,
          func = bookKeeping.func,
          context = bookKeeping.context;

      var mappedChild = func.call(context, child, bookKeeping.count++);
      if (Array.isArray(mappedChild)) {
        mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
      } else if (mappedChild != null) {
        if (isValidElement(mappedChild)) {
          mappedChild = cloneAndReplaceKey(mappedChild,
          // Keep both the (mapped) and old keys if they differ, just as
          // traverseAllChildren used to do for objects as children
          keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);
        }
        result.push(mappedChild);
      }
    }

    function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
      var escapedPrefix = '';
      if (prefix != null) {
        escapedPrefix = escapeUserProvidedKey(prefix) + '/';
      }
      var traverseContext = getPooledTraverseContext(array, escapedPrefix, func, context);
      traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
      releaseTraverseContext(traverseContext);
    }

    /**
     * Maps children that are typically specified as `props.children`.
     *
     * See https://reactjs.org/docs/react-api.html#react.children.map
     *
     * The provided mapFunction(child, key, index) will be called for each
     * leaf child.
     *
     * @param {?*} children Children tree container.
     * @param {function(*, int)} func The map function.
     * @param {*} context Context for mapFunction.
     * @return {object} Object containing the ordered map of results.
     */
    function mapChildren(children, func, context) {
      if (children == null) {
        return children;
      }
      var result = [];
      mapIntoWithKeyPrefixInternal(children, result, null, func, context);
      return result;
    }

    /**
     * Count the number of children that are typically specified as
     * `props.children`.
     *
     * See https://reactjs.org/docs/react-api.html#react.children.count
     *
     * @param {?*} children Children tree container.
     * @return {number} The number of children.
     */
    function countChildren(children, context) {
      return traverseAllChildren(children, emptyFunction.thatReturnsNull, null);
    }

    /**
     * Flatten a children object (typically specified as `props.children`) and
     * return an array with appropriately re-keyed children.
     *
     * See https://reactjs.org/docs/react-api.html#react.children.toarray
     */
    function toArray(children) {
      var result = [];
      mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
      return result;
    }

    /**
     * Returns the first child in a collection of children and verifies that there
     * is only one child in the collection.
     *
     * See https://reactjs.org/docs/react-api.html#react.children.only
     *
     * The current implementation of this function assumes that a single child gets
     * passed without a wrapper, but the purpose of this helper function is to
     * abstract away the particular structure of children.
     *
     * @param {?object} children Child collection structure.
     * @return {ReactElement} The first and only `ReactElement` contained in the
     * structure.
     */
    function onlyChild(children) {
      !isValidElement(children) ? invariant(false, 'React.Children.only expected to receive a single React element child.') : void 0;
      return children;
    }

    var describeComponentFrame = function describeComponentFrame(name, source, ownerName) {
      return '\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');
    };

    function getComponentName(fiber) {
      var type = fiber.type;

      if (typeof type === 'string') {
        return type;
      }
      if (typeof type === 'function') {
        return type.displayName || type.name;
      }
      return null;
    }

    /**
     * ReactElementValidator provides a wrapper around a element factory
     * which validates the props passed to the element. This is intended to be
     * used only in DEV and could be replaced by a static type checker for languages
     * that support it.
     */

    {
      var currentlyValidatingElement = null;

      var propTypesMisspellWarningShown = false;

      var getDisplayName = function getDisplayName(element) {
        if (element == null) {
          return '#empty';
        } else if (typeof element === 'string' || typeof element === 'number') {
          return '#text';
        } else if (typeof element.type === 'string') {
          return element.type;
        } else if (element.type === REACT_FRAGMENT_TYPE) {
          return 'React.Fragment';
        } else {
          return element.type.displayName || element.type.name || 'Unknown';
        }
      };

      var getStackAddendum = function getStackAddendum() {
        var stack = '';
        if (currentlyValidatingElement) {
          var name = getDisplayName(currentlyValidatingElement);
          var owner = currentlyValidatingElement._owner;
          stack += describeComponentFrame(name, currentlyValidatingElement._source, owner && getComponentName(owner));
        }
        stack += ReactDebugCurrentFrame.getStackAddendum() || '';
        return stack;
      };

      var VALID_FRAGMENT_PROPS = new Map([['children', true], ['key', true]]);
    }

    function getDeclarationErrorAddendum() {
      if (ReactCurrentOwner.current) {
        var name = getComponentName(ReactCurrentOwner.current);
        if (name) {
          return '\n\nCheck the render method of `' + name + '`.';
        }
      }
      return '';
    }

    function getSourceInfoErrorAddendum(elementProps) {
      if (elementProps !== null && elementProps !== undefined && elementProps.__source !== undefined) {
        var source = elementProps.__source;
        var fileName = source.fileName.replace(/^.*[\\\/]/, '');
        var lineNumber = source.lineNumber;
        return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
      }
      return '';
    }

    /**
     * Warn if there's no key explicitly set on dynamic arrays of children or
     * object keys are not valid. This allows us to keep track of children between
     * updates.
     */
    var ownerHasKeyUseWarning = {};

    function getCurrentComponentErrorInfo(parentType) {
      var info = getDeclarationErrorAddendum();

      if (!info) {
        var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
        if (parentName) {
          info = '\n\nCheck the top-level render call using <' + parentName + '>.';
        }
      }
      return info;
    }

    /**
     * Warn if the element doesn't have an explicit key assigned to it.
     * This element is in an array. The array could grow and shrink or be
     * reordered. All children that haven't already been validated are required to
     * have a "key" property assigned to it. Error statuses are cached so a warning
     * will only be shown once.
     *
     * @internal
     * @param {ReactElement} element Element that requires a key.
     * @param {*} parentType element's parent's type.
     */
    function validateExplicitKey(element, parentType) {
      if (!element._store || element._store.validated || element.key != null) {
        return;
      }
      element._store.validated = true;

      var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
      if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
        return;
      }
      ownerHasKeyUseWarning[currentComponentErrorInfo] = true;

      // Usually the current owner is the offender, but if it accepts children as a
      // property, it may be the creator of the child that's responsible for
      // assigning it a key.
      var childOwner = '';
      if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
        // Give the component that originally created this child.
        childOwner = ' It was passed a child from ' + getComponentName(element._owner) + '.';
      }

      currentlyValidatingElement = element;
      {
        warning(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.%s', currentComponentErrorInfo, childOwner, getStackAddendum());
      }
      currentlyValidatingElement = null;
    }

    /**
     * Ensure that every element either is passed in a static location, in an
     * array with an explicit keys property defined, or in an object literal
     * with valid key property.
     *
     * @internal
     * @param {ReactNode} node Statically passed child of any type.
     * @param {*} parentType node's parent's type.
     */
    function validateChildKeys(node, parentType) {
      if ((typeof node === 'undefined' ? 'undefined' : _typeof(node)) !== 'object') {
        return;
      }
      if (Array.isArray(node)) {
        for (var i = 0; i < node.length; i++) {
          var child = node[i];
          if (isValidElement(child)) {
            validateExplicitKey(child, parentType);
          }
        }
      } else if (isValidElement(node)) {
        // This element was passed in a valid location.
        if (node._store) {
          node._store.validated = true;
        }
      } else if (node) {
        var iteratorFn = getIteratorFn(node);
        if (typeof iteratorFn === 'function') {
          // Entry iterators used to provide implicit keys,
          // but now we print a separate warning for them later.
          if (iteratorFn !== node.entries) {
            var iterator = iteratorFn.call(node);
            var step;
            while (!(step = iterator.next()).done) {
              if (isValidElement(step.value)) {
                validateExplicitKey(step.value, parentType);
              }
            }
          }
        }
      }
    }

    /**
     * Given an element, validate that its props follow the propTypes definition,
     * provided by the type.
     *
     * @param {ReactElement} element
     */
    function validatePropTypes(element) {
      var componentClass = element.type;
      if (typeof componentClass !== 'function') {
        return;
      }
      var name = componentClass.displayName || componentClass.name;
      var propTypes = componentClass.propTypes;
      if (propTypes) {
        currentlyValidatingElement = element;
        checkPropTypes(propTypes, element.props, 'prop', name, getStackAddendum);
        currentlyValidatingElement = null;
      } else if (componentClass.PropTypes !== undefined && !propTypesMisspellWarningShown) {
        propTypesMisspellWarningShown = true;
        warning(false, 'Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', name || 'Unknown');
      }
      if (typeof componentClass.getDefaultProps === 'function') {
        warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
      }
    }

    /**
     * Given a fragment, validate that it can only be provided with fragment props
     * @param {ReactElement} fragment
     */
    function validateFragmentProps(fragment) {
      currentlyValidatingElement = fragment;

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = Object.keys(fragment.props)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var key = _step.value;

          if (!VALID_FRAGMENT_PROPS.has(key)) {
            warning(false, 'Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.%s', key, getStackAddendum());
            break;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator['return']) {
            _iterator['return']();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      if (fragment.ref !== null) {
        warning(false, 'Invalid attribute `ref` supplied to `React.Fragment`.%s', getStackAddendum());
      }

      currentlyValidatingElement = null;
    }

    function createElementWithValidation(type, props, children) {
      var validType = typeof type === 'string' || typeof type === 'function' || (typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'symbol' || typeof type === 'number';
      // We warn in this case but don't throw. We expect the element creation to
      // succeed and there will likely be errors in render.
      if (!validType) {
        var info = '';
        if (type === undefined || (typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object' && type !== null && Object.keys(type).length === 0) {
          info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
        }

        var sourceInfo = getSourceInfoErrorAddendum(props);
        if (sourceInfo) {
          info += sourceInfo;
        } else {
          info += getDeclarationErrorAddendum();
        }

        info += getStackAddendum() || '';

        warning(false, 'React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', type == null ? type : typeof type === 'undefined' ? 'undefined' : _typeof(type), info);
      }

      var element = createElement.apply(this, arguments);

      // The result can be nullish if a mock or a custom function is used.
      // TODO: Drop this when these are no longer allowed as the type argument.
      if (element == null) {
        return element;
      }

      // Skip key warning if the type isn't valid since our key validation logic
      // doesn't expect a non-string/function type and can throw confusing errors.
      // We don't want exception behavior to differ between dev and prod.
      // (Rendering will throw with a helpful message and as soon as the type is
      // fixed, the key warnings will appear.)
      if (validType) {
        for (var i = 2; i < arguments.length; i++) {
          validateChildKeys(arguments[i], type);
        }
      }

      if ((typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'symbol' && type === REACT_FRAGMENT_TYPE) {
        validateFragmentProps(element);
      } else {
        validatePropTypes(element);
      }

      return element;
    }

    function createFactoryWithValidation(type) {
      var validatedFactory = createElementWithValidation.bind(null, type);
      // Legacy hook TODO: Warn if this is accessed
      validatedFactory.type = type;

      {
        Object.defineProperty(validatedFactory, 'type', {
          enumerable: false,
          get: function get() {
            lowPriorityWarning$1(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');
            Object.defineProperty(this, 'type', {
              value: type
            });
            return type;
          }
        });
      }

      return validatedFactory;
    }

    function cloneElementWithValidation(element, props, children) {
      var newElement = cloneElement.apply(this, arguments);
      for (var i = 2; i < arguments.length; i++) {
        validateChildKeys(arguments[i], newElement.type);
      }
      validatePropTypes(newElement);
      return newElement;
    }

    var React = {
      Children: {
        map: mapChildren,
        forEach: forEachChildren,
        count: countChildren,
        toArray: toArray,
        only: onlyChild
      },

      Component: Component,
      PureComponent: PureComponent,
      unstable_AsyncComponent: AsyncComponent,

      Fragment: REACT_FRAGMENT_TYPE,

      createElement: createElementWithValidation,
      cloneElement: cloneElementWithValidation,
      createFactory: createFactoryWithValidation,
      isValidElement: isValidElement,

      version: ReactVersion,

      __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {
        ReactCurrentOwner: ReactCurrentOwner,
        // Used by renderers to avoid bundling object-assign twice in UMD bundles:
        assign: _assign
      }
    };

    {
      _assign(React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, {
        // These should not be included in production.
        ReactDebugCurrentFrame: ReactDebugCurrentFrame,
        // Shim for React DOM 16.0.0 which still destructured (but not used) this.
        // TODO: remove in React 17.0.
        ReactComponentTreeHook: {}
      });
    }

    var React$2 = Object.freeze({
      default: React
    });

    var React$3 = React$2 && React || React$2;

    // TODO: decide on the top-level export form.
    // This is hacky but makes it work with both Rollup and Jest.
    var react = React$3['default'] ? React$3['default'] : React$3;

    module.exports = react;
  })();
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.2.0
 * react-dom.production.min.js
 *
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var aa = __webpack_require__(3),
    l = __webpack_require__(21),
    B = __webpack_require__(9),
    C = __webpack_require__(4),
    ba = __webpack_require__(22),
    da = __webpack_require__(23),
    ea = __webpack_require__(24),
    fa = __webpack_require__(25),
    ia = __webpack_require__(26),
    D = __webpack_require__(10);
function E(a) {
  for (var b = arguments.length - 1, c = "Minified React error #" + a + "; visit http://facebook.github.io/react/docs/error-decoder.html?invariant\x3d" + a, d = 0; d < b; d++) {
    c += "\x26args[]\x3d" + encodeURIComponent(arguments[d + 1]);
  }b = Error(c + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.");b.name = "Invariant Violation";b.framesToPop = 1;throw b;
}aa ? void 0 : E("227");
var oa = { children: !0, dangerouslySetInnerHTML: !0, defaultValue: !0, defaultChecked: !0, innerHTML: !0, suppressContentEditableWarning: !0, suppressHydrationWarning: !0, style: !0 };function pa(a, b) {
  return (a & b) === b;
}
var ta = { MUST_USE_PROPERTY: 1, HAS_BOOLEAN_VALUE: 4, HAS_NUMERIC_VALUE: 8, HAS_POSITIVE_NUMERIC_VALUE: 24, HAS_OVERLOADED_BOOLEAN_VALUE: 32, HAS_STRING_BOOLEAN_VALUE: 64, injectDOMPropertyConfig: function injectDOMPropertyConfig(a) {
    var b = ta,
        c = a.Properties || {},
        d = a.DOMAttributeNamespaces || {},
        e = a.DOMAttributeNames || {};a = a.DOMMutationMethods || {};for (var f in c) {
      ua.hasOwnProperty(f) ? E("48", f) : void 0;var g = f.toLowerCase(),
          h = c[f];g = { attributeName: g, attributeNamespace: null, propertyName: f, mutationMethod: null, mustUseProperty: pa(h, b.MUST_USE_PROPERTY),
        hasBooleanValue: pa(h, b.HAS_BOOLEAN_VALUE), hasNumericValue: pa(h, b.HAS_NUMERIC_VALUE), hasPositiveNumericValue: pa(h, b.HAS_POSITIVE_NUMERIC_VALUE), hasOverloadedBooleanValue: pa(h, b.HAS_OVERLOADED_BOOLEAN_VALUE), hasStringBooleanValue: pa(h, b.HAS_STRING_BOOLEAN_VALUE) };1 >= g.hasBooleanValue + g.hasNumericValue + g.hasOverloadedBooleanValue ? void 0 : E("50", f);e.hasOwnProperty(f) && (g.attributeName = e[f]);d.hasOwnProperty(f) && (g.attributeNamespace = d[f]);a.hasOwnProperty(f) && (g.mutationMethod = a[f]);ua[f] = g;
    }
  } },
    ua = {};
function va(a, b) {
  if (oa.hasOwnProperty(a) || 2 < a.length && ("o" === a[0] || "O" === a[0]) && ("n" === a[1] || "N" === a[1])) return !1;if (null === b) return !0;switch (typeof b === "undefined" ? "undefined" : _typeof(b)) {case "boolean":
      return oa.hasOwnProperty(a) ? a = !0 : (b = wa(a)) ? a = b.hasBooleanValue || b.hasStringBooleanValue || b.hasOverloadedBooleanValue : (a = a.toLowerCase().slice(0, 5), a = "data-" === a || "aria-" === a), a;case "undefined":case "number":case "string":case "object":
      return !0;default:
      return !1;}
}function wa(a) {
  return ua.hasOwnProperty(a) ? ua[a] : null;
}
var xa = ta,
    ya = xa.MUST_USE_PROPERTY,
    K = xa.HAS_BOOLEAN_VALUE,
    za = xa.HAS_NUMERIC_VALUE,
    Aa = xa.HAS_POSITIVE_NUMERIC_VALUE,
    Ba = xa.HAS_OVERLOADED_BOOLEAN_VALUE,
    Ca = xa.HAS_STRING_BOOLEAN_VALUE,
    Da = { Properties: { allowFullScreen: K, async: K, autoFocus: K, autoPlay: K, capture: Ba, checked: ya | K, cols: Aa, contentEditable: Ca, controls: K, "default": K, defer: K, disabled: K, download: Ba, draggable: Ca, formNoValidate: K, hidden: K, loop: K, multiple: ya | K, muted: ya | K, noValidate: K, open: K, playsInline: K, readOnly: K, required: K, reversed: K, rows: Aa, rowSpan: za,
    scoped: K, seamless: K, selected: ya | K, size: Aa, start: za, span: Aa, spellCheck: Ca, style: 0, tabIndex: 0, itemScope: K, acceptCharset: 0, className: 0, htmlFor: 0, httpEquiv: 0, value: Ca }, DOMAttributeNames: { acceptCharset: "accept-charset", className: "class", htmlFor: "for", httpEquiv: "http-equiv" }, DOMMutationMethods: { value: function value(a, b) {
      if (null == b) return a.removeAttribute("value");"number" !== a.type || !1 === a.hasAttribute("value") ? a.setAttribute("value", "" + b) : a.validity && !a.validity.badInput && a.ownerDocument.activeElement !== a && a.setAttribute("value", "" + b);
    } } },
    Ea = xa.HAS_STRING_BOOLEAN_VALUE,
    M = { xlink: "http://www.w3.org/1999/xlink", xml: "http://www.w3.org/XML/1998/namespace" },
    Ga = { Properties: { autoReverse: Ea, externalResourcesRequired: Ea, preserveAlpha: Ea }, DOMAttributeNames: { autoReverse: "autoReverse", externalResourcesRequired: "externalResourcesRequired", preserveAlpha: "preserveAlpha" }, DOMAttributeNamespaces: { xlinkActuate: M.xlink, xlinkArcrole: M.xlink, xlinkHref: M.xlink, xlinkRole: M.xlink, xlinkShow: M.xlink, xlinkTitle: M.xlink, xlinkType: M.xlink,
    xmlBase: M.xml, xmlLang: M.xml, xmlSpace: M.xml } },
    Ha = /[\-\:]([a-z])/g;function Ia(a) {
  return a[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode x-height xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type xml:base xmlns:xlink xml:lang xml:space".split(" ").forEach(function (a) {
  var b = a.replace(Ha, Ia);Ga.Properties[b] = 0;Ga.DOMAttributeNames[b] = a;
});xa.injectDOMPropertyConfig(Da);xa.injectDOMPropertyConfig(Ga);
var P = { _caughtError: null, _hasCaughtError: !1, _rethrowError: null, _hasRethrowError: !1, injection: { injectErrorUtils: function injectErrorUtils(a) {
      "function" !== typeof a.invokeGuardedCallback ? E("197") : void 0;Ja = a.invokeGuardedCallback;
    } }, invokeGuardedCallback: function invokeGuardedCallback(a, b, c, d, e, f, g, h, k) {
    Ja.apply(P, arguments);
  }, invokeGuardedCallbackAndCatchFirstError: function invokeGuardedCallbackAndCatchFirstError(a, b, c, d, e, f, g, h, k) {
    P.invokeGuardedCallback.apply(this, arguments);if (P.hasCaughtError()) {
      var q = P.clearCaughtError();P._hasRethrowError || (P._hasRethrowError = !0, P._rethrowError = q);
    }
  }, rethrowCaughtError: function rethrowCaughtError() {
    return Ka.apply(P, arguments);
  }, hasCaughtError: function hasCaughtError() {
    return P._hasCaughtError;
  }, clearCaughtError: function clearCaughtError() {
    if (P._hasCaughtError) {
      var a = P._caughtError;P._caughtError = null;P._hasCaughtError = !1;return a;
    }E("198");
  } };function Ja(a, b, c, d, e, f, g, h, k) {
  P._hasCaughtError = !1;P._caughtError = null;var q = Array.prototype.slice.call(arguments, 3);try {
    b.apply(c, q);
  } catch (v) {
    P._caughtError = v, P._hasCaughtError = !0;
  }
}
function Ka() {
  if (P._hasRethrowError) {
    var a = P._rethrowError;P._rethrowError = null;P._hasRethrowError = !1;throw a;
  }
}var La = null,
    Ma = {};
function Na() {
  if (La) for (var a in Ma) {
    var b = Ma[a],
        c = La.indexOf(a);-1 < c ? void 0 : E("96", a);if (!Oa[c]) {
      b.extractEvents ? void 0 : E("97", a);Oa[c] = b;c = b.eventTypes;for (var d in c) {
        var e = void 0;var f = c[d],
            g = b,
            h = d;Pa.hasOwnProperty(h) ? E("99", h) : void 0;Pa[h] = f;var k = f.phasedRegistrationNames;if (k) {
          for (e in k) {
            k.hasOwnProperty(e) && Qa(k[e], g, h);
          }e = !0;
        } else f.registrationName ? (Qa(f.registrationName, g, h), e = !0) : e = !1;e ? void 0 : E("98", d, a);
      }
    }
  }
}
function Qa(a, b, c) {
  Ra[a] ? E("100", a) : void 0;Ra[a] = b;Sa[a] = b.eventTypes[c].dependencies;
}var Oa = [],
    Pa = {},
    Ra = {},
    Sa = {};function Ta(a) {
  La ? E("101") : void 0;La = Array.prototype.slice.call(a);Na();
}function Ua(a) {
  var b = !1,
      c;for (c in a) {
    if (a.hasOwnProperty(c)) {
      var d = a[c];Ma.hasOwnProperty(c) && Ma[c] === d || (Ma[c] ? E("102", c) : void 0, Ma[c] = d, b = !0);
    }
  }b && Na();
}
var Va = Object.freeze({ plugins: Oa, eventNameDispatchConfigs: Pa, registrationNameModules: Ra, registrationNameDependencies: Sa, possibleRegistrationNames: null, injectEventPluginOrder: Ta, injectEventPluginsByName: Ua }),
    Wa = null,
    Xa = null,
    Ya = null;function Za(a, b, c, d) {
  b = a.type || "unknown-event";a.currentTarget = Ya(d);P.invokeGuardedCallbackAndCatchFirstError(b, c, void 0, a);a.currentTarget = null;
}
function $a(a, b) {
  null == b ? E("30") : void 0;if (null == a) return b;if (Array.isArray(a)) {
    if (Array.isArray(b)) return a.push.apply(a, b), a;a.push(b);return a;
  }return Array.isArray(b) ? [a].concat(b) : [a, b];
}function ab(a, b, c) {
  Array.isArray(a) ? a.forEach(b, c) : a && b.call(c, a);
}var bb = null;
function cb(a, b) {
  if (a) {
    var c = a._dispatchListeners,
        d = a._dispatchInstances;if (Array.isArray(c)) for (var e = 0; e < c.length && !a.isPropagationStopped(); e++) {
      Za(a, b, c[e], d[e]);
    } else c && Za(a, b, c, d);a._dispatchListeners = null;a._dispatchInstances = null;a.isPersistent() || a.constructor.release(a);
  }
}function db(a) {
  return cb(a, !0);
}function gb(a) {
  return cb(a, !1);
}var hb = { injectEventPluginOrder: Ta, injectEventPluginsByName: Ua };
function ib(a, b) {
  var c = a.stateNode;if (!c) return null;var d = Wa(c);if (!d) return null;c = d[b];a: switch (b) {case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":
      (d = !d.disabled) || (a = a.type, d = !("button" === a || "input" === a || "select" === a || "textarea" === a));a = !d;break a;default:
      a = !1;}if (a) return null;c && "function" !== typeof c ? E("231", b, typeof c === "undefined" ? "undefined" : _typeof(c)) : void 0;
  return c;
}function jb(a, b, c, d) {
  for (var e, f = 0; f < Oa.length; f++) {
    var g = Oa[f];g && (g = g.extractEvents(a, b, c, d)) && (e = $a(e, g));
  }return e;
}function kb(a) {
  a && (bb = $a(bb, a));
}function lb(a) {
  var b = bb;bb = null;b && (a ? ab(b, db) : ab(b, gb), bb ? E("95") : void 0, P.rethrowCaughtError());
}var mb = Object.freeze({ injection: hb, getListener: ib, extractEvents: jb, enqueueEvents: kb, processEventQueue: lb }),
    nb = Math.random().toString(36).slice(2),
    Q = "__reactInternalInstance$" + nb,
    ob = "__reactEventHandlers$" + nb;
function pb(a) {
  if (a[Q]) return a[Q];for (var b = []; !a[Q];) {
    if (b.push(a), a.parentNode) a = a.parentNode;else return null;
  }var c = void 0,
      d = a[Q];if (5 === d.tag || 6 === d.tag) return d;for (; a && (d = a[Q]); a = b.pop()) {
    c = d;
  }return c;
}function qb(a) {
  if (5 === a.tag || 6 === a.tag) return a.stateNode;E("33");
}function rb(a) {
  return a[ob] || null;
}
var sb = Object.freeze({ precacheFiberNode: function precacheFiberNode(a, b) {
    b[Q] = a;
  }, getClosestInstanceFromNode: pb, getInstanceFromNode: function getInstanceFromNode(a) {
    a = a[Q];return !a || 5 !== a.tag && 6 !== a.tag ? null : a;
  }, getNodeFromInstance: qb, getFiberCurrentPropsFromNode: rb, updateFiberProps: function updateFiberProps(a, b) {
    a[ob] = b;
  } });function tb(a) {
  do {
    a = a["return"];
  } while (a && 5 !== a.tag);return a ? a : null;
}function ub(a, b, c) {
  for (var d = []; a;) {
    d.push(a), a = tb(a);
  }for (a = d.length; 0 < a--;) {
    b(d[a], "captured", c);
  }for (a = 0; a < d.length; a++) {
    b(d[a], "bubbled", c);
  }
}
function vb(a, b, c) {
  if (b = ib(a, c.dispatchConfig.phasedRegistrationNames[b])) c._dispatchListeners = $a(c._dispatchListeners, b), c._dispatchInstances = $a(c._dispatchInstances, a);
}function wb(a) {
  a && a.dispatchConfig.phasedRegistrationNames && ub(a._targetInst, vb, a);
}function xb(a) {
  if (a && a.dispatchConfig.phasedRegistrationNames) {
    var b = a._targetInst;b = b ? tb(b) : null;ub(b, vb, a);
  }
}
function yb(a, b, c) {
  a && c && c.dispatchConfig.registrationName && (b = ib(a, c.dispatchConfig.registrationName)) && (c._dispatchListeners = $a(c._dispatchListeners, b), c._dispatchInstances = $a(c._dispatchInstances, a));
}function zb(a) {
  a && a.dispatchConfig.registrationName && yb(a._targetInst, null, a);
}function Ab(a) {
  ab(a, wb);
}
function Bb(a, b, c, d) {
  if (c && d) a: {
    var e = c;for (var f = d, g = 0, h = e; h; h = tb(h)) {
      g++;
    }h = 0;for (var k = f; k; k = tb(k)) {
      h++;
    }for (; 0 < g - h;) {
      e = tb(e), g--;
    }for (; 0 < h - g;) {
      f = tb(f), h--;
    }for (; g--;) {
      if (e === f || e === f.alternate) break a;e = tb(e);f = tb(f);
    }e = null;
  } else e = null;f = e;for (e = []; c && c !== f;) {
    g = c.alternate;if (null !== g && g === f) break;e.push(c);c = tb(c);
  }for (c = []; d && d !== f;) {
    g = d.alternate;if (null !== g && g === f) break;c.push(d);d = tb(d);
  }for (d = 0; d < e.length; d++) {
    yb(e[d], "bubbled", a);
  }for (a = c.length; 0 < a--;) {
    yb(c[a], "captured", b);
  }
}
var Cb = Object.freeze({ accumulateTwoPhaseDispatches: Ab, accumulateTwoPhaseDispatchesSkipTarget: function accumulateTwoPhaseDispatchesSkipTarget(a) {
    ab(a, xb);
  }, accumulateEnterLeaveDispatches: Bb, accumulateDirectDispatches: function accumulateDirectDispatches(a) {
    ab(a, zb);
  } }),
    Db = null;function Eb() {
  !Db && l.canUseDOM && (Db = "textContent" in document.documentElement ? "textContent" : "innerText");return Db;
}var S = { _root: null, _startText: null, _fallbackText: null };
function Fb() {
  if (S._fallbackText) return S._fallbackText;var a,
      b = S._startText,
      c = b.length,
      d,
      e = Gb(),
      f = e.length;for (a = 0; a < c && b[a] === e[a]; a++) {}var g = c - a;for (d = 1; d <= g && b[c - d] === e[f - d]; d++) {}S._fallbackText = e.slice(a, 1 < d ? 1 - d : void 0);return S._fallbackText;
}function Gb() {
  return "value" in S._root ? S._root.value : S._root[Eb()];
}
var Hb = "dispatchConfig _targetInst nativeEvent isDefaultPrevented isPropagationStopped _dispatchListeners _dispatchInstances".split(" "),
    Ib = { type: null, target: null, currentTarget: C.thatReturnsNull, eventPhase: null, bubbles: null, cancelable: null, timeStamp: function timeStamp(a) {
    return a.timeStamp || Date.now();
  }, defaultPrevented: null, isTrusted: null };
function T(a, b, c, d) {
  this.dispatchConfig = a;this._targetInst = b;this.nativeEvent = c;a = this.constructor.Interface;for (var e in a) {
    a.hasOwnProperty(e) && ((b = a[e]) ? this[e] = b(c) : "target" === e ? this.target = d : this[e] = c[e]);
  }this.isDefaultPrevented = (null != c.defaultPrevented ? c.defaultPrevented : !1 === c.returnValue) ? C.thatReturnsTrue : C.thatReturnsFalse;this.isPropagationStopped = C.thatReturnsFalse;return this;
}
B(T.prototype, { preventDefault: function preventDefault() {
    this.defaultPrevented = !0;var a = this.nativeEvent;a && (a.preventDefault ? a.preventDefault() : "unknown" !== typeof a.returnValue && (a.returnValue = !1), this.isDefaultPrevented = C.thatReturnsTrue);
  }, stopPropagation: function stopPropagation() {
    var a = this.nativeEvent;a && (a.stopPropagation ? a.stopPropagation() : "unknown" !== typeof a.cancelBubble && (a.cancelBubble = !0), this.isPropagationStopped = C.thatReturnsTrue);
  }, persist: function persist() {
    this.isPersistent = C.thatReturnsTrue;
  }, isPersistent: C.thatReturnsFalse,
  destructor: function destructor() {
    var a = this.constructor.Interface,
        b;for (b in a) {
      this[b] = null;
    }for (a = 0; a < Hb.length; a++) {
      this[Hb[a]] = null;
    }
  } });T.Interface = Ib;T.augmentClass = function (a, b) {
  function c() {}c.prototype = this.prototype;var d = new c();B(d, a.prototype);a.prototype = d;a.prototype.constructor = a;a.Interface = B({}, this.Interface, b);a.augmentClass = this.augmentClass;Jb(a);
};Jb(T);function Kb(a, b, c, d) {
  if (this.eventPool.length) {
    var e = this.eventPool.pop();this.call(e, a, b, c, d);return e;
  }return new this(a, b, c, d);
}
function Lb(a) {
  a instanceof this ? void 0 : E("223");a.destructor();10 > this.eventPool.length && this.eventPool.push(a);
}function Jb(a) {
  a.eventPool = [];a.getPooled = Kb;a.release = Lb;
}function Mb(a, b, c, d) {
  return T.call(this, a, b, c, d);
}T.augmentClass(Mb, { data: null });function Nb(a, b, c, d) {
  return T.call(this, a, b, c, d);
}T.augmentClass(Nb, { data: null });var Pb = [9, 13, 27, 32],
    Vb = l.canUseDOM && "CompositionEvent" in window,
    Wb = null;l.canUseDOM && "documentMode" in document && (Wb = document.documentMode);var Xb;
if (Xb = l.canUseDOM && "TextEvent" in window && !Wb) {
  var Yb = window.opera;Xb = !("object" === (typeof Yb === "undefined" ? "undefined" : _typeof(Yb)) && "function" === typeof Yb.version && 12 >= parseInt(Yb.version(), 10));
}
var Zb = Xb,
    $b = l.canUseDOM && (!Vb || Wb && 8 < Wb && 11 >= Wb),
    ac = String.fromCharCode(32),
    bc = { beforeInput: { phasedRegistrationNames: { bubbled: "onBeforeInput", captured: "onBeforeInputCapture" }, dependencies: ["topCompositionEnd", "topKeyPress", "topTextInput", "topPaste"] }, compositionEnd: { phasedRegistrationNames: { bubbled: "onCompositionEnd", captured: "onCompositionEndCapture" }, dependencies: "topBlur topCompositionEnd topKeyDown topKeyPress topKeyUp topMouseDown".split(" ") }, compositionStart: { phasedRegistrationNames: { bubbled: "onCompositionStart",
      captured: "onCompositionStartCapture" }, dependencies: "topBlur topCompositionStart topKeyDown topKeyPress topKeyUp topMouseDown".split(" ") }, compositionUpdate: { phasedRegistrationNames: { bubbled: "onCompositionUpdate", captured: "onCompositionUpdateCapture" }, dependencies: "topBlur topCompositionUpdate topKeyDown topKeyPress topKeyUp topMouseDown".split(" ") } },
    cc = !1;
function dc(a, b) {
  switch (a) {case "topKeyUp":
      return -1 !== Pb.indexOf(b.keyCode);case "topKeyDown":
      return 229 !== b.keyCode;case "topKeyPress":case "topMouseDown":case "topBlur":
      return !0;default:
      return !1;}
}function ec(a) {
  a = a.detail;return "object" === (typeof a === "undefined" ? "undefined" : _typeof(a)) && "data" in a ? a.data : null;
}var fc = !1;function gc(a, b) {
  switch (a) {case "topCompositionEnd":
      return ec(b);case "topKeyPress":
      if (32 !== b.which) return null;cc = !0;return ac;case "topTextInput":
      return a = b.data, a === ac && cc ? null : a;default:
      return null;}
}
function hc(a, b) {
  if (fc) return "topCompositionEnd" === a || !Vb && dc(a, b) ? (a = Fb(), S._root = null, S._startText = null, S._fallbackText = null, fc = !1, a) : null;switch (a) {case "topPaste":
      return null;case "topKeyPress":
      if (!(b.ctrlKey || b.altKey || b.metaKey) || b.ctrlKey && b.altKey) {
        if (b.char && 1 < b.char.length) return b.char;if (b.which) return String.fromCharCode(b.which);
      }return null;case "topCompositionEnd":
      return $b ? null : b.data;default:
      return null;}
}
var ic = { eventTypes: bc, extractEvents: function extractEvents(a, b, c, d) {
    var e;if (Vb) b: {
      switch (a) {case "topCompositionStart":
          var f = bc.compositionStart;break b;case "topCompositionEnd":
          f = bc.compositionEnd;break b;case "topCompositionUpdate":
          f = bc.compositionUpdate;break b;}f = void 0;
    } else fc ? dc(a, c) && (f = bc.compositionEnd) : "topKeyDown" === a && 229 === c.keyCode && (f = bc.compositionStart);f ? ($b && (fc || f !== bc.compositionStart ? f === bc.compositionEnd && fc && (e = Fb()) : (S._root = d, S._startText = Gb(), fc = !0)), f = Mb.getPooled(f, b, c, d), e ? f.data = e : (e = ec(c), null !== e && (f.data = e)), Ab(f), e = f) : e = null;(a = Zb ? gc(a, c) : hc(a, c)) ? (b = Nb.getPooled(bc.beforeInput, b, c, d), b.data = a, Ab(b)) : b = null;return [e, b];
  } },
    jc = null,
    kc = null,
    lc = null;function mc(a) {
  if (a = Xa(a)) {
    jc && "function" === typeof jc.restoreControlledState ? void 0 : E("194");var b = Wa(a.stateNode);jc.restoreControlledState(a.stateNode, a.type, b);
  }
}var nc = { injectFiberControlledHostComponent: function injectFiberControlledHostComponent(a) {
    jc = a;
  } };function oc(a) {
  kc ? lc ? lc.push(a) : lc = [a] : kc = a;
}
function pc() {
  if (kc) {
    var a = kc,
        b = lc;lc = kc = null;mc(a);if (b) for (a = 0; a < b.length; a++) {
      mc(b[a]);
    }
  }
}var qc = Object.freeze({ injection: nc, enqueueStateRestore: oc, restoreStateIfNeeded: pc });function rc(a, b) {
  return a(b);
}var sc = !1;function tc(a, b) {
  if (sc) return rc(a, b);sc = !0;try {
    return rc(a, b);
  } finally {
    sc = !1, pc();
  }
}var uc = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 };
function vc(a) {
  var b = a && a.nodeName && a.nodeName.toLowerCase();return "input" === b ? !!uc[a.type] : "textarea" === b ? !0 : !1;
}function wc(a) {
  a = a.target || a.srcElement || window;a.correspondingUseElement && (a = a.correspondingUseElement);return 3 === a.nodeType ? a.parentNode : a;
}var xc;l.canUseDOM && (xc = document.implementation && document.implementation.hasFeature && !0 !== document.implementation.hasFeature("", ""));
function yc(a, b) {
  if (!l.canUseDOM || b && !("addEventListener" in document)) return !1;b = "on" + a;var c = b in document;c || (c = document.createElement("div"), c.setAttribute(b, "return;"), c = "function" === typeof c[b]);!c && xc && "wheel" === a && (c = document.implementation.hasFeature("Events.wheel", "3.0"));return c;
}function zc(a) {
  var b = a.type;return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b || "radio" === b);
}
function Ac(a) {
  var b = zc(a) ? "checked" : "value",
      c = Object.getOwnPropertyDescriptor(a.constructor.prototype, b),
      d = "" + a[b];if (!a.hasOwnProperty(b) && "function" === typeof c.get && "function" === typeof c.set) return Object.defineProperty(a, b, { enumerable: c.enumerable, configurable: !0, get: function get() {
      return c.get.call(this);
    }, set: function set(a) {
      d = "" + a;c.set.call(this, a);
    } }), { getValue: function getValue() {
      return d;
    }, setValue: function setValue(a) {
      d = "" + a;
    }, stopTracking: function stopTracking() {
      a._valueTracker = null;delete a[b];
    } };
}
function Bc(a) {
  a._valueTracker || (a._valueTracker = Ac(a));
}function Cc(a) {
  if (!a) return !1;var b = a._valueTracker;if (!b) return !0;var c = b.getValue();var d = "";a && (d = zc(a) ? a.checked ? "true" : "false" : a.value);a = d;return a !== c ? (b.setValue(a), !0) : !1;
}var Dc = { change: { phasedRegistrationNames: { bubbled: "onChange", captured: "onChangeCapture" }, dependencies: "topBlur topChange topClick topFocus topInput topKeyDown topKeyUp topSelectionChange".split(" ") } };
function Ec(a, b, c) {
  a = T.getPooled(Dc.change, a, b, c);a.type = "change";oc(c);Ab(a);return a;
}var Fc = null,
    Gc = null;function Hc(a) {
  kb(a);lb(!1);
}function Ic(a) {
  var b = qb(a);if (Cc(b)) return a;
}function Jc(a, b) {
  if ("topChange" === a) return b;
}var Kc = !1;l.canUseDOM && (Kc = yc("input") && (!document.documentMode || 9 < document.documentMode));function Lc() {
  Fc && (Fc.detachEvent("onpropertychange", Mc), Gc = Fc = null);
}function Mc(a) {
  "value" === a.propertyName && Ic(Gc) && (a = Ec(Gc, a, wc(a)), tc(Hc, a));
}
function Nc(a, b, c) {
  "topFocus" === a ? (Lc(), Fc = b, Gc = c, Fc.attachEvent("onpropertychange", Mc)) : "topBlur" === a && Lc();
}function Oc(a) {
  if ("topSelectionChange" === a || "topKeyUp" === a || "topKeyDown" === a) return Ic(Gc);
}function Pc(a, b) {
  if ("topClick" === a) return Ic(b);
}function $c(a, b) {
  if ("topInput" === a || "topChange" === a) return Ic(b);
}
var ad = { eventTypes: Dc, _isInputEventSupported: Kc, extractEvents: function extractEvents(a, b, c, d) {
    var e = b ? qb(b) : window,
        f = e.nodeName && e.nodeName.toLowerCase();if ("select" === f || "input" === f && "file" === e.type) var g = Jc;else if (vc(e)) {
      if (Kc) g = $c;else {
        g = Oc;var h = Nc;
      }
    } else f = e.nodeName, !f || "input" !== f.toLowerCase() || "checkbox" !== e.type && "radio" !== e.type || (g = Pc);if (g && (g = g(a, b))) return Ec(g, c, d);h && h(a, e, b);"topBlur" === a && null != b && (a = b._wrapperState || e._wrapperState) && a.controlled && "number" === e.type && (a = "" + e.value, e.getAttribute("value") !== a && e.setAttribute("value", a));
  } };function bd(a, b, c, d) {
  return T.call(this, a, b, c, d);
}T.augmentClass(bd, { view: null, detail: null });var cd = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };function dd(a) {
  var b = this.nativeEvent;return b.getModifierState ? b.getModifierState(a) : (a = cd[a]) ? !!b[a] : !1;
}function ed() {
  return dd;
}function fd(a, b, c, d) {
  return T.call(this, a, b, c, d);
}
bd.augmentClass(fd, { screenX: null, screenY: null, clientX: null, clientY: null, pageX: null, pageY: null, ctrlKey: null, shiftKey: null, altKey: null, metaKey: null, getModifierState: ed, button: null, buttons: null, relatedTarget: function relatedTarget(a) {
    return a.relatedTarget || (a.fromElement === a.srcElement ? a.toElement : a.fromElement);
  } });
var gd = { mouseEnter: { registrationName: "onMouseEnter", dependencies: ["topMouseOut", "topMouseOver"] }, mouseLeave: { registrationName: "onMouseLeave", dependencies: ["topMouseOut", "topMouseOver"] } },
    hd = { eventTypes: gd, extractEvents: function extractEvents(a, b, c, d) {
    if ("topMouseOver" === a && (c.relatedTarget || c.fromElement) || "topMouseOut" !== a && "topMouseOver" !== a) return null;var e = d.window === d ? d : (e = d.ownerDocument) ? e.defaultView || e.parentWindow : window;"topMouseOut" === a ? (a = b, b = (b = c.relatedTarget || c.toElement) ? pb(b) : null) : a = null;if (a === b) return null;var f = null == a ? e : qb(a);e = null == b ? e : qb(b);var g = fd.getPooled(gd.mouseLeave, a, c, d);g.type = "mouseleave";g.target = f;g.relatedTarget = e;c = fd.getPooled(gd.mouseEnter, b, c, d);c.type = "mouseenter";c.target = e;c.relatedTarget = f;Bb(g, c, a, b);return [g, c];
  } },
    id = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner;function jd(a) {
  a = a.type;return "string" === typeof a ? a : "function" === typeof a ? a.displayName || a.name : null;
}
function kd(a) {
  var b = a;if (a.alternate) for (; b["return"];) {
    b = b["return"];
  } else {
    if (0 !== (b.effectTag & 2)) return 1;for (; b["return"];) {
      if (b = b["return"], 0 !== (b.effectTag & 2)) return 1;
    }
  }return 3 === b.tag ? 2 : 3;
}function ld(a) {
  return (a = a._reactInternalFiber) ? 2 === kd(a) : !1;
}function md(a) {
  2 !== kd(a) ? E("188") : void 0;
}
function nd(a) {
  var b = a.alternate;if (!b) return b = kd(a), 3 === b ? E("188") : void 0, 1 === b ? null : a;for (var c = a, d = b;;) {
    var e = c["return"],
        f = e ? e.alternate : null;if (!e || !f) break;if (e.child === f.child) {
      for (var g = e.child; g;) {
        if (g === c) return md(e), a;if (g === d) return md(e), b;g = g.sibling;
      }E("188");
    }if (c["return"] !== d["return"]) c = e, d = f;else {
      g = !1;for (var h = e.child; h;) {
        if (h === c) {
          g = !0;c = e;d = f;break;
        }if (h === d) {
          g = !0;d = e;c = f;break;
        }h = h.sibling;
      }if (!g) {
        for (h = f.child; h;) {
          if (h === c) {
            g = !0;c = f;d = e;break;
          }if (h === d) {
            g = !0;d = f;c = e;break;
          }h = h.sibling;
        }g ? void 0 : E("189");
      }
    }c.alternate !== d ? E("190") : void 0;
  }3 !== c.tag ? E("188") : void 0;return c.stateNode.current === c ? a : b;
}function od(a) {
  a = nd(a);if (!a) return null;for (var b = a;;) {
    if (5 === b.tag || 6 === b.tag) return b;if (b.child) b.child["return"] = b, b = b.child;else {
      if (b === a) break;for (; !b.sibling;) {
        if (!b["return"] || b["return"] === a) return null;b = b["return"];
      }b.sibling["return"] = b["return"];b = b.sibling;
    }
  }return null;
}
function pd(a) {
  a = nd(a);if (!a) return null;for (var b = a;;) {
    if (5 === b.tag || 6 === b.tag) return b;if (b.child && 4 !== b.tag) b.child["return"] = b, b = b.child;else {
      if (b === a) break;for (; !b.sibling;) {
        if (!b["return"] || b["return"] === a) return null;b = b["return"];
      }b.sibling["return"] = b["return"];b = b.sibling;
    }
  }return null;
}var qd = [];
function rd(a) {
  var b = a.targetInst;do {
    if (!b) {
      a.ancestors.push(b);break;
    }var c;for (c = b; c["return"];) {
      c = c["return"];
    }c = 3 !== c.tag ? null : c.stateNode.containerInfo;if (!c) break;a.ancestors.push(b);b = pb(c);
  } while (b);for (c = 0; c < a.ancestors.length; c++) {
    b = a.ancestors[c], sd(a.topLevelType, b, a.nativeEvent, wc(a.nativeEvent));
  }
}var td = !0,
    sd = void 0;function ud(a) {
  td = !!a;
}function U(a, b, c) {
  return c ? ba.listen(c, b, vd.bind(null, a)) : null;
}function wd(a, b, c) {
  return c ? ba.capture(c, b, vd.bind(null, a)) : null;
}
function vd(a, b) {
  if (td) {
    var c = wc(b);c = pb(c);null === c || "number" !== typeof c.tag || 2 === kd(c) || (c = null);if (qd.length) {
      var d = qd.pop();d.topLevelType = a;d.nativeEvent = b;d.targetInst = c;a = d;
    } else a = { topLevelType: a, nativeEvent: b, targetInst: c, ancestors: [] };try {
      tc(rd, a);
    } finally {
      a.topLevelType = null, a.nativeEvent = null, a.targetInst = null, a.ancestors.length = 0, 10 > qd.length && qd.push(a);
    }
  }
}
var xd = Object.freeze({ get _enabled() {
    return td;
  }, get _handleTopLevel() {
    return sd;
  }, setHandleTopLevel: function setHandleTopLevel(a) {
    sd = a;
  }, setEnabled: ud, isEnabled: function isEnabled() {
    return td;
  }, trapBubbledEvent: U, trapCapturedEvent: wd, dispatchEvent: vd });function yd(a, b) {
  var c = {};c[a.toLowerCase()] = b.toLowerCase();c["Webkit" + a] = "webkit" + b;c["Moz" + a] = "moz" + b;c["ms" + a] = "MS" + b;c["O" + a] = "o" + b.toLowerCase();return c;
}
var zd = { animationend: yd("Animation", "AnimationEnd"), animationiteration: yd("Animation", "AnimationIteration"), animationstart: yd("Animation", "AnimationStart"), transitionend: yd("Transition", "TransitionEnd") },
    Ad = {},
    Bd = {};l.canUseDOM && (Bd = document.createElement("div").style, "AnimationEvent" in window || (delete zd.animationend.animation, delete zd.animationiteration.animation, delete zd.animationstart.animation), "TransitionEvent" in window || delete zd.transitionend.transition);
function Cd(a) {
  if (Ad[a]) return Ad[a];if (!zd[a]) return a;var b = zd[a],
      c;for (c in b) {
    if (b.hasOwnProperty(c) && c in Bd) return Ad[a] = b[c];
  }return "";
}
var Dd = { topAbort: "abort", topAnimationEnd: Cd("animationend") || "animationend", topAnimationIteration: Cd("animationiteration") || "animationiteration", topAnimationStart: Cd("animationstart") || "animationstart", topBlur: "blur", topCancel: "cancel", topCanPlay: "canplay", topCanPlayThrough: "canplaythrough", topChange: "change", topClick: "click", topClose: "close", topCompositionEnd: "compositionend", topCompositionStart: "compositionstart", topCompositionUpdate: "compositionupdate", topContextMenu: "contextmenu", topCopy: "copy",
  topCut: "cut", topDoubleClick: "dblclick", topDrag: "drag", topDragEnd: "dragend", topDragEnter: "dragenter", topDragExit: "dragexit", topDragLeave: "dragleave", topDragOver: "dragover", topDragStart: "dragstart", topDrop: "drop", topDurationChange: "durationchange", topEmptied: "emptied", topEncrypted: "encrypted", topEnded: "ended", topError: "error", topFocus: "focus", topInput: "input", topKeyDown: "keydown", topKeyPress: "keypress", topKeyUp: "keyup", topLoadedData: "loadeddata", topLoad: "load", topLoadedMetadata: "loadedmetadata", topLoadStart: "loadstart",
  topMouseDown: "mousedown", topMouseMove: "mousemove", topMouseOut: "mouseout", topMouseOver: "mouseover", topMouseUp: "mouseup", topPaste: "paste", topPause: "pause", topPlay: "play", topPlaying: "playing", topProgress: "progress", topRateChange: "ratechange", topScroll: "scroll", topSeeked: "seeked", topSeeking: "seeking", topSelectionChange: "selectionchange", topStalled: "stalled", topSuspend: "suspend", topTextInput: "textInput", topTimeUpdate: "timeupdate", topToggle: "toggle", topTouchCancel: "touchcancel", topTouchEnd: "touchend", topTouchMove: "touchmove",
  topTouchStart: "touchstart", topTransitionEnd: Cd("transitionend") || "transitionend", topVolumeChange: "volumechange", topWaiting: "waiting", topWheel: "wheel" },
    Ed = {},
    Fd = 0,
    Gd = "_reactListenersID" + ("" + Math.random()).slice(2);function Hd(a) {
  Object.prototype.hasOwnProperty.call(a, Gd) || (a[Gd] = Fd++, Ed[a[Gd]] = {});return Ed[a[Gd]];
}function Id(a) {
  for (; a && a.firstChild;) {
    a = a.firstChild;
  }return a;
}
function Jd(a, b) {
  var c = Id(a);a = 0;for (var d; c;) {
    if (3 === c.nodeType) {
      d = a + c.textContent.length;if (a <= b && d >= b) return { node: c, offset: b - a };a = d;
    }a: {
      for (; c;) {
        if (c.nextSibling) {
          c = c.nextSibling;break a;
        }c = c.parentNode;
      }c = void 0;
    }c = Id(c);
  }
}function Kd(a) {
  var b = a && a.nodeName && a.nodeName.toLowerCase();return b && ("input" === b && "text" === a.type || "textarea" === b || "true" === a.contentEditable);
}
var Ld = l.canUseDOM && "documentMode" in document && 11 >= document.documentMode,
    Md = { select: { phasedRegistrationNames: { bubbled: "onSelect", captured: "onSelectCapture" }, dependencies: "topBlur topContextMenu topFocus topKeyDown topKeyUp topMouseDown topMouseUp topSelectionChange".split(" ") } },
    Nd = null,
    Od = null,
    Pd = null,
    Qd = !1;
function Rd(a, b) {
  if (Qd || null == Nd || Nd !== da()) return null;var c = Nd;"selectionStart" in c && Kd(c) ? c = { start: c.selectionStart, end: c.selectionEnd } : window.getSelection ? (c = window.getSelection(), c = { anchorNode: c.anchorNode, anchorOffset: c.anchorOffset, focusNode: c.focusNode, focusOffset: c.focusOffset }) : c = void 0;return Pd && ea(Pd, c) ? null : (Pd = c, a = T.getPooled(Md.select, Od, a, b), a.type = "select", a.target = Nd, Ab(a), a);
}
var Sd = { eventTypes: Md, extractEvents: function extractEvents(a, b, c, d) {
    var e = d.window === d ? d.document : 9 === d.nodeType ? d : d.ownerDocument,
        f;if (!(f = !e)) {
      a: {
        e = Hd(e);f = Sa.onSelect;for (var g = 0; g < f.length; g++) {
          var h = f[g];if (!e.hasOwnProperty(h) || !e[h]) {
            e = !1;break a;
          }
        }e = !0;
      }f = !e;
    }if (f) return null;e = b ? qb(b) : window;switch (a) {case "topFocus":
        if (vc(e) || "true" === e.contentEditable) Nd = e, Od = b, Pd = null;break;case "topBlur":
        Pd = Od = Nd = null;break;case "topMouseDown":
        Qd = !0;break;case "topContextMenu":case "topMouseUp":
        return Qd = !1, Rd(c, d);case "topSelectionChange":
        if (Ld) break;
      case "topKeyDown":case "topKeyUp":
        return Rd(c, d);}return null;
  } };function Td(a, b, c, d) {
  return T.call(this, a, b, c, d);
}T.augmentClass(Td, { animationName: null, elapsedTime: null, pseudoElement: null });function Ud(a, b, c, d) {
  return T.call(this, a, b, c, d);
}T.augmentClass(Ud, { clipboardData: function clipboardData(a) {
    return "clipboardData" in a ? a.clipboardData : window.clipboardData;
  } });function Vd(a, b, c, d) {
  return T.call(this, a, b, c, d);
}bd.augmentClass(Vd, { relatedTarget: null });
function Wd(a) {
  var b = a.keyCode;"charCode" in a ? (a = a.charCode, 0 === a && 13 === b && (a = 13)) : a = b;return 32 <= a || 13 === a ? a : 0;
}
var Xd = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" },
    Yd = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4",
  116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" };function Zd(a, b, c, d) {
  return T.call(this, a, b, c, d);
}
bd.augmentClass(Zd, { key: function key(a) {
    if (a.key) {
      var b = Xd[a.key] || a.key;if ("Unidentified" !== b) return b;
    }return "keypress" === a.type ? (a = Wd(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? Yd[a.keyCode] || "Unidentified" : "";
  }, location: null, ctrlKey: null, shiftKey: null, altKey: null, metaKey: null, repeat: null, locale: null, getModifierState: ed, charCode: function charCode(a) {
    return "keypress" === a.type ? Wd(a) : 0;
  }, keyCode: function keyCode(a) {
    return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
  }, which: function which(a) {
    return "keypress" === a.type ? Wd(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
  } });function $d(a, b, c, d) {
  return T.call(this, a, b, c, d);
}fd.augmentClass($d, { dataTransfer: null });function ae(a, b, c, d) {
  return T.call(this, a, b, c, d);
}bd.augmentClass(ae, { touches: null, targetTouches: null, changedTouches: null, altKey: null, metaKey: null, ctrlKey: null, shiftKey: null, getModifierState: ed });function be(a, b, c, d) {
  return T.call(this, a, b, c, d);
}T.augmentClass(be, { propertyName: null, elapsedTime: null, pseudoElement: null });
function ce(a, b, c, d) {
  return T.call(this, a, b, c, d);
}fd.augmentClass(ce, { deltaX: function deltaX(a) {
    return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
  }, deltaY: function deltaY(a) {
    return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
  }, deltaZ: null, deltaMode: null });var de = {},
    ee = {};
"abort animationEnd animationIteration animationStart blur cancel canPlay canPlayThrough click close contextMenu copy cut doubleClick drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error focus input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing progress rateChange reset scroll seeked seeking stalled submit suspend timeUpdate toggle touchCancel touchEnd touchMove touchStart transitionEnd volumeChange waiting wheel".split(" ").forEach(function (a) {
  var b = a[0].toUpperCase() + a.slice(1),
      c = "on" + b;b = "top" + b;c = { phasedRegistrationNames: { bubbled: c, captured: c + "Capture" }, dependencies: [b] };de[a] = c;ee[b] = c;
});
var fe = { eventTypes: de, extractEvents: function extractEvents(a, b, c, d) {
    var e = ee[a];if (!e) return null;switch (a) {case "topKeyPress":
        if (0 === Wd(c)) return null;case "topKeyDown":case "topKeyUp":
        a = Zd;break;case "topBlur":case "topFocus":
        a = Vd;break;case "topClick":
        if (2 === c.button) return null;case "topDoubleClick":case "topMouseDown":case "topMouseMove":case "topMouseUp":case "topMouseOut":case "topMouseOver":case "topContextMenu":
        a = fd;break;case "topDrag":case "topDragEnd":case "topDragEnter":case "topDragExit":case "topDragLeave":case "topDragOver":case "topDragStart":case "topDrop":
        a = $d;break;case "topTouchCancel":case "topTouchEnd":case "topTouchMove":case "topTouchStart":
        a = ae;break;case "topAnimationEnd":case "topAnimationIteration":case "topAnimationStart":
        a = Td;break;case "topTransitionEnd":
        a = be;break;case "topScroll":
        a = bd;break;case "topWheel":
        a = ce;break;case "topCopy":case "topCut":case "topPaste":
        a = Ud;break;default:
        a = T;}b = a.getPooled(e, b, c, d);Ab(b);return b;
  } };sd = function sd(a, b, c, d) {
  a = jb(a, b, c, d);kb(a);lb(!1);
};hb.injectEventPluginOrder("ResponderEventPlugin SimpleEventPlugin TapEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));
Wa = sb.getFiberCurrentPropsFromNode;Xa = sb.getInstanceFromNode;Ya = sb.getNodeFromInstance;hb.injectEventPluginsByName({ SimpleEventPlugin: fe, EnterLeaveEventPlugin: hd, ChangeEventPlugin: ad, SelectEventPlugin: Sd, BeforeInputEventPlugin: ic });var ge = [],
    he = -1;function V(a) {
  0 > he || (a.current = ge[he], ge[he] = null, he--);
}function W(a, b) {
  he++;ge[he] = a.current;a.current = b;
}new Set();var ie = { current: D },
    X = { current: !1 },
    je = D;function ke(a) {
  return le(a) ? je : ie.current;
}
function me(a, b) {
  var c = a.type.contextTypes;if (!c) return D;var d = a.stateNode;if (d && d.__reactInternalMemoizedUnmaskedChildContext === b) return d.__reactInternalMemoizedMaskedChildContext;var e = {},
      f;for (f in c) {
    e[f] = b[f];
  }d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b, a.__reactInternalMemoizedMaskedChildContext = e);return e;
}function le(a) {
  return 2 === a.tag && null != a.type.childContextTypes;
}function ne(a) {
  le(a) && (V(X, a), V(ie, a));
}
function oe(a, b, c) {
  null != ie.cursor ? E("168") : void 0;W(ie, b, a);W(X, c, a);
}function pe(a, b) {
  var c = a.stateNode,
      d = a.type.childContextTypes;if ("function" !== typeof c.getChildContext) return b;c = c.getChildContext();for (var e in c) {
    e in d ? void 0 : E("108", jd(a) || "Unknown", e);
  }return B({}, b, c);
}function qe(a) {
  if (!le(a)) return !1;var b = a.stateNode;b = b && b.__reactInternalMemoizedMergedChildContext || D;je = ie.current;W(ie, b, a);W(X, X.current, a);return !0;
}
function re(a, b) {
  var c = a.stateNode;c ? void 0 : E("169");if (b) {
    var d = pe(a, je);c.__reactInternalMemoizedMergedChildContext = d;V(X, a);V(ie, a);W(ie, d, a);
  } else V(X, a);W(X, b, a);
}
function Y(a, b, c) {
  this.tag = a;this.key = b;this.stateNode = this.type = null;this.sibling = this.child = this["return"] = null;this.index = 0;this.memoizedState = this.updateQueue = this.memoizedProps = this.pendingProps = this.ref = null;this.internalContextTag = c;this.effectTag = 0;this.lastEffect = this.firstEffect = this.nextEffect = null;this.expirationTime = 0;this.alternate = null;
}
function se(a, b, c) {
  var d = a.alternate;null === d ? (d = new Y(a.tag, a.key, a.internalContextTag), d.type = a.type, d.stateNode = a.stateNode, d.alternate = a, a.alternate = d) : (d.effectTag = 0, d.nextEffect = null, d.firstEffect = null, d.lastEffect = null);d.expirationTime = c;d.pendingProps = b;d.child = a.child;d.memoizedProps = a.memoizedProps;d.memoizedState = a.memoizedState;d.updateQueue = a.updateQueue;d.sibling = a.sibling;d.index = a.index;d.ref = a.ref;return d;
}
function te(a, b, c) {
  var d = void 0,
      e = a.type,
      f = a.key;"function" === typeof e ? (d = e.prototype && e.prototype.isReactComponent ? new Y(2, f, b) : new Y(0, f, b), d.type = e, d.pendingProps = a.props) : "string" === typeof e ? (d = new Y(5, f, b), d.type = e, d.pendingProps = a.props) : "object" === (typeof e === "undefined" ? "undefined" : _typeof(e)) && null !== e && "number" === typeof e.tag ? (d = e, d.pendingProps = a.props) : E("130", null == e ? e : typeof e === "undefined" ? "undefined" : _typeof(e), "");d.expirationTime = c;return d;
}function ue(a, b, c, d) {
  b = new Y(10, d, b);b.pendingProps = a;b.expirationTime = c;return b;
}
function ve(a, b, c) {
  b = new Y(6, null, b);b.pendingProps = a;b.expirationTime = c;return b;
}function we(a, b, c) {
  b = new Y(7, a.key, b);b.type = a.handler;b.pendingProps = a;b.expirationTime = c;return b;
}function xe(a, b, c) {
  a = new Y(9, null, b);a.expirationTime = c;return a;
}function ye(a, b, c) {
  b = new Y(4, a.key, b);b.pendingProps = a.children || [];b.expirationTime = c;b.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation };return b;
}var ze = null,
    Ae = null;
function Be(a) {
  return function (b) {
    try {
      return a(b);
    } catch (c) {}
  };
}function Ce(a) {
  if ("undefined" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) return !1;var b = __REACT_DEVTOOLS_GLOBAL_HOOK__;if (b.isDisabled || !b.supportsFiber) return !0;try {
    var c = b.inject(a);ze = Be(function (a) {
      return b.onCommitFiberRoot(c, a);
    });Ae = Be(function (a) {
      return b.onCommitFiberUnmount(c, a);
    });
  } catch (d) {}return !0;
}function De(a) {
  "function" === typeof ze && ze(a);
}function Ee(a) {
  "function" === typeof Ae && Ae(a);
}
function Fe(a) {
  return { baseState: a, expirationTime: 0, first: null, last: null, callbackList: null, hasForceUpdate: !1, isInitialized: !1 };
}function Ge(a, b) {
  null === a.last ? a.first = a.last = b : (a.last.next = b, a.last = b);if (0 === a.expirationTime || a.expirationTime > b.expirationTime) a.expirationTime = b.expirationTime;
}
function He(a, b) {
  var c = a.alternate,
      d = a.updateQueue;null === d && (d = a.updateQueue = Fe(null));null !== c ? (a = c.updateQueue, null === a && (a = c.updateQueue = Fe(null))) : a = null;a = a !== d ? a : null;null === a ? Ge(d, b) : null === d.last || null === a.last ? (Ge(d, b), Ge(a, b)) : (Ge(d, b), a.last = b);
}function Ie(a, b, c, d) {
  a = a.partialState;return "function" === typeof a ? a.call(b, c, d) : a;
}
function Je(a, b, c, d, e, f) {
  null !== a && a.updateQueue === c && (c = b.updateQueue = { baseState: c.baseState, expirationTime: c.expirationTime, first: c.first, last: c.last, isInitialized: c.isInitialized, callbackList: null, hasForceUpdate: !1 });c.expirationTime = 0;c.isInitialized ? a = c.baseState : (a = c.baseState = b.memoizedState, c.isInitialized = !0);for (var g = !0, h = c.first, k = !1; null !== h;) {
    var q = h.expirationTime;if (q > f) {
      var v = c.expirationTime;if (0 === v || v > q) c.expirationTime = q;k || (k = !0, c.baseState = a);
    } else {
      k || (c.first = h.next, null === c.first && (c.last = null));if (h.isReplace) a = Ie(h, d, a, e), g = !0;else if (q = Ie(h, d, a, e)) a = g ? B({}, a, q) : B(a, q), g = !1;h.isForced && (c.hasForceUpdate = !0);null !== h.callback && (q = c.callbackList, null === q && (q = c.callbackList = []), q.push(h));
    }h = h.next;
  }null !== c.callbackList ? b.effectTag |= 32 : null !== c.first || c.hasForceUpdate || (b.updateQueue = null);k || (c.baseState = a);return a;
}
function Ke(a, b) {
  var c = a.callbackList;if (null !== c) for (a.callbackList = null, a = 0; a < c.length; a++) {
    var d = c[a],
        e = d.callback;d.callback = null;"function" !== typeof e ? E("191", e) : void 0;e.call(b);
  }
}
function Le(a, b, c, d) {
  function e(a, b) {
    b.updater = f;a.stateNode = b;b._reactInternalFiber = a;
  }var f = { isMounted: ld, enqueueSetState: function enqueueSetState(c, d, e) {
      c = c._reactInternalFiber;e = void 0 === e ? null : e;var g = b(c);He(c, { expirationTime: g, partialState: d, callback: e, isReplace: !1, isForced: !1, nextCallback: null, next: null });a(c, g);
    }, enqueueReplaceState: function enqueueReplaceState(c, d, e) {
      c = c._reactInternalFiber;e = void 0 === e ? null : e;var g = b(c);He(c, { expirationTime: g, partialState: d, callback: e, isReplace: !0, isForced: !1, nextCallback: null, next: null });
      a(c, g);
    }, enqueueForceUpdate: function enqueueForceUpdate(c, d) {
      c = c._reactInternalFiber;d = void 0 === d ? null : d;var e = b(c);He(c, { expirationTime: e, partialState: null, callback: d, isReplace: !1, isForced: !0, nextCallback: null, next: null });a(c, e);
    } };return { adoptClassInstance: e, constructClassInstance: function constructClassInstance(a, b) {
      var c = a.type,
          d = ke(a),
          f = 2 === a.tag && null != a.type.contextTypes,
          g = f ? me(a, d) : D;b = new c(b, g);e(a, b);f && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = d, a.__reactInternalMemoizedMaskedChildContext = g);return b;
    }, mountClassInstance: function mountClassInstance(a, b) {
      var c = a.alternate,
          d = a.stateNode,
          e = d.state || null,
          g = a.pendingProps;g ? void 0 : E("158");var h = ke(a);d.props = g;d.state = a.memoizedState = e;d.refs = D;d.context = me(a, h);null != a.type && null != a.type.prototype && !0 === a.type.prototype.unstable_isAsyncReactComponent && (a.internalContextTag |= 1);"function" === typeof d.componentWillMount && (e = d.state, d.componentWillMount(), e !== d.state && f.enqueueReplaceState(d, d.state, null), e = a.updateQueue, null !== e && (d.state = Je(c, a, e, d, g, b)));"function" === typeof d.componentDidMount && (a.effectTag |= 4);
    }, updateClassInstance: function updateClassInstance(a, b, e) {
      var g = b.stateNode;g.props = b.memoizedProps;g.state = b.memoizedState;var h = b.memoizedProps,
          k = b.pendingProps;k || (k = h, null == k ? E("159") : void 0);var u = g.context,
          z = ke(b);z = me(b, z);"function" !== typeof g.componentWillReceiveProps || h === k && u === z || (u = g.state, g.componentWillReceiveProps(k, z), g.state !== u && f.enqueueReplaceState(g, g.state, null));u = b.memoizedState;e = null !== b.updateQueue ? Je(a, b, b.updateQueue, g, k, e) : u;if (!(h !== k || u !== e || X.current || null !== b.updateQueue && b.updateQueue.hasForceUpdate)) return "function" !== typeof g.componentDidUpdate || h === a.memoizedProps && u === a.memoizedState || (b.effectTag |= 4), !1;var G = k;if (null === h || null !== b.updateQueue && b.updateQueue.hasForceUpdate) G = !0;else {
        var I = b.stateNode,
            L = b.type;G = "function" === typeof I.shouldComponentUpdate ? I.shouldComponentUpdate(G, e, z) : L.prototype && L.prototype.isPureReactComponent ? !ea(h, G) || !ea(u, e) : !0;
      }G ? ("function" === typeof g.componentWillUpdate && g.componentWillUpdate(k, e, z), "function" === typeof g.componentDidUpdate && (b.effectTag |= 4)) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && u === a.memoizedState || (b.effectTag |= 4), c(b, k), d(b, e));g.props = k;g.state = e;g.context = z;return G;
    } };
}var Qe = "function" === typeof Symbol && Symbol["for"],
    Re = Qe ? Symbol["for"]("react.element") : 60103,
    Se = Qe ? Symbol["for"]("react.call") : 60104,
    Te = Qe ? Symbol["for"]("react.return") : 60105,
    Ue = Qe ? Symbol["for"]("react.portal") : 60106,
    Ve = Qe ? Symbol["for"]("react.fragment") : 60107,
    We = "function" === typeof Symbol && Symbol.iterator;
function Xe(a) {
  if (null === a || "undefined" === typeof a) return null;a = We && a[We] || a["@@iterator"];return "function" === typeof a ? a : null;
}var Ye = Array.isArray;
function Ze(a, b) {
  var c = b.ref;if (null !== c && "function" !== typeof c) {
    if (b._owner) {
      b = b._owner;var d = void 0;b && (2 !== b.tag ? E("110") : void 0, d = b.stateNode);d ? void 0 : E("147", c);var e = "" + c;if (null !== a && null !== a.ref && a.ref._stringRef === e) return a.ref;a = function a(_a) {
        var b = d.refs === D ? d.refs = {} : d.refs;null === _a ? delete b[e] : b[e] = _a;
      };a._stringRef = e;return a;
    }"string" !== typeof c ? E("148") : void 0;b._owner ? void 0 : E("149", c);
  }return c;
}
function $e(a, b) {
  "textarea" !== a.type && E("31", "[object Object]" === Object.prototype.toString.call(b) ? "object with keys {" + Object.keys(b).join(", ") + "}" : b, "");
}
function af(a) {
  function b(b, c) {
    if (a) {
      var d = b.lastEffect;null !== d ? (d.nextEffect = c, b.lastEffect = c) : b.firstEffect = b.lastEffect = c;c.nextEffect = null;c.effectTag = 8;
    }
  }function c(c, d) {
    if (!a) return null;for (; null !== d;) {
      b(c, d), d = d.sibling;
    }return null;
  }function d(a, b) {
    for (a = new Map(); null !== b;) {
      null !== b.key ? a.set(b.key, b) : a.set(b.index, b), b = b.sibling;
    }return a;
  }function e(a, b, c) {
    a = se(a, b, c);a.index = 0;a.sibling = null;return a;
  }function f(b, c, d) {
    b.index = d;if (!a) return c;d = b.alternate;if (null !== d) return d = d.index, d < c ? (b.effectTag = 2, c) : d;b.effectTag = 2;return c;
  }function g(b) {
    a && null === b.alternate && (b.effectTag = 2);return b;
  }function h(a, b, c, d) {
    if (null === b || 6 !== b.tag) return b = ve(c, a.internalContextTag, d), b["return"] = a, b;b = e(b, c, d);b["return"] = a;return b;
  }function k(a, b, c, d) {
    if (null !== b && b.type === c.type) return d = e(b, c.props, d), d.ref = Ze(b, c), d["return"] = a, d;d = te(c, a.internalContextTag, d);d.ref = Ze(b, c);d["return"] = a;return d;
  }function q(a, b, c, d) {
    if (null === b || 7 !== b.tag) return b = we(c, a.internalContextTag, d), b["return"] = a, b;b = e(b, c, d);
    b["return"] = a;return b;
  }function v(a, b, c, d) {
    if (null === b || 9 !== b.tag) return b = xe(c, a.internalContextTag, d), b.type = c.value, b["return"] = a, b;b = e(b, null, d);b.type = c.value;b["return"] = a;return b;
  }function y(a, b, c, d) {
    if (null === b || 4 !== b.tag || b.stateNode.containerInfo !== c.containerInfo || b.stateNode.implementation !== c.implementation) return b = ye(c, a.internalContextTag, d), b["return"] = a, b;b = e(b, c.children || [], d);b["return"] = a;return b;
  }function u(a, b, c, d, f) {
    if (null === b || 10 !== b.tag) return b = ue(c, a.internalContextTag, d, f), b["return"] = a, b;b = e(b, c, d);b["return"] = a;return b;
  }function z(a, b, c) {
    if ("string" === typeof b || "number" === typeof b) return b = ve("" + b, a.internalContextTag, c), b["return"] = a, b;if ("object" === (typeof b === "undefined" ? "undefined" : _typeof(b)) && null !== b) {
      switch (b.$$typeof) {case Re:
          if (b.type === Ve) return b = ue(b.props.children, a.internalContextTag, c, b.key), b["return"] = a, b;c = te(b, a.internalContextTag, c);c.ref = Ze(null, b);c["return"] = a;return c;case Se:
          return b = we(b, a.internalContextTag, c), b["return"] = a, b;case Te:
          return c = xe(b, a.internalContextTag, c), c.type = b.value, c["return"] = a, c;case Ue:
          return b = ye(b, a.internalContextTag, c), b["return"] = a, b;}if (Ye(b) || Xe(b)) return b = ue(b, a.internalContextTag, c, null), b["return"] = a, b;$e(a, b);
    }return null;
  }function G(a, b, c, d) {
    var e = null !== b ? b.key : null;if ("string" === typeof c || "number" === typeof c) return null !== e ? null : h(a, b, "" + c, d);if ("object" === (typeof c === "undefined" ? "undefined" : _typeof(c)) && null !== c) {
      switch (c.$$typeof) {case Re:
          return c.key === e ? c.type === Ve ? u(a, b, c.props.children, d, e) : k(a, b, c, d) : null;case Se:
          return c.key === e ? q(a, b, c, d) : null;case Te:
          return null === e ? v(a, b, c, d) : null;case Ue:
          return c.key === e ? y(a, b, c, d) : null;}if (Ye(c) || Xe(c)) return null !== e ? null : u(a, b, c, d, null);$e(a, c);
    }return null;
  }function I(a, b, c, d, e) {
    if ("string" === typeof d || "number" === typeof d) return a = a.get(c) || null, h(b, a, "" + d, e);if ("object" === (typeof d === "undefined" ? "undefined" : _typeof(d)) && null !== d) {
      switch (d.$$typeof) {case Re:
          return a = a.get(null === d.key ? c : d.key) || null, d.type === Ve ? u(b, a, d.props.children, e, d.key) : k(b, a, d, e);case Se:
          return a = a.get(null === d.key ? c : d.key) || null, q(b, a, d, e);case Te:
          return a = a.get(c) || null, v(b, a, d, e);case Ue:
          return a = a.get(null === d.key ? c : d.key) || null, y(b, a, d, e);}if (Ye(d) || Xe(d)) return a = a.get(c) || null, u(b, a, d, e, null);$e(b, d);
    }return null;
  }function L(e, g, m, A) {
    for (var h = null, r = null, n = g, w = g = 0, k = null; null !== n && w < m.length; w++) {
      n.index > w ? (k = n, n = null) : k = n.sibling;var x = G(e, n, m[w], A);if (null === x) {
        null === n && (n = k);break;
      }a && n && null === x.alternate && b(e, n);g = f(x, g, w);null === r ? h = x : r.sibling = x;r = x;n = k;
    }if (w === m.length) return c(e, n), h;if (null === n) {
      for (; w < m.length; w++) {
        if (n = z(e, m[w], A)) g = f(n, g, w), null === r ? h = n : r.sibling = n, r = n;
      }return h;
    }for (n = d(e, n); w < m.length; w++) {
      if (k = I(n, e, w, m[w], A)) {
        if (a && null !== k.alternate) n["delete"](null === k.key ? w : k.key);g = f(k, g, w);null === r ? h = k : r.sibling = k;r = k;
      }
    }a && n.forEach(function (a) {
      return b(e, a);
    });return h;
  }function N(e, g, m, A) {
    var h = Xe(m);"function" !== typeof h ? E("150") : void 0;m = h.call(m);null == m ? E("151") : void 0;for (var r = h = null, n = g, w = g = 0, k = null, x = m.next(); null !== n && !x.done; w++, x = m.next()) {
      n.index > w ? (k = n, n = null) : k = n.sibling;var J = G(e, n, x.value, A);if (null === J) {
        n || (n = k);break;
      }a && n && null === J.alternate && b(e, n);g = f(J, g, w);null === r ? h = J : r.sibling = J;r = J;n = k;
    }if (x.done) return c(e, n), h;if (null === n) {
      for (; !x.done; w++, x = m.next()) {
        x = z(e, x.value, A), null !== x && (g = f(x, g, w), null === r ? h = x : r.sibling = x, r = x);
      }return h;
    }for (n = d(e, n); !x.done; w++, x = m.next()) {
      if (x = I(n, e, w, x.value, A), null !== x) {
        if (a && null !== x.alternate) n["delete"](null === x.key ? w : x.key);g = f(x, g, w);null === r ? h = x : r.sibling = x;r = x;
      }
    }a && n.forEach(function (a) {
      return b(e, a);
    });return h;
  }return function (a, d, f, h) {
    "object" === (typeof f === "undefined" ? "undefined" : _typeof(f)) && null !== f && f.type === Ve && null === f.key && (f = f.props.children);
    var m = "object" === (typeof f === "undefined" ? "undefined" : _typeof(f)) && null !== f;if (m) switch (f.$$typeof) {case Re:
        a: {
          var r = f.key;for (m = d; null !== m;) {
            if (m.key === r) {
              if (10 === m.tag ? f.type === Ve : m.type === f.type) {
                c(a, m.sibling);d = e(m, f.type === Ve ? f.props.children : f.props, h);d.ref = Ze(m, f);d["return"] = a;a = d;break a;
              } else {
                c(a, m);break;
              }
            } else b(a, m);m = m.sibling;
          }f.type === Ve ? (d = ue(f.props.children, a.internalContextTag, h, f.key), d["return"] = a, a = d) : (h = te(f, a.internalContextTag, h), h.ref = Ze(d, f), h["return"] = a, a = h);
        }return g(a);case Se:
        a: {
          for (m = f.key; null !== d;) {
            if (d.key === m) {
              if (7 === d.tag) {
                c(a, d.sibling);d = e(d, f, h);d["return"] = a;a = d;break a;
              } else {
                c(a, d);break;
              }
            } else b(a, d);d = d.sibling;
          }d = we(f, a.internalContextTag, h);d["return"] = a;a = d;
        }return g(a);case Te:
        a: {
          if (null !== d) if (9 === d.tag) {
            c(a, d.sibling);d = e(d, null, h);d.type = f.value;d["return"] = a;a = d;break a;
          } else c(a, d);d = xe(f, a.internalContextTag, h);d.type = f.value;d["return"] = a;a = d;
        }return g(a);case Ue:
        a: {
          for (m = f.key; null !== d;) {
            if (d.key === m) {
              if (4 === d.tag && d.stateNode.containerInfo === f.containerInfo && d.stateNode.implementation === f.implementation) {
                c(a, d.sibling);d = e(d, f.children || [], h);d["return"] = a;a = d;break a;
              } else {
                c(a, d);break;
              }
            } else b(a, d);d = d.sibling;
          }d = ye(f, a.internalContextTag, h);d["return"] = a;a = d;
        }return g(a);}if ("string" === typeof f || "number" === typeof f) return f = "" + f, null !== d && 6 === d.tag ? (c(a, d.sibling), d = e(d, f, h)) : (c(a, d), d = ve(f, a.internalContextTag, h)), d["return"] = a, a = d, g(a);if (Ye(f)) return L(a, d, f, h);if (Xe(f)) return N(a, d, f, h);m && $e(a, f);if ("undefined" === typeof f) switch (a.tag) {case 2:case 1:
        h = a.type, E("152", h.displayName || h.name || "Component");}return c(a, d);
  };
}var bf = af(!0),
    cf = af(!1);
function df(a, b, c, d, e) {
  function f(a, b, c) {
    var d = b.expirationTime;b.child = null === a ? cf(b, null, c, d) : bf(b, a.child, c, d);
  }function g(a, b) {
    var c = b.ref;null === c || a && a.ref === c || (b.effectTag |= 128);
  }function h(a, b, c, d) {
    g(a, b);if (!c) return d && re(b, !1), q(a, b);c = b.stateNode;id.current = b;var e = c.render();b.effectTag |= 1;f(a, b, e);b.memoizedState = c.state;b.memoizedProps = c.props;d && re(b, !0);return b.child;
  }function k(a) {
    var b = a.stateNode;b.pendingContext ? oe(a, b.pendingContext, b.pendingContext !== b.context) : b.context && oe(a, b.context, !1);I(a, b.containerInfo);
  }function q(a, b) {
    null !== a && b.child !== a.child ? E("153") : void 0;if (null !== b.child) {
      a = b.child;var c = se(a, a.pendingProps, a.expirationTime);b.child = c;for (c["return"] = b; null !== a.sibling;) {
        a = a.sibling, c = c.sibling = se(a, a.pendingProps, a.expirationTime), c["return"] = b;
      }c.sibling = null;
    }return b.child;
  }function v(a, b) {
    switch (b.tag) {case 3:
        k(b);break;case 2:
        qe(b);break;case 4:
        I(b, b.stateNode.containerInfo);}return null;
  }var y = a.shouldSetTextContent,
      u = a.useSyncScheduling,
      z = a.shouldDeprioritizeSubtree,
      G = b.pushHostContext,
      I = b.pushHostContainer,
      L = c.enterHydrationState,
      N = c.resetHydrationState,
      J = c.tryToClaimNextHydratableInstance;a = Le(d, e, function (a, b) {
    a.memoizedProps = b;
  }, function (a, b) {
    a.memoizedState = b;
  });var w = a.adoptClassInstance,
      m = a.constructClassInstance,
      A = a.mountClassInstance,
      Ob = a.updateClassInstance;return { beginWork: function beginWork(a, b, c) {
      if (0 === b.expirationTime || b.expirationTime > c) return v(a, b);switch (b.tag) {case 0:
          null !== a ? E("155") : void 0;var d = b.type,
              e = b.pendingProps,
              r = ke(b);r = me(b, r);d = d(e, r);b.effectTag |= 1;"object" === (typeof d === "undefined" ? "undefined" : _typeof(d)) && null !== d && "function" === typeof d.render ? (b.tag = 2, e = qe(b), w(b, d), A(b, c), b = h(a, b, !0, e)) : (b.tag = 1, f(a, b, d), b.memoizedProps = e, b = b.child);return b;case 1:
          a: {
            e = b.type;c = b.pendingProps;d = b.memoizedProps;if (X.current) null === c && (c = d);else if (null === c || d === c) {
              b = q(a, b);break a;
            }d = ke(b);d = me(b, d);e = e(c, d);b.effectTag |= 1;f(a, b, e);b.memoizedProps = c;b = b.child;
          }return b;case 2:
          return e = qe(b), d = void 0, null === a ? b.stateNode ? E("153") : (m(b, b.pendingProps), A(b, c), d = !0) : d = Ob(a, b, c), h(a, b, d, e);case 3:
          return k(b), e = b.updateQueue, null !== e ? (d = b.memoizedState, e = Je(a, b, e, null, null, c), d === e ? (N(), b = q(a, b)) : (d = e.element, r = b.stateNode, (null === a || null === a.child) && r.hydrate && L(b) ? (b.effectTag |= 2, b.child = cf(b, null, d, c)) : (N(), f(a, b, d)), b.memoizedState = e, b = b.child)) : (N(), b = q(a, b)), b;case 5:
          G(b);null === a && J(b);e = b.type;var n = b.memoizedProps;d = b.pendingProps;null === d && (d = n, null === d ? E("154") : void 0);r = null !== a ? a.memoizedProps : null;X.current || null !== d && n !== d ? (n = d.children, y(e, d) ? n = null : r && y(e, r) && (b.effectTag |= 16), g(a, b), 2147483647 !== c && !u && z(e, d) ? (b.expirationTime = 2147483647, b = null) : (f(a, b, n), b.memoizedProps = d, b = b.child)) : b = q(a, b);return b;case 6:
          return null === a && J(b), a = b.pendingProps, null === a && (a = b.memoizedProps), b.memoizedProps = a, null;case 8:
          b.tag = 7;case 7:
          e = b.pendingProps;if (X.current) null === e && (e = a && a.memoizedProps, null === e ? E("154") : void 0);else if (null === e || b.memoizedProps === e) e = b.memoizedProps;d = e.children;b.stateNode = null === a ? cf(b, b.stateNode, d, c) : bf(b, b.stateNode, d, c);b.memoizedProps = e;return b.stateNode;
        case 9:
          return null;case 4:
          a: {
            I(b, b.stateNode.containerInfo);e = b.pendingProps;if (X.current) null === e && (e = a && a.memoizedProps, null == e ? E("154") : void 0);else if (null === e || b.memoizedProps === e) {
              b = q(a, b);break a;
            }null === a ? b.child = bf(b, null, e, c) : f(a, b, e);b.memoizedProps = e;b = b.child;
          }return b;case 10:
          a: {
            c = b.pendingProps;if (X.current) null === c && (c = b.memoizedProps);else if (null === c || b.memoizedProps === c) {
              b = q(a, b);break a;
            }f(a, b, c);b.memoizedProps = c;b = b.child;
          }return b;default:
          E("156");}
    }, beginFailedWork: function beginFailedWork(a, b, c) {
      switch (b.tag) {case 2:
          qe(b);break;case 3:
          k(b);break;default:
          E("157");}b.effectTag |= 64;null === a ? b.child = null : b.child !== a.child && (b.child = a.child);if (0 === b.expirationTime || b.expirationTime > c) return v(a, b);b.firstEffect = null;b.lastEffect = null;b.child = null === a ? cf(b, null, null, c) : bf(b, a.child, null, c);2 === b.tag && (a = b.stateNode, b.memoizedProps = a.props, b.memoizedState = a.state);return b.child;
    } };
}
function ef(a, b, c) {
  function d(a) {
    a.effectTag |= 4;
  }var e = a.createInstance,
      f = a.createTextInstance,
      g = a.appendInitialChild,
      h = a.finalizeInitialChildren,
      k = a.prepareUpdate,
      q = a.persistence,
      v = b.getRootHostContainer,
      y = b.popHostContext,
      u = b.getHostContext,
      z = b.popHostContainer,
      G = c.prepareToHydrateHostInstance,
      I = c.prepareToHydrateHostTextInstance,
      L = c.popHydrationState,
      N = void 0,
      J = void 0,
      w = void 0;a.mutation ? (N = function N() {}, J = function J(a, b, c) {
    (b.updateQueue = c) && d(b);
  }, w = function w(a, b, c, e) {
    c !== e && d(b);
  }) : q ? E("235") : E("236");
  return { completeWork: function completeWork(a, b, c) {
      var m = b.pendingProps;if (null === m) m = b.memoizedProps;else if (2147483647 !== b.expirationTime || 2147483647 === c) b.pendingProps = null;switch (b.tag) {case 1:
          return null;case 2:
          return ne(b), null;case 3:
          z(b);V(X, b);V(ie, b);m = b.stateNode;m.pendingContext && (m.context = m.pendingContext, m.pendingContext = null);if (null === a || null === a.child) L(b), b.effectTag &= -3;N(b);return null;case 5:
          y(b);c = v();var A = b.type;if (null !== a && null != b.stateNode) {
            var p = a.memoizedProps,
                q = b.stateNode,
                x = u();q = k(q, A, p, m, c, x);J(a, b, q, A, p, m, c);a.ref !== b.ref && (b.effectTag |= 128);
          } else {
            if (!m) return null === b.stateNode ? E("166") : void 0, null;a = u();if (L(b)) G(b, c, a) && d(b);else {
              a = e(A, m, c, a, b);a: for (p = b.child; null !== p;) {
                if (5 === p.tag || 6 === p.tag) g(a, p.stateNode);else if (4 !== p.tag && null !== p.child) {
                  p.child["return"] = p;p = p.child;continue;
                }if (p === b) break;for (; null === p.sibling;) {
                  if (null === p["return"] || p["return"] === b) break a;p = p["return"];
                }p.sibling["return"] = p["return"];p = p.sibling;
              }h(a, A, m, c) && d(b);b.stateNode = a;
            }null !== b.ref && (b.effectTag |= 128);
          }return null;case 6:
          if (a && null != b.stateNode) w(a, b, a.memoizedProps, m);else {
            if ("string" !== typeof m) return null === b.stateNode ? E("166") : void 0, null;a = v();c = u();L(b) ? I(b) && d(b) : b.stateNode = f(m, a, c, b);
          }return null;case 7:
          (m = b.memoizedProps) ? void 0 : E("165");b.tag = 8;A = [];a: for ((p = b.stateNode) && (p["return"] = b); null !== p;) {
            if (5 === p.tag || 6 === p.tag || 4 === p.tag) E("247");else if (9 === p.tag) A.push(p.type);else if (null !== p.child) {
              p.child["return"] = p;p = p.child;continue;
            }for (; null === p.sibling;) {
              if (null === p["return"] || p["return"] === b) break a;p = p["return"];
            }p.sibling["return"] = p["return"];p = p.sibling;
          }p = m.handler;m = p(m.props, A);b.child = bf(b, null !== a ? a.child : null, m, c);return b.child;case 8:
          return b.tag = 7, null;case 9:
          return null;case 10:
          return null;case 4:
          return z(b), N(b), null;case 0:
          E("167");default:
          E("156");}
    } };
}
function ff(a, b) {
  function c(a) {
    var c = a.ref;if (null !== c) try {
      c(null);
    } catch (A) {
      b(a, A);
    }
  }function d(a) {
    "function" === typeof Ee && Ee(a);switch (a.tag) {case 2:
        c(a);var d = a.stateNode;if ("function" === typeof d.componentWillUnmount) try {
          d.props = a.memoizedProps, d.state = a.memoizedState, d.componentWillUnmount();
        } catch (A) {
          b(a, A);
        }break;case 5:
        c(a);break;case 7:
        e(a.stateNode);break;case 4:
        k && g(a);}
  }function e(a) {
    for (var b = a;;) {
      if (d(b), null === b.child || k && 4 === b.tag) {
        if (b === a) break;for (; null === b.sibling;) {
          if (null === b["return"] || b["return"] === a) return;b = b["return"];
        }b.sibling["return"] = b["return"];b = b.sibling;
      } else b.child["return"] = b, b = b.child;
    }
  }function f(a) {
    return 5 === a.tag || 3 === a.tag || 4 === a.tag;
  }function g(a) {
    for (var b = a, c = !1, f = void 0, g = void 0;;) {
      if (!c) {
        c = b["return"];a: for (;;) {
          null === c ? E("160") : void 0;switch (c.tag) {case 5:
              f = c.stateNode;g = !1;break a;case 3:
              f = c.stateNode.containerInfo;g = !0;break a;case 4:
              f = c.stateNode.containerInfo;g = !0;break a;}c = c["return"];
        }c = !0;
      }if (5 === b.tag || 6 === b.tag) e(b), g ? J(f, b.stateNode) : N(f, b.stateNode);else if (4 === b.tag ? f = b.stateNode.containerInfo : d(b), null !== b.child) {
        b.child["return"] = b;b = b.child;continue;
      }if (b === a) break;for (; null === b.sibling;) {
        if (null === b["return"] || b["return"] === a) return;b = b["return"];4 === b.tag && (c = !1);
      }b.sibling["return"] = b["return"];b = b.sibling;
    }
  }var h = a.getPublicInstance,
      k = a.mutation;a = a.persistence;k || (a ? E("235") : E("236"));var q = k.commitMount,
      v = k.commitUpdate,
      y = k.resetTextContent,
      u = k.commitTextUpdate,
      z = k.appendChild,
      G = k.appendChildToContainer,
      I = k.insertBefore,
      L = k.insertInContainerBefore,
      N = k.removeChild,
      J = k.removeChildFromContainer;return { commitResetTextContent: function commitResetTextContent(a) {
      y(a.stateNode);
    }, commitPlacement: function commitPlacement(a) {
      a: {
        for (var b = a["return"]; null !== b;) {
          if (f(b)) {
            var c = b;break a;
          }b = b["return"];
        }E("160");c = void 0;
      }var d = b = void 0;switch (c.tag) {case 5:
          b = c.stateNode;d = !1;break;case 3:
          b = c.stateNode.containerInfo;d = !0;break;case 4:
          b = c.stateNode.containerInfo;d = !0;break;default:
          E("161");}c.effectTag & 16 && (y(b), c.effectTag &= -17);a: b: for (c = a;;) {
        for (; null === c.sibling;) {
          if (null === c["return"] || f(c["return"])) {
            c = null;break a;
          }c = c["return"];
        }c.sibling["return"] = c["return"];for (c = c.sibling; 5 !== c.tag && 6 !== c.tag;) {
          if (c.effectTag & 2) continue b;if (null === c.child || 4 === c.tag) continue b;else c.child["return"] = c, c = c.child;
        }if (!(c.effectTag & 2)) {
          c = c.stateNode;break a;
        }
      }for (var e = a;;) {
        if (5 === e.tag || 6 === e.tag) c ? d ? L(b, e.stateNode, c) : I(b, e.stateNode, c) : d ? G(b, e.stateNode) : z(b, e.stateNode);else if (4 !== e.tag && null !== e.child) {
          e.child["return"] = e;e = e.child;continue;
        }if (e === a) break;for (; null === e.sibling;) {
          if (null === e["return"] || e["return"] === a) return;e = e["return"];
        }e.sibling["return"] = e["return"];e = e.sibling;
      }
    }, commitDeletion: function commitDeletion(a) {
      g(a);a["return"] = null;a.child = null;a.alternate && (a.alternate.child = null, a.alternate["return"] = null);
    }, commitWork: function commitWork(a, b) {
      switch (b.tag) {case 2:
          break;case 5:
          var c = b.stateNode;if (null != c) {
            var d = b.memoizedProps;a = null !== a ? a.memoizedProps : d;var e = b.type,
                f = b.updateQueue;b.updateQueue = null;null !== f && v(c, f, e, a, d, b);
          }break;case 6:
          null === b.stateNode ? E("162") : void 0;c = b.memoizedProps;u(b.stateNode, null !== a ? a.memoizedProps : c, c);break;case 3:
          break;default:
          E("163");}
    }, commitLifeCycles: function commitLifeCycles(a, b) {
      switch (b.tag) {case 2:
          var c = b.stateNode;if (b.effectTag & 4) if (null === a) c.props = b.memoizedProps, c.state = b.memoizedState, c.componentDidMount();else {
            var d = a.memoizedProps;a = a.memoizedState;c.props = b.memoizedProps;c.state = b.memoizedState;c.componentDidUpdate(d, a);
          }b = b.updateQueue;null !== b && Ke(b, c);break;case 3:
          c = b.updateQueue;null !== c && Ke(c, null !== b.child ? b.child.stateNode : null);break;case 5:
          c = b.stateNode;null === a && b.effectTag & 4 && q(c, b.type, b.memoizedProps, b);break;case 6:
          break;case 4:
          break;default:
          E("163");}
    }, commitAttachRef: function commitAttachRef(a) {
      var b = a.ref;if (null !== b) {
        var c = a.stateNode;switch (a.tag) {case 5:
            b(h(c));break;default:
            b(c);}
      }
    }, commitDetachRef: function commitDetachRef(a) {
      a = a.ref;null !== a && a(null);
    } };
}var gf = {};
function hf(a) {
  function b(a) {
    a === gf ? E("174") : void 0;return a;
  }var c = a.getChildHostContext,
      d = a.getRootHostContext,
      e = { current: gf },
      f = { current: gf },
      g = { current: gf };return { getHostContext: function getHostContext() {
      return b(e.current);
    }, getRootHostContainer: function getRootHostContainer() {
      return b(g.current);
    }, popHostContainer: function popHostContainer(a) {
      V(e, a);V(f, a);V(g, a);
    }, popHostContext: function popHostContext(a) {
      f.current === a && (V(e, a), V(f, a));
    }, pushHostContainer: function pushHostContainer(a, b) {
      W(g, b, a);b = d(b);W(f, a, a);W(e, b, a);
    }, pushHostContext: function pushHostContext(a) {
      var d = b(g.current),
          h = b(e.current);
      d = c(h, a.type, d);h !== d && (W(f, a, a), W(e, d, a));
    }, resetHostContainer: function resetHostContainer() {
      e.current = gf;g.current = gf;
    } };
}
function jf(a) {
  function b(a, b) {
    var c = new Y(5, null, 0);c.type = "DELETED";c.stateNode = b;c["return"] = a;c.effectTag = 8;null !== a.lastEffect ? (a.lastEffect.nextEffect = c, a.lastEffect = c) : a.firstEffect = a.lastEffect = c;
  }function c(a, b) {
    switch (a.tag) {case 5:
        return b = f(b, a.type, a.pendingProps), null !== b ? (a.stateNode = b, !0) : !1;case 6:
        return b = g(b, a.pendingProps), null !== b ? (a.stateNode = b, !0) : !1;default:
        return !1;}
  }function d(a) {
    for (a = a["return"]; null !== a && 5 !== a.tag && 3 !== a.tag;) {
      a = a["return"];
    }y = a;
  }var e = a.shouldSetTextContent;
  a = a.hydration;if (!a) return { enterHydrationState: function enterHydrationState() {
      return !1;
    }, resetHydrationState: function resetHydrationState() {}, tryToClaimNextHydratableInstance: function tryToClaimNextHydratableInstance() {}, prepareToHydrateHostInstance: function prepareToHydrateHostInstance() {
      E("175");
    }, prepareToHydrateHostTextInstance: function prepareToHydrateHostTextInstance() {
      E("176");
    }, popHydrationState: function popHydrationState() {
      return !1;
    } };var f = a.canHydrateInstance,
      g = a.canHydrateTextInstance,
      h = a.getNextHydratableSibling,
      k = a.getFirstHydratableChild,
      q = a.hydrateInstance,
      v = a.hydrateTextInstance,
      y = null,
      u = null,
      z = !1;return { enterHydrationState: function enterHydrationState(a) {
      u = k(a.stateNode.containerInfo);y = a;return z = !0;
    }, resetHydrationState: function resetHydrationState() {
      u = y = null;z = !1;
    }, tryToClaimNextHydratableInstance: function tryToClaimNextHydratableInstance(a) {
      if (z) {
        var d = u;if (d) {
          if (!c(a, d)) {
            d = h(d);if (!d || !c(a, d)) {
              a.effectTag |= 2;z = !1;y = a;return;
            }b(y, u);
          }y = a;u = k(d);
        } else a.effectTag |= 2, z = !1, y = a;
      }
    }, prepareToHydrateHostInstance: function prepareToHydrateHostInstance(a, b, c) {
      b = q(a.stateNode, a.type, a.memoizedProps, b, c, a);a.updateQueue = b;return null !== b ? !0 : !1;
    }, prepareToHydrateHostTextInstance: function prepareToHydrateHostTextInstance(a) {
      return v(a.stateNode, a.memoizedProps, a);
    }, popHydrationState: function popHydrationState(a) {
      if (a !== y) return !1;if (!z) return d(a), z = !0, !1;var c = a.type;if (5 !== a.tag || "head" !== c && "body" !== c && !e(c, a.memoizedProps)) for (c = u; c;) {
        b(a, c), c = h(c);
      }d(a);u = y ? h(a.stateNode) : null;return !0;
    } };
}
function kf(a) {
  function b(a) {
    Qb = ja = !0;var b = a.stateNode;b.current === a ? E("177") : void 0;b.isReadyForCommit = !1;id.current = null;if (1 < a.effectTag) {
      if (null !== a.lastEffect) {
        a.lastEffect.nextEffect = a;var c = a.firstEffect;
      } else c = a;
    } else c = a.firstEffect;yg();for (t = c; null !== t;) {
      var d = !1,
          e = void 0;try {
        for (; null !== t;) {
          var f = t.effectTag;f & 16 && zg(t);if (f & 128) {
            var g = t.alternate;null !== g && Ag(g);
          }switch (f & -242) {case 2:
              Ne(t);t.effectTag &= -3;break;case 6:
              Ne(t);t.effectTag &= -3;Oe(t.alternate, t);break;case 4:
              Oe(t.alternate, t);break;case 8:
              Sc = !0, Bg(t), Sc = !1;}t = t.nextEffect;
        }
      } catch (Tc) {
        d = !0, e = Tc;
      }d && (null === t ? E("178") : void 0, h(t, e), null !== t && (t = t.nextEffect));
    }Cg();b.current = a;for (t = c; null !== t;) {
      c = !1;d = void 0;try {
        for (; null !== t;) {
          var k = t.effectTag;k & 36 && Dg(t.alternate, t);k & 128 && Eg(t);if (k & 64) switch (e = t, f = void 0, null !== R && (f = R.get(e), R["delete"](e), null == f && null !== e.alternate && (e = e.alternate, f = R.get(e), R["delete"](e))), null == f ? E("184") : void 0, e.tag) {case 2:
              e.stateNode.componentDidCatch(f.error, { componentStack: f.componentStack });
              break;case 3:
              null === ca && (ca = f.error);break;default:
              E("157");}var Qc = t.nextEffect;t.nextEffect = null;t = Qc;
        }
      } catch (Tc) {
        c = !0, d = Tc;
      }c && (null === t ? E("178") : void 0, h(t, d), null !== t && (t = t.nextEffect));
    }ja = Qb = !1;"function" === typeof De && De(a.stateNode);ha && (ha.forEach(G), ha = null);null !== ca && (a = ca, ca = null, Ob(a));b = b.current.expirationTime;0 === b && (qa = R = null);return b;
  }function c(a) {
    for (;;) {
      var b = Fg(a.alternate, a, H),
          c = a["return"],
          d = a.sibling;var e = a;if (2147483647 === H || 2147483647 !== e.expirationTime) {
        if (2 !== e.tag && 3 !== e.tag) var f = 0;else f = e.updateQueue, f = null === f ? 0 : f.expirationTime;for (var g = e.child; null !== g;) {
          0 !== g.expirationTime && (0 === f || f > g.expirationTime) && (f = g.expirationTime), g = g.sibling;
        }e.expirationTime = f;
      }if (null !== b) return b;null !== c && (null === c.firstEffect && (c.firstEffect = a.firstEffect), null !== a.lastEffect && (null !== c.lastEffect && (c.lastEffect.nextEffect = a.firstEffect), c.lastEffect = a.lastEffect), 1 < a.effectTag && (null !== c.lastEffect ? c.lastEffect.nextEffect = a : c.firstEffect = a, c.lastEffect = a));if (null !== d) return d;
      if (null !== c) a = c;else {
        a.stateNode.isReadyForCommit = !0;break;
      }
    }return null;
  }function d(a) {
    var b = rg(a.alternate, a, H);null === b && (b = c(a));id.current = null;return b;
  }function e(a) {
    var b = Gg(a.alternate, a, H);null === b && (b = c(a));id.current = null;return b;
  }function f(a) {
    if (null !== R) {
      if (!(0 === H || H > a)) if (H <= Uc) for (; null !== F;) {
        F = k(F) ? e(F) : d(F);
      } else for (; null !== F && !A();) {
        F = k(F) ? e(F) : d(F);
      }
    } else if (!(0 === H || H > a)) if (H <= Uc) for (; null !== F;) {
      F = d(F);
    } else for (; null !== F && !A();) {
      F = d(F);
    }
  }function g(a, b) {
    ja ? E("243") : void 0;ja = !0;a.isReadyForCommit = !1;if (a !== ra || b !== H || null === F) {
      for (; -1 < he;) {
        ge[he] = null, he--;
      }je = D;ie.current = D;X.current = !1;x();ra = a;H = b;F = se(ra.current, null, b);
    }var c = !1,
        d = null;try {
      f(b);
    } catch (Rc) {
      c = !0, d = Rc;
    }for (; c;) {
      if (eb) {
        ca = d;break;
      }var g = F;if (null === g) eb = !0;else {
        var k = h(g, d);null === k ? E("183") : void 0;if (!eb) {
          try {
            c = k;d = b;for (k = c; null !== g;) {
              switch (g.tag) {case 2:
                  ne(g);break;case 5:
                  qg(g);break;case 3:
                  p(g);break;case 4:
                  p(g);}if (g === k || g.alternate === k) break;g = g["return"];
            }F = e(c);f(d);
          } catch (Rc) {
            c = !0;d = Rc;continue;
          }break;
        }
      }
    }b = ca;eb = ja = !1;ca = null;null !== b && Ob(b);return a.isReadyForCommit ? a.current.alternate : null;
  }function h(a, b) {
    var c = id.current = null,
        d = !1,
        e = !1,
        f = null;if (3 === a.tag) c = a, q(a) && (eb = !0);else for (var g = a["return"]; null !== g && null === c;) {
      2 === g.tag ? "function" === typeof g.stateNode.componentDidCatch && (d = !0, f = jd(g), c = g, e = !0) : 3 === g.tag && (c = g);if (q(g)) {
        if (Sc || null !== ha && (ha.has(g) || null !== g.alternate && ha.has(g.alternate))) return null;c = null;e = !1;
      }g = g["return"];
    }if (null !== c) {
      null === qa && (qa = new Set());qa.add(c);var h = "";g = a;do {
        a: switch (g.tag) {case 0:case 1:case 2:case 5:
            var k = g._debugOwner,
                Qc = g._debugSource;var m = jd(g);var n = null;k && (n = jd(k));k = Qc;m = "\n    in " + (m || "Unknown") + (k ? " (at " + k.fileName.replace(/^.*[\\\/]/, "") + ":" + k.lineNumber + ")" : n ? " (created by " + n + ")" : "");break a;default:
            m = "";}h += m;g = g["return"];
      } while (g);g = h;a = jd(a);null === R && (R = new Map());b = { componentName: a, componentStack: g, error: b, errorBoundary: d ? c.stateNode : null, errorBoundaryFound: d, errorBoundaryName: f, willRetry: e };R.set(c, b);try {
        var p = b.error;p && p.suppressReactErrorLogging || console.error(p);
      } catch (Vc) {
        Vc && Vc.suppressReactErrorLogging || console.error(Vc);
      }Qb ? (null === ha && (ha = new Set()), ha.add(c)) : G(c);return c;
    }null === ca && (ca = b);return null;
  }function k(a) {
    return null !== R && (R.has(a) || null !== a.alternate && R.has(a.alternate));
  }function q(a) {
    return null !== qa && (qa.has(a) || null !== a.alternate && qa.has(a.alternate));
  }function v() {
    return 20 * (((I() + 100) / 20 | 0) + 1);
  }function y(a) {
    return 0 !== ka ? ka : ja ? Qb ? 1 : H : !Hg || a.internalContextTag & 1 ? v() : 1;
  }function u(a, b) {
    return z(a, b, !1);
  }function z(a, b) {
    for (; null !== a;) {
      if (0 === a.expirationTime || a.expirationTime > b) a.expirationTime = b;null !== a.alternate && (0 === a.alternate.expirationTime || a.alternate.expirationTime > b) && (a.alternate.expirationTime = b);if (null === a["return"]) if (3 === a.tag) {
        var c = a.stateNode;!ja && c === ra && b < H && (F = ra = null, H = 0);var d = c,
            e = b;Rb > Ig && E("185");if (null === d.nextScheduledRoot) d.remainingExpirationTime = e, null === O ? (sa = O = d, d.nextScheduledRoot = d) : (O = O.nextScheduledRoot = d, O.nextScheduledRoot = sa);else {
          var f = d.remainingExpirationTime;if (0 === f || e < f) d.remainingExpirationTime = e;
        }Fa || (la ? Sb && (ma = d, na = 1, m(ma, na)) : 1 === e ? w(1, null) : L(e));!ja && c === ra && b < H && (F = ra = null, H = 0);
      } else break;a = a["return"];
    }
  }function G(a) {
    z(a, 1, !0);
  }function I() {
    return Uc = ((Wc() - Pe) / 10 | 0) + 2;
  }function L(a) {
    if (0 !== Tb) {
      if (a > Tb) return;Jg(Xc);
    }var b = Wc() - Pe;Tb = a;Xc = Kg(J, { timeout: 10 * (a - 2) - b });
  }function N() {
    var a = 0,
        b = null;if (null !== O) for (var c = O, d = sa; null !== d;) {
      var e = d.remainingExpirationTime;if (0 === e) {
        null === c || null === O ? E("244") : void 0;if (d === d.nextScheduledRoot) {
          sa = O = d.nextScheduledRoot = null;break;
        } else if (d === sa) sa = e = d.nextScheduledRoot, O.nextScheduledRoot = e, d.nextScheduledRoot = null;else if (d === O) {
          O = c;O.nextScheduledRoot = sa;d.nextScheduledRoot = null;break;
        } else c.nextScheduledRoot = d.nextScheduledRoot, d.nextScheduledRoot = null;d = c.nextScheduledRoot;
      } else {
        if (0 === a || e < a) a = e, b = d;if (d === O) break;c = d;d = d.nextScheduledRoot;
      }
    }c = ma;null !== c && c === b ? Rb++ : Rb = 0;ma = b;na = a;
  }function J(a) {
    w(0, a);
  }function w(a, b) {
    fb = b;for (N(); null !== ma && 0 !== na && (0 === a || na <= a) && !Yc;) {
      m(ma, na), N();
    }null !== fb && (Tb = 0, Xc = -1);0 !== na && L(na);fb = null;Yc = !1;Rb = 0;if (Ub) throw a = Zc, Zc = null, Ub = !1, a;
  }function m(a, c) {
    Fa ? E("245") : void 0;Fa = !0;if (c <= I()) {
      var d = a.finishedWork;null !== d ? (a.finishedWork = null, a.remainingExpirationTime = b(d)) : (a.finishedWork = null, d = g(a, c), null !== d && (a.remainingExpirationTime = b(d)));
    } else d = a.finishedWork, null !== d ? (a.finishedWork = null, a.remainingExpirationTime = b(d)) : (a.finishedWork = null, d = g(a, c), null !== d && (A() ? a.finishedWork = d : a.remainingExpirationTime = b(d)));Fa = !1;
  }function A() {
    return null === fb || fb.timeRemaining() > Lg ? !1 : Yc = !0;
  }function Ob(a) {
    null === ma ? E("246") : void 0;ma.remainingExpirationTime = 0;Ub || (Ub = !0, Zc = a);
  }var r = hf(a),
      n = jf(a),
      p = r.popHostContainer,
      qg = r.popHostContext,
      x = r.resetHostContainer,
      Me = df(a, r, n, u, y),
      rg = Me.beginWork,
      Gg = Me.beginFailedWork,
      Fg = ef(a, r, n).completeWork;r = ff(a, h);var zg = r.commitResetTextContent,
      Ne = r.commitPlacement,
      Bg = r.commitDeletion,
      Oe = r.commitWork,
      Dg = r.commitLifeCycles,
      Eg = r.commitAttachRef,
      Ag = r.commitDetachRef,
      Wc = a.now,
      Kg = a.scheduleDeferredCallback,
      Jg = a.cancelDeferredCallback,
      Hg = a.useSyncScheduling,
      yg = a.prepareForCommit,
      Cg = a.resetAfterCommit,
      Pe = Wc(),
      Uc = 2,
      ka = 0,
      ja = !1,
      F = null,
      ra = null,
      H = 0,
      t = null,
      R = null,
      qa = null,
      ha = null,
      ca = null,
      eb = !1,
      Qb = !1,
      Sc = !1,
      sa = null,
      O = null,
      Tb = 0,
      Xc = -1,
      Fa = !1,
      ma = null,
      na = 0,
      Yc = !1,
      Ub = !1,
      Zc = null,
      fb = null,
      la = !1,
      Sb = !1,
      Ig = 1E3,
      Rb = 0,
      Lg = 1;return { computeAsyncExpiration: v, computeExpirationForFiber: y, scheduleWork: u, batchedUpdates: function batchedUpdates(a, b) {
      var c = la;la = !0;try {
        return a(b);
      } finally {
        (la = c) || Fa || w(1, null);
      }
    }, unbatchedUpdates: function unbatchedUpdates(a) {
      if (la && !Sb) {
        Sb = !0;try {
          return a();
        } finally {
          Sb = !1;
        }
      }return a();
    }, flushSync: function flushSync(a) {
      var b = la;la = !0;try {
        a: {
          var c = ka;ka = 1;try {
            var d = a();break a;
          } finally {
            ka = c;
          }d = void 0;
        }return d;
      } finally {
        la = b, Fa ? E("187") : void 0, w(1, null);
      }
    }, deferredUpdates: function deferredUpdates(a) {
      var b = ka;ka = v();try {
        return a();
      } finally {
        ka = b;
      }
    } };
}
function lf(a) {
  function b(a) {
    a = od(a);return null === a ? null : a.stateNode;
  }var c = a.getPublicInstance;a = kf(a);var d = a.computeAsyncExpiration,
      e = a.computeExpirationForFiber,
      f = a.scheduleWork;return { createContainer: function createContainer(a, b) {
      var c = new Y(3, null, 0);a = { current: c, containerInfo: a, pendingChildren: null, remainingExpirationTime: 0, isReadyForCommit: !1, finishedWork: null, context: null, pendingContext: null, hydrate: b, nextScheduledRoot: null };return c.stateNode = a;
    }, updateContainer: function updateContainer(a, b, c, q) {
      var g = b.current;if (c) {
        c = c._reactInternalFiber;var h;b: {
          2 === kd(c) && 2 === c.tag ? void 0 : E("170");for (h = c; 3 !== h.tag;) {
            if (le(h)) {
              h = h.stateNode.__reactInternalMemoizedMergedChildContext;break b;
            }(h = h["return"]) ? void 0 : E("171");
          }h = h.stateNode.context;
        }c = le(c) ? pe(c, h) : h;
      } else c = D;null === b.context ? b.context = c : b.pendingContext = c;b = q;b = void 0 === b ? null : b;q = null != a && null != a.type && null != a.type.prototype && !0 === a.type.prototype.unstable_isAsyncReactComponent ? d() : e(g);He(g, { expirationTime: q, partialState: { element: a }, callback: b, isReplace: !1, isForced: !1,
        nextCallback: null, next: null });f(g, q);
    }, batchedUpdates: a.batchedUpdates, unbatchedUpdates: a.unbatchedUpdates, deferredUpdates: a.deferredUpdates, flushSync: a.flushSync, getPublicRootInstance: function getPublicRootInstance(a) {
      a = a.current;if (!a.child) return null;switch (a.child.tag) {case 5:
          return c(a.child.stateNode);default:
          return a.child.stateNode;}
    }, findHostInstance: b, findHostInstanceWithNoPortals: function findHostInstanceWithNoPortals(a) {
      a = pd(a);return null === a ? null : a.stateNode;
    }, injectIntoDevTools: function injectIntoDevTools(a) {
      var c = a.findFiberByHostInstance;return Ce(B({}, a, { findHostInstanceByFiber: function findHostInstanceByFiber(a) {
          return b(a);
        }, findFiberByHostInstance: function findFiberByHostInstance(a) {
          return c ? c(a) : null;
        } }));
    } };
}var mf = Object.freeze({ default: lf }),
    nf = mf && lf || mf,
    of = nf["default"] ? nf["default"] : nf;function pf(a, b, c) {
  var d = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;return { $$typeof: Ue, key: null == d ? null : "" + d, children: a, containerInfo: b, implementation: c };
}var qf = "object" === (typeof performance === "undefined" ? "undefined" : _typeof(performance)) && "function" === typeof performance.now,
    rf = void 0;rf = qf ? function () {
  return performance.now();
} : function () {
  return Date.now();
};
var sf = void 0,
    tf = void 0;
if (l.canUseDOM) {
  if ("function" !== typeof requestIdleCallback || "function" !== typeof cancelIdleCallback) {
    var uf = null,
        vf = !1,
        wf = -1,
        xf = !1,
        yf = 0,
        zf = 33,
        Af = 33,
        Bf;Bf = qf ? { didTimeout: !1, timeRemaining: function timeRemaining() {
        var a = yf - performance.now();return 0 < a ? a : 0;
      } } : { didTimeout: !1, timeRemaining: function timeRemaining() {
        var a = yf - Date.now();return 0 < a ? a : 0;
      } };var Cf = "__reactIdleCallback$" + Math.random().toString(36).slice(2);window.addEventListener("message", function (a) {
      if (a.source === window && a.data === Cf) {
        vf = !1;a = rf();if (0 >= yf - a) {
          if (-1 !== wf && wf <= a) Bf.didTimeout = !0;else {
            xf || (xf = !0, requestAnimationFrame(Df));return;
          }
        } else Bf.didTimeout = !1;wf = -1;a = uf;uf = null;null !== a && a(Bf);
      }
    }, !1);var Df = function Df(a) {
      xf = !1;var b = a - yf + Af;b < Af && zf < Af ? (8 > b && (b = 8), Af = b < zf ? zf : b) : zf = b;yf = a + Af;vf || (vf = !0, window.postMessage(Cf, "*"));
    };sf = function sf(a, b) {
      uf = a;null != b && "number" === typeof b.timeout && (wf = rf() + b.timeout);xf || (xf = !0, requestAnimationFrame(Df));return 0;
    };tf = function tf() {
      uf = null;vf = !1;wf = -1;
    };
  } else sf = window.requestIdleCallback, tf = window.cancelIdleCallback;
} else sf = function sf(a) {
  return setTimeout(function () {
    a({ timeRemaining: function timeRemaining() {
        return Infinity;
      } });
  });
}, tf = function tf(a) {
  clearTimeout(a);
};var Ef = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
    Ff = {},
    Gf = {};
function Hf(a) {
  if (Gf.hasOwnProperty(a)) return !0;if (Ff.hasOwnProperty(a)) return !1;if (Ef.test(a)) return Gf[a] = !0;Ff[a] = !0;return !1;
}
function If(a, b, c) {
  var d = wa(b);if (d && va(b, c)) {
    var e = d.mutationMethod;e ? e(a, c) : null == c || d.hasBooleanValue && !c || d.hasNumericValue && isNaN(c) || d.hasPositiveNumericValue && 1 > c || d.hasOverloadedBooleanValue && !1 === c ? Jf(a, b) : d.mustUseProperty ? a[d.propertyName] = c : (b = d.attributeName, (e = d.attributeNamespace) ? a.setAttributeNS(e, b, "" + c) : d.hasBooleanValue || d.hasOverloadedBooleanValue && !0 === c ? a.setAttribute(b, "") : a.setAttribute(b, "" + c));
  } else Kf(a, b, va(b, c) ? c : null);
}
function Kf(a, b, c) {
  Hf(b) && (null == c ? a.removeAttribute(b) : a.setAttribute(b, "" + c));
}function Jf(a, b) {
  var c = wa(b);c ? (b = c.mutationMethod) ? b(a, void 0) : c.mustUseProperty ? a[c.propertyName] = c.hasBooleanValue ? !1 : "" : a.removeAttribute(c.attributeName) : a.removeAttribute(b);
}
function Lf(a, b) {
  var c = b.value,
      d = b.checked;return B({ type: void 0, step: void 0, min: void 0, max: void 0 }, b, { defaultChecked: void 0, defaultValue: void 0, value: null != c ? c : a._wrapperState.initialValue, checked: null != d ? d : a._wrapperState.initialChecked });
}function Mf(a, b) {
  var c = b.defaultValue;a._wrapperState = { initialChecked: null != b.checked ? b.checked : b.defaultChecked, initialValue: null != b.value ? b.value : c, controlled: "checkbox" === b.type || "radio" === b.type ? null != b.checked : null != b.value };
}
function Nf(a, b) {
  b = b.checked;null != b && If(a, "checked", b);
}function Of(a, b) {
  Nf(a, b);var c = b.value;if (null != c) {
    if (0 === c && "" === a.value) a.value = "0";else if ("number" === b.type) {
      if (b = parseFloat(a.value) || 0, c != b || c == b && a.value != c) a.value = "" + c;
    } else a.value !== "" + c && (a.value = "" + c);
  } else null == b.value && null != b.defaultValue && a.defaultValue !== "" + b.defaultValue && (a.defaultValue = "" + b.defaultValue), null == b.checked && null != b.defaultChecked && (a.defaultChecked = !!b.defaultChecked);
}
function Pf(a, b) {
  switch (b.type) {case "submit":case "reset":
      break;case "color":case "date":case "datetime":case "datetime-local":case "month":case "time":case "week":
      a.value = "";a.value = a.defaultValue;break;default:
      a.value = a.value;}b = a.name;"" !== b && (a.name = "");a.defaultChecked = !a.defaultChecked;a.defaultChecked = !a.defaultChecked;"" !== b && (a.name = b);
}function Qf(a) {
  var b = "";aa.Children.forEach(a, function (a) {
    null == a || "string" !== typeof a && "number" !== typeof a || (b += a);
  });return b;
}
function Rf(a, b) {
  a = B({ children: void 0 }, b);if (b = Qf(b.children)) a.children = b;return a;
}function Sf(a, b, c, d) {
  a = a.options;if (b) {
    b = {};for (var e = 0; e < c.length; e++) {
      b["$" + c[e]] = !0;
    }for (c = 0; c < a.length; c++) {
      e = b.hasOwnProperty("$" + a[c].value), a[c].selected !== e && (a[c].selected = e), e && d && (a[c].defaultSelected = !0);
    }
  } else {
    c = "" + c;b = null;for (e = 0; e < a.length; e++) {
      if (a[e].value === c) {
        a[e].selected = !0;d && (a[e].defaultSelected = !0);return;
      }null !== b || a[e].disabled || (b = a[e]);
    }null !== b && (b.selected = !0);
  }
}
function Tf(a, b) {
  var c = b.value;a._wrapperState = { initialValue: null != c ? c : b.defaultValue, wasMultiple: !!b.multiple };
}function Uf(a, b) {
  null != b.dangerouslySetInnerHTML ? E("91") : void 0;return B({}, b, { value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue });
}function Vf(a, b) {
  var c = b.value;null == c && (c = b.defaultValue, b = b.children, null != b && (null != c ? E("92") : void 0, Array.isArray(b) && (1 >= b.length ? void 0 : E("93"), b = b[0]), c = "" + b), null == c && (c = ""));a._wrapperState = { initialValue: "" + c };
}
function Wf(a, b) {
  var c = b.value;null != c && (c = "" + c, c !== a.value && (a.value = c), null == b.defaultValue && (a.defaultValue = c));null != b.defaultValue && (a.defaultValue = b.defaultValue);
}function Xf(a) {
  var b = a.textContent;b === a._wrapperState.initialValue && (a.value = b);
}var Yf = { html: "http://www.w3.org/1999/xhtml", mathml: "http://www.w3.org/1998/Math/MathML", svg: "http://www.w3.org/2000/svg" };
function Zf(a) {
  switch (a) {case "svg":
      return "http://www.w3.org/2000/svg";case "math":
      return "http://www.w3.org/1998/Math/MathML";default:
      return "http://www.w3.org/1999/xhtml";}
}function $f(a, b) {
  return null == a || "http://www.w3.org/1999/xhtml" === a ? Zf(b) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b ? "http://www.w3.org/1999/xhtml" : a;
}
var ag = void 0,
    bg = function (a) {
  return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function (b, c, d, e) {
    MSApp.execUnsafeLocalFunction(function () {
      return a(b, c, d, e);
    });
  } : a;
}(function (a, b) {
  if (a.namespaceURI !== Yf.svg || "innerHTML" in a) a.innerHTML = b;else {
    ag = ag || document.createElement("div");ag.innerHTML = "\x3csvg\x3e" + b + "\x3c/svg\x3e";for (b = ag.firstChild; a.firstChild;) {
      a.removeChild(a.firstChild);
    }for (; b.firstChild;) {
      a.appendChild(b.firstChild);
    }
  }
});
function cg(a, b) {
  if (b) {
    var c = a.firstChild;if (c && c === a.lastChild && 3 === c.nodeType) {
      c.nodeValue = b;return;
    }
  }a.textContent = b;
}
var dg = { animationIterationCount: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0,
  stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 },
    eg = ["Webkit", "ms", "Moz", "O"];Object.keys(dg).forEach(function (a) {
  eg.forEach(function (b) {
    b = b + a.charAt(0).toUpperCase() + a.substring(1);dg[b] = dg[a];
  });
});
function fg(a, b) {
  a = a.style;for (var c in b) {
    if (b.hasOwnProperty(c)) {
      var d = 0 === c.indexOf("--");var e = c;var f = b[c];e = null == f || "boolean" === typeof f || "" === f ? "" : d || "number" !== typeof f || 0 === f || dg.hasOwnProperty(e) && dg[e] ? ("" + f).trim() : f + "px";"float" === c && (c = "cssFloat");d ? a.setProperty(c, e) : a[c] = e;
    }
  }
}var gg = B({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 });
function hg(a, b, c) {
  b && (gg[a] && (null != b.children || null != b.dangerouslySetInnerHTML ? E("137", a, c()) : void 0), null != b.dangerouslySetInnerHTML && (null != b.children ? E("60") : void 0, "object" === _typeof(b.dangerouslySetInnerHTML) && "__html" in b.dangerouslySetInnerHTML ? void 0 : E("61")), null != b.style && "object" !== _typeof(b.style) ? E("62", c()) : void 0);
}
function ig(a, b) {
  if (-1 === a.indexOf("-")) return "string" === typeof b.is;switch (a) {case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":
      return !1;default:
      return !0;}
}var jg = Yf.html,
    kg = C.thatReturns("");
function lg(a, b) {
  a = 9 === a.nodeType || 11 === a.nodeType ? a : a.ownerDocument;var c = Hd(a);b = Sa[b];for (var d = 0; d < b.length; d++) {
    var e = b[d];c.hasOwnProperty(e) && c[e] || ("topScroll" === e ? wd("topScroll", "scroll", a) : "topFocus" === e || "topBlur" === e ? (wd("topFocus", "focus", a), wd("topBlur", "blur", a), c.topBlur = !0, c.topFocus = !0) : "topCancel" === e ? (yc("cancel", !0) && wd("topCancel", "cancel", a), c.topCancel = !0) : "topClose" === e ? (yc("close", !0) && wd("topClose", "close", a), c.topClose = !0) : Dd.hasOwnProperty(e) && U(e, Dd[e], a), c[e] = !0);
  }
}
var mg = { topAbort: "abort", topCanPlay: "canplay", topCanPlayThrough: "canplaythrough", topDurationChange: "durationchange", topEmptied: "emptied", topEncrypted: "encrypted", topEnded: "ended", topError: "error", topLoadedData: "loadeddata", topLoadedMetadata: "loadedmetadata", topLoadStart: "loadstart", topPause: "pause", topPlay: "play", topPlaying: "playing", topProgress: "progress", topRateChange: "ratechange", topSeeked: "seeked", topSeeking: "seeking", topStalled: "stalled", topSuspend: "suspend", topTimeUpdate: "timeupdate", topVolumeChange: "volumechange",
  topWaiting: "waiting" };function ng(a, b, c, d) {
  c = 9 === c.nodeType ? c : c.ownerDocument;d === jg && (d = Zf(a));d === jg ? "script" === a ? (a = c.createElement("div"), a.innerHTML = "\x3cscript\x3e\x3c/script\x3e", a = a.removeChild(a.firstChild)) : a = "string" === typeof b.is ? c.createElement(a, { is: b.is }) : c.createElement(a) : a = c.createElementNS(d, a);return a;
}function og(a, b) {
  return (9 === b.nodeType ? b : b.ownerDocument).createTextNode(a);
}
function pg(a, b, c, d) {
  var e = ig(b, c);switch (b) {case "iframe":case "object":
      U("topLoad", "load", a);var f = c;break;case "video":case "audio":
      for (f in mg) {
        mg.hasOwnProperty(f) && U(f, mg[f], a);
      }f = c;break;case "source":
      U("topError", "error", a);f = c;break;case "img":case "image":
      U("topError", "error", a);U("topLoad", "load", a);f = c;break;case "form":
      U("topReset", "reset", a);U("topSubmit", "submit", a);f = c;break;case "details":
      U("topToggle", "toggle", a);f = c;break;case "input":
      Mf(a, c);f = Lf(a, c);U("topInvalid", "invalid", a);
      lg(d, "onChange");break;case "option":
      f = Rf(a, c);break;case "select":
      Tf(a, c);f = B({}, c, { value: void 0 });U("topInvalid", "invalid", a);lg(d, "onChange");break;case "textarea":
      Vf(a, c);f = Uf(a, c);U("topInvalid", "invalid", a);lg(d, "onChange");break;default:
      f = c;}hg(b, f, kg);var g = f,
      h;for (h in g) {
    if (g.hasOwnProperty(h)) {
      var k = g[h];"style" === h ? fg(a, k, kg) : "dangerouslySetInnerHTML" === h ? (k = k ? k.__html : void 0, null != k && bg(a, k)) : "children" === h ? "string" === typeof k ? ("textarea" !== b || "" !== k) && cg(a, k) : "number" === typeof k && cg(a, "" + k) : "suppressContentEditableWarning" !== h && "suppressHydrationWarning" !== h && "autoFocus" !== h && (Ra.hasOwnProperty(h) ? null != k && lg(d, h) : e ? Kf(a, h, k) : null != k && If(a, h, k));
    }
  }switch (b) {case "input":
      Bc(a);Pf(a, c);break;case "textarea":
      Bc(a);Xf(a, c);break;case "option":
      null != c.value && a.setAttribute("value", c.value);break;case "select":
      a.multiple = !!c.multiple;b = c.value;null != b ? Sf(a, !!c.multiple, b, !1) : null != c.defaultValue && Sf(a, !!c.multiple, c.defaultValue, !0);break;default:
      "function" === typeof f.onClick && (a.onclick = C);}
}
function sg(a, b, c, d, e) {
  var f = null;switch (b) {case "input":
      c = Lf(a, c);d = Lf(a, d);f = [];break;case "option":
      c = Rf(a, c);d = Rf(a, d);f = [];break;case "select":
      c = B({}, c, { value: void 0 });d = B({}, d, { value: void 0 });f = [];break;case "textarea":
      c = Uf(a, c);d = Uf(a, d);f = [];break;default:
      "function" !== typeof c.onClick && "function" === typeof d.onClick && (a.onclick = C);}hg(b, d, kg);var g, h;a = null;for (g in c) {
    if (!d.hasOwnProperty(g) && c.hasOwnProperty(g) && null != c[g]) if ("style" === g) for (h in b = c[g], b) {
      b.hasOwnProperty(h) && (a || (a = {}), a[h] = "");
    } else "dangerouslySetInnerHTML" !== g && "children" !== g && "suppressContentEditableWarning" !== g && "suppressHydrationWarning" !== g && "autoFocus" !== g && (Ra.hasOwnProperty(g) ? f || (f = []) : (f = f || []).push(g, null));
  }for (g in d) {
    var k = d[g];b = null != c ? c[g] : void 0;if (d.hasOwnProperty(g) && k !== b && (null != k || null != b)) if ("style" === g) {
      if (b) {
        for (h in b) {
          !b.hasOwnProperty(h) || k && k.hasOwnProperty(h) || (a || (a = {}), a[h] = "");
        }for (h in k) {
          k.hasOwnProperty(h) && b[h] !== k[h] && (a || (a = {}), a[h] = k[h]);
        }
      } else a || (f || (f = []), f.push(g, a)), a = k;
    } else "dangerouslySetInnerHTML" === g ? (k = k ? k.__html : void 0, b = b ? b.__html : void 0, null != k && b !== k && (f = f || []).push(g, "" + k)) : "children" === g ? b === k || "string" !== typeof k && "number" !== typeof k || (f = f || []).push(g, "" + k) : "suppressContentEditableWarning" !== g && "suppressHydrationWarning" !== g && (Ra.hasOwnProperty(g) ? (null != k && lg(e, g), f || b === k || (f = [])) : (f = f || []).push(g, k));
  }a && (f = f || []).push("style", a);return f;
}
function tg(a, b, c, d, e) {
  "input" === c && "radio" === e.type && null != e.name && Nf(a, e);ig(c, d);d = ig(c, e);for (var f = 0; f < b.length; f += 2) {
    var g = b[f],
        h = b[f + 1];"style" === g ? fg(a, h, kg) : "dangerouslySetInnerHTML" === g ? bg(a, h) : "children" === g ? cg(a, h) : d ? null != h ? Kf(a, g, h) : a.removeAttribute(g) : null != h ? If(a, g, h) : Jf(a, g);
  }switch (c) {case "input":
      Of(a, e);break;case "textarea":
      Wf(a, e);break;case "select":
      a._wrapperState.initialValue = void 0, b = a._wrapperState.wasMultiple, a._wrapperState.wasMultiple = !!e.multiple, c = e.value, null != c ? Sf(a, !!e.multiple, c, !1) : b !== !!e.multiple && (null != e.defaultValue ? Sf(a, !!e.multiple, e.defaultValue, !0) : Sf(a, !!e.multiple, e.multiple ? [] : "", !1));}
}
function ug(a, b, c, d, e) {
  switch (b) {case "iframe":case "object":
      U("topLoad", "load", a);break;case "video":case "audio":
      for (var f in mg) {
        mg.hasOwnProperty(f) && U(f, mg[f], a);
      }break;case "source":
      U("topError", "error", a);break;case "img":case "image":
      U("topError", "error", a);U("topLoad", "load", a);break;case "form":
      U("topReset", "reset", a);U("topSubmit", "submit", a);break;case "details":
      U("topToggle", "toggle", a);break;case "input":
      Mf(a, c);U("topInvalid", "invalid", a);lg(e, "onChange");break;case "select":
      Tf(a, c);
      U("topInvalid", "invalid", a);lg(e, "onChange");break;case "textarea":
      Vf(a, c), U("topInvalid", "invalid", a), lg(e, "onChange");}hg(b, c, kg);d = null;for (var g in c) {
    c.hasOwnProperty(g) && (f = c[g], "children" === g ? "string" === typeof f ? a.textContent !== f && (d = ["children", f]) : "number" === typeof f && a.textContent !== "" + f && (d = ["children", "" + f]) : Ra.hasOwnProperty(g) && null != f && lg(e, g));
  }switch (b) {case "input":
      Bc(a);Pf(a, c);break;case "textarea":
      Bc(a);Xf(a, c);break;case "select":case "option":
      break;default:
      "function" === typeof c.onClick && (a.onclick = C);}return d;
}function vg(a, b) {
  return a.nodeValue !== b;
}
var wg = Object.freeze({ createElement: ng, createTextNode: og, setInitialProperties: pg, diffProperties: sg, updateProperties: tg, diffHydratedProperties: ug, diffHydratedText: vg, warnForUnmatchedText: function warnForUnmatchedText() {}, warnForDeletedHydratableElement: function warnForDeletedHydratableElement() {}, warnForDeletedHydratableText: function warnForDeletedHydratableText() {}, warnForInsertedHydratedElement: function warnForInsertedHydratedElement() {}, warnForInsertedHydratedText: function warnForInsertedHydratedText() {}, restoreControlledState: function restoreControlledState(a, b, c) {
    switch (b) {case "input":
        Of(a, c);b = c.name;if ("radio" === c.type && null != b) {
          for (c = a; c.parentNode;) {
            c = c.parentNode;
          }c = c.querySelectorAll("input[name\x3d" + JSON.stringify("" + b) + '][type\x3d"radio"]');for (b = 0; b < c.length; b++) {
            var d = c[b];if (d !== a && d.form === a.form) {
              var e = rb(d);e ? void 0 : E("90");Cc(d);Of(d, e);
            }
          }
        }break;case "textarea":
        Wf(a, c);break;case "select":
        b = c.value, null != b && Sf(a, !!c.multiple, b, !1);}
  } });nc.injectFiberControlledHostComponent(wg);var xg = null,
    Mg = null;function Ng(a) {
  return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
}
function Og(a) {
  a = a ? 9 === a.nodeType ? a.documentElement : a.firstChild : null;return !(!a || 1 !== a.nodeType || !a.hasAttribute("data-reactroot"));
}
var Z = of({ getRootHostContext: function getRootHostContext(a) {
    var b = a.nodeType;switch (b) {case 9:case 11:
        a = (a = a.documentElement) ? a.namespaceURI : $f(null, "");break;default:
        b = 8 === b ? a.parentNode : a, a = b.namespaceURI || null, b = b.tagName, a = $f(a, b);}return a;
  }, getChildHostContext: function getChildHostContext(a, b) {
    return $f(a, b);
  }, getPublicInstance: function getPublicInstance(a) {
    return a;
  }, prepareForCommit: function prepareForCommit() {
    xg = td;var a = da();if (Kd(a)) {
      if ("selectionStart" in a) var b = { start: a.selectionStart, end: a.selectionEnd };else a: {
        var c = window.getSelection && window.getSelection();
        if (c && 0 !== c.rangeCount) {
          b = c.anchorNode;var d = c.anchorOffset,
              e = c.focusNode;c = c.focusOffset;try {
            b.nodeType, e.nodeType;
          } catch (z) {
            b = null;break a;
          }var f = 0,
              g = -1,
              h = -1,
              k = 0,
              q = 0,
              v = a,
              y = null;b: for (;;) {
            for (var u;;) {
              v !== b || 0 !== d && 3 !== v.nodeType || (g = f + d);v !== e || 0 !== c && 3 !== v.nodeType || (h = f + c);3 === v.nodeType && (f += v.nodeValue.length);if (null === (u = v.firstChild)) break;y = v;v = u;
            }for (;;) {
              if (v === a) break b;y === b && ++k === d && (g = f);y === e && ++q === c && (h = f);if (null !== (u = v.nextSibling)) break;v = y;y = v.parentNode;
            }v = u;
          }b = -1 === g || -1 === h ? null : { start: g, end: h };
        } else b = null;
      }b = b || { start: 0, end: 0 };
    } else b = null;Mg = { focusedElem: a, selectionRange: b };ud(!1);
  }, resetAfterCommit: function resetAfterCommit() {
    var a = Mg,
        b = da(),
        c = a.focusedElem,
        d = a.selectionRange;if (b !== c && fa(document.documentElement, c)) {
      if (Kd(c)) if (b = d.start, a = d.end, void 0 === a && (a = b), "selectionStart" in c) c.selectionStart = b, c.selectionEnd = Math.min(a, c.value.length);else if (window.getSelection) {
        b = window.getSelection();var e = c[Eb()].length;a = Math.min(d.start, e);d = void 0 === d.end ? a : Math.min(d.end, e);!b.extend && a > d && (e = d, d = a, a = e);e = Jd(c, a);var f = Jd(c, d);if (e && f && (1 !== b.rangeCount || b.anchorNode !== e.node || b.anchorOffset !== e.offset || b.focusNode !== f.node || b.focusOffset !== f.offset)) {
          var g = document.createRange();g.setStart(e.node, e.offset);b.removeAllRanges();a > d ? (b.addRange(g), b.extend(f.node, f.offset)) : (g.setEnd(f.node, f.offset), b.addRange(g));
        }
      }b = [];for (a = c; a = a.parentNode;) {
        1 === a.nodeType && b.push({ element: a, left: a.scrollLeft, top: a.scrollTop });
      }ia(c);for (c = 0; c < b.length; c++) {
        a = b[c], a.element.scrollLeft = a.left, a.element.scrollTop = a.top;
      }
    }Mg = null;ud(xg);xg = null;
  }, createInstance: function createInstance(a, b, c, d, e) {
    a = ng(a, b, c, d);a[Q] = e;a[ob] = b;return a;
  }, appendInitialChild: function appendInitialChild(a, b) {
    a.appendChild(b);
  }, finalizeInitialChildren: function finalizeInitialChildren(a, b, c, d) {
    pg(a, b, c, d);a: {
      switch (b) {case "button":case "input":case "select":case "textarea":
          a = !!c.autoFocus;break a;}a = !1;
    }return a;
  }, prepareUpdate: function prepareUpdate(a, b, c, d, e) {
    return sg(a, b, c, d, e);
  }, shouldSetTextContent: function shouldSetTextContent(a, b) {
    return "textarea" === a || "string" === typeof b.children || "number" === typeof b.children || "object" === _typeof(b.dangerouslySetInnerHTML) && null !== b.dangerouslySetInnerHTML && "string" === typeof b.dangerouslySetInnerHTML.__html;
  }, shouldDeprioritizeSubtree: function shouldDeprioritizeSubtree(a, b) {
    return !!b.hidden;
  }, createTextInstance: function createTextInstance(a, b, c, d) {
    a = og(a, b);a[Q] = d;return a;
  }, now: rf, mutation: { commitMount: function commitMount(a) {
      a.focus();
    }, commitUpdate: function commitUpdate(a, b, c, d, e) {
      a[ob] = e;tg(a, b, c, d, e);
    }, resetTextContent: function resetTextContent(a) {
      a.textContent = "";
    }, commitTextUpdate: function commitTextUpdate(a, b, c) {
      a.nodeValue = c;
    }, appendChild: function appendChild(a, b) {
      a.appendChild(b);
    }, appendChildToContainer: function appendChildToContainer(a, b) {
      8 === a.nodeType ? a.parentNode.insertBefore(b, a) : a.appendChild(b);
    }, insertBefore: function insertBefore(a, b, c) {
      a.insertBefore(b, c);
    }, insertInContainerBefore: function insertInContainerBefore(a, b, c) {
      8 === a.nodeType ? a.parentNode.insertBefore(b, c) : a.insertBefore(b, c);
    }, removeChild: function removeChild(a, b) {
      a.removeChild(b);
    }, removeChildFromContainer: function removeChildFromContainer(a, b) {
      8 === a.nodeType ? a.parentNode.removeChild(b) : a.removeChild(b);
    } }, hydration: { canHydrateInstance: function canHydrateInstance(a, b) {
      return 1 !== a.nodeType || b.toLowerCase() !== a.nodeName.toLowerCase() ? null : a;
    }, canHydrateTextInstance: function canHydrateTextInstance(a, b) {
      return "" === b || 3 !== a.nodeType ? null : a;
    }, getNextHydratableSibling: function getNextHydratableSibling(a) {
      for (a = a.nextSibling; a && 1 !== a.nodeType && 3 !== a.nodeType;) {
        a = a.nextSibling;
      }return a;
    }, getFirstHydratableChild: function getFirstHydratableChild(a) {
      for (a = a.firstChild; a && 1 !== a.nodeType && 3 !== a.nodeType;) {
        a = a.nextSibling;
      }return a;
    }, hydrateInstance: function hydrateInstance(a, b, c, d, e, f) {
      a[Q] = f;a[ob] = c;return ug(a, b, c, e, d);
    }, hydrateTextInstance: function hydrateTextInstance(a, b, c) {
      a[Q] = c;return vg(a, b);
    }, didNotMatchHydratedContainerTextInstance: function didNotMatchHydratedContainerTextInstance() {}, didNotMatchHydratedTextInstance: function didNotMatchHydratedTextInstance() {},
    didNotHydrateContainerInstance: function didNotHydrateContainerInstance() {}, didNotHydrateInstance: function didNotHydrateInstance() {}, didNotFindHydratableContainerInstance: function didNotFindHydratableContainerInstance() {}, didNotFindHydratableContainerTextInstance: function didNotFindHydratableContainerTextInstance() {}, didNotFindHydratableInstance: function didNotFindHydratableInstance() {}, didNotFindHydratableTextInstance: function didNotFindHydratableTextInstance() {} }, scheduleDeferredCallback: sf, cancelDeferredCallback: tf, useSyncScheduling: !0 });rc = Z.batchedUpdates;
function Pg(a, b, c, d, e) {
  Ng(c) ? void 0 : E("200");var f = c._reactRootContainer;if (f) Z.updateContainer(b, f, a, e);else {
    d = d || Og(c);if (!d) for (f = void 0; f = c.lastChild;) {
      c.removeChild(f);
    }var g = Z.createContainer(c, d);f = c._reactRootContainer = g;Z.unbatchedUpdates(function () {
      Z.updateContainer(b, g, a, e);
    });
  }return Z.getPublicRootInstance(f);
}function Qg(a, b) {
  var c = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;Ng(b) ? void 0 : E("200");return pf(a, b, null, c);
}
function Rg(a, b) {
  this._reactRootContainer = Z.createContainer(a, b);
}Rg.prototype.render = function (a, b) {
  Z.updateContainer(a, this._reactRootContainer, null, b);
};Rg.prototype.unmount = function (a) {
  Z.updateContainer(null, this._reactRootContainer, null, a);
};
var Sg = { createPortal: Qg, findDOMNode: function findDOMNode(a) {
    if (null == a) return null;if (1 === a.nodeType) return a;var b = a._reactInternalFiber;if (b) return Z.findHostInstance(b);"function" === typeof a.render ? E("188") : E("213", Object.keys(a));
  }, hydrate: function hydrate(a, b, c) {
    return Pg(null, a, b, !0, c);
  }, render: function render(a, b, c) {
    return Pg(null, a, b, !1, c);
  }, unstable_renderSubtreeIntoContainer: function unstable_renderSubtreeIntoContainer(a, b, c, d) {
    null == a || void 0 === a._reactInternalFiber ? E("38") : void 0;return Pg(a, b, c, !1, d);
  }, unmountComponentAtNode: function unmountComponentAtNode(a) {
    Ng(a) ? void 0 : E("40");return a._reactRootContainer ? (Z.unbatchedUpdates(function () {
      Pg(null, null, a, !1, function () {
        a._reactRootContainer = null;
      });
    }), !0) : !1;
  }, unstable_createPortal: Qg, unstable_batchedUpdates: tc, unstable_deferredUpdates: Z.deferredUpdates, flushSync: Z.flushSync, __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: { EventPluginHub: mb, EventPluginRegistry: Va, EventPropagators: Cb, ReactControlledComponent: qc, ReactDOMComponentTree: sb, ReactDOMEventListener: xd } };
Z.injectIntoDevTools({ findFiberByHostInstance: pb, bundleType: 0, version: "16.2.0", rendererPackageName: "react-dom" });var Tg = Object.freeze({ default: Sg }),
    Ug = Tg && Sg || Tg;module.exports = Ug["default"] ? Ug["default"] : Ug;

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var isNode = __webpack_require__(52);

/**
 * @param {*} object The object to check.
 * @return {boolean} Whether or not the object is a DOM text node.
 */
function isTextNode(object) {
  return isNode(object) && object.nodeType == 3;
}

module.exports = isTextNode;

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

/**
 * @param {*} object The object to check.
 * @return {boolean} Whether or not the object is a DOM node.
 */

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function isNode(object) {
  var doc = object ? object.ownerDocument || object : document;
  var defaultView = doc.defaultView || window;
  return !!(object && (typeof defaultView.Node === 'function' ? object instanceof defaultView.Node : (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
}

module.exports = isNode;

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/** @license React v16.2.0
 * react-dom.development.js
 *
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var _typeof=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};if(process.env.NODE_ENV!=="production"){(function(){'use strict';var React=__webpack_require__(3);var invariant=__webpack_require__(13);var warning=__webpack_require__(14);var ExecutionEnvironment=__webpack_require__(21);var _assign=__webpack_require__(9);var emptyFunction=__webpack_require__(4);var EventListener=__webpack_require__(22);var getActiveElement=__webpack_require__(23);var shallowEqual=__webpack_require__(24);var containsNode=__webpack_require__(25);var focusNode=__webpack_require__(26);var emptyObject=__webpack_require__(10);var checkPropTypes=__webpack_require__(19);var hyphenateStyleName=__webpack_require__(54);var camelizeStyleName=__webpack_require__(56);/**
 * WARNING: DO NOT manually require this module.
 * This is a replacement for `invariant(...)` used by the error code system
 * and will _only_ be required by the corresponding babel pass.
 * It always throws.
 */!React?invariant(false,'ReactDOM was loaded before React. Make sure you load the React package before loading ReactDOM.'):void 0;// These attributes should be all lowercase to allow for
// case insensitive checks
var RESERVED_PROPS={children:true,dangerouslySetInnerHTML:true,defaultValue:true,defaultChecked:true,innerHTML:true,suppressContentEditableWarning:true,suppressHydrationWarning:true,style:true};function checkMask(value,bitmask){return(value&bitmask)===bitmask;}var DOMPropertyInjection={/**
   * Mapping from normalized, camelcased property names to a configuration that
   * specifies how the associated DOM property should be accessed or rendered.
   */MUST_USE_PROPERTY:0x1,HAS_BOOLEAN_VALUE:0x4,HAS_NUMERIC_VALUE:0x8,HAS_POSITIVE_NUMERIC_VALUE:0x10|0x8,HAS_OVERLOADED_BOOLEAN_VALUE:0x20,HAS_STRING_BOOLEAN_VALUE:0x40,/**
   * Inject some specialized knowledge about the DOM. This takes a config object
   * with the following properties:
   *
   * Properties: object mapping DOM property name to one of the
   * DOMPropertyInjection constants or null. If your attribute isn't in here,
   * it won't get written to the DOM.
   *
   * DOMAttributeNames: object mapping React attribute name to the DOM
   * attribute name. Attribute names not specified use the **lowercase**
   * normalized name.
   *
   * DOMAttributeNamespaces: object mapping React attribute name to the DOM
   * attribute namespace URL. (Attribute names not specified use no namespace.)
   *
   * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.
   * Property names not specified use the normalized name.
   *
   * DOMMutationMethods: Properties that require special mutation methods. If
   * `value` is undefined, the mutation method should unset the property.
   *
   * @param {object} domPropertyConfig the config as described above.
   */injectDOMPropertyConfig:function injectDOMPropertyConfig(domPropertyConfig){var Injection=DOMPropertyInjection;var Properties=domPropertyConfig.Properties||{};var DOMAttributeNamespaces=domPropertyConfig.DOMAttributeNamespaces||{};var DOMAttributeNames=domPropertyConfig.DOMAttributeNames||{};var DOMMutationMethods=domPropertyConfig.DOMMutationMethods||{};for(var propName in Properties){!!properties.hasOwnProperty(propName)?invariant(false,"injectDOMPropertyConfig(...): You're trying to inject DOM property '%s' which has already been injected. You may be accidentally injecting the same DOM property config twice, or you may be injecting two configs that have conflicting property names.",propName):void 0;var lowerCased=propName.toLowerCase();var propConfig=Properties[propName];var propertyInfo={attributeName:lowerCased,attributeNamespace:null,propertyName:propName,mutationMethod:null,mustUseProperty:checkMask(propConfig,Injection.MUST_USE_PROPERTY),hasBooleanValue:checkMask(propConfig,Injection.HAS_BOOLEAN_VALUE),hasNumericValue:checkMask(propConfig,Injection.HAS_NUMERIC_VALUE),hasPositiveNumericValue:checkMask(propConfig,Injection.HAS_POSITIVE_NUMERIC_VALUE),hasOverloadedBooleanValue:checkMask(propConfig,Injection.HAS_OVERLOADED_BOOLEAN_VALUE),hasStringBooleanValue:checkMask(propConfig,Injection.HAS_STRING_BOOLEAN_VALUE)};!(propertyInfo.hasBooleanValue+propertyInfo.hasNumericValue+propertyInfo.hasOverloadedBooleanValue<=1)?invariant(false,"DOMProperty: Value can be one of boolean, overloaded boolean, or numeric value, but not a combination: %s",propName):void 0;if(DOMAttributeNames.hasOwnProperty(propName)){var attributeName=DOMAttributeNames[propName];propertyInfo.attributeName=attributeName;}if(DOMAttributeNamespaces.hasOwnProperty(propName)){propertyInfo.attributeNamespace=DOMAttributeNamespaces[propName];}if(DOMMutationMethods.hasOwnProperty(propName)){propertyInfo.mutationMethod=DOMMutationMethods[propName];}// Downcase references to whitelist properties to check for membership
// without case-sensitivity. This allows the whitelist to pick up
// `allowfullscreen`, which should be written using the property configuration
// for `allowFullscreen`
properties[propName]=propertyInfo;}}};/* eslint-disable max-len */var ATTRIBUTE_NAME_START_CHAR=':A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD';/* eslint-enable max-len */var ATTRIBUTE_NAME_CHAR=ATTRIBUTE_NAME_START_CHAR+'\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040';var ROOT_ATTRIBUTE_NAME='data-reactroot';/**
 * Map from property "standard name" to an object with info about how to set
 * the property in the DOM. Each object contains:
 *
 * attributeName:
 *   Used when rendering markup or with `*Attribute()`.
 * attributeNamespace
 * propertyName:
 *   Used on DOM node instances. (This includes properties that mutate due to
 *   external factors.)
 * mutationMethod:
 *   If non-null, used instead of the property or `setAttribute()` after
 *   initial render.
 * mustUseProperty:
 *   Whether the property must be accessed and mutated as an object property.
 * hasBooleanValue:
 *   Whether the property should be removed when set to a falsey value.
 * hasNumericValue:
 *   Whether the property must be numeric or parse as a numeric and should be
 *   removed when set to a falsey value.
 * hasPositiveNumericValue:
 *   Whether the property must be positive numeric or parse as a positive
 *   numeric and should be removed when set to a falsey value.
 * hasOverloadedBooleanValue:
 *   Whether the property can be used as a flag as well as with a value.
 *   Removed when strictly equal to false; present without a value when
 *   strictly equal to true; present with a value otherwise.
 */var properties={};/**
 * Checks whether a property name is a writeable attribute.
 * @method
 */function shouldSetAttribute(name,value){if(isReservedProp(name)){return false;}if(name.length>2&&(name[0]==='o'||name[0]==='O')&&(name[1]==='n'||name[1]==='N')){return false;}if(value===null){return true;}switch(typeof value==='undefined'?'undefined':_typeof(value)){case'boolean':return shouldAttributeAcceptBooleanValue(name);case'undefined':case'number':case'string':case'object':return true;default:// function, symbol
return false;}}function getPropertyInfo(name){return properties.hasOwnProperty(name)?properties[name]:null;}function shouldAttributeAcceptBooleanValue(name){if(isReservedProp(name)){return true;}var propertyInfo=getPropertyInfo(name);if(propertyInfo){return propertyInfo.hasBooleanValue||propertyInfo.hasStringBooleanValue||propertyInfo.hasOverloadedBooleanValue;}var prefix=name.toLowerCase().slice(0,5);return prefix==='data-'||prefix==='aria-';}/**
 * Checks to see if a property name is within the list of properties
 * reserved for internal React operations. These properties should
 * not be set on an HTML element.
 *
 * @private
 * @param {string} name
 * @return {boolean} If the name is within reserved props
 */function isReservedProp(name){return RESERVED_PROPS.hasOwnProperty(name);}var injection=DOMPropertyInjection;var MUST_USE_PROPERTY=injection.MUST_USE_PROPERTY;var HAS_BOOLEAN_VALUE=injection.HAS_BOOLEAN_VALUE;var HAS_NUMERIC_VALUE=injection.HAS_NUMERIC_VALUE;var HAS_POSITIVE_NUMERIC_VALUE=injection.HAS_POSITIVE_NUMERIC_VALUE;var HAS_OVERLOADED_BOOLEAN_VALUE=injection.HAS_OVERLOADED_BOOLEAN_VALUE;var HAS_STRING_BOOLEAN_VALUE=injection.HAS_STRING_BOOLEAN_VALUE;var HTMLDOMPropertyConfig={// When adding attributes to this list, be sure to also add them to
// the `possibleStandardNames` module to ensure casing and incorrect
// name warnings.
Properties:{allowFullScreen:HAS_BOOLEAN_VALUE,// specifies target context for links with `preload` type
async:HAS_BOOLEAN_VALUE,// Note: there is a special case that prevents it from being written to the DOM
// on the client side because the browsers are inconsistent. Instead we call focus().
autoFocus:HAS_BOOLEAN_VALUE,autoPlay:HAS_BOOLEAN_VALUE,capture:HAS_OVERLOADED_BOOLEAN_VALUE,checked:MUST_USE_PROPERTY|HAS_BOOLEAN_VALUE,cols:HAS_POSITIVE_NUMERIC_VALUE,contentEditable:HAS_STRING_BOOLEAN_VALUE,controls:HAS_BOOLEAN_VALUE,'default':HAS_BOOLEAN_VALUE,defer:HAS_BOOLEAN_VALUE,disabled:HAS_BOOLEAN_VALUE,download:HAS_OVERLOADED_BOOLEAN_VALUE,draggable:HAS_STRING_BOOLEAN_VALUE,formNoValidate:HAS_BOOLEAN_VALUE,hidden:HAS_BOOLEAN_VALUE,loop:HAS_BOOLEAN_VALUE,// Caution; `option.selected` is not updated if `select.multiple` is
// disabled with `removeAttribute`.
multiple:MUST_USE_PROPERTY|HAS_BOOLEAN_VALUE,muted:MUST_USE_PROPERTY|HAS_BOOLEAN_VALUE,noValidate:HAS_BOOLEAN_VALUE,open:HAS_BOOLEAN_VALUE,playsInline:HAS_BOOLEAN_VALUE,readOnly:HAS_BOOLEAN_VALUE,required:HAS_BOOLEAN_VALUE,reversed:HAS_BOOLEAN_VALUE,rows:HAS_POSITIVE_NUMERIC_VALUE,rowSpan:HAS_NUMERIC_VALUE,scoped:HAS_BOOLEAN_VALUE,seamless:HAS_BOOLEAN_VALUE,selected:MUST_USE_PROPERTY|HAS_BOOLEAN_VALUE,size:HAS_POSITIVE_NUMERIC_VALUE,start:HAS_NUMERIC_VALUE,// support for projecting regular DOM Elements via V1 named slots ( shadow dom )
span:HAS_POSITIVE_NUMERIC_VALUE,spellCheck:HAS_STRING_BOOLEAN_VALUE,// Style must be explicitly set in the attribute list. React components
// expect a style object
style:0,// Keep it in the whitelist because it is case-sensitive for SVG.
tabIndex:0,// itemScope is for for Microdata support.
// See http://schema.org/docs/gs.html
itemScope:HAS_BOOLEAN_VALUE,// These attributes must stay in the white-list because they have
// different attribute names (see DOMAttributeNames below)
acceptCharset:0,className:0,htmlFor:0,httpEquiv:0,// Attributes with mutation methods must be specified in the whitelist
// Set the string boolean flag to allow the behavior
value:HAS_STRING_BOOLEAN_VALUE},DOMAttributeNames:{acceptCharset:'accept-charset',className:'class',htmlFor:'for',httpEquiv:'http-equiv'},DOMMutationMethods:{value:function value(node,_value){if(_value==null){return node.removeAttribute('value');}// Number inputs get special treatment due to some edge cases in
// Chrome. Let everything else assign the value attribute as normal.
// https://github.com/facebook/react/issues/7253#issuecomment-236074326
if(node.type!=='number'||node.hasAttribute('value')===false){node.setAttribute('value',''+_value);}else if(node.validity&&!node.validity.badInput&&node.ownerDocument.activeElement!==node){// Don't assign an attribute if validation reports bad
// input. Chrome will clear the value. Additionally, don't
// operate on inputs that have focus, otherwise Chrome might
// strip off trailing decimal places and cause the user's
// cursor position to jump to the beginning of the input.
//
// In ReactDOMInput, we have an onBlur event that will trigger
// this function again when focus is lost.
node.setAttribute('value',''+_value);}}}};var HAS_STRING_BOOLEAN_VALUE$1=injection.HAS_STRING_BOOLEAN_VALUE;var NS={xlink:'http://www.w3.org/1999/xlink',xml:'http://www.w3.org/XML/1998/namespace'};/**
 * This is a list of all SVG attributes that need special casing,
 * namespacing, or boolean value assignment.
 *
 * When adding attributes to this list, be sure to also add them to
 * the `possibleStandardNames` module to ensure casing and incorrect
 * name warnings.
 *
 * SVG Attributes List:
 * https://www.w3.org/TR/SVG/attindex.html
 * SMIL Spec:
 * https://www.w3.org/TR/smil
 */var ATTRS=['accent-height','alignment-baseline','arabic-form','baseline-shift','cap-height','clip-path','clip-rule','color-interpolation','color-interpolation-filters','color-profile','color-rendering','dominant-baseline','enable-background','fill-opacity','fill-rule','flood-color','flood-opacity','font-family','font-size','font-size-adjust','font-stretch','font-style','font-variant','font-weight','glyph-name','glyph-orientation-horizontal','glyph-orientation-vertical','horiz-adv-x','horiz-origin-x','image-rendering','letter-spacing','lighting-color','marker-end','marker-mid','marker-start','overline-position','overline-thickness','paint-order','panose-1','pointer-events','rendering-intent','shape-rendering','stop-color','stop-opacity','strikethrough-position','strikethrough-thickness','stroke-dasharray','stroke-dashoffset','stroke-linecap','stroke-linejoin','stroke-miterlimit','stroke-opacity','stroke-width','text-anchor','text-decoration','text-rendering','underline-position','underline-thickness','unicode-bidi','unicode-range','units-per-em','v-alphabetic','v-hanging','v-ideographic','v-mathematical','vector-effect','vert-adv-y','vert-origin-x','vert-origin-y','word-spacing','writing-mode','x-height','xlink:actuate','xlink:arcrole','xlink:href','xlink:role','xlink:show','xlink:title','xlink:type','xml:base','xmlns:xlink','xml:lang','xml:space'];var SVGDOMPropertyConfig={Properties:{autoReverse:HAS_STRING_BOOLEAN_VALUE$1,externalResourcesRequired:HAS_STRING_BOOLEAN_VALUE$1,preserveAlpha:HAS_STRING_BOOLEAN_VALUE$1},DOMAttributeNames:{autoReverse:'autoReverse',externalResourcesRequired:'externalResourcesRequired',preserveAlpha:'preserveAlpha'},DOMAttributeNamespaces:{xlinkActuate:NS.xlink,xlinkArcrole:NS.xlink,xlinkHref:NS.xlink,xlinkRole:NS.xlink,xlinkShow:NS.xlink,xlinkTitle:NS.xlink,xlinkType:NS.xlink,xmlBase:NS.xml,xmlLang:NS.xml,xmlSpace:NS.xml}};var CAMELIZE=/[\-\:]([a-z])/g;var capitalize=function capitalize(token){return token[1].toUpperCase();};ATTRS.forEach(function(original){var reactName=original.replace(CAMELIZE,capitalize);SVGDOMPropertyConfig.Properties[reactName]=0;SVGDOMPropertyConfig.DOMAttributeNames[reactName]=original;});injection.injectDOMPropertyConfig(HTMLDOMPropertyConfig);injection.injectDOMPropertyConfig(SVGDOMPropertyConfig);var ReactErrorUtils={// Used by Fiber to simulate a try-catch.
_caughtError:null,_hasCaughtError:false,// Used by event system to capture/rethrow the first error.
_rethrowError:null,_hasRethrowError:false,injection:{injectErrorUtils:function injectErrorUtils(injectedErrorUtils){!(typeof injectedErrorUtils.invokeGuardedCallback==='function')?invariant(false,'Injected invokeGuardedCallback() must be a function.'):void 0;_invokeGuardedCallback=injectedErrorUtils.invokeGuardedCallback;}},/**
   * Call a function while guarding against errors that happens within it.
   * Returns an error if it throws, otherwise null.
   *
   * In production, this is implemented using a try-catch. The reason we don't
   * use a try-catch directly is so that we can swap out a different
   * implementation in DEV mode.
   *
   * @param {String} name of the guard to use for logging or debugging
   * @param {Function} func The function to invoke
   * @param {*} context The context to use when calling the function
   * @param {...*} args Arguments for function
   */invokeGuardedCallback:function invokeGuardedCallback(name,func,context,a,b,c,d,e,f){_invokeGuardedCallback.apply(ReactErrorUtils,arguments);},/**
   * Same as invokeGuardedCallback, but instead of returning an error, it stores
   * it in a global so it can be rethrown by `rethrowCaughtError` later.
   * TODO: See if _caughtError and _rethrowError can be unified.
   *
   * @param {String} name of the guard to use for logging or debugging
   * @param {Function} func The function to invoke
   * @param {*} context The context to use when calling the function
   * @param {...*} args Arguments for function
   */invokeGuardedCallbackAndCatchFirstError:function invokeGuardedCallbackAndCatchFirstError(name,func,context,a,b,c,d,e,f){ReactErrorUtils.invokeGuardedCallback.apply(this,arguments);if(ReactErrorUtils.hasCaughtError()){var error=ReactErrorUtils.clearCaughtError();if(!ReactErrorUtils._hasRethrowError){ReactErrorUtils._hasRethrowError=true;ReactErrorUtils._rethrowError=error;}}},/**
   * During execution of guarded functions we will capture the first error which
   * we will rethrow to be handled by the top level error handler.
   */rethrowCaughtError:function rethrowCaughtError(){return _rethrowCaughtError.apply(ReactErrorUtils,arguments);},hasCaughtError:function hasCaughtError(){return ReactErrorUtils._hasCaughtError;},clearCaughtError:function clearCaughtError(){if(ReactErrorUtils._hasCaughtError){var error=ReactErrorUtils._caughtError;ReactErrorUtils._caughtError=null;ReactErrorUtils._hasCaughtError=false;return error;}else{invariant(false,'clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.');}}};var _invokeGuardedCallback=function _invokeGuardedCallback(name,func,context,a,b,c,d,e,f){ReactErrorUtils._hasCaughtError=false;ReactErrorUtils._caughtError=null;var funcArgs=Array.prototype.slice.call(arguments,3);try{func.apply(context,funcArgs);}catch(error){ReactErrorUtils._caughtError=error;ReactErrorUtils._hasCaughtError=true;}};{// In DEV mode, we swap out invokeGuardedCallback for a special version
// that plays more nicely with the browser's DevTools. The idea is to preserve
// "Pause on exceptions" behavior. Because React wraps all user-provided
// functions in invokeGuardedCallback, and the production version of
// invokeGuardedCallback uses a try-catch, all user exceptions are treated
// like caught exceptions, and the DevTools won't pause unless the developer
// takes the extra step of enabling pause on caught exceptions. This is
// untintuitive, though, because even though React has caught the error, from
// the developer's perspective, the error is uncaught.
//
// To preserve the expected "Pause on exceptions" behavior, we don't use a
// try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake
// DOM node, and call the user-provided callback from inside an event handler
// for that fake event. If the callback throws, the error is "captured" using
// a global event handler. But because the error happens in a different
// event loop context, it does not interrupt the normal program flow.
// Effectively, this gives us try-catch behavior without actually using
// try-catch. Neat!
// Check that the browser supports the APIs we need to implement our special
// DEV version of invokeGuardedCallback
if(typeof window!=='undefined'&&typeof window.dispatchEvent==='function'&&typeof document!=='undefined'&&typeof document.createEvent==='function'){var fakeNode=document.createElement('react');var invokeGuardedCallbackDev=function invokeGuardedCallbackDev(name,func,context,a,b,c,d,e,f){// Keeps track of whether the user-provided callback threw an error. We
// set this to true at the beginning, then set it to false right after
// calling the function. If the function errors, `didError` will never be
// set to false. This strategy works even if the browser is flaky and
// fails to call our global error handler, because it doesn't rely on
// the error event at all.
var didError=true;// Create an event handler for our fake event. We will synchronously
// dispatch our fake event using `dispatchEvent`. Inside the handler, we
// call the user-provided callback.
var funcArgs=Array.prototype.slice.call(arguments,3);function callCallback(){// We immediately remove the callback from event listeners so that
// nested `invokeGuardedCallback` calls do not clash. Otherwise, a
// nested call would trigger the fake event handlers of any call higher
// in the stack.
fakeNode.removeEventListener(evtType,callCallback,false);func.apply(context,funcArgs);didError=false;}// Create a global error event handler. We use this to capture the value
// that was thrown. It's possible that this error handler will fire more
// than once; for example, if non-React code also calls `dispatchEvent`
// and a handler for that event throws. We should be resilient to most of
// those cases. Even if our error event handler fires more than once, the
// last error event is always used. If the callback actually does error,
// we know that the last error event is the correct one, because it's not
// possible for anything else to have happened in between our callback
// erroring and the code that follows the `dispatchEvent` call below. If
// the callback doesn't error, but the error event was fired, we know to
// ignore it because `didError` will be false, as described above.
var error=void 0;// Use this to track whether the error event is ever called.
var didSetError=false;var isCrossOriginError=false;function onError(event){error=event.error;didSetError=true;if(error===null&&event.colno===0&&event.lineno===0){isCrossOriginError=true;}}// Create a fake event type.
var evtType='react-'+(name?name:'invokeguardedcallback');// Attach our event handlers
window.addEventListener('error',onError);fakeNode.addEventListener(evtType,callCallback,false);// Synchronously dispatch our fake event. If the user-provided function
// errors, it will trigger our global error handler.
var evt=document.createEvent('Event');evt.initEvent(evtType,false,false);fakeNode.dispatchEvent(evt);if(didError){if(!didSetError){// The callback errored, but the error event never fired.
error=new Error('An error was thrown inside one of your components, but React '+"doesn't know what it was. This is likely due to browser "+'flakiness. React does its best to preserve the "Pause on '+'exceptions" behavior of the DevTools, which requires some '+"DEV-mode only tricks. It's possible that these don't work in "+'your browser. Try triggering the error in production mode, '+'or switching to a modern browser. If you suspect that this is '+'actually an issue with React, please file an issue.');}else if(isCrossOriginError){error=new Error("A cross-origin error was thrown. React doesn't have access to "+'the actual error object in development. '+'See https://fb.me/react-crossorigin-error for more information.');}ReactErrorUtils._hasCaughtError=true;ReactErrorUtils._caughtError=error;}else{ReactErrorUtils._hasCaughtError=false;ReactErrorUtils._caughtError=null;}// Remove our event listeners
window.removeEventListener('error',onError);};_invokeGuardedCallback=invokeGuardedCallbackDev;}}var _rethrowCaughtError=function _rethrowCaughtError(){if(ReactErrorUtils._hasRethrowError){var error=ReactErrorUtils._rethrowError;ReactErrorUtils._rethrowError=null;ReactErrorUtils._hasRethrowError=false;throw error;}};/**
 * Injectable ordering of event plugins.
 */var eventPluginOrder=null;/**
 * Injectable mapping from names to event plugin modules.
 */var namesToPlugins={};/**
 * Recomputes the plugin list using the injected plugins and plugin ordering.
 *
 * @private
 */function recomputePluginOrdering(){if(!eventPluginOrder){// Wait until an `eventPluginOrder` is injected.
return;}for(var pluginName in namesToPlugins){var pluginModule=namesToPlugins[pluginName];var pluginIndex=eventPluginOrder.indexOf(pluginName);!(pluginIndex>-1)?invariant(false,'EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.',pluginName):void 0;if(plugins[pluginIndex]){continue;}!pluginModule.extractEvents?invariant(false,'EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.',pluginName):void 0;plugins[pluginIndex]=pluginModule;var publishedEvents=pluginModule.eventTypes;for(var eventName in publishedEvents){!publishEventForPlugin(publishedEvents[eventName],pluginModule,eventName)?invariant(false,'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.',eventName,pluginName):void 0;}}}/**
 * Publishes an event so that it can be dispatched by the supplied plugin.
 *
 * @param {object} dispatchConfig Dispatch configuration for the event.
 * @param {object} PluginModule Plugin publishing the event.
 * @return {boolean} True if the event was successfully published.
 * @private
 */function publishEventForPlugin(dispatchConfig,pluginModule,eventName){!!eventNameDispatchConfigs.hasOwnProperty(eventName)?invariant(false,'EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.',eventName):void 0;eventNameDispatchConfigs[eventName]=dispatchConfig;var phasedRegistrationNames=dispatchConfig.phasedRegistrationNames;if(phasedRegistrationNames){for(var phaseName in phasedRegistrationNames){if(phasedRegistrationNames.hasOwnProperty(phaseName)){var phasedRegistrationName=phasedRegistrationNames[phaseName];publishRegistrationName(phasedRegistrationName,pluginModule,eventName);}}return true;}else if(dispatchConfig.registrationName){publishRegistrationName(dispatchConfig.registrationName,pluginModule,eventName);return true;}return false;}/**
 * Publishes a registration name that is used to identify dispatched events.
 *
 * @param {string} registrationName Registration name to add.
 * @param {object} PluginModule Plugin publishing the event.
 * @private
 */function publishRegistrationName(registrationName,pluginModule,eventName){!!registrationNameModules[registrationName]?invariant(false,'EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.',registrationName):void 0;registrationNameModules[registrationName]=pluginModule;registrationNameDependencies[registrationName]=pluginModule.eventTypes[eventName].dependencies;{var lowerCasedName=registrationName.toLowerCase();possibleRegistrationNames[lowerCasedName]=registrationName;if(registrationName==='onDoubleClick'){possibleRegistrationNames.ondblclick=registrationName;}}}/**
 * Registers plugins so that they can extract and dispatch events.
 *
 * @see {EventPluginHub}
 *//**
 * Ordered list of injected plugins.
 */var plugins=[];/**
 * Mapping from event name to dispatch config
 */var eventNameDispatchConfigs={};/**
 * Mapping from registration name to plugin module
 */var registrationNameModules={};/**
 * Mapping from registration name to event name
 */var registrationNameDependencies={};/**
 * Mapping from lowercase registration names to the properly cased version,
 * used to warn in the case of missing event handlers. Available
 * only in true.
 * @type {Object}
 */var possibleRegistrationNames={};// Trust the developer to only use possibleRegistrationNames in true
/**
 * Injects an ordering of plugins (by plugin name). This allows the ordering
 * to be decoupled from injection of the actual plugins so that ordering is
 * always deterministic regardless of packaging, on-the-fly injection, etc.
 *
 * @param {array} InjectedEventPluginOrder
 * @internal
 * @see {EventPluginHub.injection.injectEventPluginOrder}
 */function injectEventPluginOrder(injectedEventPluginOrder){!!eventPluginOrder?invariant(false,'EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.'):void 0;// Clone the ordering so it cannot be dynamically mutated.
eventPluginOrder=Array.prototype.slice.call(injectedEventPluginOrder);recomputePluginOrdering();}/**
 * Injects plugins to be used by `EventPluginHub`. The plugin names must be
 * in the ordering injected by `injectEventPluginOrder`.
 *
 * Plugins can be injected as part of page initialization or on-the-fly.
 *
 * @param {object} injectedNamesToPlugins Map from names to plugin modules.
 * @internal
 * @see {EventPluginHub.injection.injectEventPluginsByName}
 */function injectEventPluginsByName(injectedNamesToPlugins){var isOrderingDirty=false;for(var pluginName in injectedNamesToPlugins){if(!injectedNamesToPlugins.hasOwnProperty(pluginName)){continue;}var pluginModule=injectedNamesToPlugins[pluginName];if(!namesToPlugins.hasOwnProperty(pluginName)||namesToPlugins[pluginName]!==pluginModule){!!namesToPlugins[pluginName]?invariant(false,'EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.',pluginName):void 0;namesToPlugins[pluginName]=pluginModule;isOrderingDirty=true;}}if(isOrderingDirty){recomputePluginOrdering();}}var EventPluginRegistry=Object.freeze({plugins:plugins,eventNameDispatchConfigs:eventNameDispatchConfigs,registrationNameModules:registrationNameModules,registrationNameDependencies:registrationNameDependencies,possibleRegistrationNames:possibleRegistrationNames,injectEventPluginOrder:injectEventPluginOrder,injectEventPluginsByName:injectEventPluginsByName});var getFiberCurrentPropsFromNode=null;var getInstanceFromNode=null;var getNodeFromInstance=null;var injection$2={injectComponentTree:function injectComponentTree(Injected){getFiberCurrentPropsFromNode=Injected.getFiberCurrentPropsFromNode;getInstanceFromNode=Injected.getInstanceFromNode;getNodeFromInstance=Injected.getNodeFromInstance;{warning(getNodeFromInstance&&getInstanceFromNode,'EventPluginUtils.injection.injectComponentTree(...): Injected '+'module is missing getNodeFromInstance or getInstanceFromNode.');}}};var validateEventDispatches;{validateEventDispatches=function validateEventDispatches(event){var dispatchListeners=event._dispatchListeners;var dispatchInstances=event._dispatchInstances;var listenersIsArr=Array.isArray(dispatchListeners);var listenersLen=listenersIsArr?dispatchListeners.length:dispatchListeners?1:0;var instancesIsArr=Array.isArray(dispatchInstances);var instancesLen=instancesIsArr?dispatchInstances.length:dispatchInstances?1:0;warning(instancesIsArr===listenersIsArr&&instancesLen===listenersLen,'EventPluginUtils: Invalid `event`.');};}/**
 * Dispatch the event to the listener.
 * @param {SyntheticEvent} event SyntheticEvent to handle
 * @param {boolean} simulated If the event is simulated (changes exn behavior)
 * @param {function} listener Application-level callback
 * @param {*} inst Internal component instance
 */function executeDispatch(event,simulated,listener,inst){var type=event.type||'unknown-event';event.currentTarget=getNodeFromInstance(inst);ReactErrorUtils.invokeGuardedCallbackAndCatchFirstError(type,listener,undefined,event);event.currentTarget=null;}/**
 * Standard/simple iteration through an event's collected dispatches.
 */function executeDispatchesInOrder(event,simulated){var dispatchListeners=event._dispatchListeners;var dispatchInstances=event._dispatchInstances;{validateEventDispatches(event);}if(Array.isArray(dispatchListeners)){for(var i=0;i<dispatchListeners.length;i++){if(event.isPropagationStopped()){break;}// Listeners and Instances are two parallel arrays that are always in sync.
executeDispatch(event,simulated,dispatchListeners[i],dispatchInstances[i]);}}else if(dispatchListeners){executeDispatch(event,simulated,dispatchListeners,dispatchInstances);}event._dispatchListeners=null;event._dispatchInstances=null;}/**
 * @see executeDispatchesInOrderStopAtTrueImpl
 *//**
 * Execution of a "direct" dispatch - there must be at most one dispatch
 * accumulated on the event or it is considered an error. It doesn't really make
 * sense for an event with multiple dispatches (bubbled) to keep track of the
 * return values at each dispatch execution, but it does tend to make sense when
 * dealing with "direct" dispatches.
 *
 * @return {*} The return value of executing the single dispatch.
 *//**
 * @param {SyntheticEvent} event
 * @return {boolean} True iff number of dispatches accumulated is greater than 0.
 *//**
 * Accumulates items that must not be null or undefined into the first one. This
 * is used to conserve memory by avoiding array allocations, and thus sacrifices
 * API cleanness. Since `current` can be null before being passed in and not
 * null after this function, make sure to assign it back to `current`:
 *
 * `a = accumulateInto(a, b);`
 *
 * This API should be sparingly used. Try `accumulate` for something cleaner.
 *
 * @return {*|array<*>} An accumulation of items.
 */function accumulateInto(current,next){!(next!=null)?invariant(false,'accumulateInto(...): Accumulated items must not be null or undefined.'):void 0;if(current==null){return next;}// Both are not empty. Warning: Never call x.concat(y) when you are not
// certain that x is an Array (x could be a string with concat method).
if(Array.isArray(current)){if(Array.isArray(next)){current.push.apply(current,next);return current;}current.push(next);return current;}if(Array.isArray(next)){// A bit too dangerous to mutate `next`.
return[current].concat(next);}return[current,next];}/**
 * @param {array} arr an "accumulation" of items which is either an Array or
 * a single item. Useful when paired with the `accumulate` module. This is a
 * simple utility that allows us to reason about a collection of items, but
 * handling the case when there is exactly one item (and we do not need to
 * allocate an array).
 * @param {function} cb Callback invoked with each element or a collection.
 * @param {?} [scope] Scope used as `this` in a callback.
 */function forEachAccumulated(arr,cb,scope){if(Array.isArray(arr)){arr.forEach(cb,scope);}else if(arr){cb.call(scope,arr);}}/**
 * Internal queue of events that have accumulated their dispatches and are
 * waiting to have their dispatches executed.
 */var eventQueue=null;/**
 * Dispatches an event and releases it back into the pool, unless persistent.
 *
 * @param {?object} event Synthetic event to be dispatched.
 * @param {boolean} simulated If the event is simulated (changes exn behavior)
 * @private
 */var executeDispatchesAndRelease=function executeDispatchesAndRelease(event,simulated){if(event){executeDispatchesInOrder(event,simulated);if(!event.isPersistent()){event.constructor.release(event);}}};var executeDispatchesAndReleaseSimulated=function executeDispatchesAndReleaseSimulated(e){return executeDispatchesAndRelease(e,true);};var executeDispatchesAndReleaseTopLevel=function executeDispatchesAndReleaseTopLevel(e){return executeDispatchesAndRelease(e,false);};function isInteractive(tag){return tag==='button'||tag==='input'||tag==='select'||tag==='textarea';}function shouldPreventMouseEvent(name,type,props){switch(name){case'onClick':case'onClickCapture':case'onDoubleClick':case'onDoubleClickCapture':case'onMouseDown':case'onMouseDownCapture':case'onMouseMove':case'onMouseMoveCapture':case'onMouseUp':case'onMouseUpCapture':return!!(props.disabled&&isInteractive(type));default:return false;}}/**
 * This is a unified interface for event plugins to be installed and configured.
 *
 * Event plugins can implement the following properties:
 *
 *   `extractEvents` {function(string, DOMEventTarget, string, object): *}
 *     Required. When a top-level event is fired, this method is expected to
 *     extract synthetic events that will in turn be queued and dispatched.
 *
 *   `eventTypes` {object}
 *     Optional, plugins that fire events must publish a mapping of registration
 *     names that are used to register listeners. Values of this mapping must
 *     be objects that contain `registrationName` or `phasedRegistrationNames`.
 *
 *   `executeDispatch` {function(object, function, string)}
 *     Optional, allows plugins to override how an event gets dispatched. By
 *     default, the listener is simply invoked.
 *
 * Each plugin that is injected into `EventsPluginHub` is immediately operable.
 *
 * @public
 *//**
 * Methods for injecting dependencies.
 */var injection$1={/**
   * @param {array} InjectedEventPluginOrder
   * @public
   */injectEventPluginOrder:injectEventPluginOrder,/**
   * @param {object} injectedNamesToPlugins Map from names to plugin modules.
   */injectEventPluginsByName:injectEventPluginsByName};/**
 * @param {object} inst The instance, which is the source of events.
 * @param {string} registrationName Name of listener (e.g. `onClick`).
 * @return {?function} The stored callback.
 */function getListener(inst,registrationName){var listener;// TODO: shouldPreventMouseEvent is DOM-specific and definitely should not
// live here; needs to be moved to a better place soon
var stateNode=inst.stateNode;if(!stateNode){// Work in progress (ex: onload events in incremental mode).
return null;}var props=getFiberCurrentPropsFromNode(stateNode);if(!props){// Work in progress.
return null;}listener=props[registrationName];if(shouldPreventMouseEvent(registrationName,inst.type,props)){return null;}!(!listener||typeof listener==='function')?invariant(false,'Expected `%s` listener to be a function, instead got a value of `%s` type.',registrationName,typeof listener==='undefined'?'undefined':_typeof(listener)):void 0;return listener;}/**
 * Allows registered plugins an opportunity to extract events from top-level
 * native browser events.
 *
 * @return {*} An accumulation of synthetic events.
 * @internal
 */function extractEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget){var events;for(var i=0;i<plugins.length;i++){// Not every plugin in the ordering may be loaded at runtime.
var possiblePlugin=plugins[i];if(possiblePlugin){var extractedEvents=possiblePlugin.extractEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget);if(extractedEvents){events=accumulateInto(events,extractedEvents);}}}return events;}/**
 * Enqueues a synthetic event that should be dispatched when
 * `processEventQueue` is invoked.
 *
 * @param {*} events An accumulation of synthetic events.
 * @internal
 */function enqueueEvents(events){if(events){eventQueue=accumulateInto(eventQueue,events);}}/**
 * Dispatches all synthetic events on the event queue.
 *
 * @internal
 */function processEventQueue(simulated){// Set `eventQueue` to null before processing it so that we can tell if more
// events get enqueued while processing.
var processingEventQueue=eventQueue;eventQueue=null;if(!processingEventQueue){return;}if(simulated){forEachAccumulated(processingEventQueue,executeDispatchesAndReleaseSimulated);}else{forEachAccumulated(processingEventQueue,executeDispatchesAndReleaseTopLevel);}!!eventQueue?invariant(false,'processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.'):void 0;// This would be a good time to rethrow if any of the event handlers threw.
ReactErrorUtils.rethrowCaughtError();}var EventPluginHub=Object.freeze({injection:injection$1,getListener:getListener,extractEvents:extractEvents,enqueueEvents:enqueueEvents,processEventQueue:processEventQueue});var IndeterminateComponent=0;// Before we know whether it is functional or class
var FunctionalComponent=1;var ClassComponent=2;var HostRoot=3;// Root of a host tree. Could be nested inside another node.
var HostPortal=4;// A subtree. Could be an entry point to a different renderer.
var HostComponent=5;var HostText=6;var CallComponent=7;var CallHandlerPhase=8;var ReturnComponent=9;var Fragment=10;var randomKey=Math.random().toString(36).slice(2);var internalInstanceKey='__reactInternalInstance$'+randomKey;var internalEventHandlersKey='__reactEventHandlers$'+randomKey;function precacheFiberNode$1(hostInst,node){node[internalInstanceKey]=hostInst;}/**
 * Given a DOM node, return the closest ReactDOMComponent or
 * ReactDOMTextComponent instance ancestor.
 */function getClosestInstanceFromNode(node){if(node[internalInstanceKey]){return node[internalInstanceKey];}// Walk up the tree until we find an ancestor whose instance we have cached.
var parents=[];while(!node[internalInstanceKey]){parents.push(node);if(node.parentNode){node=node.parentNode;}else{// Top of the tree. This node must not be part of a React tree (or is
// unmounted, potentially).
return null;}}var closest=void 0;var inst=node[internalInstanceKey];if(inst.tag===HostComponent||inst.tag===HostText){// In Fiber, this will always be the deepest root.
return inst;}for(;node&&(inst=node[internalInstanceKey]);node=parents.pop()){closest=inst;}return closest;}/**
 * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent
 * instance, or null if the node was not rendered by this React.
 */function getInstanceFromNode$1(node){var inst=node[internalInstanceKey];if(inst){if(inst.tag===HostComponent||inst.tag===HostText){return inst;}else{return null;}}return null;}/**
 * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding
 * DOM node.
 */function getNodeFromInstance$1(inst){if(inst.tag===HostComponent||inst.tag===HostText){// In Fiber this, is just the state node right now. We assume it will be
// a host component or host text.
return inst.stateNode;}// Without this first invariant, passing a non-DOM-component triggers the next
// invariant for a missing parent, which is super confusing.
invariant(false,'getNodeFromInstance: Invalid argument.');}function getFiberCurrentPropsFromNode$1(node){return node[internalEventHandlersKey]||null;}function updateFiberProps$1(node,props){node[internalEventHandlersKey]=props;}var ReactDOMComponentTree=Object.freeze({precacheFiberNode:precacheFiberNode$1,getClosestInstanceFromNode:getClosestInstanceFromNode,getInstanceFromNode:getInstanceFromNode$1,getNodeFromInstance:getNodeFromInstance$1,getFiberCurrentPropsFromNode:getFiberCurrentPropsFromNode$1,updateFiberProps:updateFiberProps$1});function getParent(inst){do{inst=inst['return'];// TODO: If this is a HostRoot we might want to bail out.
// That is depending on if we want nested subtrees (layers) to bubble
// events to their parent. We could also go through parentNode on the
// host node but that wouldn't work for React Native and doesn't let us
// do the portal feature.
}while(inst&&inst.tag!==HostComponent);if(inst){return inst;}return null;}/**
 * Return the lowest common ancestor of A and B, or null if they are in
 * different trees.
 */function getLowestCommonAncestor(instA,instB){var depthA=0;for(var tempA=instA;tempA;tempA=getParent(tempA)){depthA++;}var depthB=0;for(var tempB=instB;tempB;tempB=getParent(tempB)){depthB++;}// If A is deeper, crawl up.
while(depthA-depthB>0){instA=getParent(instA);depthA--;}// If B is deeper, crawl up.
while(depthB-depthA>0){instB=getParent(instB);depthB--;}// Walk in lockstep until we find a match.
var depth=depthA;while(depth--){if(instA===instB||instA===instB.alternate){return instA;}instA=getParent(instA);instB=getParent(instB);}return null;}/**
 * Return if A is an ancestor of B.
 *//**
 * Return the parent instance of the passed-in instance.
 */function getParentInstance(inst){return getParent(inst);}/**
 * Simulates the traversal of a two-phase, capture/bubble event dispatch.
 */function traverseTwoPhase(inst,fn,arg){var path=[];while(inst){path.push(inst);inst=getParent(inst);}var i;for(i=path.length;i-->0;){fn(path[i],'captured',arg);}for(i=0;i<path.length;i++){fn(path[i],'bubbled',arg);}}/**
 * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that
 * should would receive a `mouseEnter` or `mouseLeave` event.
 *
 * Does not invoke the callback on the nearest common ancestor because nothing
 * "entered" or "left" that element.
 */function traverseEnterLeave(from,to,fn,argFrom,argTo){var common=from&&to?getLowestCommonAncestor(from,to):null;var pathFrom=[];while(true){if(!from){break;}if(from===common){break;}var alternate=from.alternate;if(alternate!==null&&alternate===common){break;}pathFrom.push(from);from=getParent(from);}var pathTo=[];while(true){if(!to){break;}if(to===common){break;}var _alternate=to.alternate;if(_alternate!==null&&_alternate===common){break;}pathTo.push(to);to=getParent(to);}for(var i=0;i<pathFrom.length;i++){fn(pathFrom[i],'bubbled',argFrom);}for(var _i=pathTo.length;_i-->0;){fn(pathTo[_i],'captured',argTo);}}/**
 * Some event types have a notion of different registration names for different
 * "phases" of propagation. This finds listeners by a given phase.
 */function listenerAtPhase(inst,event,propagationPhase){var registrationName=event.dispatchConfig.phasedRegistrationNames[propagationPhase];return getListener(inst,registrationName);}/**
 * A small set of propagation patterns, each of which will accept a small amount
 * of information, and generate a set of "dispatch ready event objects" - which
 * are sets of events that have already been annotated with a set of dispatched
 * listener functions/ids. The API is designed this way to discourage these
 * propagation strategies from actually executing the dispatches, since we
 * always want to collect the entire set of dispatches before executing even a
 * single one.
 *//**
 * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
 * here, allows us to not have to bind or create functions for each event.
 * Mutating the event's members allows us to not have to create a wrapping
 * "dispatch" object that pairs the event with the listener.
 */function accumulateDirectionalDispatches(inst,phase,event){{warning(inst,'Dispatching inst must not be null');}var listener=listenerAtPhase(inst,event,phase);if(listener){event._dispatchListeners=accumulateInto(event._dispatchListeners,listener);event._dispatchInstances=accumulateInto(event._dispatchInstances,inst);}}/**
 * Collect dispatches (must be entirely collected before dispatching - see unit
 * tests). Lazily allocate the array to conserve memory.  We must loop through
 * each event and perform the traversal for each one. We cannot perform a
 * single traversal for the entire collection of events because each event may
 * have a different target.
 */function accumulateTwoPhaseDispatchesSingle(event){if(event&&event.dispatchConfig.phasedRegistrationNames){traverseTwoPhase(event._targetInst,accumulateDirectionalDispatches,event);}}/**
 * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.
 */function accumulateTwoPhaseDispatchesSingleSkipTarget(event){if(event&&event.dispatchConfig.phasedRegistrationNames){var targetInst=event._targetInst;var parentInst=targetInst?getParentInstance(targetInst):null;traverseTwoPhase(parentInst,accumulateDirectionalDispatches,event);}}/**
 * Accumulates without regard to direction, does not look for phased
 * registration names. Same as `accumulateDirectDispatchesSingle` but without
 * requiring that the `dispatchMarker` be the same as the dispatched ID.
 */function accumulateDispatches(inst,ignoredDirection,event){if(inst&&event&&event.dispatchConfig.registrationName){var registrationName=event.dispatchConfig.registrationName;var listener=getListener(inst,registrationName);if(listener){event._dispatchListeners=accumulateInto(event._dispatchListeners,listener);event._dispatchInstances=accumulateInto(event._dispatchInstances,inst);}}}/**
 * Accumulates dispatches on an `SyntheticEvent`, but only for the
 * `dispatchMarker`.
 * @param {SyntheticEvent} event
 */function accumulateDirectDispatchesSingle(event){if(event&&event.dispatchConfig.registrationName){accumulateDispatches(event._targetInst,null,event);}}function accumulateTwoPhaseDispatches(events){forEachAccumulated(events,accumulateTwoPhaseDispatchesSingle);}function accumulateTwoPhaseDispatchesSkipTarget(events){forEachAccumulated(events,accumulateTwoPhaseDispatchesSingleSkipTarget);}function accumulateEnterLeaveDispatches(leave,enter,from,to){traverseEnterLeave(from,to,accumulateDispatches,leave,enter);}function accumulateDirectDispatches(events){forEachAccumulated(events,accumulateDirectDispatchesSingle);}var EventPropagators=Object.freeze({accumulateTwoPhaseDispatches:accumulateTwoPhaseDispatches,accumulateTwoPhaseDispatchesSkipTarget:accumulateTwoPhaseDispatchesSkipTarget,accumulateEnterLeaveDispatches:accumulateEnterLeaveDispatches,accumulateDirectDispatches:accumulateDirectDispatches});var contentKey=null;/**
 * Gets the key used to access text content on a DOM node.
 *
 * @return {?string} Key used to access text content.
 * @internal
 */function getTextContentAccessor(){if(!contentKey&&ExecutionEnvironment.canUseDOM){// Prefer textContent to innerText because many browsers support both but
// SVG <text> elements don't support innerText even when <div> does.
contentKey='textContent'in document.documentElement?'textContent':'innerText';}return contentKey;}/**
 * This helper object stores information about text content of a target node,
 * allowing comparison of content before and after a given event.
 *
 * Identify the node where selection currently begins, then observe
 * both its text content and its current position in the DOM. Since the
 * browser may natively replace the target node during composition, we can
 * use its position to find its replacement.
 *
 *
 */var compositionState={_root:null,_startText:null,_fallbackText:null};function initialize(nativeEventTarget){compositionState._root=nativeEventTarget;compositionState._startText=getText();return true;}function reset(){compositionState._root=null;compositionState._startText=null;compositionState._fallbackText=null;}function getData(){if(compositionState._fallbackText){return compositionState._fallbackText;}var start;var startValue=compositionState._startText;var startLength=startValue.length;var end;var endValue=getText();var endLength=endValue.length;for(start=0;start<startLength;start++){if(startValue[start]!==endValue[start]){break;}}var minEnd=startLength-start;for(end=1;end<=minEnd;end++){if(startValue[startLength-end]!==endValue[endLength-end]){break;}}var sliceTail=end>1?1-end:undefined;compositionState._fallbackText=endValue.slice(start,sliceTail);return compositionState._fallbackText;}function getText(){if('value'in compositionState._root){return compositionState._root.value;}return compositionState._root[getTextContentAccessor()];}/* eslint valid-typeof: 0 */var didWarnForAddedNewProperty=false;var isProxySupported=typeof Proxy==='function';var EVENT_POOL_SIZE=10;var shouldBeReleasedProperties=['dispatchConfig','_targetInst','nativeEvent','isDefaultPrevented','isPropagationStopped','_dispatchListeners','_dispatchInstances'];/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var EventInterface={type:null,target:null,// currentTarget is set when dispatching; no use in copying it here
currentTarget:emptyFunction.thatReturnsNull,eventPhase:null,bubbles:null,cancelable:null,timeStamp:function timeStamp(event){return event.timeStamp||Date.now();},defaultPrevented:null,isTrusted:null};/**
 * Synthetic events are dispatched by event plugins, typically in response to a
 * top-level event delegation handler.
 *
 * These systems should generally use pooling to reduce the frequency of garbage
 * collection. The system should check `isPersistent` to determine whether the
 * event should be released into the pool after being dispatched. Users that
 * need a persisted event should invoke `persist`.
 *
 * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
 * normalizing browser quirks. Subclasses do not necessarily have to implement a
 * DOM interface; custom application-specific events can also subclass this.
 *
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {*} targetInst Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @param {DOMEventTarget} nativeEventTarget Target node.
 */function SyntheticEvent(dispatchConfig,targetInst,nativeEvent,nativeEventTarget){{// these have a getter/setter for warnings
delete this.nativeEvent;delete this.preventDefault;delete this.stopPropagation;}this.dispatchConfig=dispatchConfig;this._targetInst=targetInst;this.nativeEvent=nativeEvent;var Interface=this.constructor.Interface;for(var propName in Interface){if(!Interface.hasOwnProperty(propName)){continue;}{delete this[propName];// this has a getter/setter for warnings
}var normalize=Interface[propName];if(normalize){this[propName]=normalize(nativeEvent);}else{if(propName==='target'){this.target=nativeEventTarget;}else{this[propName]=nativeEvent[propName];}}}var defaultPrevented=nativeEvent.defaultPrevented!=null?nativeEvent.defaultPrevented:nativeEvent.returnValue===false;if(defaultPrevented){this.isDefaultPrevented=emptyFunction.thatReturnsTrue;}else{this.isDefaultPrevented=emptyFunction.thatReturnsFalse;}this.isPropagationStopped=emptyFunction.thatReturnsFalse;return this;}_assign(SyntheticEvent.prototype,{preventDefault:function preventDefault(){this.defaultPrevented=true;var event=this.nativeEvent;if(!event){return;}if(event.preventDefault){event.preventDefault();}else if(typeof event.returnValue!=='unknown'){event.returnValue=false;}this.isDefaultPrevented=emptyFunction.thatReturnsTrue;},stopPropagation:function stopPropagation(){var event=this.nativeEvent;if(!event){return;}if(event.stopPropagation){event.stopPropagation();}else if(typeof event.cancelBubble!=='unknown'){// The ChangeEventPlugin registers a "propertychange" event for
// IE. This event does not support bubbling or cancelling, and
// any references to cancelBubble throw "Member not found".  A
// typeof check of "unknown" circumvents this issue (and is also
// IE specific).
event.cancelBubble=true;}this.isPropagationStopped=emptyFunction.thatReturnsTrue;},/**
   * We release all dispatched `SyntheticEvent`s after each event loop, adding
   * them back into the pool. This allows a way to hold onto a reference that
   * won't be added back into the pool.
   */persist:function persist(){this.isPersistent=emptyFunction.thatReturnsTrue;},/**
   * Checks if this event should be released back into the pool.
   *
   * @return {boolean} True if this should not be released, false otherwise.
   */isPersistent:emptyFunction.thatReturnsFalse,/**
   * `PooledClass` looks for `destructor` on each instance it releases.
   */destructor:function destructor(){var Interface=this.constructor.Interface;for(var propName in Interface){{Object.defineProperty(this,propName,getPooledWarningPropertyDefinition(propName,Interface[propName]));}}for(var i=0;i<shouldBeReleasedProperties.length;i++){this[shouldBeReleasedProperties[i]]=null;}{Object.defineProperty(this,'nativeEvent',getPooledWarningPropertyDefinition('nativeEvent',null));Object.defineProperty(this,'preventDefault',getPooledWarningPropertyDefinition('preventDefault',emptyFunction));Object.defineProperty(this,'stopPropagation',getPooledWarningPropertyDefinition('stopPropagation',emptyFunction));}}});SyntheticEvent.Interface=EventInterface;/**
 * Helper to reduce boilerplate when creating subclasses.
 *
 * @param {function} Class
 * @param {?object} Interface
 */SyntheticEvent.augmentClass=function(Class,Interface){var Super=this;var E=function E(){};E.prototype=Super.prototype;var prototype=new E();_assign(prototype,Class.prototype);Class.prototype=prototype;Class.prototype.constructor=Class;Class.Interface=_assign({},Super.Interface,Interface);Class.augmentClass=Super.augmentClass;addEventPoolingTo(Class);};/** Proxying after everything set on SyntheticEvent
 * to resolve Proxy issue on some WebKit browsers
 * in which some Event properties are set to undefined (GH#10010)
 */{if(isProxySupported){/*eslint-disable no-func-assign */SyntheticEvent=new Proxy(SyntheticEvent,{construct:function construct(target,args){return this.apply(target,Object.create(target.prototype),args);},apply:function apply(constructor,that,args){return new Proxy(constructor.apply(that,args),{set:function set(target,prop,value){if(prop!=='isPersistent'&&!target.constructor.Interface.hasOwnProperty(prop)&&shouldBeReleasedProperties.indexOf(prop)===-1){warning(didWarnForAddedNewProperty||target.isPersistent(),"This synthetic event is reused for performance reasons. If you're "+"seeing this, you're adding a new property in the synthetic event object. "+'The property is never released. See '+'https://fb.me/react-event-pooling for more information.');didWarnForAddedNewProperty=true;}target[prop]=value;return true;}});}});/*eslint-enable no-func-assign */}}addEventPoolingTo(SyntheticEvent);/**
 * Helper to nullify syntheticEvent instance properties when destructing
 *
 * @param {String} propName
 * @param {?object} getVal
 * @return {object} defineProperty object
 */function getPooledWarningPropertyDefinition(propName,getVal){var isFunction=typeof getVal==='function';return{configurable:true,set:set,get:get};function set(val){var action=isFunction?'setting the method':'setting the property';warn(action,'This is effectively a no-op');return val;}function get(){var action=isFunction?'accessing the method':'accessing the property';var result=isFunction?'This is a no-op function':'This is set to null';warn(action,result);return getVal;}function warn(action,result){var warningCondition=false;warning(warningCondition,"This synthetic event is reused for performance reasons. If you're seeing this, "+"you're %s `%s` on a released/nullified synthetic event. %s. "+'If you must keep the original synthetic event around, use event.persist(). '+'See https://fb.me/react-event-pooling for more information.',action,propName,result);}}function getPooledEvent(dispatchConfig,targetInst,nativeEvent,nativeInst){var EventConstructor=this;if(EventConstructor.eventPool.length){var instance=EventConstructor.eventPool.pop();EventConstructor.call(instance,dispatchConfig,targetInst,nativeEvent,nativeInst);return instance;}return new EventConstructor(dispatchConfig,targetInst,nativeEvent,nativeInst);}function releasePooledEvent(event){var EventConstructor=this;!(event instanceof EventConstructor)?invariant(false,'Trying to release an event instance  into a pool of a different type.'):void 0;event.destructor();if(EventConstructor.eventPool.length<EVENT_POOL_SIZE){EventConstructor.eventPool.push(event);}}function addEventPoolingTo(EventConstructor){EventConstructor.eventPool=[];EventConstructor.getPooled=getPooledEvent;EventConstructor.release=releasePooledEvent;}var SyntheticEvent$1=SyntheticEvent;/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
 */var CompositionEventInterface={data:null};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */function SyntheticCompositionEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticEvent$1.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticEvent$1.augmentClass(SyntheticCompositionEvent,CompositionEventInterface);/**
 * @interface Event
 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
 *      /#events-inputevents
 */var InputEventInterface={data:null};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */function SyntheticInputEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticEvent$1.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticEvent$1.augmentClass(SyntheticInputEvent,InputEventInterface);var END_KEYCODES=[9,13,27,32];// Tab, Return, Esc, Space
var START_KEYCODE=229;var canUseCompositionEvent=ExecutionEnvironment.canUseDOM&&'CompositionEvent'in window;var documentMode=null;if(ExecutionEnvironment.canUseDOM&&'documentMode'in document){documentMode=document.documentMode;}// Webkit offers a very useful `textInput` event that can be used to
// directly represent `beforeInput`. The IE `textinput` event is not as
// useful, so we don't use it.
var canUseTextInputEvent=ExecutionEnvironment.canUseDOM&&'TextEvent'in window&&!documentMode&&!isPresto();// In IE9+, we have access to composition events, but the data supplied
// by the native compositionend event may be incorrect. Japanese ideographic
// spaces, for instance (\u3000) are not recorded correctly.
var useFallbackCompositionData=ExecutionEnvironment.canUseDOM&&(!canUseCompositionEvent||documentMode&&documentMode>8&&documentMode<=11);/**
 * Opera <= 12 includes TextEvent in window, but does not fire
 * text input events. Rely on keypress instead.
 */function isPresto(){var opera=window.opera;return(typeof opera==='undefined'?'undefined':_typeof(opera))==='object'&&typeof opera.version==='function'&&parseInt(opera.version(),10)<=12;}var SPACEBAR_CODE=32;var SPACEBAR_CHAR=String.fromCharCode(SPACEBAR_CODE);// Events and their corresponding property names.
var eventTypes={beforeInput:{phasedRegistrationNames:{bubbled:'onBeforeInput',captured:'onBeforeInputCapture'},dependencies:['topCompositionEnd','topKeyPress','topTextInput','topPaste']},compositionEnd:{phasedRegistrationNames:{bubbled:'onCompositionEnd',captured:'onCompositionEndCapture'},dependencies:['topBlur','topCompositionEnd','topKeyDown','topKeyPress','topKeyUp','topMouseDown']},compositionStart:{phasedRegistrationNames:{bubbled:'onCompositionStart',captured:'onCompositionStartCapture'},dependencies:['topBlur','topCompositionStart','topKeyDown','topKeyPress','topKeyUp','topMouseDown']},compositionUpdate:{phasedRegistrationNames:{bubbled:'onCompositionUpdate',captured:'onCompositionUpdateCapture'},dependencies:['topBlur','topCompositionUpdate','topKeyDown','topKeyPress','topKeyUp','topMouseDown']}};// Track whether we've ever handled a keypress on the space key.
var hasSpaceKeypress=false;/**
 * Return whether a native keypress event is assumed to be a command.
 * This is required because Firefox fires `keypress` events for key commands
 * (cut, copy, select-all, etc.) even though no character is inserted.
 */function isKeypressCommand(nativeEvent){return(nativeEvent.ctrlKey||nativeEvent.altKey||nativeEvent.metaKey)&&// ctrlKey && altKey is equivalent to AltGr, and is not a command.
!(nativeEvent.ctrlKey&&nativeEvent.altKey);}/**
 * Translate native top level events into event types.
 *
 * @param {string} topLevelType
 * @return {object}
 */function getCompositionEventType(topLevelType){switch(topLevelType){case'topCompositionStart':return eventTypes.compositionStart;case'topCompositionEnd':return eventTypes.compositionEnd;case'topCompositionUpdate':return eventTypes.compositionUpdate;}}/**
 * Does our fallback best-guess model think this event signifies that
 * composition has begun?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */function isFallbackCompositionStart(topLevelType,nativeEvent){return topLevelType==='topKeyDown'&&nativeEvent.keyCode===START_KEYCODE;}/**
 * Does our fallback mode think that this event is the end of composition?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */function isFallbackCompositionEnd(topLevelType,nativeEvent){switch(topLevelType){case'topKeyUp':// Command keys insert or clear IME input.
return END_KEYCODES.indexOf(nativeEvent.keyCode)!==-1;case'topKeyDown':// Expect IME keyCode on each keydown. If we get any other
// code we must have exited earlier.
return nativeEvent.keyCode!==START_KEYCODE;case'topKeyPress':case'topMouseDown':case'topBlur':// Events are not possible without cancelling IME.
return true;default:return false;}}/**
 * Google Input Tools provides composition data via a CustomEvent,
 * with the `data` property populated in the `detail` object. If this
 * is available on the event object, use it. If not, this is a plain
 * composition event and we have nothing special to extract.
 *
 * @param {object} nativeEvent
 * @return {?string}
 */function getDataFromCustomEvent(nativeEvent){var detail=nativeEvent.detail;if((typeof detail==='undefined'?'undefined':_typeof(detail))==='object'&&'data'in detail){return detail.data;}return null;}// Track the current IME composition status, if any.
var isComposing=false;/**
 * @return {?object} A SyntheticCompositionEvent.
 */function extractCompositionEvent(topLevelType,targetInst,nativeEvent,nativeEventTarget){var eventType;var fallbackData;if(canUseCompositionEvent){eventType=getCompositionEventType(topLevelType);}else if(!isComposing){if(isFallbackCompositionStart(topLevelType,nativeEvent)){eventType=eventTypes.compositionStart;}}else if(isFallbackCompositionEnd(topLevelType,nativeEvent)){eventType=eventTypes.compositionEnd;}if(!eventType){return null;}if(useFallbackCompositionData){// The current composition is stored statically and must not be
// overwritten while composition continues.
if(!isComposing&&eventType===eventTypes.compositionStart){isComposing=initialize(nativeEventTarget);}else if(eventType===eventTypes.compositionEnd){if(isComposing){fallbackData=getData();}}}var event=SyntheticCompositionEvent.getPooled(eventType,targetInst,nativeEvent,nativeEventTarget);if(fallbackData){// Inject data generated from fallback path into the synthetic event.
// This matches the property of native CompositionEventInterface.
event.data=fallbackData;}else{var customData=getDataFromCustomEvent(nativeEvent);if(customData!==null){event.data=customData;}}accumulateTwoPhaseDispatches(event);return event;}/**
 * @param {TopLevelTypes} topLevelType Record from `BrowserEventConstants`.
 * @param {object} nativeEvent Native browser event.
 * @return {?string} The string corresponding to this `beforeInput` event.
 */function getNativeBeforeInputChars(topLevelType,nativeEvent){switch(topLevelType){case'topCompositionEnd':return getDataFromCustomEvent(nativeEvent);case'topKeyPress':/**
       * If native `textInput` events are available, our goal is to make
       * use of them. However, there is a special case: the spacebar key.
       * In Webkit, preventing default on a spacebar `textInput` event
       * cancels character insertion, but it *also* causes the browser
       * to fall back to its default spacebar behavior of scrolling the
       * page.
       *
       * Tracking at:
       * https://code.google.com/p/chromium/issues/detail?id=355103
       *
       * To avoid this issue, use the keypress event as if no `textInput`
       * event is available.
       */var which=nativeEvent.which;if(which!==SPACEBAR_CODE){return null;}hasSpaceKeypress=true;return SPACEBAR_CHAR;case'topTextInput':// Record the characters to be added to the DOM.
var chars=nativeEvent.data;// If it's a spacebar character, assume that we have already handled
// it at the keypress level and bail immediately. Android Chrome
// doesn't give us keycodes, so we need to blacklist it.
if(chars===SPACEBAR_CHAR&&hasSpaceKeypress){return null;}return chars;default:// For other native event types, do nothing.
return null;}}/**
 * For browsers that do not provide the `textInput` event, extract the
 * appropriate string to use for SyntheticInputEvent.
 *
 * @param {string} topLevelType Record from `BrowserEventConstants`.
 * @param {object} nativeEvent Native browser event.
 * @return {?string} The fallback string for this `beforeInput` event.
 */function getFallbackBeforeInputChars(topLevelType,nativeEvent){// If we are currently composing (IME) and using a fallback to do so,
// try to extract the composed characters from the fallback object.
// If composition event is available, we extract a string only at
// compositionevent, otherwise extract it at fallback events.
if(isComposing){if(topLevelType==='topCompositionEnd'||!canUseCompositionEvent&&isFallbackCompositionEnd(topLevelType,nativeEvent)){var chars=getData();reset();isComposing=false;return chars;}return null;}switch(topLevelType){case'topPaste':// If a paste event occurs after a keypress, throw out the input
// chars. Paste events should not lead to BeforeInput events.
return null;case'topKeyPress':/**
       * As of v27, Firefox may fire keypress events even when no character
       * will be inserted. A few possibilities:
       *
       * - `which` is `0`. Arrow keys, Esc key, etc.
       *
       * - `which` is the pressed key code, but no char is available.
       *   Ex: 'AltGr + d` in Polish. There is no modified character for
       *   this key combination and no character is inserted into the
       *   document, but FF fires the keypress for char code `100` anyway.
       *   No `input` event will occur.
       *
       * - `which` is the pressed key code, but a command combination is
       *   being used. Ex: `Cmd+C`. No character is inserted, and no
       *   `input` event will occur.
       */if(!isKeypressCommand(nativeEvent)){// IE fires the `keypress` event when a user types an emoji via
// Touch keyboard of Windows.  In such a case, the `char` property
// holds an emoji character like `\uD83D\uDE0A`.  Because its length
// is 2, the property `which` does not represent an emoji correctly.
// In such a case, we directly return the `char` property instead of
// using `which`.
if(nativeEvent.char&&nativeEvent.char.length>1){return nativeEvent.char;}else if(nativeEvent.which){return String.fromCharCode(nativeEvent.which);}}return null;case'topCompositionEnd':return useFallbackCompositionData?null:nativeEvent.data;default:return null;}}/**
 * Extract a SyntheticInputEvent for `beforeInput`, based on either native
 * `textInput` or fallback behavior.
 *
 * @return {?object} A SyntheticInputEvent.
 */function extractBeforeInputEvent(topLevelType,targetInst,nativeEvent,nativeEventTarget){var chars;if(canUseTextInputEvent){chars=getNativeBeforeInputChars(topLevelType,nativeEvent);}else{chars=getFallbackBeforeInputChars(topLevelType,nativeEvent);}// If no characters are being inserted, no BeforeInput event should
// be fired.
if(!chars){return null;}var event=SyntheticInputEvent.getPooled(eventTypes.beforeInput,targetInst,nativeEvent,nativeEventTarget);event.data=chars;accumulateTwoPhaseDispatches(event);return event;}/**
 * Create an `onBeforeInput` event to match
 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
 *
 * This event plugin is based on the native `textInput` event
 * available in Chrome, Safari, Opera, and IE. This event fires after
 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
 *
 * `beforeInput` is spec'd but not implemented in any browsers, and
 * the `input` event does not provide any useful information about what has
 * actually been added, contrary to the spec. Thus, `textInput` is the best
 * available event to identify the characters that have actually been inserted
 * into the target node.
 *
 * This plugin is also responsible for emitting `composition` events, thus
 * allowing us to share composition fallback code for both `beforeInput` and
 * `composition` event types.
 */var BeforeInputEventPlugin={eventTypes:eventTypes,extractEvents:function extractEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget){return[extractCompositionEvent(topLevelType,targetInst,nativeEvent,nativeEventTarget),extractBeforeInputEvent(topLevelType,targetInst,nativeEvent,nativeEventTarget)];}};// Use to restore controlled state after a change event has fired.
var fiberHostComponent=null;var ReactControlledComponentInjection={injectFiberControlledHostComponent:function injectFiberControlledHostComponent(hostComponentImpl){// The fiber implementation doesn't use dynamic dispatch so we need to
// inject the implementation.
fiberHostComponent=hostComponentImpl;}};var restoreTarget=null;var restoreQueue=null;function restoreStateOfTarget(target){// We perform this translation at the end of the event loop so that we
// always receive the correct fiber here
var internalInstance=getInstanceFromNode(target);if(!internalInstance){// Unmounted
return;}!(fiberHostComponent&&typeof fiberHostComponent.restoreControlledState==='function')?invariant(false,'Fiber needs to be injected to handle a fiber target for controlled events. This error is likely caused by a bug in React. Please file an issue.'):void 0;var props=getFiberCurrentPropsFromNode(internalInstance.stateNode);fiberHostComponent.restoreControlledState(internalInstance.stateNode,internalInstance.type,props);}var injection$3=ReactControlledComponentInjection;function enqueueStateRestore(target){if(restoreTarget){if(restoreQueue){restoreQueue.push(target);}else{restoreQueue=[target];}}else{restoreTarget=target;}}function restoreStateIfNeeded(){if(!restoreTarget){return;}var target=restoreTarget;var queuedTargets=restoreQueue;restoreTarget=null;restoreQueue=null;restoreStateOfTarget(target);if(queuedTargets){for(var i=0;i<queuedTargets.length;i++){restoreStateOfTarget(queuedTargets[i]);}}}var ReactControlledComponent=Object.freeze({injection:injection$3,enqueueStateRestore:enqueueStateRestore,restoreStateIfNeeded:restoreStateIfNeeded});// Used as a way to call batchedUpdates when we don't have a reference to
// the renderer. Such as when we're dispatching events or if third party
// libraries need to call batchedUpdates. Eventually, this API will go away when
// everything is batched by default. We'll then have a similar API to opt-out of
// scheduled work and instead do synchronous work.
// Defaults
var fiberBatchedUpdates=function fiberBatchedUpdates(fn,bookkeeping){return fn(bookkeeping);};var isNestingBatched=false;function batchedUpdates(fn,bookkeeping){if(isNestingBatched){// If we are currently inside another batch, we need to wait until it
// fully completes before restoring state. Therefore, we add the target to
// a queue of work.
return fiberBatchedUpdates(fn,bookkeeping);}isNestingBatched=true;try{return fiberBatchedUpdates(fn,bookkeeping);}finally{// Here we wait until all updates have propagated, which is important
// when using controlled components within layers:
// https://github.com/facebook/react/issues/1698
// Then we restore state of any controlled component.
isNestingBatched=false;restoreStateIfNeeded();}}var ReactGenericBatchingInjection={injectFiberBatchedUpdates:function injectFiberBatchedUpdates(_batchedUpdates){fiberBatchedUpdates=_batchedUpdates;}};var injection$4=ReactGenericBatchingInjection;/**
 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
 */var supportedInputTypes={color:true,date:true,datetime:true,'datetime-local':true,email:true,month:true,number:true,password:true,range:true,search:true,tel:true,text:true,time:true,url:true,week:true};function isTextInputElement(elem){var nodeName=elem&&elem.nodeName&&elem.nodeName.toLowerCase();if(nodeName==='input'){return!!supportedInputTypes[elem.type];}if(nodeName==='textarea'){return true;}return false;}/**
 * HTML nodeType values that represent the type of the node
 */var ELEMENT_NODE=1;var TEXT_NODE=3;var COMMENT_NODE=8;var DOCUMENT_NODE=9;var DOCUMENT_FRAGMENT_NODE=11;/**
 * Gets the target node from a native browser event by accounting for
 * inconsistencies in browser DOM APIs.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {DOMEventTarget} Target node.
 */function getEventTarget(nativeEvent){var target=nativeEvent.target||nativeEvent.srcElement||window;// Normalize SVG <use> element events #4963
if(target.correspondingUseElement){target=target.correspondingUseElement;}// Safari may fire events on text nodes (Node.TEXT_NODE is 3).
// @see http://www.quirksmode.org/js/events_properties.html
return target.nodeType===TEXT_NODE?target.parentNode:target;}var useHasFeature;if(ExecutionEnvironment.canUseDOM){useHasFeature=document.implementation&&document.implementation.hasFeature&&// always returns true in newer browsers as per the standard.
// @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
document.implementation.hasFeature('','')!==true;}/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @param {?boolean} capture Check if the capture phase is supported.
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */function isEventSupported(eventNameSuffix,capture){if(!ExecutionEnvironment.canUseDOM||capture&&!('addEventListener'in document)){return false;}var eventName='on'+eventNameSuffix;var isSupported=eventName in document;if(!isSupported){var element=document.createElement('div');element.setAttribute(eventName,'return;');isSupported=typeof element[eventName]==='function';}if(!isSupported&&useHasFeature&&eventNameSuffix==='wheel'){// This is the only way to test support for the `wheel` event in IE9+.
isSupported=document.implementation.hasFeature('Events.wheel','3.0');}return isSupported;}function isCheckable(elem){var type=elem.type;var nodeName=elem.nodeName;return nodeName&&nodeName.toLowerCase()==='input'&&(type==='checkbox'||type==='radio');}function getTracker(node){return node._valueTracker;}function detachTracker(node){node._valueTracker=null;}function getValueFromNode(node){var value='';if(!node){return value;}if(isCheckable(node)){value=node.checked?'true':'false';}else{value=node.value;}return value;}function trackValueOnNode(node){var valueField=isCheckable(node)?'checked':'value';var descriptor=Object.getOwnPropertyDescriptor(node.constructor.prototype,valueField);var currentValue=''+node[valueField];// if someone has already defined a value or Safari, then bail
// and don't track value will cause over reporting of changes,
// but it's better then a hard failure
// (needed for certain tests that spyOn input values and Safari)
if(node.hasOwnProperty(valueField)||typeof descriptor.get!=='function'||typeof descriptor.set!=='function'){return;}Object.defineProperty(node,valueField,{enumerable:descriptor.enumerable,configurable:true,get:function get(){return descriptor.get.call(this);},set:function set(value){currentValue=''+value;descriptor.set.call(this,value);}});var tracker={getValue:function getValue(){return currentValue;},setValue:function setValue(value){currentValue=''+value;},stopTracking:function stopTracking(){detachTracker(node);delete node[valueField];}};return tracker;}function track(node){if(getTracker(node)){return;}// TODO: Once it's just Fiber we can move this to node._wrapperState
node._valueTracker=trackValueOnNode(node);}function updateValueIfChanged(node){if(!node){return false;}var tracker=getTracker(node);// if there is no tracker at this point it's unlikely
// that trying again will succeed
if(!tracker){return true;}var lastValue=tracker.getValue();var nextValue=getValueFromNode(node);if(nextValue!==lastValue){tracker.setValue(nextValue);return true;}return false;}var eventTypes$1={change:{phasedRegistrationNames:{bubbled:'onChange',captured:'onChangeCapture'},dependencies:['topBlur','topChange','topClick','topFocus','topInput','topKeyDown','topKeyUp','topSelectionChange']}};function createAndAccumulateChangeEvent(inst,nativeEvent,target){var event=SyntheticEvent$1.getPooled(eventTypes$1.change,inst,nativeEvent,target);event.type='change';// Flag this event loop as needing state restore.
enqueueStateRestore(target);accumulateTwoPhaseDispatches(event);return event;}/**
 * For IE shims
 */var activeElement=null;var activeElementInst=null;/**
 * SECTION: handle `change` event
 */function shouldUseChangeEvent(elem){var nodeName=elem.nodeName&&elem.nodeName.toLowerCase();return nodeName==='select'||nodeName==='input'&&elem.type==='file';}function manualDispatchChangeEvent(nativeEvent){var event=createAndAccumulateChangeEvent(activeElementInst,nativeEvent,getEventTarget(nativeEvent));// If change and propertychange bubbled, we'd just bind to it like all the
// other events and have it go through ReactBrowserEventEmitter. Since it
// doesn't, we manually listen for the events and so we have to enqueue and
// process the abstract event manually.
//
// Batching is necessary here in order to ensure that all event handlers run
// before the next rerender (including event handlers attached to ancestor
// elements instead of directly on the input). Without this, controlled
// components don't work properly in conjunction with event bubbling because
// the component is rerendered and the value reverted before all the event
// handlers can run. See https://github.com/facebook/react/issues/708.
batchedUpdates(runEventInBatch,event);}function runEventInBatch(event){enqueueEvents(event);processEventQueue(false);}function getInstIfValueChanged(targetInst){var targetNode=getNodeFromInstance$1(targetInst);if(updateValueIfChanged(targetNode)){return targetInst;}}function getTargetInstForChangeEvent(topLevelType,targetInst){if(topLevelType==='topChange'){return targetInst;}}/**
 * SECTION: handle `input` event
 */var isInputEventSupported=false;if(ExecutionEnvironment.canUseDOM){// IE9 claims to support the input event but fails to trigger it when
// deleting text, so we ignore its input events.
isInputEventSupported=isEventSupported('input')&&(!document.documentMode||document.documentMode>9);}/**
 * (For IE <=9) Starts tracking propertychange events on the passed-in element
 * and override the value property so that we can distinguish user events from
 * value changes in JS.
 */function startWatchingForValueChange(target,targetInst){activeElement=target;activeElementInst=targetInst;activeElement.attachEvent('onpropertychange',handlePropertyChange);}/**
 * (For IE <=9) Removes the event listeners from the currently-tracked element,
 * if any exists.
 */function stopWatchingForValueChange(){if(!activeElement){return;}activeElement.detachEvent('onpropertychange',handlePropertyChange);activeElement=null;activeElementInst=null;}/**
 * (For IE <=9) Handles a propertychange event, sending a `change` event if
 * the value of the active element has changed.
 */function handlePropertyChange(nativeEvent){if(nativeEvent.propertyName!=='value'){return;}if(getInstIfValueChanged(activeElementInst)){manualDispatchChangeEvent(nativeEvent);}}function handleEventsForInputEventPolyfill(topLevelType,target,targetInst){if(topLevelType==='topFocus'){// In IE9, propertychange fires for most input events but is buggy and
// doesn't fire when text is deleted, but conveniently, selectionchange
// appears to fire in all of the remaining cases so we catch those and
// forward the event if the value has changed
// In either case, we don't want to call the event handler if the value
// is changed from JS so we redefine a setter for `.value` that updates
// our activeElementValue variable, allowing us to ignore those changes
//
// stopWatching() should be a noop here but we call it just in case we
// missed a blur event somehow.
stopWatchingForValueChange();startWatchingForValueChange(target,targetInst);}else if(topLevelType==='topBlur'){stopWatchingForValueChange();}}// For IE8 and IE9.
function getTargetInstForInputEventPolyfill(topLevelType,targetInst){if(topLevelType==='topSelectionChange'||topLevelType==='topKeyUp'||topLevelType==='topKeyDown'){// On the selectionchange event, the target is just document which isn't
// helpful for us so just check activeElement instead.
//
// 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
// propertychange on the first input event after setting `value` from a
// script and fires only keydown, keypress, keyup. Catching keyup usually
// gets it and catching keydown lets us fire an event for the first
// keystroke if user does a key repeat (it'll be a little delayed: right
// before the second keystroke). Other input methods (e.g., paste) seem to
// fire selectionchange normally.
return getInstIfValueChanged(activeElementInst);}}/**
 * SECTION: handle `click` event
 */function shouldUseClickEvent(elem){// Use the `click` event to detect changes to checkbox and radio inputs.
// This approach works across all browsers, whereas `change` does not fire
// until `blur` in IE8.
var nodeName=elem.nodeName;return nodeName&&nodeName.toLowerCase()==='input'&&(elem.type==='checkbox'||elem.type==='radio');}function getTargetInstForClickEvent(topLevelType,targetInst){if(topLevelType==='topClick'){return getInstIfValueChanged(targetInst);}}function getTargetInstForInputOrChangeEvent(topLevelType,targetInst){if(topLevelType==='topInput'||topLevelType==='topChange'){return getInstIfValueChanged(targetInst);}}function handleControlledInputBlur(inst,node){// TODO: In IE, inst is occasionally null. Why?
if(inst==null){return;}// Fiber and ReactDOM keep wrapper state in separate places
var state=inst._wrapperState||node._wrapperState;if(!state||!state.controlled||node.type!=='number'){return;}// If controlled, assign the value attribute to the current value on blur
var value=''+node.value;if(node.getAttribute('value')!==value){node.setAttribute('value',value);}}/**
 * This plugin creates an `onChange` event that normalizes change events
 * across form elements. This event fires at a time when it's possible to
 * change the element's value without seeing a flicker.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - select
 */var ChangeEventPlugin={eventTypes:eventTypes$1,_isInputEventSupported:isInputEventSupported,extractEvents:function extractEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget){var targetNode=targetInst?getNodeFromInstance$1(targetInst):window;var getTargetInstFunc,handleEventFunc;if(shouldUseChangeEvent(targetNode)){getTargetInstFunc=getTargetInstForChangeEvent;}else if(isTextInputElement(targetNode)){if(isInputEventSupported){getTargetInstFunc=getTargetInstForInputOrChangeEvent;}else{getTargetInstFunc=getTargetInstForInputEventPolyfill;handleEventFunc=handleEventsForInputEventPolyfill;}}else if(shouldUseClickEvent(targetNode)){getTargetInstFunc=getTargetInstForClickEvent;}if(getTargetInstFunc){var inst=getTargetInstFunc(topLevelType,targetInst);if(inst){var event=createAndAccumulateChangeEvent(inst,nativeEvent,nativeEventTarget);return event;}}if(handleEventFunc){handleEventFunc(topLevelType,targetNode,targetInst);}// When blurring, set the value attribute for number inputs
if(topLevelType==='topBlur'){handleControlledInputBlur(targetInst,targetNode);}}};/**
 * Module that is injectable into `EventPluginHub`, that specifies a
 * deterministic ordering of `EventPlugin`s. A convenient way to reason about
 * plugins, without having to package every one of them. This is better than
 * having plugins be ordered in the same order that they are injected because
 * that ordering would be influenced by the packaging order.
 * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that
 * preventing default on events is convenient in `SimpleEventPlugin` handlers.
 */var DOMEventPluginOrder=['ResponderEventPlugin','SimpleEventPlugin','TapEventPlugin','EnterLeaveEventPlugin','ChangeEventPlugin','SelectEventPlugin','BeforeInputEventPlugin'];/**
 * @interface UIEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var UIEventInterface={view:null,detail:null};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */function SyntheticUIEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticEvent$1.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticEvent$1.augmentClass(SyntheticUIEvent,UIEventInterface);/**
 * Translation from modifier key to the associated property in the event.
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
 */var modifierKeyToProp={Alt:'altKey',Control:'ctrlKey',Meta:'metaKey',Shift:'shiftKey'};// IE8 does not implement getModifierState so we simply map it to the only
// modifier keys exposed by the event itself, does not support Lock-keys.
// Currently, all major browsers except Chrome seems to support Lock-keys.
function modifierStateGetter(keyArg){var syntheticEvent=this;var nativeEvent=syntheticEvent.nativeEvent;if(nativeEvent.getModifierState){return nativeEvent.getModifierState(keyArg);}var keyProp=modifierKeyToProp[keyArg];return keyProp?!!nativeEvent[keyProp]:false;}function getEventModifierState(nativeEvent){return modifierStateGetter;}/**
 * @interface MouseEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var MouseEventInterface={screenX:null,screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:getEventModifierState,button:null,buttons:null,relatedTarget:function relatedTarget(event){return event.relatedTarget||(event.fromElement===event.srcElement?event.toElement:event.fromElement);}};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */function SyntheticMouseEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticUIEvent.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticUIEvent.augmentClass(SyntheticMouseEvent,MouseEventInterface);var eventTypes$2={mouseEnter:{registrationName:'onMouseEnter',dependencies:['topMouseOut','topMouseOver']},mouseLeave:{registrationName:'onMouseLeave',dependencies:['topMouseOut','topMouseOver']}};var EnterLeaveEventPlugin={eventTypes:eventTypes$2,/**
   * For almost every interaction we care about, there will be both a top-level
   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
   * we do not extract duplicate events. However, moving the mouse into the
   * browser from outside will not fire a `mouseout` event. In this case, we use
   * the `mouseover` top-level event.
   */extractEvents:function extractEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget){if(topLevelType==='topMouseOver'&&(nativeEvent.relatedTarget||nativeEvent.fromElement)){return null;}if(topLevelType!=='topMouseOut'&&topLevelType!=='topMouseOver'){// Must not be a mouse in or mouse out - ignoring.
return null;}var win;if(nativeEventTarget.window===nativeEventTarget){// `nativeEventTarget` is probably a window object.
win=nativeEventTarget;}else{// TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
var doc=nativeEventTarget.ownerDocument;if(doc){win=doc.defaultView||doc.parentWindow;}else{win=window;}}var from;var to;if(topLevelType==='topMouseOut'){from=targetInst;var related=nativeEvent.relatedTarget||nativeEvent.toElement;to=related?getClosestInstanceFromNode(related):null;}else{// Moving to a node from outside the window.
from=null;to=targetInst;}if(from===to){// Nothing pertains to our managed components.
return null;}var fromNode=from==null?win:getNodeFromInstance$1(from);var toNode=to==null?win:getNodeFromInstance$1(to);var leave=SyntheticMouseEvent.getPooled(eventTypes$2.mouseLeave,from,nativeEvent,nativeEventTarget);leave.type='mouseleave';leave.target=fromNode;leave.relatedTarget=toNode;var enter=SyntheticMouseEvent.getPooled(eventTypes$2.mouseEnter,to,nativeEvent,nativeEventTarget);enter.type='mouseenter';enter.target=toNode;enter.relatedTarget=fromNode;accumulateEnterLeaveDispatches(leave,enter,from,to);return[leave,enter];}};/**
 * `ReactInstanceMap` maintains a mapping from a public facing stateful
 * instance (key) and the internal representation (value). This allows public
 * methods to accept the user facing instance as an argument and map them back
 * to internal methods.
 *
 * Note that this module is currently shared and assumed to be stateless.
 * If this becomes an actual Map, that will break.
 *//**
 * This API should be called `delete` but we'd have to make sure to always
 * transform these to strings for IE support. When this transform is fully
 * supported we can rename it.
 */function get(key){return key._reactInternalFiber;}function has(key){return key._reactInternalFiber!==undefined;}function set(key,value){key._reactInternalFiber=value;}var ReactInternals=React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;var ReactCurrentOwner=ReactInternals.ReactCurrentOwner;var ReactDebugCurrentFrame=ReactInternals.ReactDebugCurrentFrame;function getComponentName(fiber){var type=fiber.type;if(typeof type==='string'){return type;}if(typeof type==='function'){return type.displayName||type.name;}return null;}// Don't change these two values:
var NoEffect=0;//           0b00000000
var PerformedWork=1;//      0b00000001
// You can change the rest (and add more).
var Placement=2;//          0b00000010
var Update=4;//             0b00000100
var PlacementAndUpdate=6;// 0b00000110
var Deletion=8;//           0b00001000
var ContentReset=16;//      0b00010000
var Callback=32;//          0b00100000
var Err=64;//               0b01000000
var Ref=128;//              0b10000000
var MOUNTING=1;var MOUNTED=2;var UNMOUNTED=3;function isFiberMountedImpl(fiber){var node=fiber;if(!fiber.alternate){// If there is no alternate, this might be a new tree that isn't inserted
// yet. If it is, then it will have a pending insertion effect on it.
if((node.effectTag&Placement)!==NoEffect){return MOUNTING;}while(node['return']){node=node['return'];if((node.effectTag&Placement)!==NoEffect){return MOUNTING;}}}else{while(node['return']){node=node['return'];}}if(node.tag===HostRoot){// TODO: Check if this was a nested HostRoot when used with
// renderContainerIntoSubtree.
return MOUNTED;}// If we didn't hit the root, that means that we're in an disconnected tree
// that has been unmounted.
return UNMOUNTED;}function isFiberMounted(fiber){return isFiberMountedImpl(fiber)===MOUNTED;}function isMounted(component){{var owner=ReactCurrentOwner.current;if(owner!==null&&owner.tag===ClassComponent){var ownerFiber=owner;var instance=ownerFiber.stateNode;warning(instance._warnedAboutRefsInRender,'%s is accessing isMounted inside its render() function. '+'render() should be a pure function of props and state. It should '+'never access something that requires stale data from the previous '+'render, such as refs. Move this logic to componentDidMount and '+'componentDidUpdate instead.',getComponentName(ownerFiber)||'A component');instance._warnedAboutRefsInRender=true;}}var fiber=get(component);if(!fiber){return false;}return isFiberMountedImpl(fiber)===MOUNTED;}function assertIsMounted(fiber){!(isFiberMountedImpl(fiber)===MOUNTED)?invariant(false,'Unable to find node on an unmounted component.'):void 0;}function findCurrentFiberUsingSlowPath(fiber){var alternate=fiber.alternate;if(!alternate){// If there is no alternate, then we only need to check if it is mounted.
var state=isFiberMountedImpl(fiber);!(state!==UNMOUNTED)?invariant(false,'Unable to find node on an unmounted component.'):void 0;if(state===MOUNTING){return null;}return fiber;}// If we have two possible branches, we'll walk backwards up to the root
// to see what path the root points to. On the way we may hit one of the
// special cases and we'll deal with them.
var a=fiber;var b=alternate;while(true){var parentA=a['return'];var parentB=parentA?parentA.alternate:null;if(!parentA||!parentB){// We're at the root.
break;}// If both copies of the parent fiber point to the same child, we can
// assume that the child is current. This happens when we bailout on low
// priority: the bailed out fiber's child reuses the current child.
if(parentA.child===parentB.child){var child=parentA.child;while(child){if(child===a){// We've determined that A is the current branch.
assertIsMounted(parentA);return fiber;}if(child===b){// We've determined that B is the current branch.
assertIsMounted(parentA);return alternate;}child=child.sibling;}// We should never have an alternate for any mounting node. So the only
// way this could possibly happen is if this was unmounted, if at all.
invariant(false,'Unable to find node on an unmounted component.');}if(a['return']!==b['return']){// The return pointer of A and the return pointer of B point to different
// fibers. We assume that return pointers never criss-cross, so A must
// belong to the child set of A.return, and B must belong to the child
// set of B.return.
a=parentA;b=parentB;}else{// The return pointers point to the same fiber. We'll have to use the
// default, slow path: scan the child sets of each parent alternate to see
// which child belongs to which set.
//
// Search parent A's child set
var didFindChild=false;var _child=parentA.child;while(_child){if(_child===a){didFindChild=true;a=parentA;b=parentB;break;}if(_child===b){didFindChild=true;b=parentA;a=parentB;break;}_child=_child.sibling;}if(!didFindChild){// Search parent B's child set
_child=parentB.child;while(_child){if(_child===a){didFindChild=true;a=parentB;b=parentA;break;}if(_child===b){didFindChild=true;b=parentB;a=parentA;break;}_child=_child.sibling;}!didFindChild?invariant(false,'Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.'):void 0;}}!(a.alternate===b)?invariant(false,'Return fibers should always be each others\' alternates. This error is likely caused by a bug in React. Please file an issue.'):void 0;}// If the root is not a host container, we're in a disconnected tree. I.e.
// unmounted.
!(a.tag===HostRoot)?invariant(false,'Unable to find node on an unmounted component.'):void 0;if(a.stateNode.current===a){// We've determined that A is the current branch.
return fiber;}// Otherwise B has to be current branch.
return alternate;}function findCurrentHostFiber(parent){var currentParent=findCurrentFiberUsingSlowPath(parent);if(!currentParent){return null;}// Next we'll drill down this component to find the first HostComponent/Text.
var node=currentParent;while(true){if(node.tag===HostComponent||node.tag===HostText){return node;}else if(node.child){node.child['return']=node;node=node.child;continue;}if(node===currentParent){return null;}while(!node.sibling){if(!node['return']||node['return']===currentParent){return null;}node=node['return'];}node.sibling['return']=node['return'];node=node.sibling;}// Flow needs the return null here, but ESLint complains about it.
// eslint-disable-next-line no-unreachable
return null;}function findCurrentHostFiberWithNoPortals(parent){var currentParent=findCurrentFiberUsingSlowPath(parent);if(!currentParent){return null;}// Next we'll drill down this component to find the first HostComponent/Text.
var node=currentParent;while(true){if(node.tag===HostComponent||node.tag===HostText){return node;}else if(node.child&&node.tag!==HostPortal){node.child['return']=node;node=node.child;continue;}if(node===currentParent){return null;}while(!node.sibling){if(!node['return']||node['return']===currentParent){return null;}node=node['return'];}node.sibling['return']=node['return'];node=node.sibling;}// Flow needs the return null here, but ESLint complains about it.
// eslint-disable-next-line no-unreachable
return null;}var CALLBACK_BOOKKEEPING_POOL_SIZE=10;var callbackBookkeepingPool=[];/**
 * Find the deepest React component completely containing the root of the
 * passed-in instance (for use when entire React trees are nested within each
 * other). If React trees are not nested, returns null.
 */function findRootContainerNode(inst){// TODO: It may be a good idea to cache this to prevent unnecessary DOM
// traversal, but caching is difficult to do correctly without using a
// mutation observer to listen for all DOM changes.
while(inst['return']){inst=inst['return'];}if(inst.tag!==HostRoot){// This can happen if we're in a detached tree.
return null;}return inst.stateNode.containerInfo;}// Used to store ancestor hierarchy in top level callback
function getTopLevelCallbackBookKeeping(topLevelType,nativeEvent,targetInst){if(callbackBookkeepingPool.length){var instance=callbackBookkeepingPool.pop();instance.topLevelType=topLevelType;instance.nativeEvent=nativeEvent;instance.targetInst=targetInst;return instance;}return{topLevelType:topLevelType,nativeEvent:nativeEvent,targetInst:targetInst,ancestors:[]};}function releaseTopLevelCallbackBookKeeping(instance){instance.topLevelType=null;instance.nativeEvent=null;instance.targetInst=null;instance.ancestors.length=0;if(callbackBookkeepingPool.length<CALLBACK_BOOKKEEPING_POOL_SIZE){callbackBookkeepingPool.push(instance);}}function handleTopLevelImpl(bookKeeping){var targetInst=bookKeeping.targetInst;// Loop through the hierarchy, in case there's any nested components.
// It's important that we build the array of ancestors before calling any
// event handlers, because event handlers can modify the DOM, leading to
// inconsistencies with ReactMount's node cache. See #1105.
var ancestor=targetInst;do{if(!ancestor){bookKeeping.ancestors.push(ancestor);break;}var root=findRootContainerNode(ancestor);if(!root){break;}bookKeeping.ancestors.push(ancestor);ancestor=getClosestInstanceFromNode(root);}while(ancestor);for(var i=0;i<bookKeeping.ancestors.length;i++){targetInst=bookKeeping.ancestors[i];_handleTopLevel(bookKeeping.topLevelType,targetInst,bookKeeping.nativeEvent,getEventTarget(bookKeeping.nativeEvent));}}// TODO: can we stop exporting these?
var _enabled=true;var _handleTopLevel=void 0;function setHandleTopLevel(handleTopLevel){_handleTopLevel=handleTopLevel;}function setEnabled(enabled){_enabled=!!enabled;}function isEnabled(){return _enabled;}/**
 * Traps top-level events by using event bubbling.
 *
 * @param {string} topLevelType Record from `BrowserEventConstants`.
 * @param {string} handlerBaseName Event name (e.g. "click").
 * @param {object} element Element on which to attach listener.
 * @return {?object} An object with a remove function which will forcefully
 *                  remove the listener.
 * @internal
 */function trapBubbledEvent(topLevelType,handlerBaseName,element){if(!element){return null;}return EventListener.listen(element,handlerBaseName,dispatchEvent.bind(null,topLevelType));}/**
 * Traps a top-level event by using event capturing.
 *
 * @param {string} topLevelType Record from `BrowserEventConstants`.
 * @param {string} handlerBaseName Event name (e.g. "click").
 * @param {object} element Element on which to attach listener.
 * @return {?object} An object with a remove function which will forcefully
 *                  remove the listener.
 * @internal
 */function trapCapturedEvent(topLevelType,handlerBaseName,element){if(!element){return null;}return EventListener.capture(element,handlerBaseName,dispatchEvent.bind(null,topLevelType));}function dispatchEvent(topLevelType,nativeEvent){if(!_enabled){return;}var nativeEventTarget=getEventTarget(nativeEvent);var targetInst=getClosestInstanceFromNode(nativeEventTarget);if(targetInst!==null&&typeof targetInst.tag==='number'&&!isFiberMounted(targetInst)){// If we get an event (ex: img onload) before committing that
// component's mount, ignore it for now (that is, treat it as if it was an
// event on a non-React tree). We might also consider queueing events and
// dispatching them after the mount.
targetInst=null;}var bookKeeping=getTopLevelCallbackBookKeeping(topLevelType,nativeEvent,targetInst);try{// Event queue being processed in the same cycle allows
// `preventDefault`.
batchedUpdates(handleTopLevelImpl,bookKeeping);}finally{releaseTopLevelCallbackBookKeeping(bookKeeping);}}var ReactDOMEventListener=Object.freeze({get _enabled(){return _enabled;},get _handleTopLevel(){return _handleTopLevel;},setHandleTopLevel:setHandleTopLevel,setEnabled:setEnabled,isEnabled:isEnabled,trapBubbledEvent:trapBubbledEvent,trapCapturedEvent:trapCapturedEvent,dispatchEvent:dispatchEvent});/**
 * Generate a mapping of standard vendor prefixes using the defined style property and event name.
 *
 * @param {string} styleProp
 * @param {string} eventName
 * @returns {object}
 */function makePrefixMap(styleProp,eventName){var prefixes={};prefixes[styleProp.toLowerCase()]=eventName.toLowerCase();prefixes['Webkit'+styleProp]='webkit'+eventName;prefixes['Moz'+styleProp]='moz'+eventName;prefixes['ms'+styleProp]='MS'+eventName;prefixes['O'+styleProp]='o'+eventName.toLowerCase();return prefixes;}/**
 * A list of event names to a configurable list of vendor prefixes.
 */var vendorPrefixes={animationend:makePrefixMap('Animation','AnimationEnd'),animationiteration:makePrefixMap('Animation','AnimationIteration'),animationstart:makePrefixMap('Animation','AnimationStart'),transitionend:makePrefixMap('Transition','TransitionEnd')};/**
 * Event names that have already been detected and prefixed (if applicable).
 */var prefixedEventNames={};/**
 * Element to check for prefixes on.
 */var style={};/**
 * Bootstrap if a DOM exists.
 */if(ExecutionEnvironment.canUseDOM){style=document.createElement('div').style;// On some platforms, in particular some releases of Android 4.x,
// the un-prefixed "animation" and "transition" properties are defined on the
// style object but the events that fire will still be prefixed, so we need
// to check if the un-prefixed events are usable, and if not remove them from the map.
if(!('AnimationEvent'in window)){delete vendorPrefixes.animationend.animation;delete vendorPrefixes.animationiteration.animation;delete vendorPrefixes.animationstart.animation;}// Same as above
if(!('TransitionEvent'in window)){delete vendorPrefixes.transitionend.transition;}}/**
 * Attempts to determine the correct vendor prefixed event name.
 *
 * @param {string} eventName
 * @returns {string}
 */function getVendorPrefixedEventName(eventName){if(prefixedEventNames[eventName]){return prefixedEventNames[eventName];}else if(!vendorPrefixes[eventName]){return eventName;}var prefixMap=vendorPrefixes[eventName];for(var styleProp in prefixMap){if(prefixMap.hasOwnProperty(styleProp)&&styleProp in style){return prefixedEventNames[eventName]=prefixMap[styleProp];}}return'';}/**
 * Types of raw signals from the browser caught at the top level.
 *
 * For events like 'submit' which don't consistently bubble (which we
 * trap at a lower node than `document`), binding at `document` would
 * cause duplicate events so we don't include them here.
 */var topLevelTypes$1={topAbort:'abort',topAnimationEnd:getVendorPrefixedEventName('animationend')||'animationend',topAnimationIteration:getVendorPrefixedEventName('animationiteration')||'animationiteration',topAnimationStart:getVendorPrefixedEventName('animationstart')||'animationstart',topBlur:'blur',topCancel:'cancel',topCanPlay:'canplay',topCanPlayThrough:'canplaythrough',topChange:'change',topClick:'click',topClose:'close',topCompositionEnd:'compositionend',topCompositionStart:'compositionstart',topCompositionUpdate:'compositionupdate',topContextMenu:'contextmenu',topCopy:'copy',topCut:'cut',topDoubleClick:'dblclick',topDrag:'drag',topDragEnd:'dragend',topDragEnter:'dragenter',topDragExit:'dragexit',topDragLeave:'dragleave',topDragOver:'dragover',topDragStart:'dragstart',topDrop:'drop',topDurationChange:'durationchange',topEmptied:'emptied',topEncrypted:'encrypted',topEnded:'ended',topError:'error',topFocus:'focus',topInput:'input',topKeyDown:'keydown',topKeyPress:'keypress',topKeyUp:'keyup',topLoadedData:'loadeddata',topLoad:'load',topLoadedMetadata:'loadedmetadata',topLoadStart:'loadstart',topMouseDown:'mousedown',topMouseMove:'mousemove',topMouseOut:'mouseout',topMouseOver:'mouseover',topMouseUp:'mouseup',topPaste:'paste',topPause:'pause',topPlay:'play',topPlaying:'playing',topProgress:'progress',topRateChange:'ratechange',topScroll:'scroll',topSeeked:'seeked',topSeeking:'seeking',topSelectionChange:'selectionchange',topStalled:'stalled',topSuspend:'suspend',topTextInput:'textInput',topTimeUpdate:'timeupdate',topToggle:'toggle',topTouchCancel:'touchcancel',topTouchEnd:'touchend',topTouchMove:'touchmove',topTouchStart:'touchstart',topTransitionEnd:getVendorPrefixedEventName('transitionend')||'transitionend',topVolumeChange:'volumechange',topWaiting:'waiting',topWheel:'wheel'};var BrowserEventConstants={topLevelTypes:topLevelTypes$1};function runEventQueueInBatch(events){enqueueEvents(events);processEventQueue(false);}/**
 * Streams a fired top-level event to `EventPluginHub` where plugins have the
 * opportunity to create `ReactEvent`s to be dispatched.
 */function handleTopLevel(topLevelType,targetInst,nativeEvent,nativeEventTarget){var events=extractEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget);runEventQueueInBatch(events);}var topLevelTypes=BrowserEventConstants.topLevelTypes;/**
 * Summary of `ReactBrowserEventEmitter` event handling:
 *
 *  - Top-level delegation is used to trap most native browser events. This
 *    may only occur in the main thread and is the responsibility of
 *    ReactDOMEventListener, which is injected and can therefore support
 *    pluggable event sources. This is the only work that occurs in the main
 *    thread.
 *
 *  - We normalize and de-duplicate events to account for browser quirks. This
 *    may be done in the worker thread.
 *
 *  - Forward these native events (with the associated top-level type used to
 *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want
 *    to extract any synthetic events.
 *
 *  - The `EventPluginHub` will then process each event by annotating them with
 *    "dispatches", a sequence of listeners and IDs that care about that event.
 *
 *  - The `EventPluginHub` then dispatches the events.
 *
 * Overview of React and the event system:
 *
 * +------------+    .
 * |    DOM     |    .
 * +------------+    .
 *       |           .
 *       v           .
 * +------------+    .
 * | ReactEvent |    .
 * |  Listener  |    .
 * +------------+    .                         +-----------+
 *       |           .               +--------+|SimpleEvent|
 *       |           .               |         |Plugin     |
 * +-----|------+    .               v         +-----------+
 * |     |      |    .    +--------------+                    +------------+
 * |     +-----------.--->|EventPluginHub|                    |    Event   |
 * |            |    .    |              |     +-----------+  | Propagators|
 * | ReactEvent |    .    |              |     |TapEvent   |  |------------|
 * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|
 * |            |    .    |              |     +-----------+  |  utilities |
 * |     +-----------.--->|              |                    +------------+
 * |     |      |    .    +--------------+
 * +-----|------+    .                ^        +-----------+
 *       |           .                |        |Enter/Leave|
 *       +           .                +-------+|Plugin     |
 * +-------------+   .                         +-----------+
 * | application |   .
 * |-------------|   .
 * |             |   .
 * |             |   .
 * +-------------+   .
 *                   .
 *    React Core     .  General Purpose Event Plugin System
 */var alreadyListeningTo={};var reactTopListenersCounter=0;/**
 * To ensure no conflicts with other potential React instances on the page
 */var topListenersIDKey='_reactListenersID'+(''+Math.random()).slice(2);function getListeningForDocument(mountAt){// In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`
// directly.
if(!Object.prototype.hasOwnProperty.call(mountAt,topListenersIDKey)){mountAt[topListenersIDKey]=reactTopListenersCounter++;alreadyListeningTo[mountAt[topListenersIDKey]]={};}return alreadyListeningTo[mountAt[topListenersIDKey]];}/**
 * We listen for bubbled touch events on the document object.
 *
 * Firefox v8.01 (and possibly others) exhibited strange behavior when
 * mounting `onmousemove` events at some node that was not the document
 * element. The symptoms were that if your mouse is not moving over something
 * contained within that mount point (for example on the background) the
 * top-level listeners for `onmousemove` won't be called. However, if you
 * register the `mousemove` on the document object, then it will of course
 * catch all `mousemove`s. This along with iOS quirks, justifies restricting
 * top-level listeners to the document object only, at least for these
 * movement types of events and possibly all events.
 *
 * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
 *
 * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but
 * they bubble to document.
 *
 * @param {string} registrationName Name of listener (e.g. `onClick`).
 * @param {object} contentDocumentHandle Document which owns the container
 */function listenTo(registrationName,contentDocumentHandle){var mountAt=contentDocumentHandle;var isListening=getListeningForDocument(mountAt);var dependencies=registrationNameDependencies[registrationName];for(var i=0;i<dependencies.length;i++){var dependency=dependencies[i];if(!(isListening.hasOwnProperty(dependency)&&isListening[dependency])){if(dependency==='topScroll'){trapCapturedEvent('topScroll','scroll',mountAt);}else if(dependency==='topFocus'||dependency==='topBlur'){trapCapturedEvent('topFocus','focus',mountAt);trapCapturedEvent('topBlur','blur',mountAt);// to make sure blur and focus event listeners are only attached once
isListening.topBlur=true;isListening.topFocus=true;}else if(dependency==='topCancel'){if(isEventSupported('cancel',true)){trapCapturedEvent('topCancel','cancel',mountAt);}isListening.topCancel=true;}else if(dependency==='topClose'){if(isEventSupported('close',true)){trapCapturedEvent('topClose','close',mountAt);}isListening.topClose=true;}else if(topLevelTypes.hasOwnProperty(dependency)){trapBubbledEvent(dependency,topLevelTypes[dependency],mountAt);}isListening[dependency]=true;}}}function isListeningToAllDependencies(registrationName,mountAt){var isListening=getListeningForDocument(mountAt);var dependencies=registrationNameDependencies[registrationName];for(var i=0;i<dependencies.length;i++){var dependency=dependencies[i];if(!(isListening.hasOwnProperty(dependency)&&isListening[dependency])){return false;}}return true;}/**
 * Given any node return the first leaf node without children.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {DOMElement|DOMTextNode}
 */function getLeafNode(node){while(node&&node.firstChild){node=node.firstChild;}return node;}/**
 * Get the next sibling within a container. This will walk up the
 * DOM if a node's siblings have been exhausted.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {?DOMElement|DOMTextNode}
 */function getSiblingNode(node){while(node){if(node.nextSibling){return node.nextSibling;}node=node.parentNode;}}/**
 * Get object describing the nodes which contain characters at offset.
 *
 * @param {DOMElement|DOMTextNode} root
 * @param {number} offset
 * @return {?object}
 */function getNodeForCharacterOffset(root,offset){var node=getLeafNode(root);var nodeStart=0;var nodeEnd=0;while(node){if(node.nodeType===TEXT_NODE){nodeEnd=nodeStart+node.textContent.length;if(nodeStart<=offset&&nodeEnd>=offset){return{node:node,offset:offset-nodeStart};}nodeStart=nodeEnd;}node=getLeafNode(getSiblingNode(node));}}/**
 * @param {DOMElement} outerNode
 * @return {?object}
 */function getOffsets(outerNode){var selection=window.getSelection&&window.getSelection();if(!selection||selection.rangeCount===0){return null;}var anchorNode=selection.anchorNode,anchorOffset=selection.anchorOffset,focusNode$$1=selection.focusNode,focusOffset=selection.focusOffset;// In Firefox, anchorNode and focusNode can be "anonymous divs", e.g. the
// up/down buttons on an <input type="number">. Anonymous divs do not seem to
// expose properties, triggering a "Permission denied error" if any of its
// properties are accessed. The only seemingly possible way to avoid erroring
// is to access a property that typically works for non-anonymous divs and
// catch any error that may otherwise arise. See
// https://bugzilla.mozilla.org/show_bug.cgi?id=208427
try{/* eslint-disable no-unused-expressions */anchorNode.nodeType;focusNode$$1.nodeType;/* eslint-enable no-unused-expressions */}catch(e){return null;}return getModernOffsetsFromPoints(outerNode,anchorNode,anchorOffset,focusNode$$1,focusOffset);}/**
 * Returns {start, end} where `start` is the character/codepoint index of
 * (anchorNode, anchorOffset) within the textContent of `outerNode`, and
 * `end` is the index of (focusNode, focusOffset).
 *
 * Returns null if you pass in garbage input but we should probably just crash.
 *
 * Exported only for testing.
 */function getModernOffsetsFromPoints(outerNode,anchorNode,anchorOffset,focusNode$$1,focusOffset){var length=0;var start=-1;var end=-1;var indexWithinAnchor=0;var indexWithinFocus=0;var node=outerNode;var parentNode=null;outer:while(true){var next=null;while(true){if(node===anchorNode&&(anchorOffset===0||node.nodeType===TEXT_NODE)){start=length+anchorOffset;}if(node===focusNode$$1&&(focusOffset===0||node.nodeType===TEXT_NODE)){end=length+focusOffset;}if(node.nodeType===TEXT_NODE){length+=node.nodeValue.length;}if((next=node.firstChild)===null){break;}// Moving from `node` to its first child `next`.
parentNode=node;node=next;}while(true){if(node===outerNode){// If `outerNode` has children, this is always the second time visiting
// it. If it has no children, this is still the first loop, and the only
// valid selection is anchorNode and focusNode both equal to this node
// and both offsets 0, in which case we will have handled above.
break outer;}if(parentNode===anchorNode&&++indexWithinAnchor===anchorOffset){start=length;}if(parentNode===focusNode$$1&&++indexWithinFocus===focusOffset){end=length;}if((next=node.nextSibling)!==null){break;}node=parentNode;parentNode=node.parentNode;}// Moving from `node` to its next sibling `next`.
node=next;}if(start===-1||end===-1){// This should never happen. (Would happen if the anchor/focus nodes aren't
// actually inside the passed-in node.)
return null;}return{start:start,end:end};}/**
 * In modern non-IE browsers, we can support both forward and backward
 * selections.
 *
 * Note: IE10+ supports the Selection object, but it does not support
 * the `extend` method, which means that even in modern IE, it's not possible
 * to programmatically create a backward selection. Thus, for all IE
 * versions, we use the old IE API to create our selections.
 *
 * @param {DOMElement|DOMTextNode} node
 * @param {object} offsets
 */function setOffsets(node,offsets){if(!window.getSelection){return;}var selection=window.getSelection();var length=node[getTextContentAccessor()].length;var start=Math.min(offsets.start,length);var end=offsets.end===undefined?start:Math.min(offsets.end,length);// IE 11 uses modern selection, but doesn't support the extend method.
// Flip backward selections, so we can set with a single range.
if(!selection.extend&&start>end){var temp=end;end=start;start=temp;}var startMarker=getNodeForCharacterOffset(node,start);var endMarker=getNodeForCharacterOffset(node,end);if(startMarker&&endMarker){if(selection.rangeCount===1&&selection.anchorNode===startMarker.node&&selection.anchorOffset===startMarker.offset&&selection.focusNode===endMarker.node&&selection.focusOffset===endMarker.offset){return;}var range=document.createRange();range.setStart(startMarker.node,startMarker.offset);selection.removeAllRanges();if(start>end){selection.addRange(range);selection.extend(endMarker.node,endMarker.offset);}else{range.setEnd(endMarker.node,endMarker.offset);selection.addRange(range);}}}function isInDocument(node){return containsNode(document.documentElement,node);}/**
 * @ReactInputSelection: React input selection module. Based on Selection.js,
 * but modified to be suitable for react and has a couple of bug fixes (doesn't
 * assume buttons have range selections allowed).
 * Input selection module for React.
 */function hasSelectionCapabilities(elem){var nodeName=elem&&elem.nodeName&&elem.nodeName.toLowerCase();return nodeName&&(nodeName==='input'&&elem.type==='text'||nodeName==='textarea'||elem.contentEditable==='true');}function getSelectionInformation(){var focusedElem=getActiveElement();return{focusedElem:focusedElem,selectionRange:hasSelectionCapabilities(focusedElem)?getSelection$1(focusedElem):null};}/**
 * @restoreSelection: If any selection information was potentially lost,
 * restore it. This is useful when performing operations that could remove dom
 * nodes and place them back in, resulting in focus being lost.
 */function restoreSelection(priorSelectionInformation){var curFocusedElem=getActiveElement();var priorFocusedElem=priorSelectionInformation.focusedElem;var priorSelectionRange=priorSelectionInformation.selectionRange;if(curFocusedElem!==priorFocusedElem&&isInDocument(priorFocusedElem)){if(hasSelectionCapabilities(priorFocusedElem)){setSelection(priorFocusedElem,priorSelectionRange);}// Focusing a node can change the scroll position, which is undesirable
var ancestors=[];var ancestor=priorFocusedElem;while(ancestor=ancestor.parentNode){if(ancestor.nodeType===ELEMENT_NODE){ancestors.push({element:ancestor,left:ancestor.scrollLeft,top:ancestor.scrollTop});}}focusNode(priorFocusedElem);for(var i=0;i<ancestors.length;i++){var info=ancestors[i];info.element.scrollLeft=info.left;info.element.scrollTop=info.top;}}}/**
 * @getSelection: Gets the selection bounds of a focused textarea, input or
 * contentEditable node.
 * -@input: Look up selection bounds of this input
 * -@return {start: selectionStart, end: selectionEnd}
 */function getSelection$1(input){var selection=void 0;if('selectionStart'in input){// Modern browser with input or textarea.
selection={start:input.selectionStart,end:input.selectionEnd};}else{// Content editable or old IE textarea.
selection=getOffsets(input);}return selection||{start:0,end:0};}/**
 * @setSelection: Sets the selection bounds of a textarea or input and focuses
 * the input.
 * -@input     Set selection bounds of this input or textarea
 * -@offsets   Object of same form that is returned from get*
 */function setSelection(input,offsets){var start=offsets.start,end=offsets.end;if(end===undefined){end=start;}if('selectionStart'in input){input.selectionStart=start;input.selectionEnd=Math.min(end,input.value.length);}else{setOffsets(input,offsets);}}var skipSelectionChangeEvent=ExecutionEnvironment.canUseDOM&&'documentMode'in document&&document.documentMode<=11;var eventTypes$3={select:{phasedRegistrationNames:{bubbled:'onSelect',captured:'onSelectCapture'},dependencies:['topBlur','topContextMenu','topFocus','topKeyDown','topKeyUp','topMouseDown','topMouseUp','topSelectionChange']}};var activeElement$1=null;var activeElementInst$1=null;var lastSelection=null;var mouseDown=false;/**
 * Get an object which is a unique representation of the current selection.
 *
 * The return value will not be consistent across nodes or browsers, but
 * two identical selections on the same node will return identical objects.
 *
 * @param {DOMElement} node
 * @return {object}
 */function getSelection(node){if('selectionStart'in node&&hasSelectionCapabilities(node)){return{start:node.selectionStart,end:node.selectionEnd};}else if(window.getSelection){var selection=window.getSelection();return{anchorNode:selection.anchorNode,anchorOffset:selection.anchorOffset,focusNode:selection.focusNode,focusOffset:selection.focusOffset};}}/**
 * Poll selection to see whether it's changed.
 *
 * @param {object} nativeEvent
 * @return {?SyntheticEvent}
 */function constructSelectEvent(nativeEvent,nativeEventTarget){// Ensure we have the right element, and that the user is not dragging a
// selection (this matches native `select` event behavior). In HTML5, select
// fires only on input and textarea thus if there's no focused element we
// won't dispatch.
if(mouseDown||activeElement$1==null||activeElement$1!==getActiveElement()){return null;}// Only fire when selection has actually changed.
var currentSelection=getSelection(activeElement$1);if(!lastSelection||!shallowEqual(lastSelection,currentSelection)){lastSelection=currentSelection;var syntheticEvent=SyntheticEvent$1.getPooled(eventTypes$3.select,activeElementInst$1,nativeEvent,nativeEventTarget);syntheticEvent.type='select';syntheticEvent.target=activeElement$1;accumulateTwoPhaseDispatches(syntheticEvent);return syntheticEvent;}return null;}/**
 * This plugin creates an `onSelect` event that normalizes select events
 * across form elements.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - contentEditable
 *
 * This differs from native browser implementations in the following ways:
 * - Fires on contentEditable fields as well as inputs.
 * - Fires for collapsed selection.
 * - Fires after user input.
 */var SelectEventPlugin={eventTypes:eventTypes$3,extractEvents:function extractEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget){var doc=nativeEventTarget.window===nativeEventTarget?nativeEventTarget.document:nativeEventTarget.nodeType===DOCUMENT_NODE?nativeEventTarget:nativeEventTarget.ownerDocument;// Track whether all listeners exists for this plugin. If none exist, we do
// not extract events. See #3639.
if(!doc||!isListeningToAllDependencies('onSelect',doc)){return null;}var targetNode=targetInst?getNodeFromInstance$1(targetInst):window;switch(topLevelType){// Track the input node that has focus.
case'topFocus':if(isTextInputElement(targetNode)||targetNode.contentEditable==='true'){activeElement$1=targetNode;activeElementInst$1=targetInst;lastSelection=null;}break;case'topBlur':activeElement$1=null;activeElementInst$1=null;lastSelection=null;break;// Don't fire the event while the user is dragging. This matches the
// semantics of the native select event.
case'topMouseDown':mouseDown=true;break;case'topContextMenu':case'topMouseUp':mouseDown=false;return constructSelectEvent(nativeEvent,nativeEventTarget);// Chrome and IE fire non-standard event when selection is changed (and
// sometimes when it hasn't). IE's event fires out of order with respect
// to key and input events on deletion, so we discard it.
//
// Firefox doesn't support selectionchange, so check selection status
// after each key entry. The selection changes after keydown and before
// keyup, but we check on keydown as well in the case of holding down a
// key, when multiple keydown events are fired but only one keyup is.
// This is also our approach for IE handling, for the reason above.
case'topSelectionChange':if(skipSelectionChangeEvent){break;}// falls through
case'topKeyDown':case'topKeyUp':return constructSelectEvent(nativeEvent,nativeEventTarget);}return null;}};/**
 * @interface Event
 * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface
 * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent
 */var AnimationEventInterface={animationName:null,elapsedTime:null,pseudoElement:null};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */function SyntheticAnimationEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticEvent$1.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticEvent$1.augmentClass(SyntheticAnimationEvent,AnimationEventInterface);/**
 * @interface Event
 * @see http://www.w3.org/TR/clipboard-apis/
 */var ClipboardEventInterface={clipboardData:function clipboardData(event){return'clipboardData'in event?event.clipboardData:window.clipboardData;}};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */function SyntheticClipboardEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticEvent$1.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticEvent$1.augmentClass(SyntheticClipboardEvent,ClipboardEventInterface);/**
 * @interface FocusEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var FocusEventInterface={relatedTarget:null};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */function SyntheticFocusEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticUIEvent.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticUIEvent.augmentClass(SyntheticFocusEvent,FocusEventInterface);/**
 * `charCode` represents the actual "character code" and is safe to use with
 * `String.fromCharCode`. As such, only keys that correspond to printable
 * characters produce a valid `charCode`, the only exception to this is Enter.
 * The Tab-key is considered non-printable and does not have a `charCode`,
 * presumably because it does not produce a tab-character in browsers.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {number} Normalized `charCode` property.
 */function getEventCharCode(nativeEvent){var charCode;var keyCode=nativeEvent.keyCode;if('charCode'in nativeEvent){charCode=nativeEvent.charCode;// FF does not set `charCode` for the Enter-key, check against `keyCode`.
if(charCode===0&&keyCode===13){charCode=13;}}else{// IE8 does not implement `charCode`, but `keyCode` has the correct value.
charCode=keyCode;}// Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
// Must not discard the (non-)printable Enter-key.
if(charCode>=32||charCode===13){return charCode;}return 0;}/**
 * Normalization of deprecated HTML5 `key` values
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */var normalizeKey={Esc:'Escape',Spacebar:' ',Left:'ArrowLeft',Up:'ArrowUp',Right:'ArrowRight',Down:'ArrowDown',Del:'Delete',Win:'OS',Menu:'ContextMenu',Apps:'ContextMenu',Scroll:'ScrollLock',MozPrintableKey:'Unidentified'};/**
 * Translation from legacy `keyCode` to HTML5 `key`
 * Only special keys supported, all others depend on keyboard layout or browser
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */var translateToKey={'8':'Backspace','9':'Tab','12':'Clear','13':'Enter','16':'Shift','17':'Control','18':'Alt','19':'Pause','20':'CapsLock','27':'Escape','32':' ','33':'PageUp','34':'PageDown','35':'End','36':'Home','37':'ArrowLeft','38':'ArrowUp','39':'ArrowRight','40':'ArrowDown','45':'Insert','46':'Delete','112':'F1','113':'F2','114':'F3','115':'F4','116':'F5','117':'F6','118':'F7','119':'F8','120':'F9','121':'F10','122':'F11','123':'F12','144':'NumLock','145':'ScrollLock','224':'Meta'};/**
 * @param {object} nativeEvent Native browser event.
 * @return {string} Normalized `key` property.
 */function getEventKey(nativeEvent){if(nativeEvent.key){// Normalize inconsistent values reported by browsers due to
// implementations of a working draft specification.
// FireFox implements `key` but returns `MozPrintableKey` for all
// printable characters (normalized to `Unidentified`), ignore it.
var key=normalizeKey[nativeEvent.key]||nativeEvent.key;if(key!=='Unidentified'){return key;}}// Browser does not implement `key`, polyfill as much of it as we can.
if(nativeEvent.type==='keypress'){var charCode=getEventCharCode(nativeEvent);// The enter-key is technically both printable and non-printable and can
// thus be captured by `keypress`, no other non-printable key should.
return charCode===13?'Enter':String.fromCharCode(charCode);}if(nativeEvent.type==='keydown'||nativeEvent.type==='keyup'){// While user keyboard layout determines the actual meaning of each
// `keyCode` value, almost all function keys have a universal value.
return translateToKey[nativeEvent.keyCode]||'Unidentified';}return'';}/**
 * @interface KeyboardEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var KeyboardEventInterface={key:getEventKey,location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:getEventModifierState,// Legacy Interface
charCode:function charCode(event){// `charCode` is the result of a KeyPress event and represents the value of
// the actual printable character.
// KeyPress is deprecated, but its replacement is not yet final and not
// implemented in any major browser. Only KeyPress has charCode.
if(event.type==='keypress'){return getEventCharCode(event);}return 0;},keyCode:function keyCode(event){// `keyCode` is the result of a KeyDown/Up event and represents the value of
// physical keyboard key.
// The actual meaning of the value depends on the users' keyboard layout
// which cannot be detected. Assuming that it is a US keyboard layout
// provides a surprisingly accurate mapping for US and European users.
// Due to this, it is left to the user to implement at this time.
if(event.type==='keydown'||event.type==='keyup'){return event.keyCode;}return 0;},which:function which(event){// `which` is an alias for either `keyCode` or `charCode` depending on the
// type of the event.
if(event.type==='keypress'){return getEventCharCode(event);}if(event.type==='keydown'||event.type==='keyup'){return event.keyCode;}return 0;}};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */function SyntheticKeyboardEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticUIEvent.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent,KeyboardEventInterface);/**
 * @interface DragEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var DragEventInterface={dataTransfer:null};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticMouseEvent}
 */function SyntheticDragEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticMouseEvent.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticMouseEvent.augmentClass(SyntheticDragEvent,DragEventInterface);/**
 * @interface TouchEvent
 * @see http://www.w3.org/TR/touch-events/
 */var TouchEventInterface={touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:getEventModifierState};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */function SyntheticTouchEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticUIEvent.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticUIEvent.augmentClass(SyntheticTouchEvent,TouchEventInterface);/**
 * @interface Event
 * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-
 * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent
 */var TransitionEventInterface={propertyName:null,elapsedTime:null,pseudoElement:null};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */function SyntheticTransitionEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticEvent$1.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticEvent$1.augmentClass(SyntheticTransitionEvent,TransitionEventInterface);/**
 * @interface WheelEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var WheelEventInterface={deltaX:function deltaX(event){return'deltaX'in event?event.deltaX:// Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
'wheelDeltaX'in event?-event.wheelDeltaX:0;},deltaY:function deltaY(event){return'deltaY'in event?event.deltaY:// Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
'wheelDeltaY'in event?-event.wheelDeltaY:// Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
'wheelDelta'in event?-event.wheelDelta:0;},deltaZ:null,// Browsers without "deltaMode" is reporting in raw wheel delta where one
// notch on the scroll is always +/- 120, roughly equivalent to pixels.
// A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
// ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
deltaMode:null};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticMouseEvent}
 */function SyntheticWheelEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticMouseEvent.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticMouseEvent.augmentClass(SyntheticWheelEvent,WheelEventInterface);/**
 * Turns
 * ['abort', ...]
 * into
 * eventTypes = {
 *   'abort': {
 *     phasedRegistrationNames: {
 *       bubbled: 'onAbort',
 *       captured: 'onAbortCapture',
 *     },
 *     dependencies: ['topAbort'],
 *   },
 *   ...
 * };
 * topLevelEventsToDispatchConfig = {
 *   'topAbort': { sameConfig }
 * };
 */var eventTypes$4={};var topLevelEventsToDispatchConfig={};['abort','animationEnd','animationIteration','animationStart','blur','cancel','canPlay','canPlayThrough','click','close','contextMenu','copy','cut','doubleClick','drag','dragEnd','dragEnter','dragExit','dragLeave','dragOver','dragStart','drop','durationChange','emptied','encrypted','ended','error','focus','input','invalid','keyDown','keyPress','keyUp','load','loadedData','loadedMetadata','loadStart','mouseDown','mouseMove','mouseOut','mouseOver','mouseUp','paste','pause','play','playing','progress','rateChange','reset','scroll','seeked','seeking','stalled','submit','suspend','timeUpdate','toggle','touchCancel','touchEnd','touchMove','touchStart','transitionEnd','volumeChange','waiting','wheel'].forEach(function(event){var capitalizedEvent=event[0].toUpperCase()+event.slice(1);var onEvent='on'+capitalizedEvent;var topEvent='top'+capitalizedEvent;var type={phasedRegistrationNames:{bubbled:onEvent,captured:onEvent+'Capture'},dependencies:[topEvent]};eventTypes$4[event]=type;topLevelEventsToDispatchConfig[topEvent]=type;});// Only used in DEV for exhaustiveness validation.
var knownHTMLTopLevelTypes=['topAbort','topCancel','topCanPlay','topCanPlayThrough','topClose','topDurationChange','topEmptied','topEncrypted','topEnded','topError','topInput','topInvalid','topLoad','topLoadedData','topLoadedMetadata','topLoadStart','topPause','topPlay','topPlaying','topProgress','topRateChange','topReset','topSeeked','topSeeking','topStalled','topSubmit','topSuspend','topTimeUpdate','topToggle','topVolumeChange','topWaiting'];var SimpleEventPlugin={eventTypes:eventTypes$4,extractEvents:function extractEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget){var dispatchConfig=topLevelEventsToDispatchConfig[topLevelType];if(!dispatchConfig){return null;}var EventConstructor;switch(topLevelType){case'topKeyPress':// Firefox creates a keypress event for function keys too. This removes
// the unwanted keypress events. Enter is however both printable and
// non-printable. One would expect Tab to be as well (but it isn't).
if(getEventCharCode(nativeEvent)===0){return null;}/* falls through */case'topKeyDown':case'topKeyUp':EventConstructor=SyntheticKeyboardEvent;break;case'topBlur':case'topFocus':EventConstructor=SyntheticFocusEvent;break;case'topClick':// Firefox creates a click event on right mouse clicks. This removes the
// unwanted click events.
if(nativeEvent.button===2){return null;}/* falls through */case'topDoubleClick':case'topMouseDown':case'topMouseMove':case'topMouseUp':// TODO: Disabled elements should not respond to mouse events
/* falls through */case'topMouseOut':case'topMouseOver':case'topContextMenu':EventConstructor=SyntheticMouseEvent;break;case'topDrag':case'topDragEnd':case'topDragEnter':case'topDragExit':case'topDragLeave':case'topDragOver':case'topDragStart':case'topDrop':EventConstructor=SyntheticDragEvent;break;case'topTouchCancel':case'topTouchEnd':case'topTouchMove':case'topTouchStart':EventConstructor=SyntheticTouchEvent;break;case'topAnimationEnd':case'topAnimationIteration':case'topAnimationStart':EventConstructor=SyntheticAnimationEvent;break;case'topTransitionEnd':EventConstructor=SyntheticTransitionEvent;break;case'topScroll':EventConstructor=SyntheticUIEvent;break;case'topWheel':EventConstructor=SyntheticWheelEvent;break;case'topCopy':case'topCut':case'topPaste':EventConstructor=SyntheticClipboardEvent;break;default:{if(knownHTMLTopLevelTypes.indexOf(topLevelType)===-1){warning(false,'SimpleEventPlugin: Unhandled event type, `%s`. This warning '+'is likely caused by a bug in React. Please file an issue.',topLevelType);}}// HTML Events
// @see http://www.w3.org/TR/html5/index.html#events-0
EventConstructor=SyntheticEvent$1;break;}var event=EventConstructor.getPooled(dispatchConfig,targetInst,nativeEvent,nativeEventTarget);accumulateTwoPhaseDispatches(event);return event;}};setHandleTopLevel(handleTopLevel);/**
 * Inject modules for resolving DOM hierarchy and plugin ordering.
 */injection$1.injectEventPluginOrder(DOMEventPluginOrder);injection$2.injectComponentTree(ReactDOMComponentTree);/**
 * Some important event plugins included by default (without having to require
 * them).
 */injection$1.injectEventPluginsByName({SimpleEventPlugin:SimpleEventPlugin,EnterLeaveEventPlugin:EnterLeaveEventPlugin,ChangeEventPlugin:ChangeEventPlugin,SelectEventPlugin:SelectEventPlugin,BeforeInputEventPlugin:BeforeInputEventPlugin});var enableAsyncSubtreeAPI=true;var enableAsyncSchedulingByDefaultInReactDOM=false;// Exports ReactDOM.createRoot
var enableCreateRoot=false;var enableUserTimingAPI=true;// Mutating mode (React DOM, React ART, React Native):
var enableMutatingReconciler=true;// Experimental noop mode (currently unused):
var enableNoopReconciler=false;// Experimental persistent mode (CS):
var enablePersistentReconciler=false;// Helps identify side effects in begin-phase lifecycle hooks and setState reducers:
var debugRenderPhaseSideEffects=false;// Only used in www builds.
var valueStack=[];{var fiberStack=[];}var index=-1;function createCursor(defaultValue){return{current:defaultValue};}function pop(cursor,fiber){if(index<0){{warning(false,'Unexpected pop.');}return;}{if(fiber!==fiberStack[index]){warning(false,'Unexpected Fiber popped.');}}cursor.current=valueStack[index];valueStack[index]=null;{fiberStack[index]=null;}index--;}function push(cursor,value,fiber){index++;valueStack[index]=cursor.current;{fiberStack[index]=fiber;}cursor.current=value;}function reset$1(){while(index>-1){valueStack[index]=null;{fiberStack[index]=null;}index--;}}var describeComponentFrame=function describeComponentFrame(name,source,ownerName){return'\n    in '+(name||'Unknown')+(source?' (at '+source.fileName.replace(/^.*[\\\/]/,'')+':'+source.lineNumber+')':ownerName?' (created by '+ownerName+')':'');};function describeFiber(fiber){switch(fiber.tag){case IndeterminateComponent:case FunctionalComponent:case ClassComponent:case HostComponent:var owner=fiber._debugOwner;var source=fiber._debugSource;var name=getComponentName(fiber);var ownerName=null;if(owner){ownerName=getComponentName(owner);}return describeComponentFrame(name,source,ownerName);default:return'';}}// This function can only be called with a work-in-progress fiber and
// only during begin or complete phase. Do not call it under any other
// circumstances.
function getStackAddendumByWorkInProgressFiber(workInProgress){var info='';var node=workInProgress;do{info+=describeFiber(node);// Otherwise this return pointer might point to the wrong tree:
node=node['return'];}while(node);return info;}function getCurrentFiberOwnerName(){{var fiber=ReactDebugCurrentFiber.current;if(fiber===null){return null;}var owner=fiber._debugOwner;if(owner!==null&&typeof owner!=='undefined'){return getComponentName(owner);}}return null;}function getCurrentFiberStackAddendum(){{var fiber=ReactDebugCurrentFiber.current;if(fiber===null){return null;}// Safe because if current fiber exists, we are reconciling,
// and it is guaranteed to be the work-in-progress version.
return getStackAddendumByWorkInProgressFiber(fiber);}return null;}function resetCurrentFiber(){ReactDebugCurrentFrame.getCurrentStack=null;ReactDebugCurrentFiber.current=null;ReactDebugCurrentFiber.phase=null;}function setCurrentFiber(fiber){ReactDebugCurrentFrame.getCurrentStack=getCurrentFiberStackAddendum;ReactDebugCurrentFiber.current=fiber;ReactDebugCurrentFiber.phase=null;}function setCurrentPhase(phase){ReactDebugCurrentFiber.phase=phase;}var ReactDebugCurrentFiber={current:null,phase:null,resetCurrentFiber:resetCurrentFiber,setCurrentFiber:setCurrentFiber,setCurrentPhase:setCurrentPhase,getCurrentFiberOwnerName:getCurrentFiberOwnerName,getCurrentFiberStackAddendum:getCurrentFiberStackAddendum};// Prefix measurements so that it's possible to filter them.
// Longer prefixes are hard to read in DevTools.
var reactEmoji='\u269B';var warningEmoji='\u26D4';var supportsUserTiming=typeof performance!=='undefined'&&typeof performance.mark==='function'&&typeof performance.clearMarks==='function'&&typeof performance.measure==='function'&&typeof performance.clearMeasures==='function';// Keep track of current fiber so that we know the path to unwind on pause.
// TODO: this looks the same as nextUnitOfWork in scheduler. Can we unify them?
var currentFiber=null;// If we're in the middle of user code, which fiber and method is it?
// Reusing `currentFiber` would be confusing for this because user code fiber
// can change during commit phase too, but we don't need to unwind it (since
// lifecycles in the commit phase don't resemble a tree).
var currentPhase=null;var currentPhaseFiber=null;// Did lifecycle hook schedule an update? This is often a performance problem,
// so we will keep track of it, and include it in the report.
// Track commits caused by cascading updates.
var isCommitting=false;var hasScheduledUpdateInCurrentCommit=false;var hasScheduledUpdateInCurrentPhase=false;var commitCountInCurrentWorkLoop=0;var effectCountInCurrentCommit=0;var isWaitingForCallback=false;// During commits, we only show a measurement once per method name
// to avoid stretch the commit phase with measurement overhead.
var labelsInCurrentCommit=new Set();var formatMarkName=function formatMarkName(markName){return reactEmoji+' '+markName;};var formatLabel=function formatLabel(label,warning$$1){var prefix=warning$$1?warningEmoji+' ':reactEmoji+' ';var suffix=warning$$1?' Warning: '+warning$$1:'';return''+prefix+label+suffix;};var beginMark=function beginMark(markName){performance.mark(formatMarkName(markName));};var clearMark=function clearMark(markName){performance.clearMarks(formatMarkName(markName));};var endMark=function endMark(label,markName,warning$$1){var formattedMarkName=formatMarkName(markName);var formattedLabel=formatLabel(label,warning$$1);try{performance.measure(formattedLabel,formattedMarkName);}catch(err){}// If previous mark was missing for some reason, this will throw.
// This could only happen if React crashed in an unexpected place earlier.
// Don't pile on with more errors.
// Clear marks immediately to avoid growing buffer.
performance.clearMarks(formattedMarkName);performance.clearMeasures(formattedLabel);};var getFiberMarkName=function getFiberMarkName(label,debugID){return label+' (#'+debugID+')';};var getFiberLabel=function getFiberLabel(componentName,isMounted,phase){if(phase===null){// These are composite component total time measurements.
return componentName+' ['+(isMounted?'update':'mount')+']';}else{// Composite component methods.
return componentName+'.'+phase;}};var beginFiberMark=function beginFiberMark(fiber,phase){var componentName=getComponentName(fiber)||'Unknown';var debugID=fiber._debugID;var isMounted=fiber.alternate!==null;var label=getFiberLabel(componentName,isMounted,phase);if(isCommitting&&labelsInCurrentCommit.has(label)){// During the commit phase, we don't show duplicate labels because
// there is a fixed overhead for every measurement, and we don't
// want to stretch the commit phase beyond necessary.
return false;}labelsInCurrentCommit.add(label);var markName=getFiberMarkName(label,debugID);beginMark(markName);return true;};var clearFiberMark=function clearFiberMark(fiber,phase){var componentName=getComponentName(fiber)||'Unknown';var debugID=fiber._debugID;var isMounted=fiber.alternate!==null;var label=getFiberLabel(componentName,isMounted,phase);var markName=getFiberMarkName(label,debugID);clearMark(markName);};var endFiberMark=function endFiberMark(fiber,phase,warning$$1){var componentName=getComponentName(fiber)||'Unknown';var debugID=fiber._debugID;var isMounted=fiber.alternate!==null;var label=getFiberLabel(componentName,isMounted,phase);var markName=getFiberMarkName(label,debugID);endMark(label,markName,warning$$1);};var shouldIgnoreFiber=function shouldIgnoreFiber(fiber){// Host components should be skipped in the timeline.
// We could check typeof fiber.type, but does this work with RN?
switch(fiber.tag){case HostRoot:case HostComponent:case HostText:case HostPortal:case ReturnComponent:case Fragment:return true;default:return false;}};var clearPendingPhaseMeasurement=function clearPendingPhaseMeasurement(){if(currentPhase!==null&&currentPhaseFiber!==null){clearFiberMark(currentPhaseFiber,currentPhase);}currentPhaseFiber=null;currentPhase=null;hasScheduledUpdateInCurrentPhase=false;};var pauseTimers=function pauseTimers(){// Stops all currently active measurements so that they can be resumed
// if we continue in a later deferred loop from the same unit of work.
var fiber=currentFiber;while(fiber){if(fiber._debugIsCurrentlyTiming){endFiberMark(fiber,null,null);}fiber=fiber['return'];}};var resumeTimersRecursively=function resumeTimersRecursively(fiber){if(fiber['return']!==null){resumeTimersRecursively(fiber['return']);}if(fiber._debugIsCurrentlyTiming){beginFiberMark(fiber,null);}};var resumeTimers=function resumeTimers(){// Resumes all measurements that were active during the last deferred loop.
if(currentFiber!==null){resumeTimersRecursively(currentFiber);}};function recordEffect(){if(enableUserTimingAPI){effectCountInCurrentCommit++;}}function recordScheduleUpdate(){if(enableUserTimingAPI){if(isCommitting){hasScheduledUpdateInCurrentCommit=true;}if(currentPhase!==null&&currentPhase!=='componentWillMount'&&currentPhase!=='componentWillReceiveProps'){hasScheduledUpdateInCurrentPhase=true;}}}function startRequestCallbackTimer(){if(enableUserTimingAPI){if(supportsUserTiming&&!isWaitingForCallback){isWaitingForCallback=true;beginMark('(Waiting for async callback...)');}}}function stopRequestCallbackTimer(didExpire){if(enableUserTimingAPI){if(supportsUserTiming){isWaitingForCallback=false;var warning$$1=didExpire?'React was blocked by main thread':null;endMark('(Waiting for async callback...)','(Waiting for async callback...)',warning$$1);}}}function startWorkTimer(fiber){if(enableUserTimingAPI){if(!supportsUserTiming||shouldIgnoreFiber(fiber)){return;}// If we pause, this is the fiber to unwind from.
currentFiber=fiber;if(!beginFiberMark(fiber,null)){return;}fiber._debugIsCurrentlyTiming=true;}}function cancelWorkTimer(fiber){if(enableUserTimingAPI){if(!supportsUserTiming||shouldIgnoreFiber(fiber)){return;}// Remember we shouldn't complete measurement for this fiber.
// Otherwise flamechart will be deep even for small updates.
fiber._debugIsCurrentlyTiming=false;clearFiberMark(fiber,null);}}function stopWorkTimer(fiber){if(enableUserTimingAPI){if(!supportsUserTiming||shouldIgnoreFiber(fiber)){return;}// If we pause, its parent is the fiber to unwind from.
currentFiber=fiber['return'];if(!fiber._debugIsCurrentlyTiming){return;}fiber._debugIsCurrentlyTiming=false;endFiberMark(fiber,null,null);}}function stopFailedWorkTimer(fiber){if(enableUserTimingAPI){if(!supportsUserTiming||shouldIgnoreFiber(fiber)){return;}// If we pause, its parent is the fiber to unwind from.
currentFiber=fiber['return'];if(!fiber._debugIsCurrentlyTiming){return;}fiber._debugIsCurrentlyTiming=false;var warning$$1='An error was thrown inside this error boundary';endFiberMark(fiber,null,warning$$1);}}function startPhaseTimer(fiber,phase){if(enableUserTimingAPI){if(!supportsUserTiming){return;}clearPendingPhaseMeasurement();if(!beginFiberMark(fiber,phase)){return;}currentPhaseFiber=fiber;currentPhase=phase;}}function stopPhaseTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}if(currentPhase!==null&&currentPhaseFiber!==null){var warning$$1=hasScheduledUpdateInCurrentPhase?'Scheduled a cascading update':null;endFiberMark(currentPhaseFiber,currentPhase,warning$$1);}currentPhase=null;currentPhaseFiber=null;}}function startWorkLoopTimer(nextUnitOfWork){if(enableUserTimingAPI){currentFiber=nextUnitOfWork;if(!supportsUserTiming){return;}commitCountInCurrentWorkLoop=0;// This is top level call.
// Any other measurements are performed within.
beginMark('(React Tree Reconciliation)');// Resume any measurements that were in progress during the last loop.
resumeTimers();}}function stopWorkLoopTimer(interruptedBy){if(enableUserTimingAPI){if(!supportsUserTiming){return;}var warning$$1=null;if(interruptedBy!==null){if(interruptedBy.tag===HostRoot){warning$$1='A top-level update interrupted the previous render';}else{var componentName=getComponentName(interruptedBy)||'Unknown';warning$$1='An update to '+componentName+' interrupted the previous render';}}else if(commitCountInCurrentWorkLoop>1){warning$$1='There were cascading updates';}commitCountInCurrentWorkLoop=0;// Pause any measurements until the next loop.
pauseTimers();endMark('(React Tree Reconciliation)','(React Tree Reconciliation)',warning$$1);}}function startCommitTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}isCommitting=true;hasScheduledUpdateInCurrentCommit=false;labelsInCurrentCommit.clear();beginMark('(Committing Changes)');}}function stopCommitTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}var warning$$1=null;if(hasScheduledUpdateInCurrentCommit){warning$$1='Lifecycle hook scheduled a cascading update';}else if(commitCountInCurrentWorkLoop>0){warning$$1='Caused by a cascading update in earlier commit';}hasScheduledUpdateInCurrentCommit=false;commitCountInCurrentWorkLoop++;isCommitting=false;labelsInCurrentCommit.clear();endMark('(Committing Changes)','(Committing Changes)',warning$$1);}}function startCommitHostEffectsTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}effectCountInCurrentCommit=0;beginMark('(Committing Host Effects)');}}function stopCommitHostEffectsTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}var count=effectCountInCurrentCommit;effectCountInCurrentCommit=0;endMark('(Committing Host Effects: '+count+' Total)','(Committing Host Effects)',null);}}function startCommitLifeCyclesTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}effectCountInCurrentCommit=0;beginMark('(Calling Lifecycle Methods)');}}function stopCommitLifeCyclesTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}var count=effectCountInCurrentCommit;effectCountInCurrentCommit=0;endMark('(Calling Lifecycle Methods: '+count+' Total)','(Calling Lifecycle Methods)',null);}}{var warnedAboutMissingGetChildContext={};}// A cursor to the current merged context object on the stack.
var contextStackCursor=createCursor(emptyObject);// A cursor to a boolean indicating whether the context has changed.
var didPerformWorkStackCursor=createCursor(false);// Keep track of the previous context object that was on the stack.
// We use this to get access to the parent context after we have already
// pushed the next context provider, and now need to merge their contexts.
var previousContext=emptyObject;function getUnmaskedContext(workInProgress){var hasOwnContext=isContextProvider(workInProgress);if(hasOwnContext){// If the fiber is a context provider itself, when we read its context
// we have already pushed its own child context on the stack. A context
// provider should not "see" its own child context. Therefore we read the
// previous (parent) context instead for a context provider.
return previousContext;}return contextStackCursor.current;}function cacheContext(workInProgress,unmaskedContext,maskedContext){var instance=workInProgress.stateNode;instance.__reactInternalMemoizedUnmaskedChildContext=unmaskedContext;instance.__reactInternalMemoizedMaskedChildContext=maskedContext;}function getMaskedContext(workInProgress,unmaskedContext){var type=workInProgress.type;var contextTypes=type.contextTypes;if(!contextTypes){return emptyObject;}// Avoid recreating masked context unless unmasked context has changed.
// Failing to do this will result in unnecessary calls to componentWillReceiveProps.
// This may trigger infinite loops if componentWillReceiveProps calls setState.
var instance=workInProgress.stateNode;if(instance&&instance.__reactInternalMemoizedUnmaskedChildContext===unmaskedContext){return instance.__reactInternalMemoizedMaskedChildContext;}var context={};for(var key in contextTypes){context[key]=unmaskedContext[key];}{var name=getComponentName(workInProgress)||'Unknown';checkPropTypes(contextTypes,context,'context',name,ReactDebugCurrentFiber.getCurrentFiberStackAddendum);}// Cache unmasked context so we can avoid recreating masked context unless necessary.
// Context is created before the class component is instantiated so check for instance.
if(instance){cacheContext(workInProgress,unmaskedContext,context);}return context;}function hasContextChanged(){return didPerformWorkStackCursor.current;}function isContextConsumer(fiber){return fiber.tag===ClassComponent&&fiber.type.contextTypes!=null;}function isContextProvider(fiber){return fiber.tag===ClassComponent&&fiber.type.childContextTypes!=null;}function popContextProvider(fiber){if(!isContextProvider(fiber)){return;}pop(didPerformWorkStackCursor,fiber);pop(contextStackCursor,fiber);}function popTopLevelContextObject(fiber){pop(didPerformWorkStackCursor,fiber);pop(contextStackCursor,fiber);}function pushTopLevelContextObject(fiber,context,didChange){!(contextStackCursor.cursor==null)?invariant(false,'Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.'):void 0;push(contextStackCursor,context,fiber);push(didPerformWorkStackCursor,didChange,fiber);}function processChildContext(fiber,parentContext){var instance=fiber.stateNode;var childContextTypes=fiber.type.childContextTypes;// TODO (bvaughn) Replace this behavior with an invariant() in the future.
// It has only been added in Fiber to match the (unintentional) behavior in Stack.
if(typeof instance.getChildContext!=='function'){{var componentName=getComponentName(fiber)||'Unknown';if(!warnedAboutMissingGetChildContext[componentName]){warnedAboutMissingGetChildContext[componentName]=true;warning(false,'%s.childContextTypes is specified but there is no getChildContext() method '+'on the instance. You can either define getChildContext() on %s or remove '+'childContextTypes from it.',componentName,componentName);}}return parentContext;}var childContext=void 0;{ReactDebugCurrentFiber.setCurrentPhase('getChildContext');}startPhaseTimer(fiber,'getChildContext');childContext=instance.getChildContext();stopPhaseTimer();{ReactDebugCurrentFiber.setCurrentPhase(null);}for(var contextKey in childContext){!(contextKey in childContextTypes)?invariant(false,'%s.getChildContext(): key "%s" is not defined in childContextTypes.',getComponentName(fiber)||'Unknown',contextKey):void 0;}{var name=getComponentName(fiber)||'Unknown';checkPropTypes(childContextTypes,childContext,'child context',name,// In practice, there is one case in which we won't get a stack. It's when
// somebody calls unstable_renderSubtreeIntoContainer() and we process
// context from the parent component instance. The stack will be missing
// because it's outside of the reconciliation, and so the pointer has not
// been set. This is rare and doesn't matter. We'll also remove that API.
ReactDebugCurrentFiber.getCurrentFiberStackAddendum);}return _assign({},parentContext,childContext);}function pushContextProvider(workInProgress){if(!isContextProvider(workInProgress)){return false;}var instance=workInProgress.stateNode;// We push the context as early as possible to ensure stack integrity.
// If the instance does not exist yet, we will push null at first,
// and replace it on the stack later when invalidating the context.
var memoizedMergedChildContext=instance&&instance.__reactInternalMemoizedMergedChildContext||emptyObject;// Remember the parent context so we can merge with it later.
// Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.
previousContext=contextStackCursor.current;push(contextStackCursor,memoizedMergedChildContext,workInProgress);push(didPerformWorkStackCursor,didPerformWorkStackCursor.current,workInProgress);return true;}function invalidateContextProvider(workInProgress,didChange){var instance=workInProgress.stateNode;!instance?invariant(false,'Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.'):void 0;if(didChange){// Merge parent and own context.
// Skip this if we're not updating due to sCU.
// This avoids unnecessarily recomputing memoized values.
var mergedContext=processChildContext(workInProgress,previousContext);instance.__reactInternalMemoizedMergedChildContext=mergedContext;// Replace the old (or empty) context with the new one.
// It is important to unwind the context in the reverse order.
pop(didPerformWorkStackCursor,workInProgress);pop(contextStackCursor,workInProgress);// Now push the new context and mark that it has changed.
push(contextStackCursor,mergedContext,workInProgress);push(didPerformWorkStackCursor,didChange,workInProgress);}else{pop(didPerformWorkStackCursor,workInProgress);push(didPerformWorkStackCursor,didChange,workInProgress);}}function resetContext(){previousContext=emptyObject;contextStackCursor.current=emptyObject;didPerformWorkStackCursor.current=false;}function findCurrentUnmaskedContext(fiber){// Currently this is only used with renderSubtreeIntoContainer; not sure if it
// makes sense elsewhere
!(isFiberMounted(fiber)&&fiber.tag===ClassComponent)?invariant(false,'Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.'):void 0;var node=fiber;while(node.tag!==HostRoot){if(isContextProvider(node)){return node.stateNode.__reactInternalMemoizedMergedChildContext;}var parent=node['return'];!parent?invariant(false,'Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.'):void 0;node=parent;}return node.stateNode.context;}var NoWork=0;// TODO: Use an opaque type once ESLint et al support the syntax
var Sync=1;var Never=2147483647;// Max int32: Math.pow(2, 31) - 1
var UNIT_SIZE=10;var MAGIC_NUMBER_OFFSET=2;// 1 unit of expiration time represents 10ms.
function msToExpirationTime(ms){// Always add an offset so that we don't clash with the magic number for NoWork.
return(ms/UNIT_SIZE|0)+MAGIC_NUMBER_OFFSET;}function expirationTimeToMs(expirationTime){return(expirationTime-MAGIC_NUMBER_OFFSET)*UNIT_SIZE;}function ceiling(num,precision){return((num/precision|0)+1)*precision;}function computeExpirationBucket(currentTime,expirationInMs,bucketSizeMs){return ceiling(currentTime+expirationInMs/UNIT_SIZE,bucketSizeMs/UNIT_SIZE);}var NoContext=0;var AsyncUpdates=1;{var hasBadMapPolyfill=false;try{var nonExtensibleObject=Object.preventExtensions({});/* eslint-disable no-new *//* eslint-enable no-new */}catch(e){// TODO: Consider warning about bad polyfills
hasBadMapPolyfill=true;}}// A Fiber is work on a Component that needs to be done or was done. There can
// be more than one per component.
{var debugCounter=1;}function FiberNode(tag,key,internalContextTag){// Instance
this.tag=tag;this.key=key;this.type=null;this.stateNode=null;// Fiber
this['return']=null;this.child=null;this.sibling=null;this.index=0;this.ref=null;this.pendingProps=null;this.memoizedProps=null;this.updateQueue=null;this.memoizedState=null;this.internalContextTag=internalContextTag;// Effects
this.effectTag=NoEffect;this.nextEffect=null;this.firstEffect=null;this.lastEffect=null;this.expirationTime=NoWork;this.alternate=null;{this._debugID=debugCounter++;this._debugSource=null;this._debugOwner=null;this._debugIsCurrentlyTiming=false;if(!hasBadMapPolyfill&&typeof Object.preventExtensions==='function'){Object.preventExtensions(this);}}}// This is a constructor function, rather than a POJO constructor, still
// please ensure we do the following:
// 1) Nobody should add any instance methods on this. Instance methods can be
//    more difficult to predict when they get optimized and they are almost
//    never inlined properly in static compilers.
// 2) Nobody should rely on `instanceof Fiber` for type testing. We should
//    always know when it is a fiber.
// 3) We might want to experiment with using numeric keys since they are easier
//    to optimize in a non-JIT environment.
// 4) We can easily go from a constructor to a createFiber object literal if that
//    is faster.
// 5) It should be easy to port this to a C struct and keep a C implementation
//    compatible.
var createFiber=function createFiber(tag,key,internalContextTag){// $FlowFixMe: the shapes are exact here but Flow doesn't like constructors
return new FiberNode(tag,key,internalContextTag);};function shouldConstruct(Component){return!!(Component.prototype&&Component.prototype.isReactComponent);}// This is used to create an alternate fiber to do work on.
function createWorkInProgress(current,pendingProps,expirationTime){var workInProgress=current.alternate;if(workInProgress===null){// We use a double buffering pooling technique because we know that we'll
// only ever need at most two versions of a tree. We pool the "other" unused
// node that we're free to reuse. This is lazily created to avoid allocating
// extra objects for things that are never updated. It also allow us to
// reclaim the extra memory if needed.
workInProgress=createFiber(current.tag,current.key,current.internalContextTag);workInProgress.type=current.type;workInProgress.stateNode=current.stateNode;{// DEV-only fields
workInProgress._debugID=current._debugID;workInProgress._debugSource=current._debugSource;workInProgress._debugOwner=current._debugOwner;}workInProgress.alternate=current;current.alternate=workInProgress;}else{// We already have an alternate.
// Reset the effect tag.
workInProgress.effectTag=NoEffect;// The effect list is no longer valid.
workInProgress.nextEffect=null;workInProgress.firstEffect=null;workInProgress.lastEffect=null;}workInProgress.expirationTime=expirationTime;workInProgress.pendingProps=pendingProps;workInProgress.child=current.child;workInProgress.memoizedProps=current.memoizedProps;workInProgress.memoizedState=current.memoizedState;workInProgress.updateQueue=current.updateQueue;// These will be overridden during the parent's reconciliation
workInProgress.sibling=current.sibling;workInProgress.index=current.index;workInProgress.ref=current.ref;return workInProgress;}function createHostRootFiber(){var fiber=createFiber(HostRoot,null,NoContext);return fiber;}function createFiberFromElement(element,internalContextTag,expirationTime){var owner=null;{owner=element._owner;}var fiber=void 0;var type=element.type,key=element.key;if(typeof type==='function'){fiber=shouldConstruct(type)?createFiber(ClassComponent,key,internalContextTag):createFiber(IndeterminateComponent,key,internalContextTag);fiber.type=type;fiber.pendingProps=element.props;}else if(typeof type==='string'){fiber=createFiber(HostComponent,key,internalContextTag);fiber.type=type;fiber.pendingProps=element.props;}else if((typeof type==='undefined'?'undefined':_typeof(type))==='object'&&type!==null&&typeof type.tag==='number'){// Currently assumed to be a continuation and therefore is a fiber already.
// TODO: The yield system is currently broken for updates in some cases.
// The reified yield stores a fiber, but we don't know which fiber that is;
// the current or a workInProgress? When the continuation gets rendered here
// we don't know if we can reuse that fiber or if we need to clone it.
// There is probably a clever way to restructure this.
fiber=type;fiber.pendingProps=element.props;}else{var info='';{if(type===undefined||(typeof type==='undefined'?'undefined':_typeof(type))==='object'&&type!==null&&Object.keys(type).length===0){info+=' You likely forgot to export your component from the file '+"it's defined in, or you might have mixed up default and named imports.";}var ownerName=owner?getComponentName(owner):null;if(ownerName){info+='\n\nCheck the render method of `'+ownerName+'`.';}}invariant(false,'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s',type==null?type:typeof type==='undefined'?'undefined':_typeof(type),info);}{fiber._debugSource=element._source;fiber._debugOwner=element._owner;}fiber.expirationTime=expirationTime;return fiber;}function createFiberFromFragment(elements,internalContextTag,expirationTime,key){var fiber=createFiber(Fragment,key,internalContextTag);fiber.pendingProps=elements;fiber.expirationTime=expirationTime;return fiber;}function createFiberFromText(content,internalContextTag,expirationTime){var fiber=createFiber(HostText,null,internalContextTag);fiber.pendingProps=content;fiber.expirationTime=expirationTime;return fiber;}function createFiberFromHostInstanceForDeletion(){var fiber=createFiber(HostComponent,null,NoContext);fiber.type='DELETED';return fiber;}function createFiberFromCall(call,internalContextTag,expirationTime){var fiber=createFiber(CallComponent,call.key,internalContextTag);fiber.type=call.handler;fiber.pendingProps=call;fiber.expirationTime=expirationTime;return fiber;}function createFiberFromReturn(returnNode,internalContextTag,expirationTime){var fiber=createFiber(ReturnComponent,null,internalContextTag);fiber.expirationTime=expirationTime;return fiber;}function createFiberFromPortal(portal,internalContextTag,expirationTime){var fiber=createFiber(HostPortal,portal.key,internalContextTag);fiber.pendingProps=portal.children||[];fiber.expirationTime=expirationTime;fiber.stateNode={containerInfo:portal.containerInfo,pendingChildren:null,// Used by persistent updates
implementation:portal.implementation};return fiber;}function createFiberRoot(containerInfo,hydrate){// Cyclic construction. This cheats the type system right now because
// stateNode is any.
var uninitializedFiber=createHostRootFiber();var root={current:uninitializedFiber,containerInfo:containerInfo,pendingChildren:null,remainingExpirationTime:NoWork,isReadyForCommit:false,finishedWork:null,context:null,pendingContext:null,hydrate:hydrate,nextScheduledRoot:null};uninitializedFiber.stateNode=root;return root;}var onCommitFiberRoot=null;var onCommitFiberUnmount=null;var hasLoggedError=false;function catchErrors(fn){return function(arg){try{return fn(arg);}catch(err){if(true&&!hasLoggedError){hasLoggedError=true;warning(false,'React DevTools encountered an error: %s',err);}}};}function injectInternals(internals){if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__==='undefined'){// No DevTools
return false;}var hook=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(hook.isDisabled){// This isn't a real property on the hook, but it can be set to opt out
// of DevTools integration and associated warnings and logs.
// https://github.com/facebook/react/issues/3877
return true;}if(!hook.supportsFiber){{warning(false,'The installed version of React DevTools is too old and will not work '+'with the current version of React. Please update React DevTools. '+'https://fb.me/react-devtools');}// DevTools exists, even though it doesn't support Fiber.
return true;}try{var rendererID=hook.inject(internals);// We have successfully injected, so now it is safe to set up hooks.
onCommitFiberRoot=catchErrors(function(root){return hook.onCommitFiberRoot(rendererID,root);});onCommitFiberUnmount=catchErrors(function(fiber){return hook.onCommitFiberUnmount(rendererID,fiber);});}catch(err){// Catch all errors because it is unsafe to throw during initialization.
{warning(false,'React DevTools encountered an error: %s.',err);}}// DevTools exists
return true;}function onCommitRoot(root){if(typeof onCommitFiberRoot==='function'){onCommitFiberRoot(root);}}function onCommitUnmount(fiber){if(typeof onCommitFiberUnmount==='function'){onCommitFiberUnmount(fiber);}}{var didWarnUpdateInsideUpdate=false;}// Callbacks are not validated until invocation
// Singly linked-list of updates. When an update is scheduled, it is added to
// the queue of the current fiber and the work-in-progress fiber. The two queues
// are separate but they share a persistent structure.
//
// During reconciliation, updates are removed from the work-in-progress fiber,
// but they remain on the current fiber. That ensures that if a work-in-progress
// is aborted, the aborted updates are recovered by cloning from current.
//
// The work-in-progress queue is always a subset of the current queue.
//
// When the tree is committed, the work-in-progress becomes the current.
function createUpdateQueue(baseState){var queue={baseState:baseState,expirationTime:NoWork,first:null,last:null,callbackList:null,hasForceUpdate:false,isInitialized:false};{queue.isProcessing=false;}return queue;}function insertUpdateIntoQueue(queue,update){// Append the update to the end of the list.
if(queue.last===null){// Queue is empty
queue.first=queue.last=update;}else{queue.last.next=update;queue.last=update;}if(queue.expirationTime===NoWork||queue.expirationTime>update.expirationTime){queue.expirationTime=update.expirationTime;}}function insertUpdateIntoFiber(fiber,update){// We'll have at least one and at most two distinct update queues.
var alternateFiber=fiber.alternate;var queue1=fiber.updateQueue;if(queue1===null){// TODO: We don't know what the base state will be until we begin work.
// It depends on which fiber is the next current. Initialize with an empty
// base state, then set to the memoizedState when rendering. Not super
// happy with this approach.
queue1=fiber.updateQueue=createUpdateQueue(null);}var queue2=void 0;if(alternateFiber!==null){queue2=alternateFiber.updateQueue;if(queue2===null){queue2=alternateFiber.updateQueue=createUpdateQueue(null);}}else{queue2=null;}queue2=queue2!==queue1?queue2:null;// Warn if an update is scheduled from inside an updater function.
{if((queue1.isProcessing||queue2!==null&&queue2.isProcessing)&&!didWarnUpdateInsideUpdate){warning(false,'An update (setState, replaceState, or forceUpdate) was scheduled '+'from inside an update function. Update functions should be pure, '+'with zero side-effects. Consider using componentDidUpdate or a '+'callback.');didWarnUpdateInsideUpdate=true;}}// If there's only one queue, add the update to that queue and exit.
if(queue2===null){insertUpdateIntoQueue(queue1,update);return;}// If either queue is empty, we need to add to both queues.
if(queue1.last===null||queue2.last===null){insertUpdateIntoQueue(queue1,update);insertUpdateIntoQueue(queue2,update);return;}// If both lists are not empty, the last update is the same for both lists
// because of structural sharing. So, we should only append to one of
// the lists.
insertUpdateIntoQueue(queue1,update);// But we still need to update the `last` pointer of queue2.
queue2.last=update;}function getUpdateExpirationTime(fiber){if(fiber.tag!==ClassComponent&&fiber.tag!==HostRoot){return NoWork;}var updateQueue=fiber.updateQueue;if(updateQueue===null){return NoWork;}return updateQueue.expirationTime;}function getStateFromUpdate(update,instance,prevState,props){var partialState=update.partialState;if(typeof partialState==='function'){var updateFn=partialState;// Invoke setState callback an extra time to help detect side-effects.
if(debugRenderPhaseSideEffects){updateFn.call(instance,prevState,props);}return updateFn.call(instance,prevState,props);}else{return partialState;}}function processUpdateQueue(current,workInProgress,queue,instance,props,renderExpirationTime){if(current!==null&&current.updateQueue===queue){// We need to create a work-in-progress queue, by cloning the current queue.
var currentQueue=queue;queue=workInProgress.updateQueue={baseState:currentQueue.baseState,expirationTime:currentQueue.expirationTime,first:currentQueue.first,last:currentQueue.last,isInitialized:currentQueue.isInitialized,// These fields are no longer valid because they were already committed.
// Reset them.
callbackList:null,hasForceUpdate:false};}{// Set this flag so we can warn if setState is called inside the update
// function of another setState.
queue.isProcessing=true;}// Reset the remaining expiration time. If we skip over any updates, we'll
// increase this accordingly.
queue.expirationTime=NoWork;// TODO: We don't know what the base state will be until we begin work.
// It depends on which fiber is the next current. Initialize with an empty
// base state, then set to the memoizedState when rendering. Not super
// happy with this approach.
var state=void 0;if(queue.isInitialized){state=queue.baseState;}else{state=queue.baseState=workInProgress.memoizedState;queue.isInitialized=true;}var dontMutatePrevState=true;var update=queue.first;var didSkip=false;while(update!==null){var updateExpirationTime=update.expirationTime;if(updateExpirationTime>renderExpirationTime){// This update does not have sufficient priority. Skip it.
var remainingExpirationTime=queue.expirationTime;if(remainingExpirationTime===NoWork||remainingExpirationTime>updateExpirationTime){// Update the remaining expiration time.
queue.expirationTime=updateExpirationTime;}if(!didSkip){didSkip=true;queue.baseState=state;}// Continue to the next update.
update=update.next;continue;}// This update does have sufficient priority.
// If no previous updates were skipped, drop this update from the queue by
// advancing the head of the list.
if(!didSkip){queue.first=update.next;if(queue.first===null){queue.last=null;}}// Process the update
var _partialState=void 0;if(update.isReplace){state=getStateFromUpdate(update,instance,state,props);dontMutatePrevState=true;}else{_partialState=getStateFromUpdate(update,instance,state,props);if(_partialState){if(dontMutatePrevState){// $FlowFixMe: Idk how to type this properly.
state=_assign({},state,_partialState);}else{state=_assign(state,_partialState);}dontMutatePrevState=false;}}if(update.isForced){queue.hasForceUpdate=true;}if(update.callback!==null){// Append to list of callbacks.
var _callbackList=queue.callbackList;if(_callbackList===null){_callbackList=queue.callbackList=[];}_callbackList.push(update);}update=update.next;}if(queue.callbackList!==null){workInProgress.effectTag|=Callback;}else if(queue.first===null&&!queue.hasForceUpdate){// The queue is empty. We can reset it.
workInProgress.updateQueue=null;}if(!didSkip){didSkip=true;queue.baseState=state;}{// No longer processing.
queue.isProcessing=false;}return state;}function commitCallbacks(queue,context){var callbackList=queue.callbackList;if(callbackList===null){return;}// Set the list to null to make sure they don't get called more than once.
queue.callbackList=null;for(var i=0;i<callbackList.length;i++){var update=callbackList[i];var _callback=update.callback;// This update might be processed again. Clear the callback so it's only
// called once.
update.callback=null;!(typeof _callback==='function')?invariant(false,'Invalid argument passed as callback. Expected a function. Instead received: %s',_callback):void 0;_callback.call(context);}}var fakeInternalInstance={};var isArray=Array.isArray;{var didWarnAboutStateAssignmentForComponent={};var warnOnInvalidCallback=function warnOnInvalidCallback(callback,callerName){warning(callback===null||typeof callback==='function','%s(...): Expected the last optional `callback` argument to be a '+'function. Instead received: %s.',callerName,callback);};// This is so gross but it's at least non-critical and can be removed if
// it causes problems. This is meant to give a nicer error message for
// ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,
// ...)) which otherwise throws a "_processChildContext is not a function"
// exception.
Object.defineProperty(fakeInternalInstance,'_processChildContext',{enumerable:false,value:function value(){invariant(false,'_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn\'t supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).');}});Object.freeze(fakeInternalInstance);}var ReactFiberClassComponent=function ReactFiberClassComponent(scheduleWork,computeExpirationForFiber,memoizeProps,memoizeState){// Class component state updater
var updater={isMounted:isMounted,enqueueSetState:function enqueueSetState(instance,partialState,callback){var fiber=get(instance);callback=callback===undefined?null:callback;{warnOnInvalidCallback(callback,'setState');}var expirationTime=computeExpirationForFiber(fiber);var update={expirationTime:expirationTime,partialState:partialState,callback:callback,isReplace:false,isForced:false,nextCallback:null,next:null};insertUpdateIntoFiber(fiber,update);scheduleWork(fiber,expirationTime);},enqueueReplaceState:function enqueueReplaceState(instance,state,callback){var fiber=get(instance);callback=callback===undefined?null:callback;{warnOnInvalidCallback(callback,'replaceState');}var expirationTime=computeExpirationForFiber(fiber);var update={expirationTime:expirationTime,partialState:state,callback:callback,isReplace:true,isForced:false,nextCallback:null,next:null};insertUpdateIntoFiber(fiber,update);scheduleWork(fiber,expirationTime);},enqueueForceUpdate:function enqueueForceUpdate(instance,callback){var fiber=get(instance);callback=callback===undefined?null:callback;{warnOnInvalidCallback(callback,'forceUpdate');}var expirationTime=computeExpirationForFiber(fiber);var update={expirationTime:expirationTime,partialState:null,callback:callback,isReplace:false,isForced:true,nextCallback:null,next:null};insertUpdateIntoFiber(fiber,update);scheduleWork(fiber,expirationTime);}};function checkShouldComponentUpdate(workInProgress,oldProps,newProps,oldState,newState,newContext){if(oldProps===null||workInProgress.updateQueue!==null&&workInProgress.updateQueue.hasForceUpdate){// If the workInProgress already has an Update effect, return true
return true;}var instance=workInProgress.stateNode;var type=workInProgress.type;if(typeof instance.shouldComponentUpdate==='function'){startPhaseTimer(workInProgress,'shouldComponentUpdate');var shouldUpdate=instance.shouldComponentUpdate(newProps,newState,newContext);stopPhaseTimer();// Simulate an async bailout/interruption by invoking lifecycle twice.
if(debugRenderPhaseSideEffects){instance.shouldComponentUpdate(newProps,newState,newContext);}{warning(shouldUpdate!==undefined,'%s.shouldComponentUpdate(): Returned undefined instead of a '+'boolean value. Make sure to return true or false.',getComponentName(workInProgress)||'Unknown');}return shouldUpdate;}if(type.prototype&&type.prototype.isPureReactComponent){return!shallowEqual(oldProps,newProps)||!shallowEqual(oldState,newState);}return true;}function checkClassInstance(workInProgress){var instance=workInProgress.stateNode;var type=workInProgress.type;{var name=getComponentName(workInProgress);var renderPresent=instance.render;if(!renderPresent){if(type.prototype&&typeof type.prototype.render==='function'){warning(false,'%s(...): No `render` method found on the returned component '+'instance: did you accidentally return an object from the constructor?',name);}else{warning(false,'%s(...): No `render` method found on the returned component '+'instance: you may have forgotten to define `render`.',name);}}var noGetInitialStateOnES6=!instance.getInitialState||instance.getInitialState.isReactClassApproved||instance.state;warning(noGetInitialStateOnES6,'getInitialState was defined on %s, a plain JavaScript class. '+'This is only supported for classes created using React.createClass. '+'Did you mean to define a state property instead?',name);var noGetDefaultPropsOnES6=!instance.getDefaultProps||instance.getDefaultProps.isReactClassApproved;warning(noGetDefaultPropsOnES6,'getDefaultProps was defined on %s, a plain JavaScript class. '+'This is only supported for classes created using React.createClass. '+'Use a static property to define defaultProps instead.',name);var noInstancePropTypes=!instance.propTypes;warning(noInstancePropTypes,'propTypes was defined as an instance property on %s. Use a static '+'property to define propTypes instead.',name);var noInstanceContextTypes=!instance.contextTypes;warning(noInstanceContextTypes,'contextTypes was defined as an instance property on %s. Use a static '+'property to define contextTypes instead.',name);var noComponentShouldUpdate=typeof instance.componentShouldUpdate!=='function';warning(noComponentShouldUpdate,'%s has a method called '+'componentShouldUpdate(). Did you mean shouldComponentUpdate()? '+'The name is phrased as a question because the function is '+'expected to return a value.',name);if(type.prototype&&type.prototype.isPureReactComponent&&typeof instance.shouldComponentUpdate!=='undefined'){warning(false,'%s has a method called shouldComponentUpdate(). '+'shouldComponentUpdate should not be used when extending React.PureComponent. '+'Please extend React.Component if shouldComponentUpdate is used.',getComponentName(workInProgress)||'A pure component');}var noComponentDidUnmount=typeof instance.componentDidUnmount!=='function';warning(noComponentDidUnmount,'%s has a method called '+'componentDidUnmount(). But there is no such lifecycle method. '+'Did you mean componentWillUnmount()?',name);var noComponentDidReceiveProps=typeof instance.componentDidReceiveProps!=='function';warning(noComponentDidReceiveProps,'%s has a method called '+'componentDidReceiveProps(). But there is no such lifecycle method. '+'If you meant to update the state in response to changing props, '+'use componentWillReceiveProps(). If you meant to fetch data or '+'run side-effects or mutations after React has updated the UI, use componentDidUpdate().',name);var noComponentWillRecieveProps=typeof instance.componentWillRecieveProps!=='function';warning(noComponentWillRecieveProps,'%s has a method called '+'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?',name);var hasMutatedProps=instance.props!==workInProgress.pendingProps;warning(instance.props===undefined||!hasMutatedProps,'%s(...): When calling super() in `%s`, make sure to pass '+"up the same props that your component's constructor was passed.",name,name);var noInstanceDefaultProps=!instance.defaultProps;warning(noInstanceDefaultProps,'Setting defaultProps as an instance property on %s is not supported and will be ignored.'+' Instead, define defaultProps as a static property on %s.',name,name);}var state=instance.state;if(state&&((typeof state==='undefined'?'undefined':_typeof(state))!=='object'||isArray(state))){warning(false,'%s.state: must be set to an object or null',getComponentName(workInProgress));}if(typeof instance.getChildContext==='function'){warning(_typeof(workInProgress.type.childContextTypes)==='object','%s.getChildContext(): childContextTypes must be defined in order to '+'use getChildContext().',getComponentName(workInProgress));}}function resetInputPointers(workInProgress,instance){instance.props=workInProgress.memoizedProps;instance.state=workInProgress.memoizedState;}function adoptClassInstance(workInProgress,instance){instance.updater=updater;workInProgress.stateNode=instance;// The instance needs access to the fiber so that it can schedule updates
set(instance,workInProgress);{instance._reactInternalInstance=fakeInternalInstance;}}function constructClassInstance(workInProgress,props){var ctor=workInProgress.type;var unmaskedContext=getUnmaskedContext(workInProgress);var needsContext=isContextConsumer(workInProgress);var context=needsContext?getMaskedContext(workInProgress,unmaskedContext):emptyObject;var instance=new ctor(props,context);adoptClassInstance(workInProgress,instance);// Cache unmasked context so we can avoid recreating masked context unless necessary.
// ReactFiberContext usually updates this cache but can't for newly-created instances.
if(needsContext){cacheContext(workInProgress,unmaskedContext,context);}return instance;}function callComponentWillMount(workInProgress,instance){startPhaseTimer(workInProgress,'componentWillMount');var oldState=instance.state;instance.componentWillMount();stopPhaseTimer();// Simulate an async bailout/interruption by invoking lifecycle twice.
if(debugRenderPhaseSideEffects){instance.componentWillMount();}if(oldState!==instance.state){{warning(false,'%s.componentWillMount(): Assigning directly to this.state is '+"deprecated (except inside a component's "+'constructor). Use setState instead.',getComponentName(workInProgress));}updater.enqueueReplaceState(instance,instance.state,null);}}function callComponentWillReceiveProps(workInProgress,instance,newProps,newContext){startPhaseTimer(workInProgress,'componentWillReceiveProps');var oldState=instance.state;instance.componentWillReceiveProps(newProps,newContext);stopPhaseTimer();// Simulate an async bailout/interruption by invoking lifecycle twice.
if(debugRenderPhaseSideEffects){instance.componentWillReceiveProps(newProps,newContext);}if(instance.state!==oldState){{var componentName=getComponentName(workInProgress)||'Component';if(!didWarnAboutStateAssignmentForComponent[componentName]){warning(false,'%s.componentWillReceiveProps(): Assigning directly to '+"this.state is deprecated (except inside a component's "+'constructor). Use setState instead.',componentName);didWarnAboutStateAssignmentForComponent[componentName]=true;}}updater.enqueueReplaceState(instance,instance.state,null);}}// Invokes the mount life-cycles on a previously never rendered instance.
function mountClassInstance(workInProgress,renderExpirationTime){var current=workInProgress.alternate;{checkClassInstance(workInProgress);}var instance=workInProgress.stateNode;var state=instance.state||null;var props=workInProgress.pendingProps;!props?invariant(false,'There must be pending props for an initial mount. This error is likely caused by a bug in React. Please file an issue.'):void 0;var unmaskedContext=getUnmaskedContext(workInProgress);instance.props=props;instance.state=workInProgress.memoizedState=state;instance.refs=emptyObject;instance.context=getMaskedContext(workInProgress,unmaskedContext);if(enableAsyncSubtreeAPI&&workInProgress.type!=null&&workInProgress.type.prototype!=null&&workInProgress.type.prototype.unstable_isAsyncReactComponent===true){workInProgress.internalContextTag|=AsyncUpdates;}if(typeof instance.componentWillMount==='function'){callComponentWillMount(workInProgress,instance);// If we had additional state updates during this life-cycle, let's
// process them now.
var updateQueue=workInProgress.updateQueue;if(updateQueue!==null){instance.state=processUpdateQueue(current,workInProgress,updateQueue,instance,props,renderExpirationTime);}}if(typeof instance.componentDidMount==='function'){workInProgress.effectTag|=Update;}}// Called on a preexisting class instance. Returns false if a resumed render
// could be reused.
// function resumeMountClassInstance(
//   workInProgress: Fiber,
//   priorityLevel: PriorityLevel,
// ): boolean {
//   const instance = workInProgress.stateNode;
//   resetInputPointers(workInProgress, instance);
//   let newState = workInProgress.memoizedState;
//   let newProps = workInProgress.pendingProps;
//   if (!newProps) {
//     // If there isn't any new props, then we'll reuse the memoized props.
//     // This could be from already completed work.
//     newProps = workInProgress.memoizedProps;
//     invariant(
//       newProps != null,
//       'There should always be pending or memoized props. This error is ' +
//         'likely caused by a bug in React. Please file an issue.',
//     );
//   }
//   const newUnmaskedContext = getUnmaskedContext(workInProgress);
//   const newContext = getMaskedContext(workInProgress, newUnmaskedContext);
//   const oldContext = instance.context;
//   const oldProps = workInProgress.memoizedProps;
//   if (
//     typeof instance.componentWillReceiveProps === 'function' &&
//     (oldProps !== newProps || oldContext !== newContext)
//   ) {
//     callComponentWillReceiveProps(
//       workInProgress,
//       instance,
//       newProps,
//       newContext,
//     );
//   }
//   // Process the update queue before calling shouldComponentUpdate
//   const updateQueue = workInProgress.updateQueue;
//   if (updateQueue !== null) {
//     newState = processUpdateQueue(
//       workInProgress,
//       updateQueue,
//       instance,
//       newState,
//       newProps,
//       priorityLevel,
//     );
//   }
//   // TODO: Should we deal with a setState that happened after the last
//   // componentWillMount and before this componentWillMount? Probably
//   // unsupported anyway.
//   if (
//     !checkShouldComponentUpdate(
//       workInProgress,
//       workInProgress.memoizedProps,
//       newProps,
//       workInProgress.memoizedState,
//       newState,
//       newContext,
//     )
//   ) {
//     // Update the existing instance's state, props, and context pointers even
//     // though we're bailing out.
//     instance.props = newProps;
//     instance.state = newState;
//     instance.context = newContext;
//     return false;
//   }
//   // Update the input pointers now so that they are correct when we call
//   // componentWillMount
//   instance.props = newProps;
//   instance.state = newState;
//   instance.context = newContext;
//   if (typeof instance.componentWillMount === 'function') {
//     callComponentWillMount(workInProgress, instance);
//     // componentWillMount may have called setState. Process the update queue.
//     const newUpdateQueue = workInProgress.updateQueue;
//     if (newUpdateQueue !== null) {
//       newState = processUpdateQueue(
//         workInProgress,
//         newUpdateQueue,
//         instance,
//         newState,
//         newProps,
//         priorityLevel,
//       );
//     }
//   }
//   if (typeof instance.componentDidMount === 'function') {
//     workInProgress.effectTag |= Update;
//   }
//   instance.state = newState;
//   return true;
// }
// Invokes the update life-cycles and returns false if it shouldn't rerender.
function updateClassInstance(current,workInProgress,renderExpirationTime){var instance=workInProgress.stateNode;resetInputPointers(workInProgress,instance);var oldProps=workInProgress.memoizedProps;var newProps=workInProgress.pendingProps;if(!newProps){// If there aren't any new props, then we'll reuse the memoized props.
// This could be from already completed work.
newProps=oldProps;!(newProps!=null)?invariant(false,'There should always be pending or memoized props. This error is likely caused by a bug in React. Please file an issue.'):void 0;}var oldContext=instance.context;var newUnmaskedContext=getUnmaskedContext(workInProgress);var newContext=getMaskedContext(workInProgress,newUnmaskedContext);// Note: During these life-cycles, instance.props/instance.state are what
// ever the previously attempted to render - not the "current". However,
// during componentDidUpdate we pass the "current" props.
if(typeof instance.componentWillReceiveProps==='function'&&(oldProps!==newProps||oldContext!==newContext)){callComponentWillReceiveProps(workInProgress,instance,newProps,newContext);}// Compute the next state using the memoized state and the update queue.
var oldState=workInProgress.memoizedState;// TODO: Previous state can be null.
var newState=void 0;if(workInProgress.updateQueue!==null){newState=processUpdateQueue(current,workInProgress,workInProgress.updateQueue,instance,newProps,renderExpirationTime);}else{newState=oldState;}if(oldProps===newProps&&oldState===newState&&!hasContextChanged()&&!(workInProgress.updateQueue!==null&&workInProgress.updateQueue.hasForceUpdate)){// If an update was already in progress, we should schedule an Update
// effect even though we're bailing out, so that cWU/cDU are called.
if(typeof instance.componentDidUpdate==='function'){if(oldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.effectTag|=Update;}}return false;}var shouldUpdate=checkShouldComponentUpdate(workInProgress,oldProps,newProps,oldState,newState,newContext);if(shouldUpdate){if(typeof instance.componentWillUpdate==='function'){startPhaseTimer(workInProgress,'componentWillUpdate');instance.componentWillUpdate(newProps,newState,newContext);stopPhaseTimer();// Simulate an async bailout/interruption by invoking lifecycle twice.
if(debugRenderPhaseSideEffects){instance.componentWillUpdate(newProps,newState,newContext);}}if(typeof instance.componentDidUpdate==='function'){workInProgress.effectTag|=Update;}}else{// If an update was already in progress, we should schedule an Update
// effect even though we're bailing out, so that cWU/cDU are called.
if(typeof instance.componentDidUpdate==='function'){if(oldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.effectTag|=Update;}}// If shouldComponentUpdate returned false, we should still update the
// memoized props/state to indicate that this work can be reused.
memoizeProps(workInProgress,newProps);memoizeState(workInProgress,newState);}// Update the existing instance's state, props, and context pointers even
// if shouldComponentUpdate returns false.
instance.props=newProps;instance.state=newState;instance.context=newContext;return shouldUpdate;}return{adoptClassInstance:adoptClassInstance,constructClassInstance:constructClassInstance,mountClassInstance:mountClassInstance,// resumeMountClassInstance,
updateClassInstance:updateClassInstance};};// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol=typeof Symbol==='function'&&Symbol['for'];var REACT_ELEMENT_TYPE=hasSymbol?Symbol['for']('react.element'):0xeac7;var REACT_CALL_TYPE=hasSymbol?Symbol['for']('react.call'):0xeac8;var REACT_RETURN_TYPE=hasSymbol?Symbol['for']('react.return'):0xeac9;var REACT_PORTAL_TYPE=hasSymbol?Symbol['for']('react.portal'):0xeaca;var REACT_FRAGMENT_TYPE=hasSymbol?Symbol['for']('react.fragment'):0xeacb;var MAYBE_ITERATOR_SYMBOL=typeof Symbol==='function'&&Symbol.iterator;var FAUX_ITERATOR_SYMBOL='@@iterator';function getIteratorFn(maybeIterable){if(maybeIterable===null||typeof maybeIterable==='undefined'){return null;}var maybeIterator=MAYBE_ITERATOR_SYMBOL&&maybeIterable[MAYBE_ITERATOR_SYMBOL]||maybeIterable[FAUX_ITERATOR_SYMBOL];if(typeof maybeIterator==='function'){return maybeIterator;}return null;}var getCurrentFiberStackAddendum$1=ReactDebugCurrentFiber.getCurrentFiberStackAddendum;{var didWarnAboutMaps=false;/**
   * Warn if there's no key explicitly set on dynamic arrays of children or
   * object keys are not valid. This allows us to keep track of children between
   * updates.
   */var ownerHasKeyUseWarning={};var ownerHasFunctionTypeWarning={};var warnForMissingKey=function warnForMissingKey(child){if(child===null||(typeof child==='undefined'?'undefined':_typeof(child))!=='object'){return;}if(!child._store||child._store.validated||child.key!=null){return;}!(_typeof(child._store)==='object')?invariant(false,'React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.'):void 0;child._store.validated=true;var currentComponentErrorInfo='Each child in an array or iterator should have a unique '+'"key" prop. See https://fb.me/react-warning-keys for '+'more information.'+(getCurrentFiberStackAddendum$1()||'');if(ownerHasKeyUseWarning[currentComponentErrorInfo]){return;}ownerHasKeyUseWarning[currentComponentErrorInfo]=true;warning(false,'Each child in an array or iterator should have a unique '+'"key" prop. See https://fb.me/react-warning-keys for '+'more information.%s',getCurrentFiberStackAddendum$1());};}var isArray$1=Array.isArray;function coerceRef(current,element){var mixedRef=element.ref;if(mixedRef!==null&&typeof mixedRef!=='function'){if(element._owner){var owner=element._owner;var inst=void 0;if(owner){var ownerFiber=owner;!(ownerFiber.tag===ClassComponent)?invariant(false,'Stateless function components cannot have refs.'):void 0;inst=ownerFiber.stateNode;}!inst?invariant(false,'Missing owner for string ref %s. This error is likely caused by a bug in React. Please file an issue.',mixedRef):void 0;var stringRef=''+mixedRef;// Check if previous string ref matches new string ref
if(current!==null&&current.ref!==null&&current.ref._stringRef===stringRef){return current.ref;}var ref=function ref(value){var refs=inst.refs===emptyObject?inst.refs={}:inst.refs;if(value===null){delete refs[stringRef];}else{refs[stringRef]=value;}};ref._stringRef=stringRef;return ref;}else{!(typeof mixedRef==='string')?invariant(false,'Expected ref to be a function or a string.'):void 0;!element._owner?invariant(false,'Element ref was specified as a string (%s) but no owner was set. You may have multiple copies of React loaded. (details: https://fb.me/react-refs-must-have-owner).',mixedRef):void 0;}}return mixedRef;}function throwOnInvalidObjectType(returnFiber,newChild){if(returnFiber.type!=='textarea'){var addendum='';{addendum=' If you meant to render a collection of children, use an array '+'instead.'+(getCurrentFiberStackAddendum$1()||'');}invariant(false,'Objects are not valid as a React child (found: %s).%s',Object.prototype.toString.call(newChild)==='[object Object]'?'object with keys {'+Object.keys(newChild).join(', ')+'}':newChild,addendum);}}function warnOnFunctionType(){var currentComponentErrorInfo='Functions are not valid as a React child. This may happen if '+'you return a Component instead of <Component /> from render. '+'Or maybe you meant to call this function rather than return it.'+(getCurrentFiberStackAddendum$1()||'');if(ownerHasFunctionTypeWarning[currentComponentErrorInfo]){return;}ownerHasFunctionTypeWarning[currentComponentErrorInfo]=true;warning(false,'Functions are not valid as a React child. This may happen if '+'you return a Component instead of <Component /> from render. '+'Or maybe you meant to call this function rather than return it.%s',getCurrentFiberStackAddendum$1()||'');}// This wrapper function exists because I expect to clone the code in each path
// to be able to optimize each path individually by branching early. This needs
// a compiler or we can do it manually. Helpers that don't need this branching
// live outside of this function.
function ChildReconciler(shouldTrackSideEffects){function deleteChild(returnFiber,childToDelete){if(!shouldTrackSideEffects){// Noop.
return;}// Deletions are added in reversed order so we add it to the front.
// At this point, the return fiber's effect list is empty except for
// deletions, so we can just append the deletion to the list. The remaining
// effects aren't added until the complete phase. Once we implement
// resuming, this may not be true.
var last=returnFiber.lastEffect;if(last!==null){last.nextEffect=childToDelete;returnFiber.lastEffect=childToDelete;}else{returnFiber.firstEffect=returnFiber.lastEffect=childToDelete;}childToDelete.nextEffect=null;childToDelete.effectTag=Deletion;}function deleteRemainingChildren(returnFiber,currentFirstChild){if(!shouldTrackSideEffects){// Noop.
return null;}// TODO: For the shouldClone case, this could be micro-optimized a bit by
// assuming that after the first child we've already added everything.
var childToDelete=currentFirstChild;while(childToDelete!==null){deleteChild(returnFiber,childToDelete);childToDelete=childToDelete.sibling;}return null;}function mapRemainingChildren(returnFiber,currentFirstChild){// Add the remaining children to a temporary map so that we can find them by
// keys quickly. Implicit (null) keys get added to this set with their index
var existingChildren=new Map();var existingChild=currentFirstChild;while(existingChild!==null){if(existingChild.key!==null){existingChildren.set(existingChild.key,existingChild);}else{existingChildren.set(existingChild.index,existingChild);}existingChild=existingChild.sibling;}return existingChildren;}function useFiber(fiber,pendingProps,expirationTime){// We currently set sibling to null and index to 0 here because it is easy
// to forget to do before returning it. E.g. for the single child case.
var clone=createWorkInProgress(fiber,pendingProps,expirationTime);clone.index=0;clone.sibling=null;return clone;}function placeChild(newFiber,lastPlacedIndex,newIndex){newFiber.index=newIndex;if(!shouldTrackSideEffects){// Noop.
return lastPlacedIndex;}var current=newFiber.alternate;if(current!==null){var oldIndex=current.index;if(oldIndex<lastPlacedIndex){// This is a move.
newFiber.effectTag=Placement;return lastPlacedIndex;}else{// This item can stay in place.
return oldIndex;}}else{// This is an insertion.
newFiber.effectTag=Placement;return lastPlacedIndex;}}function placeSingleChild(newFiber){// This is simpler for the single child case. We only need to do a
// placement for inserting new children.
if(shouldTrackSideEffects&&newFiber.alternate===null){newFiber.effectTag=Placement;}return newFiber;}function updateTextNode(returnFiber,current,textContent,expirationTime){if(current===null||current.tag!==HostText){// Insert
var created=createFiberFromText(textContent,returnFiber.internalContextTag,expirationTime);created['return']=returnFiber;return created;}else{// Update
var existing=useFiber(current,textContent,expirationTime);existing['return']=returnFiber;return existing;}}function updateElement(returnFiber,current,element,expirationTime){if(current!==null&&current.type===element.type){// Move based on index
var existing=useFiber(current,element.props,expirationTime);existing.ref=coerceRef(current,element);existing['return']=returnFiber;{existing._debugSource=element._source;existing._debugOwner=element._owner;}return existing;}else{// Insert
var created=createFiberFromElement(element,returnFiber.internalContextTag,expirationTime);created.ref=coerceRef(current,element);created['return']=returnFiber;return created;}}function updateCall(returnFiber,current,call,expirationTime){// TODO: Should this also compare handler to determine whether to reuse?
if(current===null||current.tag!==CallComponent){// Insert
var created=createFiberFromCall(call,returnFiber.internalContextTag,expirationTime);created['return']=returnFiber;return created;}else{// Move based on index
var existing=useFiber(current,call,expirationTime);existing['return']=returnFiber;return existing;}}function updateReturn(returnFiber,current,returnNode,expirationTime){if(current===null||current.tag!==ReturnComponent){// Insert
var created=createFiberFromReturn(returnNode,returnFiber.internalContextTag,expirationTime);created.type=returnNode.value;created['return']=returnFiber;return created;}else{// Move based on index
var existing=useFiber(current,null,expirationTime);existing.type=returnNode.value;existing['return']=returnFiber;return existing;}}function updatePortal(returnFiber,current,portal,expirationTime){if(current===null||current.tag!==HostPortal||current.stateNode.containerInfo!==portal.containerInfo||current.stateNode.implementation!==portal.implementation){// Insert
var created=createFiberFromPortal(portal,returnFiber.internalContextTag,expirationTime);created['return']=returnFiber;return created;}else{// Update
var existing=useFiber(current,portal.children||[],expirationTime);existing['return']=returnFiber;return existing;}}function updateFragment(returnFiber,current,fragment,expirationTime,key){if(current===null||current.tag!==Fragment){// Insert
var created=createFiberFromFragment(fragment,returnFiber.internalContextTag,expirationTime,key);created['return']=returnFiber;return created;}else{// Update
var existing=useFiber(current,fragment,expirationTime);existing['return']=returnFiber;return existing;}}function createChild(returnFiber,newChild,expirationTime){if(typeof newChild==='string'||typeof newChild==='number'){// Text nodes don't have keys. If the previous node is implicitly keyed
// we can continue to replace it without aborting even if it is not a text
// node.
var created=createFiberFromText(''+newChild,returnFiber.internalContextTag,expirationTime);created['return']=returnFiber;return created;}if((typeof newChild==='undefined'?'undefined':_typeof(newChild))==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:{if(newChild.type===REACT_FRAGMENT_TYPE){var _created=createFiberFromFragment(newChild.props.children,returnFiber.internalContextTag,expirationTime,newChild.key);_created['return']=returnFiber;return _created;}else{var _created2=createFiberFromElement(newChild,returnFiber.internalContextTag,expirationTime);_created2.ref=coerceRef(null,newChild);_created2['return']=returnFiber;return _created2;}}case REACT_CALL_TYPE:{var _created3=createFiberFromCall(newChild,returnFiber.internalContextTag,expirationTime);_created3['return']=returnFiber;return _created3;}case REACT_RETURN_TYPE:{var _created4=createFiberFromReturn(newChild,returnFiber.internalContextTag,expirationTime);_created4.type=newChild.value;_created4['return']=returnFiber;return _created4;}case REACT_PORTAL_TYPE:{var _created5=createFiberFromPortal(newChild,returnFiber.internalContextTag,expirationTime);_created5['return']=returnFiber;return _created5;}}if(isArray$1(newChild)||getIteratorFn(newChild)){var _created6=createFiberFromFragment(newChild,returnFiber.internalContextTag,expirationTime,null);_created6['return']=returnFiber;return _created6;}throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType();}}return null;}function updateSlot(returnFiber,oldFiber,newChild,expirationTime){// Update the fiber if the keys match, otherwise return null.
var key=oldFiber!==null?oldFiber.key:null;if(typeof newChild==='string'||typeof newChild==='number'){// Text nodes don't have keys. If the previous node is implicitly keyed
// we can continue to replace it without aborting even if it is not a text
// node.
if(key!==null){return null;}return updateTextNode(returnFiber,oldFiber,''+newChild,expirationTime);}if((typeof newChild==='undefined'?'undefined':_typeof(newChild))==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:{if(newChild.key===key){if(newChild.type===REACT_FRAGMENT_TYPE){return updateFragment(returnFiber,oldFiber,newChild.props.children,expirationTime,key);}return updateElement(returnFiber,oldFiber,newChild,expirationTime);}else{return null;}}case REACT_CALL_TYPE:{if(newChild.key===key){return updateCall(returnFiber,oldFiber,newChild,expirationTime);}else{return null;}}case REACT_RETURN_TYPE:{// Returns don't have keys. If the previous node is implicitly keyed
// we can continue to replace it without aborting even if it is not a
// yield.
if(key===null){return updateReturn(returnFiber,oldFiber,newChild,expirationTime);}else{return null;}}case REACT_PORTAL_TYPE:{if(newChild.key===key){return updatePortal(returnFiber,oldFiber,newChild,expirationTime);}else{return null;}}}if(isArray$1(newChild)||getIteratorFn(newChild)){if(key!==null){return null;}return updateFragment(returnFiber,oldFiber,newChild,expirationTime,null);}throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType();}}return null;}function updateFromMap(existingChildren,returnFiber,newIdx,newChild,expirationTime){if(typeof newChild==='string'||typeof newChild==='number'){// Text nodes don't have keys, so we neither have to check the old nor
// new node for the key. If both are text nodes, they match.
var matchedFiber=existingChildren.get(newIdx)||null;return updateTextNode(returnFiber,matchedFiber,''+newChild,expirationTime);}if((typeof newChild==='undefined'?'undefined':_typeof(newChild))==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:{var _matchedFiber=existingChildren.get(newChild.key===null?newIdx:newChild.key)||null;if(newChild.type===REACT_FRAGMENT_TYPE){return updateFragment(returnFiber,_matchedFiber,newChild.props.children,expirationTime,newChild.key);}return updateElement(returnFiber,_matchedFiber,newChild,expirationTime);}case REACT_CALL_TYPE:{var _matchedFiber2=existingChildren.get(newChild.key===null?newIdx:newChild.key)||null;return updateCall(returnFiber,_matchedFiber2,newChild,expirationTime);}case REACT_RETURN_TYPE:{// Returns don't have keys, so we neither have to check the old nor
// new node for the key. If both are returns, they match.
var _matchedFiber3=existingChildren.get(newIdx)||null;return updateReturn(returnFiber,_matchedFiber3,newChild,expirationTime);}case REACT_PORTAL_TYPE:{var _matchedFiber4=existingChildren.get(newChild.key===null?newIdx:newChild.key)||null;return updatePortal(returnFiber,_matchedFiber4,newChild,expirationTime);}}if(isArray$1(newChild)||getIteratorFn(newChild)){var _matchedFiber5=existingChildren.get(newIdx)||null;return updateFragment(returnFiber,_matchedFiber5,newChild,expirationTime,null);}throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType();}}return null;}/**
   * Warns if there is a duplicate or missing key
   */function warnOnInvalidKey(child,knownKeys){{if((typeof child==='undefined'?'undefined':_typeof(child))!=='object'||child===null){return knownKeys;}switch(child.$$typeof){case REACT_ELEMENT_TYPE:case REACT_CALL_TYPE:case REACT_PORTAL_TYPE:warnForMissingKey(child);var key=child.key;if(typeof key!=='string'){break;}if(knownKeys===null){knownKeys=new Set();knownKeys.add(key);break;}if(!knownKeys.has(key)){knownKeys.add(key);break;}warning(false,'Encountered two children with the same key, `%s`. '+'Keys should be unique so that components maintain their identity '+'across updates. Non-unique keys may cause children to be '+'duplicated and/or omitted — the behavior is unsupported and '+'could change in a future version.%s',key,getCurrentFiberStackAddendum$1());break;default:break;}}return knownKeys;}function reconcileChildrenArray(returnFiber,currentFirstChild,newChildren,expirationTime){// This algorithm can't optimize by searching from boths ends since we
// don't have backpointers on fibers. I'm trying to see how far we can get
// with that model. If it ends up not being worth the tradeoffs, we can
// add it later.
// Even with a two ended optimization, we'd want to optimize for the case
// where there are few changes and brute force the comparison instead of
// going for the Map. It'd like to explore hitting that path first in
// forward-only mode and only go for the Map once we notice that we need
// lots of look ahead. This doesn't handle reversal as well as two ended
// search but that's unusual. Besides, for the two ended optimization to
// work on Iterables, we'd need to copy the whole set.
// In this first iteration, we'll just live with hitting the bad case
// (adding everything to a Map) in for every insert/move.
// If you change this code, also update reconcileChildrenIterator() which
// uses the same algorithm.
{// First, validate keys.
var knownKeys=null;for(var i=0;i<newChildren.length;i++){var child=newChildren[i];knownKeys=warnOnInvalidKey(child,knownKeys);}}var resultingFirstChild=null;var previousNewFiber=null;var oldFiber=currentFirstChild;var lastPlacedIndex=0;var newIdx=0;var nextOldFiber=null;for(;oldFiber!==null&&newIdx<newChildren.length;newIdx++){if(oldFiber.index>newIdx){nextOldFiber=oldFiber;oldFiber=null;}else{nextOldFiber=oldFiber.sibling;}var newFiber=updateSlot(returnFiber,oldFiber,newChildren[newIdx],expirationTime);if(newFiber===null){// TODO: This breaks on empty slots like null children. That's
// unfortunate because it triggers the slow path all the time. We need
// a better way to communicate whether this was a miss or null,
// boolean, undefined, etc.
if(oldFiber===null){oldFiber=nextOldFiber;}break;}if(shouldTrackSideEffects){if(oldFiber&&newFiber.alternate===null){// We matched the slot, but we didn't reuse the existing fiber, so we
// need to delete the existing child.
deleteChild(returnFiber,oldFiber);}}lastPlacedIndex=placeChild(newFiber,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.
resultingFirstChild=newFiber;}else{// TODO: Defer siblings if we're not at the right index for this slot.
// I.e. if we had null values before, then we want to defer this
// for each null value. However, we also don't want to call updateSlot
// with the previous one.
previousNewFiber.sibling=newFiber;}previousNewFiber=newFiber;oldFiber=nextOldFiber;}if(newIdx===newChildren.length){// We've reached the end of the new children. We can delete the rest.
deleteRemainingChildren(returnFiber,oldFiber);return resultingFirstChild;}if(oldFiber===null){// If we don't have any more existing children we can choose a fast path
// since the rest will all be insertions.
for(;newIdx<newChildren.length;newIdx++){var _newFiber=createChild(returnFiber,newChildren[newIdx],expirationTime);if(!_newFiber){continue;}lastPlacedIndex=placeChild(_newFiber,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.
resultingFirstChild=_newFiber;}else{previousNewFiber.sibling=_newFiber;}previousNewFiber=_newFiber;}return resultingFirstChild;}// Add all children to a key map for quick lookups.
var existingChildren=mapRemainingChildren(returnFiber,oldFiber);// Keep scanning and use the map to restore deleted items as moves.
for(;newIdx<newChildren.length;newIdx++){var _newFiber2=updateFromMap(existingChildren,returnFiber,newIdx,newChildren[newIdx],expirationTime);if(_newFiber2){if(shouldTrackSideEffects){if(_newFiber2.alternate!==null){// The new fiber is a work in progress, but if there exists a
// current, that means that we reused the fiber. We need to delete
// it from the child list so that we don't add it to the deletion
// list.
existingChildren['delete'](_newFiber2.key===null?newIdx:_newFiber2.key);}}lastPlacedIndex=placeChild(_newFiber2,lastPlacedIndex,newIdx);if(previousNewFiber===null){resultingFirstChild=_newFiber2;}else{previousNewFiber.sibling=_newFiber2;}previousNewFiber=_newFiber2;}}if(shouldTrackSideEffects){// Any existing children that weren't consumed above were deleted. We need
// to add them to the deletion list.
existingChildren.forEach(function(child){return deleteChild(returnFiber,child);});}return resultingFirstChild;}function reconcileChildrenIterator(returnFiber,currentFirstChild,newChildrenIterable,expirationTime){// This is the same implementation as reconcileChildrenArray(),
// but using the iterator instead.
var iteratorFn=getIteratorFn(newChildrenIterable);!(typeof iteratorFn==='function')?invariant(false,'An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.'):void 0;{// Warn about using Maps as children
if(typeof newChildrenIterable.entries==='function'){var possibleMap=newChildrenIterable;if(possibleMap.entries===iteratorFn){warning(didWarnAboutMaps,'Using Maps as children is unsupported and will likely yield '+'unexpected results. Convert it to a sequence/iterable of keyed '+'ReactElements instead.%s',getCurrentFiberStackAddendum$1());didWarnAboutMaps=true;}}// First, validate keys.
// We'll get a different iterator later for the main pass.
var _newChildren=iteratorFn.call(newChildrenIterable);if(_newChildren){var knownKeys=null;var _step=_newChildren.next();for(;!_step.done;_step=_newChildren.next()){var child=_step.value;knownKeys=warnOnInvalidKey(child,knownKeys);}}}var newChildren=iteratorFn.call(newChildrenIterable);!(newChildren!=null)?invariant(false,'An iterable object provided no iterator.'):void 0;var resultingFirstChild=null;var previousNewFiber=null;var oldFiber=currentFirstChild;var lastPlacedIndex=0;var newIdx=0;var nextOldFiber=null;var step=newChildren.next();for(;oldFiber!==null&&!step.done;newIdx++,step=newChildren.next()){if(oldFiber.index>newIdx){nextOldFiber=oldFiber;oldFiber=null;}else{nextOldFiber=oldFiber.sibling;}var newFiber=updateSlot(returnFiber,oldFiber,step.value,expirationTime);if(newFiber===null){// TODO: This breaks on empty slots like null children. That's
// unfortunate because it triggers the slow path all the time. We need
// a better way to communicate whether this was a miss or null,
// boolean, undefined, etc.
if(!oldFiber){oldFiber=nextOldFiber;}break;}if(shouldTrackSideEffects){if(oldFiber&&newFiber.alternate===null){// We matched the slot, but we didn't reuse the existing fiber, so we
// need to delete the existing child.
deleteChild(returnFiber,oldFiber);}}lastPlacedIndex=placeChild(newFiber,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.
resultingFirstChild=newFiber;}else{// TODO: Defer siblings if we're not at the right index for this slot.
// I.e. if we had null values before, then we want to defer this
// for each null value. However, we also don't want to call updateSlot
// with the previous one.
previousNewFiber.sibling=newFiber;}previousNewFiber=newFiber;oldFiber=nextOldFiber;}if(step.done){// We've reached the end of the new children. We can delete the rest.
deleteRemainingChildren(returnFiber,oldFiber);return resultingFirstChild;}if(oldFiber===null){// If we don't have any more existing children we can choose a fast path
// since the rest will all be insertions.
for(;!step.done;newIdx++,step=newChildren.next()){var _newFiber3=createChild(returnFiber,step.value,expirationTime);if(_newFiber3===null){continue;}lastPlacedIndex=placeChild(_newFiber3,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.
resultingFirstChild=_newFiber3;}else{previousNewFiber.sibling=_newFiber3;}previousNewFiber=_newFiber3;}return resultingFirstChild;}// Add all children to a key map for quick lookups.
var existingChildren=mapRemainingChildren(returnFiber,oldFiber);// Keep scanning and use the map to restore deleted items as moves.
for(;!step.done;newIdx++,step=newChildren.next()){var _newFiber4=updateFromMap(existingChildren,returnFiber,newIdx,step.value,expirationTime);if(_newFiber4!==null){if(shouldTrackSideEffects){if(_newFiber4.alternate!==null){// The new fiber is a work in progress, but if there exists a
// current, that means that we reused the fiber. We need to delete
// it from the child list so that we don't add it to the deletion
// list.
existingChildren['delete'](_newFiber4.key===null?newIdx:_newFiber4.key);}}lastPlacedIndex=placeChild(_newFiber4,lastPlacedIndex,newIdx);if(previousNewFiber===null){resultingFirstChild=_newFiber4;}else{previousNewFiber.sibling=_newFiber4;}previousNewFiber=_newFiber4;}}if(shouldTrackSideEffects){// Any existing children that weren't consumed above were deleted. We need
// to add them to the deletion list.
existingChildren.forEach(function(child){return deleteChild(returnFiber,child);});}return resultingFirstChild;}function reconcileSingleTextNode(returnFiber,currentFirstChild,textContent,expirationTime){// There's no need to check for keys on text nodes since we don't have a
// way to define them.
if(currentFirstChild!==null&&currentFirstChild.tag===HostText){// We already have an existing node so let's just update it and delete
// the rest.
deleteRemainingChildren(returnFiber,currentFirstChild.sibling);var existing=useFiber(currentFirstChild,textContent,expirationTime);existing['return']=returnFiber;return existing;}// The existing first child is not a text node so we need to create one
// and delete the existing ones.
deleteRemainingChildren(returnFiber,currentFirstChild);var created=createFiberFromText(textContent,returnFiber.internalContextTag,expirationTime);created['return']=returnFiber;return created;}function reconcileSingleElement(returnFiber,currentFirstChild,element,expirationTime){var key=element.key;var child=currentFirstChild;while(child!==null){// TODO: If key === null and child.key === null, then this only applies to
// the first item in the list.
if(child.key===key){if(child.tag===Fragment?element.type===REACT_FRAGMENT_TYPE:child.type===element.type){deleteRemainingChildren(returnFiber,child.sibling);var existing=useFiber(child,element.type===REACT_FRAGMENT_TYPE?element.props.children:element.props,expirationTime);existing.ref=coerceRef(child,element);existing['return']=returnFiber;{existing._debugSource=element._source;existing._debugOwner=element._owner;}return existing;}else{deleteRemainingChildren(returnFiber,child);break;}}else{deleteChild(returnFiber,child);}child=child.sibling;}if(element.type===REACT_FRAGMENT_TYPE){var created=createFiberFromFragment(element.props.children,returnFiber.internalContextTag,expirationTime,element.key);created['return']=returnFiber;return created;}else{var _created7=createFiberFromElement(element,returnFiber.internalContextTag,expirationTime);_created7.ref=coerceRef(currentFirstChild,element);_created7['return']=returnFiber;return _created7;}}function reconcileSingleCall(returnFiber,currentFirstChild,call,expirationTime){var key=call.key;var child=currentFirstChild;while(child!==null){// TODO: If key === null and child.key === null, then this only applies to
// the first item in the list.
if(child.key===key){if(child.tag===CallComponent){deleteRemainingChildren(returnFiber,child.sibling);var existing=useFiber(child,call,expirationTime);existing['return']=returnFiber;return existing;}else{deleteRemainingChildren(returnFiber,child);break;}}else{deleteChild(returnFiber,child);}child=child.sibling;}var created=createFiberFromCall(call,returnFiber.internalContextTag,expirationTime);created['return']=returnFiber;return created;}function reconcileSingleReturn(returnFiber,currentFirstChild,returnNode,expirationTime){// There's no need to check for keys on yields since they're stateless.
var child=currentFirstChild;if(child!==null){if(child.tag===ReturnComponent){deleteRemainingChildren(returnFiber,child.sibling);var existing=useFiber(child,null,expirationTime);existing.type=returnNode.value;existing['return']=returnFiber;return existing;}else{deleteRemainingChildren(returnFiber,child);}}var created=createFiberFromReturn(returnNode,returnFiber.internalContextTag,expirationTime);created.type=returnNode.value;created['return']=returnFiber;return created;}function reconcileSinglePortal(returnFiber,currentFirstChild,portal,expirationTime){var key=portal.key;var child=currentFirstChild;while(child!==null){// TODO: If key === null and child.key === null, then this only applies to
// the first item in the list.
if(child.key===key){if(child.tag===HostPortal&&child.stateNode.containerInfo===portal.containerInfo&&child.stateNode.implementation===portal.implementation){deleteRemainingChildren(returnFiber,child.sibling);var existing=useFiber(child,portal.children||[],expirationTime);existing['return']=returnFiber;return existing;}else{deleteRemainingChildren(returnFiber,child);break;}}else{deleteChild(returnFiber,child);}child=child.sibling;}var created=createFiberFromPortal(portal,returnFiber.internalContextTag,expirationTime);created['return']=returnFiber;return created;}// This API will tag the children with the side-effect of the reconciliation
// itself. They will be added to the side-effect list as we pass through the
// children and the parent.
function reconcileChildFibers(returnFiber,currentFirstChild,newChild,expirationTime){// This function is not recursive.
// If the top level item is an array, we treat it as a set of children,
// not as a fragment. Nested arrays on the other hand will be treated as
// fragment nodes. Recursion happens at the normal flow.
// Handle top level unkeyed fragments as if they were arrays.
// This leads to an ambiguity between <>{[...]}</> and <>...</>.
// We treat the ambiguous cases above the same.
if((typeof newChild==='undefined'?'undefined':_typeof(newChild))==='object'&&newChild!==null&&newChild.type===REACT_FRAGMENT_TYPE&&newChild.key===null){newChild=newChild.props.children;}// Handle object types
var isObject=(typeof newChild==='undefined'?'undefined':_typeof(newChild))==='object'&&newChild!==null;if(isObject){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:return placeSingleChild(reconcileSingleElement(returnFiber,currentFirstChild,newChild,expirationTime));case REACT_CALL_TYPE:return placeSingleChild(reconcileSingleCall(returnFiber,currentFirstChild,newChild,expirationTime));case REACT_RETURN_TYPE:return placeSingleChild(reconcileSingleReturn(returnFiber,currentFirstChild,newChild,expirationTime));case REACT_PORTAL_TYPE:return placeSingleChild(reconcileSinglePortal(returnFiber,currentFirstChild,newChild,expirationTime));}}if(typeof newChild==='string'||typeof newChild==='number'){return placeSingleChild(reconcileSingleTextNode(returnFiber,currentFirstChild,''+newChild,expirationTime));}if(isArray$1(newChild)){return reconcileChildrenArray(returnFiber,currentFirstChild,newChild,expirationTime);}if(getIteratorFn(newChild)){return reconcileChildrenIterator(returnFiber,currentFirstChild,newChild,expirationTime);}if(isObject){throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType();}}if(typeof newChild==='undefined'){// If the new child is undefined, and the return fiber is a composite
// component, throw an error. If Fiber return types are disabled,
// we already threw above.
switch(returnFiber.tag){case ClassComponent:{{var instance=returnFiber.stateNode;if(instance.render._isMockFunction){// We allow auto-mocks to proceed as if they're returning null.
break;}}}// Intentionally fall through to the next case, which handles both
// functions and classes
// eslint-disable-next-lined no-fallthrough
case FunctionalComponent:{var Component=returnFiber.type;invariant(false,'%s(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.',Component.displayName||Component.name||'Component');}}}// Remaining cases are all treated as empty.
return deleteRemainingChildren(returnFiber,currentFirstChild);}return reconcileChildFibers;}var reconcileChildFibers=ChildReconciler(true);var mountChildFibers=ChildReconciler(false);function cloneChildFibers(current,workInProgress){!(current===null||workInProgress.child===current.child)?invariant(false,'Resuming work not yet implemented.'):void 0;if(workInProgress.child===null){return;}var currentChild=workInProgress.child;var newChild=createWorkInProgress(currentChild,currentChild.pendingProps,currentChild.expirationTime);workInProgress.child=newChild;newChild['return']=workInProgress;while(currentChild.sibling!==null){currentChild=currentChild.sibling;newChild=newChild.sibling=createWorkInProgress(currentChild,currentChild.pendingProps,currentChild.expirationTime);newChild['return']=workInProgress;}newChild.sibling=null;}{var warnedAboutStatelessRefs={};}var ReactFiberBeginWork=function ReactFiberBeginWork(config,hostContext,hydrationContext,scheduleWork,computeExpirationForFiber){var shouldSetTextContent=config.shouldSetTextContent,useSyncScheduling=config.useSyncScheduling,shouldDeprioritizeSubtree=config.shouldDeprioritizeSubtree;var pushHostContext=hostContext.pushHostContext,pushHostContainer=hostContext.pushHostContainer;var enterHydrationState=hydrationContext.enterHydrationState,resetHydrationState=hydrationContext.resetHydrationState,tryToClaimNextHydratableInstance=hydrationContext.tryToClaimNextHydratableInstance;var _ReactFiberClassCompo=ReactFiberClassComponent(scheduleWork,computeExpirationForFiber,memoizeProps,memoizeState),adoptClassInstance=_ReactFiberClassCompo.adoptClassInstance,constructClassInstance=_ReactFiberClassCompo.constructClassInstance,mountClassInstance=_ReactFiberClassCompo.mountClassInstance,updateClassInstance=_ReactFiberClassCompo.updateClassInstance;// TODO: Remove this and use reconcileChildrenAtExpirationTime directly.
function reconcileChildren(current,workInProgress,nextChildren){reconcileChildrenAtExpirationTime(current,workInProgress,nextChildren,workInProgress.expirationTime);}function reconcileChildrenAtExpirationTime(current,workInProgress,nextChildren,renderExpirationTime){if(current===null){// If this is a fresh new component that hasn't been rendered yet, we
// won't update its child set by applying minimal side-effects. Instead,
// we will add them all to the child before it gets rendered. That means
// we can optimize this reconciliation pass by not tracking side-effects.
workInProgress.child=mountChildFibers(workInProgress,null,nextChildren,renderExpirationTime);}else{// If the current child is the same as the work in progress, it means that
// we haven't yet started any work on these children. Therefore, we use
// the clone algorithm to create a copy of all the current children.
// If we had any progressed work already, that is invalid at this point so
// let's throw it out.
workInProgress.child=reconcileChildFibers(workInProgress,current.child,nextChildren,renderExpirationTime);}}function updateFragment(current,workInProgress){var nextChildren=workInProgress.pendingProps;if(hasContextChanged()){// Normally we can bail out on props equality but if context has changed
// we don't do the bailout and we have to reuse existing props instead.
if(nextChildren===null){nextChildren=workInProgress.memoizedProps;}}else if(nextChildren===null||workInProgress.memoizedProps===nextChildren){return bailoutOnAlreadyFinishedWork(current,workInProgress);}reconcileChildren(current,workInProgress,nextChildren);memoizeProps(workInProgress,nextChildren);return workInProgress.child;}function markRef(current,workInProgress){var ref=workInProgress.ref;if(ref!==null&&(!current||current.ref!==ref)){// Schedule a Ref effect
workInProgress.effectTag|=Ref;}}function updateFunctionalComponent(current,workInProgress){var fn=workInProgress.type;var nextProps=workInProgress.pendingProps;var memoizedProps=workInProgress.memoizedProps;if(hasContextChanged()){// Normally we can bail out on props equality but if context has changed
// we don't do the bailout and we have to reuse existing props instead.
if(nextProps===null){nextProps=memoizedProps;}}else{if(nextProps===null||memoizedProps===nextProps){return bailoutOnAlreadyFinishedWork(current,workInProgress);}// TODO: consider bringing fn.shouldComponentUpdate() back.
// It used to be here.
}var unmaskedContext=getUnmaskedContext(workInProgress);var context=getMaskedContext(workInProgress,unmaskedContext);var nextChildren;{ReactCurrentOwner.current=workInProgress;ReactDebugCurrentFiber.setCurrentPhase('render');nextChildren=fn(nextProps,context);ReactDebugCurrentFiber.setCurrentPhase(null);}// React DevTools reads this flag.
workInProgress.effectTag|=PerformedWork;reconcileChildren(current,workInProgress,nextChildren);memoizeProps(workInProgress,nextProps);return workInProgress.child;}function updateClassComponent(current,workInProgress,renderExpirationTime){// Push context providers early to prevent context stack mismatches.
// During mounting we don't know the child context yet as the instance doesn't exist.
// We will invalidate the child context in finishClassComponent() right after rendering.
var hasContext=pushContextProvider(workInProgress);var shouldUpdate=void 0;if(current===null){if(!workInProgress.stateNode){// In the initial pass we might need to construct the instance.
constructClassInstance(workInProgress,workInProgress.pendingProps);mountClassInstance(workInProgress,renderExpirationTime);shouldUpdate=true;}else{invariant(false,'Resuming work not yet implemented.');// In a resume, we'll already have an instance we can reuse.
// shouldUpdate = resumeMountClassInstance(workInProgress, renderExpirationTime);
}}else{shouldUpdate=updateClassInstance(current,workInProgress,renderExpirationTime);}return finishClassComponent(current,workInProgress,shouldUpdate,hasContext);}function finishClassComponent(current,workInProgress,shouldUpdate,hasContext){// Refs should update even if shouldComponentUpdate returns false
markRef(current,workInProgress);if(!shouldUpdate){// Context providers should defer to sCU for rendering
if(hasContext){invalidateContextProvider(workInProgress,false);}return bailoutOnAlreadyFinishedWork(current,workInProgress);}var instance=workInProgress.stateNode;// Rerender
ReactCurrentOwner.current=workInProgress;var nextChildren=void 0;{ReactDebugCurrentFiber.setCurrentPhase('render');nextChildren=instance.render();if(debugRenderPhaseSideEffects){instance.render();}ReactDebugCurrentFiber.setCurrentPhase(null);}// React DevTools reads this flag.
workInProgress.effectTag|=PerformedWork;reconcileChildren(current,workInProgress,nextChildren);// Memoize props and state using the values we just used to render.
// TODO: Restructure so we never read values from the instance.
memoizeState(workInProgress,instance.state);memoizeProps(workInProgress,instance.props);// The context might have changed so we need to recalculate it.
if(hasContext){invalidateContextProvider(workInProgress,true);}return workInProgress.child;}function pushHostRootContext(workInProgress){var root=workInProgress.stateNode;if(root.pendingContext){pushTopLevelContextObject(workInProgress,root.pendingContext,root.pendingContext!==root.context);}else if(root.context){// Should always be set
pushTopLevelContextObject(workInProgress,root.context,false);}pushHostContainer(workInProgress,root.containerInfo);}function updateHostRoot(current,workInProgress,renderExpirationTime){pushHostRootContext(workInProgress);var updateQueue=workInProgress.updateQueue;if(updateQueue!==null){var prevState=workInProgress.memoizedState;var state=processUpdateQueue(current,workInProgress,updateQueue,null,null,renderExpirationTime);if(prevState===state){// If the state is the same as before, that's a bailout because we had
// no work that expires at this time.
resetHydrationState();return bailoutOnAlreadyFinishedWork(current,workInProgress);}var element=state.element;var root=workInProgress.stateNode;if((current===null||current.child===null)&&root.hydrate&&enterHydrationState(workInProgress)){// If we don't have any current children this might be the first pass.
// We always try to hydrate. If this isn't a hydration pass there won't
// be any children to hydrate which is effectively the same thing as
// not hydrating.
// This is a bit of a hack. We track the host root as a placement to
// know that we're currently in a mounting state. That way isMounted
// works as expected. We must reset this before committing.
// TODO: Delete this when we delete isMounted and findDOMNode.
workInProgress.effectTag|=Placement;// Ensure that children mount into this root without tracking
// side-effects. This ensures that we don't store Placement effects on
// nodes that will be hydrated.
workInProgress.child=mountChildFibers(workInProgress,null,element,renderExpirationTime);}else{// Otherwise reset hydration state in case we aborted and resumed another
// root.
resetHydrationState();reconcileChildren(current,workInProgress,element);}memoizeState(workInProgress,state);return workInProgress.child;}resetHydrationState();// If there is no update queue, that's a bailout because the root has no props.
return bailoutOnAlreadyFinishedWork(current,workInProgress);}function updateHostComponent(current,workInProgress,renderExpirationTime){pushHostContext(workInProgress);if(current===null){tryToClaimNextHydratableInstance(workInProgress);}var type=workInProgress.type;var memoizedProps=workInProgress.memoizedProps;var nextProps=workInProgress.pendingProps;if(nextProps===null){nextProps=memoizedProps;!(nextProps!==null)?invariant(false,'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.'):void 0;}var prevProps=current!==null?current.memoizedProps:null;if(hasContextChanged()){// Normally we can bail out on props equality but if context has changed
// we don't do the bailout and we have to reuse existing props instead.
}else if(nextProps===null||memoizedProps===nextProps){return bailoutOnAlreadyFinishedWork(current,workInProgress);}var nextChildren=nextProps.children;var isDirectTextChild=shouldSetTextContent(type,nextProps);if(isDirectTextChild){// We special case a direct text child of a host node. This is a common
// case. We won't handle it as a reified child. We will instead handle
// this in the host environment that also have access to this prop. That
// avoids allocating another HostText fiber and traversing it.
nextChildren=null;}else if(prevProps&&shouldSetTextContent(type,prevProps)){// If we're switching from a direct text child to a normal child, or to
// empty, we need to schedule the text content to be reset.
workInProgress.effectTag|=ContentReset;}markRef(current,workInProgress);// Check the host config to see if the children are offscreen/hidden.
if(renderExpirationTime!==Never&&!useSyncScheduling&&shouldDeprioritizeSubtree(type,nextProps)){// Down-prioritize the children.
workInProgress.expirationTime=Never;// Bailout and come back to this fiber later.
return null;}reconcileChildren(current,workInProgress,nextChildren);memoizeProps(workInProgress,nextProps);return workInProgress.child;}function updateHostText(current,workInProgress){if(current===null){tryToClaimNextHydratableInstance(workInProgress);}var nextProps=workInProgress.pendingProps;if(nextProps===null){nextProps=workInProgress.memoizedProps;}memoizeProps(workInProgress,nextProps);// Nothing to do here. This is terminal. We'll do the completion step
// immediately after.
return null;}function mountIndeterminateComponent(current,workInProgress,renderExpirationTime){!(current===null)?invariant(false,'An indeterminate component should never have mounted. This error is likely caused by a bug in React. Please file an issue.'):void 0;var fn=workInProgress.type;var props=workInProgress.pendingProps;var unmaskedContext=getUnmaskedContext(workInProgress);var context=getMaskedContext(workInProgress,unmaskedContext);var value;{if(fn.prototype&&typeof fn.prototype.render==='function'){var componentName=getComponentName(workInProgress);warning(false,"The <%s /> component appears to have a render method, but doesn't extend React.Component. "+'This is likely to cause errors. Change %s to extend React.Component instead.',componentName,componentName);}ReactCurrentOwner.current=workInProgress;value=fn(props,context);}// React DevTools reads this flag.
workInProgress.effectTag|=PerformedWork;if((typeof value==='undefined'?'undefined':_typeof(value))==='object'&&value!==null&&typeof value.render==='function'){// Proceed under the assumption that this is a class instance
workInProgress.tag=ClassComponent;// Push context providers early to prevent context stack mismatches.
// During mounting we don't know the child context yet as the instance doesn't exist.
// We will invalidate the child context in finishClassComponent() right after rendering.
var hasContext=pushContextProvider(workInProgress);adoptClassInstance(workInProgress,value);mountClassInstance(workInProgress,renderExpirationTime);return finishClassComponent(current,workInProgress,true,hasContext);}else{// Proceed under the assumption that this is a functional component
workInProgress.tag=FunctionalComponent;{var Component=workInProgress.type;if(Component){warning(!Component.childContextTypes,'%s(...): childContextTypes cannot be defined on a functional component.',Component.displayName||Component.name||'Component');}if(workInProgress.ref!==null){var info='';var ownerName=ReactDebugCurrentFiber.getCurrentFiberOwnerName();if(ownerName){info+='\n\nCheck the render method of `'+ownerName+'`.';}var warningKey=ownerName||workInProgress._debugID||'';var debugSource=workInProgress._debugSource;if(debugSource){warningKey=debugSource.fileName+':'+debugSource.lineNumber;}if(!warnedAboutStatelessRefs[warningKey]){warnedAboutStatelessRefs[warningKey]=true;warning(false,'Stateless function components cannot be given refs. '+'Attempts to access this ref will fail.%s%s',info,ReactDebugCurrentFiber.getCurrentFiberStackAddendum());}}}reconcileChildren(current,workInProgress,value);memoizeProps(workInProgress,props);return workInProgress.child;}}function updateCallComponent(current,workInProgress,renderExpirationTime){var nextCall=workInProgress.pendingProps;if(hasContextChanged()){// Normally we can bail out on props equality but if context has changed
// we don't do the bailout and we have to reuse existing props instead.
if(nextCall===null){nextCall=current&&current.memoizedProps;!(nextCall!==null)?invariant(false,'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.'):void 0;}}else if(nextCall===null||workInProgress.memoizedProps===nextCall){nextCall=workInProgress.memoizedProps;// TODO: When bailing out, we might need to return the stateNode instead
// of the child. To check it for work.
// return bailoutOnAlreadyFinishedWork(current, workInProgress);
}var nextChildren=nextCall.children;// The following is a fork of reconcileChildrenAtExpirationTime but using
// stateNode to store the child.
if(current===null){workInProgress.stateNode=mountChildFibers(workInProgress,workInProgress.stateNode,nextChildren,renderExpirationTime);}else{workInProgress.stateNode=reconcileChildFibers(workInProgress,workInProgress.stateNode,nextChildren,renderExpirationTime);}memoizeProps(workInProgress,nextCall);// This doesn't take arbitrary time so we could synchronously just begin
// eagerly do the work of workInProgress.child as an optimization.
return workInProgress.stateNode;}function updatePortalComponent(current,workInProgress,renderExpirationTime){pushHostContainer(workInProgress,workInProgress.stateNode.containerInfo);var nextChildren=workInProgress.pendingProps;if(hasContextChanged()){// Normally we can bail out on props equality but if context has changed
// we don't do the bailout and we have to reuse existing props instead.
if(nextChildren===null){nextChildren=current&&current.memoizedProps;!(nextChildren!=null)?invariant(false,'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.'):void 0;}}else if(nextChildren===null||workInProgress.memoizedProps===nextChildren){return bailoutOnAlreadyFinishedWork(current,workInProgress);}if(current===null){// Portals are special because we don't append the children during mount
// but at commit. Therefore we need to track insertions which the normal
// flow doesn't do during mount. This doesn't happen at the root because
// the root always starts with a "current" with a null child.
// TODO: Consider unifying this with how the root works.
workInProgress.child=reconcileChildFibers(workInProgress,null,nextChildren,renderExpirationTime);memoizeProps(workInProgress,nextChildren);}else{reconcileChildren(current,workInProgress,nextChildren);memoizeProps(workInProgress,nextChildren);}return workInProgress.child;}/*
  function reuseChildrenEffects(returnFiber : Fiber, firstChild : Fiber) {
    let child = firstChild;
    do {
      // Ensure that the first and last effect of the parent corresponds
      // to the children's first and last effect.
      if (!returnFiber.firstEffect) {
        returnFiber.firstEffect = child.firstEffect;
      }
      if (child.lastEffect) {
        if (returnFiber.lastEffect) {
          returnFiber.lastEffect.nextEffect = child.firstEffect;
        }
        returnFiber.lastEffect = child.lastEffect;
      }
    } while (child = child.sibling);
  }
  */function bailoutOnAlreadyFinishedWork(current,workInProgress){cancelWorkTimer(workInProgress);// TODO: We should ideally be able to bail out early if the children have no
// more work to do. However, since we don't have a separation of this
// Fiber's priority and its children yet - we don't know without doing lots
// of the same work we do anyway. Once we have that separation we can just
// bail out here if the children has no more work at this priority level.
// if (workInProgress.priorityOfChildren <= priorityLevel) {
//   // If there are side-effects in these children that have not yet been
//   // committed we need to ensure that they get properly transferred up.
//   if (current && current.child !== workInProgress.child) {
//     reuseChildrenEffects(workInProgress, child);
//   }
//   return null;
// }
cloneChildFibers(current,workInProgress);return workInProgress.child;}function bailoutOnLowPriority(current,workInProgress){cancelWorkTimer(workInProgress);// TODO: Handle HostComponent tags here as well and call pushHostContext()?
// See PR 8590 discussion for context
switch(workInProgress.tag){case HostRoot:pushHostRootContext(workInProgress);break;case ClassComponent:pushContextProvider(workInProgress);break;case HostPortal:pushHostContainer(workInProgress,workInProgress.stateNode.containerInfo);break;}// TODO: What if this is currently in progress?
// How can that happen? How is this not being cloned?
return null;}// TODO: Delete memoizeProps/State and move to reconcile/bailout instead
function memoizeProps(workInProgress,nextProps){workInProgress.memoizedProps=nextProps;}function memoizeState(workInProgress,nextState){workInProgress.memoizedState=nextState;// Don't reset the updateQueue, in case there are pending updates. Resetting
// is handled by processUpdateQueue.
}function beginWork(current,workInProgress,renderExpirationTime){if(workInProgress.expirationTime===NoWork||workInProgress.expirationTime>renderExpirationTime){return bailoutOnLowPriority(current,workInProgress);}switch(workInProgress.tag){case IndeterminateComponent:return mountIndeterminateComponent(current,workInProgress,renderExpirationTime);case FunctionalComponent:return updateFunctionalComponent(current,workInProgress);case ClassComponent:return updateClassComponent(current,workInProgress,renderExpirationTime);case HostRoot:return updateHostRoot(current,workInProgress,renderExpirationTime);case HostComponent:return updateHostComponent(current,workInProgress,renderExpirationTime);case HostText:return updateHostText(current,workInProgress);case CallHandlerPhase:// This is a restart. Reset the tag to the initial phase.
workInProgress.tag=CallComponent;// Intentionally fall through since this is now the same.
case CallComponent:return updateCallComponent(current,workInProgress,renderExpirationTime);case ReturnComponent:// A return component is just a placeholder, we can just run through the
// next one immediately.
return null;case HostPortal:return updatePortalComponent(current,workInProgress,renderExpirationTime);case Fragment:return updateFragment(current,workInProgress);default:invariant(false,'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');}}function beginFailedWork(current,workInProgress,renderExpirationTime){// Push context providers here to avoid a push/pop context mismatch.
switch(workInProgress.tag){case ClassComponent:pushContextProvider(workInProgress);break;case HostRoot:pushHostRootContext(workInProgress);break;default:invariant(false,'Invalid type of work. This error is likely caused by a bug in React. Please file an issue.');}// Add an error effect so we can handle the error during the commit phase
workInProgress.effectTag|=Err;// This is a weird case where we do "resume" work — work that failed on
// our first attempt. Because we no longer have a notion of "progressed
// deletions," reset the child to the current child to make sure we delete
// it again. TODO: Find a better way to handle this, perhaps during a more
// general overhaul of error handling.
if(current===null){workInProgress.child=null;}else if(workInProgress.child!==current.child){workInProgress.child=current.child;}if(workInProgress.expirationTime===NoWork||workInProgress.expirationTime>renderExpirationTime){return bailoutOnLowPriority(current,workInProgress);}// If we don't bail out, we're going be recomputing our children so we need
// to drop our effect list.
workInProgress.firstEffect=null;workInProgress.lastEffect=null;// Unmount the current children as if the component rendered null
var nextChildren=null;reconcileChildrenAtExpirationTime(current,workInProgress,nextChildren,renderExpirationTime);if(workInProgress.tag===ClassComponent){var instance=workInProgress.stateNode;workInProgress.memoizedProps=instance.props;workInProgress.memoizedState=instance.state;}return workInProgress.child;}return{beginWork:beginWork,beginFailedWork:beginFailedWork};};var ReactFiberCompleteWork=function ReactFiberCompleteWork(config,hostContext,hydrationContext){var createInstance=config.createInstance,createTextInstance=config.createTextInstance,appendInitialChild=config.appendInitialChild,finalizeInitialChildren=config.finalizeInitialChildren,prepareUpdate=config.prepareUpdate,mutation=config.mutation,persistence=config.persistence;var getRootHostContainer=hostContext.getRootHostContainer,popHostContext=hostContext.popHostContext,getHostContext=hostContext.getHostContext,popHostContainer=hostContext.popHostContainer;var prepareToHydrateHostInstance=hydrationContext.prepareToHydrateHostInstance,prepareToHydrateHostTextInstance=hydrationContext.prepareToHydrateHostTextInstance,popHydrationState=hydrationContext.popHydrationState;function markUpdate(workInProgress){// Tag the fiber with an update effect. This turns a Placement into
// an UpdateAndPlacement.
workInProgress.effectTag|=Update;}function markRef(workInProgress){workInProgress.effectTag|=Ref;}function appendAllReturns(returns,workInProgress){var node=workInProgress.stateNode;if(node){node['return']=workInProgress;}while(node!==null){if(node.tag===HostComponent||node.tag===HostText||node.tag===HostPortal){invariant(false,'A call cannot have host component children.');}else if(node.tag===ReturnComponent){returns.push(node.type);}else if(node.child!==null){node.child['return']=node;node=node.child;continue;}while(node.sibling===null){if(node['return']===null||node['return']===workInProgress){return;}node=node['return'];}node.sibling['return']=node['return'];node=node.sibling;}}function moveCallToHandlerPhase(current,workInProgress,renderExpirationTime){var call=workInProgress.memoizedProps;!call?invariant(false,'Should be resolved by now. This error is likely caused by a bug in React. Please file an issue.'):void 0;// First step of the call has completed. Now we need to do the second.
// TODO: It would be nice to have a multi stage call represented by a
// single component, or at least tail call optimize nested ones. Currently
// that requires additional fields that we don't want to add to the fiber.
// So this requires nested handlers.
// Note: This doesn't mutate the alternate node. I don't think it needs to
// since this stage is reset for every pass.
workInProgress.tag=CallHandlerPhase;// Build up the returns.
// TODO: Compare this to a generator or opaque helpers like Children.
var returns=[];appendAllReturns(returns,workInProgress);var fn=call.handler;var props=call.props;var nextChildren=fn(props,returns);var currentFirstChild=current!==null?current.child:null;workInProgress.child=reconcileChildFibers(workInProgress,currentFirstChild,nextChildren,renderExpirationTime);return workInProgress.child;}function appendAllChildren(parent,workInProgress){// We only have the top Fiber that was created but we need recurse down its
// children to find all the terminal nodes.
var node=workInProgress.child;while(node!==null){if(node.tag===HostComponent||node.tag===HostText){appendInitialChild(parent,node.stateNode);}else if(node.tag===HostPortal){// If we have a portal child, then we don't want to traverse
// down its children. Instead, we'll get insertions from each child in
// the portal directly.
}else if(node.child!==null){node.child['return']=node;node=node.child;continue;}if(node===workInProgress){return;}while(node.sibling===null){if(node['return']===null||node['return']===workInProgress){return;}node=node['return'];}node.sibling['return']=node['return'];node=node.sibling;}}var updateHostContainer=void 0;var updateHostComponent=void 0;var updateHostText=void 0;if(mutation){if(enableMutatingReconciler){// Mutation mode
updateHostContainer=function updateHostContainer(workInProgress){// Noop
};updateHostComponent=function updateHostComponent(current,workInProgress,updatePayload,type,oldProps,newProps,rootContainerInstance){// TODO: Type this specific to this type of component.
workInProgress.updateQueue=updatePayload;// If the update payload indicates that there is a change or if there
// is a new ref we mark this as an update. All the work is done in commitWork.
if(updatePayload){markUpdate(workInProgress);}};updateHostText=function updateHostText(current,workInProgress,oldText,newText){// If the text differs, mark it as an update. All the work in done in commitWork.
if(oldText!==newText){markUpdate(workInProgress);}};}else{invariant(false,'Mutating reconciler is disabled.');}}else if(persistence){if(enablePersistentReconciler){// Persistent host tree mode
var cloneInstance=persistence.cloneInstance,createContainerChildSet=persistence.createContainerChildSet,appendChildToContainerChildSet=persistence.appendChildToContainerChildSet,finalizeContainerChildren=persistence.finalizeContainerChildren;// An unfortunate fork of appendAllChildren because we have two different parent types.
var appendAllChildrenToContainer=function appendAllChildrenToContainer(containerChildSet,workInProgress){// We only have the top Fiber that was created but we need recurse down its
// children to find all the terminal nodes.
var node=workInProgress.child;while(node!==null){if(node.tag===HostComponent||node.tag===HostText){appendChildToContainerChildSet(containerChildSet,node.stateNode);}else if(node.tag===HostPortal){// If we have a portal child, then we don't want to traverse
// down its children. Instead, we'll get insertions from each child in
// the portal directly.
}else if(node.child!==null){node.child['return']=node;node=node.child;continue;}if(node===workInProgress){return;}while(node.sibling===null){if(node['return']===null||node['return']===workInProgress){return;}node=node['return'];}node.sibling['return']=node['return'];node=node.sibling;}};updateHostContainer=function updateHostContainer(workInProgress){var portalOrRoot=workInProgress.stateNode;var childrenUnchanged=workInProgress.firstEffect===null;if(childrenUnchanged){// No changes, just reuse the existing instance.
}else{var container=portalOrRoot.containerInfo;var newChildSet=createContainerChildSet(container);if(finalizeContainerChildren(container,newChildSet)){markUpdate(workInProgress);}portalOrRoot.pendingChildren=newChildSet;// If children might have changed, we have to add them all to the set.
appendAllChildrenToContainer(newChildSet,workInProgress);// Schedule an update on the container to swap out the container.
markUpdate(workInProgress);}};updateHostComponent=function updateHostComponent(current,workInProgress,updatePayload,type,oldProps,newProps,rootContainerInstance){// If there are no effects associated with this node, then none of our children had any updates.
// This guarantees that we can reuse all of them.
var childrenUnchanged=workInProgress.firstEffect===null;var currentInstance=current.stateNode;if(childrenUnchanged&&updatePayload===null){// No changes, just reuse the existing instance.
// Note that this might release a previous clone.
workInProgress.stateNode=currentInstance;}else{var recyclableInstance=workInProgress.stateNode;var newInstance=cloneInstance(currentInstance,updatePayload,type,oldProps,newProps,workInProgress,childrenUnchanged,recyclableInstance);if(finalizeInitialChildren(newInstance,type,newProps,rootContainerInstance)){markUpdate(workInProgress);}workInProgress.stateNode=newInstance;if(childrenUnchanged){// If there are no other effects in this tree, we need to flag this node as having one.
// Even though we're not going to use it for anything.
// Otherwise parents won't know that there are new children to propagate upwards.
markUpdate(workInProgress);}else{// If children might have changed, we have to add them all to the set.
appendAllChildren(newInstance,workInProgress);}}};updateHostText=function updateHostText(current,workInProgress,oldText,newText){if(oldText!==newText){// If the text content differs, we'll create a new text instance for it.
var rootContainerInstance=getRootHostContainer();var currentHostContext=getHostContext();workInProgress.stateNode=createTextInstance(newText,rootContainerInstance,currentHostContext,workInProgress);// We'll have to mark it as having an effect, even though we won't use the effect for anything.
// This lets the parents know that at least one of their children has changed.
markUpdate(workInProgress);}};}else{invariant(false,'Persistent reconciler is disabled.');}}else{if(enableNoopReconciler){// No host operations
updateHostContainer=function updateHostContainer(workInProgress){// Noop
};updateHostComponent=function updateHostComponent(current,workInProgress,updatePayload,type,oldProps,newProps,rootContainerInstance){// Noop
};updateHostText=function updateHostText(current,workInProgress,oldText,newText){// Noop
};}else{invariant(false,'Noop reconciler is disabled.');}}function completeWork(current,workInProgress,renderExpirationTime){// Get the latest props.
var newProps=workInProgress.pendingProps;if(newProps===null){newProps=workInProgress.memoizedProps;}else if(workInProgress.expirationTime!==Never||renderExpirationTime===Never){// Reset the pending props, unless this was a down-prioritization.
workInProgress.pendingProps=null;}switch(workInProgress.tag){case FunctionalComponent:return null;case ClassComponent:{// We are leaving this subtree, so pop context if any.
popContextProvider(workInProgress);return null;}case HostRoot:{popHostContainer(workInProgress);popTopLevelContextObject(workInProgress);var fiberRoot=workInProgress.stateNode;if(fiberRoot.pendingContext){fiberRoot.context=fiberRoot.pendingContext;fiberRoot.pendingContext=null;}if(current===null||current.child===null){// If we hydrated, pop so that we can delete any remaining children
// that weren't hydrated.
popHydrationState(workInProgress);// This resets the hacky state to fix isMounted before committing.
// TODO: Delete this when we delete isMounted and findDOMNode.
workInProgress.effectTag&=~Placement;}updateHostContainer(workInProgress);return null;}case HostComponent:{popHostContext(workInProgress);var rootContainerInstance=getRootHostContainer();var type=workInProgress.type;if(current!==null&&workInProgress.stateNode!=null){// If we have an alternate, that means this is an update and we need to
// schedule a side-effect to do the updates.
var oldProps=current.memoizedProps;// If we get updated because one of our children updated, we don't
// have newProps so we'll have to reuse them.
// TODO: Split the update API as separate for the props vs. children.
// Even better would be if children weren't special cased at all tho.
var instance=workInProgress.stateNode;var currentHostContext=getHostContext();var updatePayload=prepareUpdate(instance,type,oldProps,newProps,rootContainerInstance,currentHostContext);updateHostComponent(current,workInProgress,updatePayload,type,oldProps,newProps,rootContainerInstance);if(current.ref!==workInProgress.ref){markRef(workInProgress);}}else{if(!newProps){!(workInProgress.stateNode!==null)?invariant(false,'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.'):void 0;// This can happen when we abort work.
return null;}var _currentHostContext=getHostContext();// TODO: Move createInstance to beginWork and keep it on a context
// "stack" as the parent. Then append children as we go in beginWork
// or completeWork depending on we want to add then top->down or
// bottom->up. Top->down is faster in IE11.
var wasHydrated=popHydrationState(workInProgress);if(wasHydrated){// TODO: Move this and createInstance step into the beginPhase
// to consolidate.
if(prepareToHydrateHostInstance(workInProgress,rootContainerInstance,_currentHostContext)){// If changes to the hydrated node needs to be applied at the
// commit-phase we mark this as such.
markUpdate(workInProgress);}}else{var _instance=createInstance(type,newProps,rootContainerInstance,_currentHostContext,workInProgress);appendAllChildren(_instance,workInProgress);// Certain renderers require commit-time effects for initial mount.
// (eg DOM renderer supports auto-focus for certain elements).
// Make sure such renderers get scheduled for later work.
if(finalizeInitialChildren(_instance,type,newProps,rootContainerInstance)){markUpdate(workInProgress);}workInProgress.stateNode=_instance;}if(workInProgress.ref!==null){// If there is a ref on a host node we need to schedule a callback
markRef(workInProgress);}}return null;}case HostText:{var newText=newProps;if(current&&workInProgress.stateNode!=null){var oldText=current.memoizedProps;// If we have an alternate, that means this is an update and we need
// to schedule a side-effect to do the updates.
updateHostText(current,workInProgress,oldText,newText);}else{if(typeof newText!=='string'){!(workInProgress.stateNode!==null)?invariant(false,'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.'):void 0;// This can happen when we abort work.
return null;}var _rootContainerInstance=getRootHostContainer();var _currentHostContext2=getHostContext();var _wasHydrated=popHydrationState(workInProgress);if(_wasHydrated){if(prepareToHydrateHostTextInstance(workInProgress)){markUpdate(workInProgress);}}else{workInProgress.stateNode=createTextInstance(newText,_rootContainerInstance,_currentHostContext2,workInProgress);}}return null;}case CallComponent:return moveCallToHandlerPhase(current,workInProgress,renderExpirationTime);case CallHandlerPhase:// Reset the tag to now be a first phase call.
workInProgress.tag=CallComponent;return null;case ReturnComponent:// Does nothing.
return null;case Fragment:return null;case HostPortal:popHostContainer(workInProgress);updateHostContainer(workInProgress);return null;// Error cases
case IndeterminateComponent:invariant(false,'An indeterminate component should have become determinate before completing. This error is likely caused by a bug in React. Please file an issue.');// eslint-disable-next-line no-fallthrough
default:invariant(false,'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');}}return{completeWork:completeWork};};var invokeGuardedCallback$2=ReactErrorUtils.invokeGuardedCallback;var hasCaughtError$1=ReactErrorUtils.hasCaughtError;var clearCaughtError$1=ReactErrorUtils.clearCaughtError;var ReactFiberCommitWork=function ReactFiberCommitWork(config,captureError){var getPublicInstance=config.getPublicInstance,mutation=config.mutation,persistence=config.persistence;var callComponentWillUnmountWithTimer=function callComponentWillUnmountWithTimer(current,instance){startPhaseTimer(current,'componentWillUnmount');instance.props=current.memoizedProps;instance.state=current.memoizedState;instance.componentWillUnmount();stopPhaseTimer();};// Capture errors so they don't interrupt unmounting.
function safelyCallComponentWillUnmount(current,instance){{invokeGuardedCallback$2(null,callComponentWillUnmountWithTimer,null,current,instance);if(hasCaughtError$1()){var unmountError=clearCaughtError$1();captureError(current,unmountError);}}}function safelyDetachRef(current){var ref=current.ref;if(ref!==null){{invokeGuardedCallback$2(null,ref,null,null);if(hasCaughtError$1()){var refError=clearCaughtError$1();captureError(current,refError);}}}}function commitLifeCycles(current,finishedWork){switch(finishedWork.tag){case ClassComponent:{var instance=finishedWork.stateNode;if(finishedWork.effectTag&Update){if(current===null){startPhaseTimer(finishedWork,'componentDidMount');instance.props=finishedWork.memoizedProps;instance.state=finishedWork.memoizedState;instance.componentDidMount();stopPhaseTimer();}else{var prevProps=current.memoizedProps;var prevState=current.memoizedState;startPhaseTimer(finishedWork,'componentDidUpdate');instance.props=finishedWork.memoizedProps;instance.state=finishedWork.memoizedState;instance.componentDidUpdate(prevProps,prevState);stopPhaseTimer();}}var updateQueue=finishedWork.updateQueue;if(updateQueue!==null){commitCallbacks(updateQueue,instance);}return;}case HostRoot:{var _updateQueue=finishedWork.updateQueue;if(_updateQueue!==null){var _instance=finishedWork.child!==null?finishedWork.child.stateNode:null;commitCallbacks(_updateQueue,_instance);}return;}case HostComponent:{var _instance2=finishedWork.stateNode;// Renderers may schedule work to be done after host components are mounted
// (eg DOM renderer may schedule auto-focus for inputs and form controls).
// These effects should only be committed when components are first mounted,
// aka when there is no current/alternate.
if(current===null&&finishedWork.effectTag&Update){var type=finishedWork.type;var props=finishedWork.memoizedProps;commitMount(_instance2,type,props,finishedWork);}return;}case HostText:{// We have no life-cycles associated with text.
return;}case HostPortal:{// We have no life-cycles associated with portals.
return;}default:{invariant(false,'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');}}}function commitAttachRef(finishedWork){var ref=finishedWork.ref;if(ref!==null){var instance=finishedWork.stateNode;switch(finishedWork.tag){case HostComponent:ref(getPublicInstance(instance));break;default:ref(instance);}}}function commitDetachRef(current){var currentRef=current.ref;if(currentRef!==null){currentRef(null);}}// User-originating errors (lifecycles and refs) should not interrupt
// deletion, so don't let them throw. Host-originating errors should
// interrupt deletion, so it's okay
function commitUnmount(current){if(typeof onCommitUnmount==='function'){onCommitUnmount(current);}switch(current.tag){case ClassComponent:{safelyDetachRef(current);var instance=current.stateNode;if(typeof instance.componentWillUnmount==='function'){safelyCallComponentWillUnmount(current,instance);}return;}case HostComponent:{safelyDetachRef(current);return;}case CallComponent:{commitNestedUnmounts(current.stateNode);return;}case HostPortal:{// TODO: this is recursive.
// We are also not using this parent because
// the portal will get pushed immediately.
if(enableMutatingReconciler&&mutation){unmountHostComponents(current);}else if(enablePersistentReconciler&&persistence){emptyPortalContainer(current);}return;}}}function commitNestedUnmounts(root){// While we're inside a removed host node we don't want to call
// removeChild on the inner nodes because they're removed by the top
// call anyway. We also want to call componentWillUnmount on all
// composites before this host node is removed from the tree. Therefore
var node=root;while(true){commitUnmount(node);// Visit children because they may contain more composite or host nodes.
// Skip portals because commitUnmount() currently visits them recursively.
if(node.child!==null&&(// If we use mutation we drill down into portals using commitUnmount above.
// If we don't use mutation we drill down into portals here instead.
!mutation||node.tag!==HostPortal)){node.child['return']=node;node=node.child;continue;}if(node===root){return;}while(node.sibling===null){if(node['return']===null||node['return']===root){return;}node=node['return'];}node.sibling['return']=node['return'];node=node.sibling;}}function detachFiber(current){// Cut off the return pointers to disconnect it from the tree. Ideally, we
// should clear the child pointer of the parent alternate to let this
// get GC:ed but we don't know which for sure which parent is the current
// one so we'll settle for GC:ing the subtree of this child. This child
// itself will be GC:ed when the parent updates the next time.
current['return']=null;current.child=null;if(current.alternate){current.alternate.child=null;current.alternate['return']=null;}}if(!mutation){var commitContainer=void 0;if(persistence){var replaceContainerChildren=persistence.replaceContainerChildren,createContainerChildSet=persistence.createContainerChildSet;var emptyPortalContainer=function emptyPortalContainer(current){var portal=current.stateNode;var containerInfo=portal.containerInfo;var emptyChildSet=createContainerChildSet(containerInfo);replaceContainerChildren(containerInfo,emptyChildSet);};commitContainer=function commitContainer(finishedWork){switch(finishedWork.tag){case ClassComponent:{return;}case HostComponent:{return;}case HostText:{return;}case HostRoot:case HostPortal:{var portalOrRoot=finishedWork.stateNode;var containerInfo=portalOrRoot.containerInfo,_pendingChildren=portalOrRoot.pendingChildren;replaceContainerChildren(containerInfo,_pendingChildren);return;}default:{invariant(false,'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');}}};}else{commitContainer=function commitContainer(finishedWork){// Noop
};}if(enablePersistentReconciler||enableNoopReconciler){return{commitResetTextContent:function commitResetTextContent(finishedWork){},commitPlacement:function commitPlacement(finishedWork){},commitDeletion:function commitDeletion(current){// Detach refs and call componentWillUnmount() on the whole subtree.
commitNestedUnmounts(current);detachFiber(current);},commitWork:function commitWork(current,finishedWork){commitContainer(finishedWork);},commitLifeCycles:commitLifeCycles,commitAttachRef:commitAttachRef,commitDetachRef:commitDetachRef};}else if(persistence){invariant(false,'Persistent reconciler is disabled.');}else{invariant(false,'Noop reconciler is disabled.');}}var commitMount=mutation.commitMount,commitUpdate=mutation.commitUpdate,resetTextContent=mutation.resetTextContent,commitTextUpdate=mutation.commitTextUpdate,appendChild=mutation.appendChild,appendChildToContainer=mutation.appendChildToContainer,insertBefore=mutation.insertBefore,insertInContainerBefore=mutation.insertInContainerBefore,removeChild=mutation.removeChild,removeChildFromContainer=mutation.removeChildFromContainer;function getHostParentFiber(fiber){var parent=fiber['return'];while(parent!==null){if(isHostParent(parent)){return parent;}parent=parent['return'];}invariant(false,'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.');}function isHostParent(fiber){return fiber.tag===HostComponent||fiber.tag===HostRoot||fiber.tag===HostPortal;}function getHostSibling(fiber){// We're going to search forward into the tree until we find a sibling host
// node. Unfortunately, if multiple insertions are done in a row we have to
// search past them. This leads to exponential search for the next sibling.
var node=fiber;siblings:while(true){// If we didn't find anything, let's try the next sibling.
while(node.sibling===null){if(node['return']===null||isHostParent(node['return'])){// If we pop out of the root or hit the parent the fiber we are the
// last sibling.
return null;}node=node['return'];}node.sibling['return']=node['return'];node=node.sibling;while(node.tag!==HostComponent&&node.tag!==HostText){// If it is not host node and, we might have a host node inside it.
// Try to search down until we find one.
if(node.effectTag&Placement){// If we don't have a child, try the siblings instead.
continue siblings;}// If we don't have a child, try the siblings instead.
// We also skip portals because they are not part of this host tree.
if(node.child===null||node.tag===HostPortal){continue siblings;}else{node.child['return']=node;node=node.child;}}// Check if this host node is stable or about to be placed.
if(!(node.effectTag&Placement)){// Found it!
return node.stateNode;}}}function commitPlacement(finishedWork){// Recursively insert all host nodes into the parent.
var parentFiber=getHostParentFiber(finishedWork);var parent=void 0;var isContainer=void 0;switch(parentFiber.tag){case HostComponent:parent=parentFiber.stateNode;isContainer=false;break;case HostRoot:parent=parentFiber.stateNode.containerInfo;isContainer=true;break;case HostPortal:parent=parentFiber.stateNode.containerInfo;isContainer=true;break;default:invariant(false,'Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.');}if(parentFiber.effectTag&ContentReset){// Reset the text content of the parent before doing any insertions
resetTextContent(parent);// Clear ContentReset from the effect tag
parentFiber.effectTag&=~ContentReset;}var before=getHostSibling(finishedWork);// We only have the top Fiber that was inserted but we need recurse down its
// children to find all the terminal nodes.
var node=finishedWork;while(true){if(node.tag===HostComponent||node.tag===HostText){if(before){if(isContainer){insertInContainerBefore(parent,node.stateNode,before);}else{insertBefore(parent,node.stateNode,before);}}else{if(isContainer){appendChildToContainer(parent,node.stateNode);}else{appendChild(parent,node.stateNode);}}}else if(node.tag===HostPortal){// If the insertion itself is a portal, then we don't want to traverse
// down its children. Instead, we'll get insertions from each child in
// the portal directly.
}else if(node.child!==null){node.child['return']=node;node=node.child;continue;}if(node===finishedWork){return;}while(node.sibling===null){if(node['return']===null||node['return']===finishedWork){return;}node=node['return'];}node.sibling['return']=node['return'];node=node.sibling;}}function unmountHostComponents(current){// We only have the top Fiber that was inserted but we need recurse down its
var node=current;// Each iteration, currentParent is populated with node's host parent if not
// currentParentIsValid.
var currentParentIsValid=false;var currentParent=void 0;var currentParentIsContainer=void 0;while(true){if(!currentParentIsValid){var parent=node['return'];findParent:while(true){!(parent!==null)?invariant(false,'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.'):void 0;switch(parent.tag){case HostComponent:currentParent=parent.stateNode;currentParentIsContainer=false;break findParent;case HostRoot:currentParent=parent.stateNode.containerInfo;currentParentIsContainer=true;break findParent;case HostPortal:currentParent=parent.stateNode.containerInfo;currentParentIsContainer=true;break findParent;}parent=parent['return'];}currentParentIsValid=true;}if(node.tag===HostComponent||node.tag===HostText){commitNestedUnmounts(node);// After all the children have unmounted, it is now safe to remove the
// node from the tree.
if(currentParentIsContainer){removeChildFromContainer(currentParent,node.stateNode);}else{removeChild(currentParent,node.stateNode);}// Don't visit children because we already visited them.
}else if(node.tag===HostPortal){// When we go into a portal, it becomes the parent to remove from.
// We will reassign it back when we pop the portal on the way up.
currentParent=node.stateNode.containerInfo;// Visit children because portals might contain host components.
if(node.child!==null){node.child['return']=node;node=node.child;continue;}}else{commitUnmount(node);// Visit children because we may find more host components below.
if(node.child!==null){node.child['return']=node;node=node.child;continue;}}if(node===current){return;}while(node.sibling===null){if(node['return']===null||node['return']===current){return;}node=node['return'];if(node.tag===HostPortal){// When we go out of the portal, we need to restore the parent.
// Since we don't keep a stack of them, we will search for it.
currentParentIsValid=false;}}node.sibling['return']=node['return'];node=node.sibling;}}function commitDeletion(current){// Recursively delete all host nodes from the parent.
// Detach refs and call componentWillUnmount() on the whole subtree.
unmountHostComponents(current);detachFiber(current);}function commitWork(current,finishedWork){switch(finishedWork.tag){case ClassComponent:{return;}case HostComponent:{var instance=finishedWork.stateNode;if(instance!=null){// Commit the work prepared earlier.
var newProps=finishedWork.memoizedProps;// For hydration we reuse the update path but we treat the oldProps
// as the newProps. The updatePayload will contain the real change in
// this case.
var oldProps=current!==null?current.memoizedProps:newProps;var type=finishedWork.type;// TODO: Type the updateQueue to be specific to host components.
var updatePayload=finishedWork.updateQueue;finishedWork.updateQueue=null;if(updatePayload!==null){commitUpdate(instance,updatePayload,type,oldProps,newProps,finishedWork);}}return;}case HostText:{!(finishedWork.stateNode!==null)?invariant(false,'This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.'):void 0;var textInstance=finishedWork.stateNode;var newText=finishedWork.memoizedProps;// For hydration we reuse the update path but we treat the oldProps
// as the newProps. The updatePayload will contain the real change in
// this case.
var oldText=current!==null?current.memoizedProps:newText;commitTextUpdate(textInstance,oldText,newText);return;}case HostRoot:{return;}default:{invariant(false,'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');}}}function commitResetTextContent(current){resetTextContent(current.stateNode);}if(enableMutatingReconciler){return{commitResetTextContent:commitResetTextContent,commitPlacement:commitPlacement,commitDeletion:commitDeletion,commitWork:commitWork,commitLifeCycles:commitLifeCycles,commitAttachRef:commitAttachRef,commitDetachRef:commitDetachRef};}else{invariant(false,'Mutating reconciler is disabled.');}};var NO_CONTEXT={};var ReactFiberHostContext=function ReactFiberHostContext(config){var getChildHostContext=config.getChildHostContext,getRootHostContext=config.getRootHostContext;var contextStackCursor=createCursor(NO_CONTEXT);var contextFiberStackCursor=createCursor(NO_CONTEXT);var rootInstanceStackCursor=createCursor(NO_CONTEXT);function requiredContext(c){!(c!==NO_CONTEXT)?invariant(false,'Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.'):void 0;return c;}function getRootHostContainer(){var rootInstance=requiredContext(rootInstanceStackCursor.current);return rootInstance;}function pushHostContainer(fiber,nextRootInstance){// Push current root instance onto the stack;
// This allows us to reset root when portals are popped.
push(rootInstanceStackCursor,nextRootInstance,fiber);var nextRootContext=getRootHostContext(nextRootInstance);// Track the context and the Fiber that provided it.
// This enables us to pop only Fibers that provide unique contexts.
push(contextFiberStackCursor,fiber,fiber);push(contextStackCursor,nextRootContext,fiber);}function popHostContainer(fiber){pop(contextStackCursor,fiber);pop(contextFiberStackCursor,fiber);pop(rootInstanceStackCursor,fiber);}function getHostContext(){var context=requiredContext(contextStackCursor.current);return context;}function pushHostContext(fiber){var rootInstance=requiredContext(rootInstanceStackCursor.current);var context=requiredContext(contextStackCursor.current);var nextContext=getChildHostContext(context,fiber.type,rootInstance);// Don't push this Fiber's context unless it's unique.
if(context===nextContext){return;}// Track the context and the Fiber that provided it.
// This enables us to pop only Fibers that provide unique contexts.
push(contextFiberStackCursor,fiber,fiber);push(contextStackCursor,nextContext,fiber);}function popHostContext(fiber){// Do not pop unless this Fiber provided the current context.
// pushHostContext() only pushes Fibers that provide unique contexts.
if(contextFiberStackCursor.current!==fiber){return;}pop(contextStackCursor,fiber);pop(contextFiberStackCursor,fiber);}function resetHostContainer(){contextStackCursor.current=NO_CONTEXT;rootInstanceStackCursor.current=NO_CONTEXT;}return{getHostContext:getHostContext,getRootHostContainer:getRootHostContainer,popHostContainer:popHostContainer,popHostContext:popHostContext,pushHostContainer:pushHostContainer,pushHostContext:pushHostContext,resetHostContainer:resetHostContainer};};var ReactFiberHydrationContext=function ReactFiberHydrationContext(config){var shouldSetTextContent=config.shouldSetTextContent,hydration=config.hydration;// If this doesn't have hydration mode.
if(!hydration){return{enterHydrationState:function enterHydrationState(){return false;},resetHydrationState:function resetHydrationState(){},tryToClaimNextHydratableInstance:function tryToClaimNextHydratableInstance(){},prepareToHydrateHostInstance:function prepareToHydrateHostInstance(){invariant(false,'Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');},prepareToHydrateHostTextInstance:function prepareToHydrateHostTextInstance(){invariant(false,'Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');},popHydrationState:function popHydrationState(fiber){return false;}};}var canHydrateInstance=hydration.canHydrateInstance,canHydrateTextInstance=hydration.canHydrateTextInstance,getNextHydratableSibling=hydration.getNextHydratableSibling,getFirstHydratableChild=hydration.getFirstHydratableChild,hydrateInstance=hydration.hydrateInstance,hydrateTextInstance=hydration.hydrateTextInstance,didNotMatchHydratedContainerTextInstance=hydration.didNotMatchHydratedContainerTextInstance,didNotMatchHydratedTextInstance=hydration.didNotMatchHydratedTextInstance,didNotHydrateContainerInstance=hydration.didNotHydrateContainerInstance,didNotHydrateInstance=hydration.didNotHydrateInstance,didNotFindHydratableContainerInstance=hydration.didNotFindHydratableContainerInstance,didNotFindHydratableContainerTextInstance=hydration.didNotFindHydratableContainerTextInstance,didNotFindHydratableInstance=hydration.didNotFindHydratableInstance,didNotFindHydratableTextInstance=hydration.didNotFindHydratableTextInstance;// The deepest Fiber on the stack involved in a hydration context.
// This may have been an insertion or a hydration.
var hydrationParentFiber=null;var nextHydratableInstance=null;var isHydrating=false;function enterHydrationState(fiber){var parentInstance=fiber.stateNode.containerInfo;nextHydratableInstance=getFirstHydratableChild(parentInstance);hydrationParentFiber=fiber;isHydrating=true;return true;}function deleteHydratableInstance(returnFiber,instance){{switch(returnFiber.tag){case HostRoot:didNotHydrateContainerInstance(returnFiber.stateNode.containerInfo,instance);break;case HostComponent:didNotHydrateInstance(returnFiber.type,returnFiber.memoizedProps,returnFiber.stateNode,instance);break;}}var childToDelete=createFiberFromHostInstanceForDeletion();childToDelete.stateNode=instance;childToDelete['return']=returnFiber;childToDelete.effectTag=Deletion;// This might seem like it belongs on progressedFirstDeletion. However,
// these children are not part of the reconciliation list of children.
// Even if we abort and rereconcile the children, that will try to hydrate
// again and the nodes are still in the host tree so these will be
// recreated.
if(returnFiber.lastEffect!==null){returnFiber.lastEffect.nextEffect=childToDelete;returnFiber.lastEffect=childToDelete;}else{returnFiber.firstEffect=returnFiber.lastEffect=childToDelete;}}function insertNonHydratedInstance(returnFiber,fiber){fiber.effectTag|=Placement;{switch(returnFiber.tag){case HostRoot:{var parentContainer=returnFiber.stateNode.containerInfo;switch(fiber.tag){case HostComponent:var type=fiber.type;var props=fiber.pendingProps;didNotFindHydratableContainerInstance(parentContainer,type,props);break;case HostText:var text=fiber.pendingProps;didNotFindHydratableContainerTextInstance(parentContainer,text);break;}break;}case HostComponent:{var parentType=returnFiber.type;var parentProps=returnFiber.memoizedProps;var parentInstance=returnFiber.stateNode;switch(fiber.tag){case HostComponent:var _type=fiber.type;var _props=fiber.pendingProps;didNotFindHydratableInstance(parentType,parentProps,parentInstance,_type,_props);break;case HostText:var _text=fiber.pendingProps;didNotFindHydratableTextInstance(parentType,parentProps,parentInstance,_text);break;}break;}default:return;}}}function tryHydrate(fiber,nextInstance){switch(fiber.tag){case HostComponent:{var type=fiber.type;var props=fiber.pendingProps;var instance=canHydrateInstance(nextInstance,type,props);if(instance!==null){fiber.stateNode=instance;return true;}return false;}case HostText:{var text=fiber.pendingProps;var textInstance=canHydrateTextInstance(nextInstance,text);if(textInstance!==null){fiber.stateNode=textInstance;return true;}return false;}default:return false;}}function tryToClaimNextHydratableInstance(fiber){if(!isHydrating){return;}var nextInstance=nextHydratableInstance;if(!nextInstance){// Nothing to hydrate. Make it an insertion.
insertNonHydratedInstance(hydrationParentFiber,fiber);isHydrating=false;hydrationParentFiber=fiber;return;}if(!tryHydrate(fiber,nextInstance)){// If we can't hydrate this instance let's try the next one.
// We use this as a heuristic. It's based on intuition and not data so it
// might be flawed or unnecessary.
nextInstance=getNextHydratableSibling(nextInstance);if(!nextInstance||!tryHydrate(fiber,nextInstance)){// Nothing to hydrate. Make it an insertion.
insertNonHydratedInstance(hydrationParentFiber,fiber);isHydrating=false;hydrationParentFiber=fiber;return;}// We matched the next one, we'll now assume that the first one was
// superfluous and we'll delete it. Since we can't eagerly delete it
// we'll have to schedule a deletion. To do that, this node needs a dummy
// fiber associated with it.
deleteHydratableInstance(hydrationParentFiber,nextHydratableInstance);}hydrationParentFiber=fiber;nextHydratableInstance=getFirstHydratableChild(nextInstance);}function prepareToHydrateHostInstance(fiber,rootContainerInstance,hostContext){var instance=fiber.stateNode;var updatePayload=hydrateInstance(instance,fiber.type,fiber.memoizedProps,rootContainerInstance,hostContext,fiber);// TODO: Type this specific to this type of component.
fiber.updateQueue=updatePayload;// If the update payload indicates that there is a change or if there
// is a new ref we mark this as an update.
if(updatePayload!==null){return true;}return false;}function prepareToHydrateHostTextInstance(fiber){var textInstance=fiber.stateNode;var textContent=fiber.memoizedProps;var shouldUpdate=hydrateTextInstance(textInstance,textContent,fiber);{if(shouldUpdate){// We assume that prepareToHydrateHostTextInstance is called in a context where the
// hydration parent is the parent host component of this host text.
var returnFiber=hydrationParentFiber;if(returnFiber!==null){switch(returnFiber.tag){case HostRoot:{var parentContainer=returnFiber.stateNode.containerInfo;didNotMatchHydratedContainerTextInstance(parentContainer,textInstance,textContent);break;}case HostComponent:{var parentType=returnFiber.type;var parentProps=returnFiber.memoizedProps;var parentInstance=returnFiber.stateNode;didNotMatchHydratedTextInstance(parentType,parentProps,parentInstance,textInstance,textContent);break;}}}}}return shouldUpdate;}function popToNextHostParent(fiber){var parent=fiber['return'];while(parent!==null&&parent.tag!==HostComponent&&parent.tag!==HostRoot){parent=parent['return'];}hydrationParentFiber=parent;}function popHydrationState(fiber){if(fiber!==hydrationParentFiber){// We're deeper than the current hydration context, inside an inserted
// tree.
return false;}if(!isHydrating){// If we're not currently hydrating but we're in a hydration context, then
// we were an insertion and now need to pop up reenter hydration of our
// siblings.
popToNextHostParent(fiber);isHydrating=true;return false;}var type=fiber.type;// If we have any remaining hydratable nodes, we need to delete them now.
// We only do this deeper than head and body since they tend to have random
// other nodes in them. We also ignore components with pure text content in
// side of them.
// TODO: Better heuristic.
if(fiber.tag!==HostComponent||type!=='head'&&type!=='body'&&!shouldSetTextContent(type,fiber.memoizedProps)){var nextInstance=nextHydratableInstance;while(nextInstance){deleteHydratableInstance(fiber,nextInstance);nextInstance=getNextHydratableSibling(nextInstance);}}popToNextHostParent(fiber);nextHydratableInstance=hydrationParentFiber?getNextHydratableSibling(fiber.stateNode):null;return true;}function resetHydrationState(){hydrationParentFiber=null;nextHydratableInstance=null;isHydrating=false;}return{enterHydrationState:enterHydrationState,resetHydrationState:resetHydrationState,tryToClaimNextHydratableInstance:tryToClaimNextHydratableInstance,prepareToHydrateHostInstance:prepareToHydrateHostInstance,prepareToHydrateHostTextInstance:prepareToHydrateHostTextInstance,popHydrationState:popHydrationState};};// This lets us hook into Fiber to debug what it's doing.
// See https://github.com/facebook/react/pull/8033.
// This is not part of the public API, not even for React DevTools.
// You may only inject a debugTool if you work on React Fiber itself.
var ReactFiberInstrumentation={debugTool:null};var ReactFiberInstrumentation_1=ReactFiberInstrumentation;var defaultShowDialog=function defaultShowDialog(capturedError){return true;};var showDialog=defaultShowDialog;function logCapturedError(capturedError){var logError=showDialog(capturedError);// Allow injected showDialog() to prevent default console.error logging.
// This enables renderers like ReactNative to better manage redbox behavior.
if(logError===false){return;}var error=capturedError.error;var suppressLogging=error&&error.suppressReactErrorLogging;if(suppressLogging){return;}{var componentName=capturedError.componentName,componentStack=capturedError.componentStack,errorBoundaryName=capturedError.errorBoundaryName,errorBoundaryFound=capturedError.errorBoundaryFound,willRetry=capturedError.willRetry;var componentNameMessage=componentName?'The above error occurred in the <'+componentName+'> component:':'The above error occurred in one of your React components:';var errorBoundaryMessage=void 0;// errorBoundaryFound check is sufficient; errorBoundaryName check is to satisfy Flow.
if(errorBoundaryFound&&errorBoundaryName){if(willRetry){errorBoundaryMessage='React will try to recreate this component tree from scratch '+('using the error boundary you provided, '+errorBoundaryName+'.');}else{errorBoundaryMessage='This error was initially handled by the error boundary '+errorBoundaryName+'.\n'+'Recreating the tree from scratch failed so React will unmount the tree.';}}else{errorBoundaryMessage='Consider adding an error boundary to your tree to customize error handling behavior.\n'+'Visit https://fb.me/react-error-boundaries to learn more about error boundaries.';}var combinedMessage=''+componentNameMessage+componentStack+'\n\n'+(''+errorBoundaryMessage);// In development, we provide our own message with just the component stack.
// We don't include the original error message and JS stack because the browser
// has already printed it. Even if the application swallows the error, it is still
// displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.
console.error(combinedMessage);}}var invokeGuardedCallback$1=ReactErrorUtils.invokeGuardedCallback;var hasCaughtError=ReactErrorUtils.hasCaughtError;var clearCaughtError=ReactErrorUtils.clearCaughtError;{var didWarnAboutStateTransition=false;var didWarnSetStateChildContext=false;var didWarnStateUpdateForUnmountedComponent={};var warnAboutUpdateOnUnmounted=function warnAboutUpdateOnUnmounted(fiber){var componentName=getComponentName(fiber)||'ReactClass';if(didWarnStateUpdateForUnmountedComponent[componentName]){return;}warning(false,'Can only update a mounted or mounting '+'component. This usually means you called setState, replaceState, '+'or forceUpdate on an unmounted component. This is a no-op.\n\nPlease '+'check the code for the %s component.',componentName);didWarnStateUpdateForUnmountedComponent[componentName]=true;};var warnAboutInvalidUpdates=function warnAboutInvalidUpdates(instance){switch(ReactDebugCurrentFiber.phase){case'getChildContext':if(didWarnSetStateChildContext){return;}warning(false,'setState(...): Cannot call setState() inside getChildContext()');didWarnSetStateChildContext=true;break;case'render':if(didWarnAboutStateTransition){return;}warning(false,'Cannot update during an existing state transition (such as within '+"`render` or another component's constructor). Render methods should "+'be a pure function of props and state; constructor side-effects are '+'an anti-pattern, but can be moved to `componentWillMount`.');didWarnAboutStateTransition=true;break;}};}var ReactFiberScheduler=function ReactFiberScheduler(config){var hostContext=ReactFiberHostContext(config);var hydrationContext=ReactFiberHydrationContext(config);var popHostContainer=hostContext.popHostContainer,popHostContext=hostContext.popHostContext,resetHostContainer=hostContext.resetHostContainer;var _ReactFiberBeginWork=ReactFiberBeginWork(config,hostContext,hydrationContext,scheduleWork,computeExpirationForFiber),beginWork=_ReactFiberBeginWork.beginWork,beginFailedWork=_ReactFiberBeginWork.beginFailedWork;var _ReactFiberCompleteWo=ReactFiberCompleteWork(config,hostContext,hydrationContext),completeWork=_ReactFiberCompleteWo.completeWork;var _ReactFiberCommitWork=ReactFiberCommitWork(config,captureError),commitResetTextContent=_ReactFiberCommitWork.commitResetTextContent,commitPlacement=_ReactFiberCommitWork.commitPlacement,commitDeletion=_ReactFiberCommitWork.commitDeletion,commitWork=_ReactFiberCommitWork.commitWork,commitLifeCycles=_ReactFiberCommitWork.commitLifeCycles,commitAttachRef=_ReactFiberCommitWork.commitAttachRef,commitDetachRef=_ReactFiberCommitWork.commitDetachRef;var now=config.now,scheduleDeferredCallback=config.scheduleDeferredCallback,cancelDeferredCallback=config.cancelDeferredCallback,useSyncScheduling=config.useSyncScheduling,prepareForCommit=config.prepareForCommit,resetAfterCommit=config.resetAfterCommit;// Represents the current time in ms.
var startTime=now();var mostRecentCurrentTime=msToExpirationTime(0);// Represents the expiration time that incoming updates should use. (If this
// is NoWork, use the default strategy: async updates in async mode, sync
// updates in sync mode.)
var expirationContext=NoWork;var isWorking=false;// The next work in progress fiber that we're currently working on.
var nextUnitOfWork=null;var nextRoot=null;// The time at which we're currently rendering work.
var nextRenderExpirationTime=NoWork;// The next fiber with an effect that we're currently committing.
var nextEffect=null;// Keep track of which fibers have captured an error that need to be handled.
// Work is removed from this collection after componentDidCatch is called.
var capturedErrors=null;// Keep track of which fibers have failed during the current batch of work.
// This is a different set than capturedErrors, because it is not reset until
// the end of the batch. This is needed to propagate errors correctly if a
// subtree fails more than once.
var failedBoundaries=null;// Error boundaries that captured an error during the current commit.
var commitPhaseBoundaries=null;var firstUncaughtError=null;var didFatal=false;var isCommitting=false;var isUnmounting=false;// Used for performance tracking.
var interruptedBy=null;function resetContextStack(){// Reset the stack
reset$1();// Reset the cursors
resetContext();resetHostContainer();}function commitAllHostEffects(){while(nextEffect!==null){{ReactDebugCurrentFiber.setCurrentFiber(nextEffect);}recordEffect();var effectTag=nextEffect.effectTag;if(effectTag&ContentReset){commitResetTextContent(nextEffect);}if(effectTag&Ref){var current=nextEffect.alternate;if(current!==null){commitDetachRef(current);}}// The following switch statement is only concerned about placement,
// updates, and deletions. To avoid needing to add a case for every
// possible bitmap value, we remove the secondary effects from the
// effect tag and switch on that value.
var primaryEffectTag=effectTag&~(Callback|Err|ContentReset|Ref|PerformedWork);switch(primaryEffectTag){case Placement:{commitPlacement(nextEffect);// Clear the "placement" from effect tag so that we know that this is inserted, before
// any life-cycles like componentDidMount gets called.
// TODO: findDOMNode doesn't rely on this any more but isMounted
// does and isMounted is deprecated anyway so we should be able
// to kill this.
nextEffect.effectTag&=~Placement;break;}case PlacementAndUpdate:{// Placement
commitPlacement(nextEffect);// Clear the "placement" from effect tag so that we know that this is inserted, before
// any life-cycles like componentDidMount gets called.
nextEffect.effectTag&=~Placement;// Update
var _current=nextEffect.alternate;commitWork(_current,nextEffect);break;}case Update:{var _current2=nextEffect.alternate;commitWork(_current2,nextEffect);break;}case Deletion:{isUnmounting=true;commitDeletion(nextEffect);isUnmounting=false;break;}}nextEffect=nextEffect.nextEffect;}{ReactDebugCurrentFiber.resetCurrentFiber();}}function commitAllLifeCycles(){while(nextEffect!==null){var effectTag=nextEffect.effectTag;if(effectTag&(Update|Callback)){recordEffect();var current=nextEffect.alternate;commitLifeCycles(current,nextEffect);}if(effectTag&Ref){recordEffect();commitAttachRef(nextEffect);}if(effectTag&Err){recordEffect();commitErrorHandling(nextEffect);}var next=nextEffect.nextEffect;// Ensure that we clean these up so that we don't accidentally keep them.
// I'm not actually sure this matters because we can't reset firstEffect
// and lastEffect since they're on every node, not just the effectful
// ones. So we have to clean everything as we reuse nodes anyway.
nextEffect.nextEffect=null;// Ensure that we reset the effectTag here so that we can rely on effect
// tags to reason about the current life-cycle.
nextEffect=next;}}function commitRoot(finishedWork){// We keep track of this so that captureError can collect any boundaries
// that capture an error during the commit phase. The reason these aren't
// local to this function is because errors that occur during cWU are
// captured elsewhere, to prevent the unmount from being interrupted.
isWorking=true;isCommitting=true;startCommitTimer();var root=finishedWork.stateNode;!(root.current!==finishedWork)?invariant(false,'Cannot commit the same tree as before. This is probably a bug related to the return field. This error is likely caused by a bug in React. Please file an issue.'):void 0;root.isReadyForCommit=false;// Reset this to null before calling lifecycles
ReactCurrentOwner.current=null;var firstEffect=void 0;if(finishedWork.effectTag>PerformedWork){// A fiber's effect list consists only of its children, not itself. So if
// the root has an effect, we need to add it to the end of the list. The
// resulting list is the set that would belong to the root's parent, if
// it had one; that is, all the effects in the tree including the root.
if(finishedWork.lastEffect!==null){finishedWork.lastEffect.nextEffect=finishedWork;firstEffect=finishedWork.firstEffect;}else{firstEffect=finishedWork;}}else{// There is no effect on the root.
firstEffect=finishedWork.firstEffect;}prepareForCommit();// Commit all the side-effects within a tree. We'll do this in two passes.
// The first pass performs all the host insertions, updates, deletions and
// ref unmounts.
nextEffect=firstEffect;startCommitHostEffectsTimer();while(nextEffect!==null){var didError=false;var _error=void 0;{invokeGuardedCallback$1(null,commitAllHostEffects,null);if(hasCaughtError()){didError=true;_error=clearCaughtError();}}if(didError){!(nextEffect!==null)?invariant(false,'Should have next effect. This error is likely caused by a bug in React. Please file an issue.'):void 0;captureError(nextEffect,_error);// Clean-up
if(nextEffect!==null){nextEffect=nextEffect.nextEffect;}}}stopCommitHostEffectsTimer();resetAfterCommit();// The work-in-progress tree is now the current tree. This must come after
// the first pass of the commit phase, so that the previous tree is still
// current during componentWillUnmount, but before the second pass, so that
// the finished work is current during componentDidMount/Update.
root.current=finishedWork;// In the second pass we'll perform all life-cycles and ref callbacks.
// Life-cycles happen as a separate pass so that all placements, updates,
// and deletions in the entire tree have already been invoked.
// This pass also triggers any renderer-specific initial effects.
nextEffect=firstEffect;startCommitLifeCyclesTimer();while(nextEffect!==null){var _didError=false;var _error2=void 0;{invokeGuardedCallback$1(null,commitAllLifeCycles,null);if(hasCaughtError()){_didError=true;_error2=clearCaughtError();}}if(_didError){!(nextEffect!==null)?invariant(false,'Should have next effect. This error is likely caused by a bug in React. Please file an issue.'):void 0;captureError(nextEffect,_error2);if(nextEffect!==null){nextEffect=nextEffect.nextEffect;}}}isCommitting=false;isWorking=false;stopCommitLifeCyclesTimer();stopCommitTimer();if(typeof onCommitRoot==='function'){onCommitRoot(finishedWork.stateNode);}if(true&&ReactFiberInstrumentation_1.debugTool){ReactFiberInstrumentation_1.debugTool.onCommitWork(finishedWork);}// If we caught any errors during this commit, schedule their boundaries
// to update.
if(commitPhaseBoundaries){commitPhaseBoundaries.forEach(scheduleErrorRecovery);commitPhaseBoundaries=null;}if(firstUncaughtError!==null){var _error3=firstUncaughtError;firstUncaughtError=null;onUncaughtError(_error3);}var remainingTime=root.current.expirationTime;if(remainingTime===NoWork){capturedErrors=null;failedBoundaries=null;}return remainingTime;}function resetExpirationTime(workInProgress,renderTime){if(renderTime!==Never&&workInProgress.expirationTime===Never){// The children of this component are hidden. Don't bubble their
// expiration times.
return;}// Check for pending updates.
var newExpirationTime=getUpdateExpirationTime(workInProgress);// TODO: Calls need to visit stateNode
// Bubble up the earliest expiration time.
var child=workInProgress.child;while(child!==null){if(child.expirationTime!==NoWork&&(newExpirationTime===NoWork||newExpirationTime>child.expirationTime)){newExpirationTime=child.expirationTime;}child=child.sibling;}workInProgress.expirationTime=newExpirationTime;}function completeUnitOfWork(workInProgress){while(true){// The current, flushed, state of this fiber is the alternate.
// Ideally nothing should rely on this, but relying on it here
// means that we don't need an additional field on the work in
// progress.
var current=workInProgress.alternate;{ReactDebugCurrentFiber.setCurrentFiber(workInProgress);}var next=completeWork(current,workInProgress,nextRenderExpirationTime);{ReactDebugCurrentFiber.resetCurrentFiber();}var returnFiber=workInProgress['return'];var siblingFiber=workInProgress.sibling;resetExpirationTime(workInProgress,nextRenderExpirationTime);if(next!==null){stopWorkTimer(workInProgress);if(true&&ReactFiberInstrumentation_1.debugTool){ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);}// If completing this work spawned new work, do that next. We'll come
// back here again.
return next;}if(returnFiber!==null){// Append all the effects of the subtree and this fiber onto the effect
// list of the parent. The completion order of the children affects the
// side-effect order.
if(returnFiber.firstEffect===null){returnFiber.firstEffect=workInProgress.firstEffect;}if(workInProgress.lastEffect!==null){if(returnFiber.lastEffect!==null){returnFiber.lastEffect.nextEffect=workInProgress.firstEffect;}returnFiber.lastEffect=workInProgress.lastEffect;}// If this fiber had side-effects, we append it AFTER the children's
// side-effects. We can perform certain side-effects earlier if
// needed, by doing multiple passes over the effect list. We don't want
// to schedule our own side-effect on our own list because if end up
// reusing children we'll schedule this effect onto itself since we're
// at the end.
var effectTag=workInProgress.effectTag;// Skip both NoWork and PerformedWork tags when creating the effect list.
// PerformedWork effect is read by React DevTools but shouldn't be committed.
if(effectTag>PerformedWork){if(returnFiber.lastEffect!==null){returnFiber.lastEffect.nextEffect=workInProgress;}else{returnFiber.firstEffect=workInProgress;}returnFiber.lastEffect=workInProgress;}}stopWorkTimer(workInProgress);if(true&&ReactFiberInstrumentation_1.debugTool){ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);}if(siblingFiber!==null){// If there is more work to do in this returnFiber, do that next.
return siblingFiber;}else if(returnFiber!==null){// If there's no more work in this returnFiber. Complete the returnFiber.
workInProgress=returnFiber;continue;}else{// We've reached the root.
var root=workInProgress.stateNode;root.isReadyForCommit=true;return null;}}// Without this explicit null return Flow complains of invalid return type
// TODO Remove the above while(true) loop
// eslint-disable-next-line no-unreachable
return null;}function performUnitOfWork(workInProgress){// The current, flushed, state of this fiber is the alternate.
// Ideally nothing should rely on this, but relying on it here
// means that we don't need an additional field on the work in
// progress.
var current=workInProgress.alternate;// See if beginning this work spawns more work.
startWorkTimer(workInProgress);{ReactDebugCurrentFiber.setCurrentFiber(workInProgress);}var next=beginWork(current,workInProgress,nextRenderExpirationTime);{ReactDebugCurrentFiber.resetCurrentFiber();}if(true&&ReactFiberInstrumentation_1.debugTool){ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);}if(next===null){// If this doesn't spawn new work, complete the current work.
next=completeUnitOfWork(workInProgress);}ReactCurrentOwner.current=null;return next;}function performFailedUnitOfWork(workInProgress){// The current, flushed, state of this fiber is the alternate.
// Ideally nothing should rely on this, but relying on it here
// means that we don't need an additional field on the work in
// progress.
var current=workInProgress.alternate;// See if beginning this work spawns more work.
startWorkTimer(workInProgress);{ReactDebugCurrentFiber.setCurrentFiber(workInProgress);}var next=beginFailedWork(current,workInProgress,nextRenderExpirationTime);{ReactDebugCurrentFiber.resetCurrentFiber();}if(true&&ReactFiberInstrumentation_1.debugTool){ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);}if(next===null){// If this doesn't spawn new work, complete the current work.
next=completeUnitOfWork(workInProgress);}ReactCurrentOwner.current=null;return next;}function workLoop(expirationTime){if(capturedErrors!==null){// If there are unhandled errors, switch to the slow work loop.
// TODO: How to avoid this check in the fast path? Maybe the renderer
// could keep track of which roots have unhandled errors and call a
// forked version of renderRoot.
slowWorkLoopThatChecksForFailedWork(expirationTime);return;}if(nextRenderExpirationTime===NoWork||nextRenderExpirationTime>expirationTime){return;}if(nextRenderExpirationTime<=mostRecentCurrentTime){// Flush all expired work.
while(nextUnitOfWork!==null){nextUnitOfWork=performUnitOfWork(nextUnitOfWork);}}else{// Flush asynchronous work until the deadline runs out of time.
while(nextUnitOfWork!==null&&!shouldYield()){nextUnitOfWork=performUnitOfWork(nextUnitOfWork);}}}function slowWorkLoopThatChecksForFailedWork(expirationTime){if(nextRenderExpirationTime===NoWork||nextRenderExpirationTime>expirationTime){return;}if(nextRenderExpirationTime<=mostRecentCurrentTime){// Flush all expired work.
while(nextUnitOfWork!==null){if(hasCapturedError(nextUnitOfWork)){// Use a forked version of performUnitOfWork
nextUnitOfWork=performFailedUnitOfWork(nextUnitOfWork);}else{nextUnitOfWork=performUnitOfWork(nextUnitOfWork);}}}else{// Flush asynchronous work until the deadline runs out of time.
while(nextUnitOfWork!==null&&!shouldYield()){if(hasCapturedError(nextUnitOfWork)){// Use a forked version of performUnitOfWork
nextUnitOfWork=performFailedUnitOfWork(nextUnitOfWork);}else{nextUnitOfWork=performUnitOfWork(nextUnitOfWork);}}}}function renderRootCatchBlock(root,failedWork,boundary,expirationTime){// We're going to restart the error boundary that captured the error.
// Conceptually, we're unwinding the stack. We need to unwind the
// context stack, too.
unwindContexts(failedWork,boundary);// Restart the error boundary using a forked version of
// performUnitOfWork that deletes the boundary's children. The entire
// failed subree will be unmounted. During the commit phase, a special
// lifecycle method is called on the error boundary, which triggers
// a re-render.
nextUnitOfWork=performFailedUnitOfWork(boundary);// Continue working.
workLoop(expirationTime);}function renderRoot(root,expirationTime){!!isWorking?invariant(false,'renderRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.'):void 0;isWorking=true;// We're about to mutate the work-in-progress tree. If the root was pending
// commit, it no longer is: we'll need to complete it again.
root.isReadyForCommit=false;// Check if we're starting from a fresh stack, or if we're resuming from
// previously yielded work.
if(root!==nextRoot||expirationTime!==nextRenderExpirationTime||nextUnitOfWork===null){// Reset the stack and start working from the root.
resetContextStack();nextRoot=root;nextRenderExpirationTime=expirationTime;nextUnitOfWork=createWorkInProgress(nextRoot.current,null,expirationTime);}startWorkLoopTimer(nextUnitOfWork);var didError=false;var error=null;{invokeGuardedCallback$1(null,workLoop,null,expirationTime);if(hasCaughtError()){didError=true;error=clearCaughtError();}}// An error was thrown during the render phase.
while(didError){if(didFatal){// This was a fatal error. Don't attempt to recover from it.
firstUncaughtError=error;break;}var failedWork=nextUnitOfWork;if(failedWork===null){// An error was thrown but there's no current unit of work. This can
// happen during the commit phase if there's a bug in the renderer.
didFatal=true;continue;}// "Capture" the error by finding the nearest boundary. If there is no
// error boundary, we use the root.
var boundary=captureError(failedWork,error);!(boundary!==null)?invariant(false,'Should have found an error boundary. This error is likely caused by a bug in React. Please file an issue.'):void 0;if(didFatal){// The error we just captured was a fatal error. This happens
// when the error propagates to the root more than once.
continue;}didError=false;error=null;{invokeGuardedCallback$1(null,renderRootCatchBlock,null,root,failedWork,boundary,expirationTime);if(hasCaughtError()){didError=true;error=clearCaughtError();continue;}}// We're finished working. Exit the error loop.
break;}var uncaughtError=firstUncaughtError;// We're done performing work. Time to clean up.
stopWorkLoopTimer(interruptedBy);interruptedBy=null;isWorking=false;didFatal=false;firstUncaughtError=null;if(uncaughtError!==null){onUncaughtError(uncaughtError);}return root.isReadyForCommit?root.current.alternate:null;}// Returns the boundary that captured the error, or null if the error is ignored
function captureError(failedWork,error){// It is no longer valid because we exited the user code.
ReactCurrentOwner.current=null;{ReactDebugCurrentFiber.resetCurrentFiber();}// Search for the nearest error boundary.
var boundary=null;// Passed to logCapturedError()
var errorBoundaryFound=false;var willRetry=false;var errorBoundaryName=null;// Host containers are a special case. If the failed work itself is a host
// container, then it acts as its own boundary. In all other cases, we
// ignore the work itself and only search through the parents.
if(failedWork.tag===HostRoot){boundary=failedWork;if(isFailedBoundary(failedWork)){// If this root already failed, there must have been an error when
// attempting to unmount it. This is a worst-case scenario and
// should only be possible if there's a bug in the renderer.
didFatal=true;}}else{var node=failedWork['return'];while(node!==null&&boundary===null){if(node.tag===ClassComponent){var instance=node.stateNode;if(typeof instance.componentDidCatch==='function'){errorBoundaryFound=true;errorBoundaryName=getComponentName(node);// Found an error boundary!
boundary=node;willRetry=true;}}else if(node.tag===HostRoot){// Treat the root like a no-op error boundary
boundary=node;}if(isFailedBoundary(node)){// This boundary is already in a failed state.
// If we're currently unmounting, that means this error was
// thrown while unmounting a failed subtree. We should ignore
// the error.
if(isUnmounting){return null;}// If we're in the commit phase, we should check to see if
// this boundary already captured an error during this commit.
// This case exists because multiple errors can be thrown during
// a single commit without interruption.
if(commitPhaseBoundaries!==null&&(commitPhaseBoundaries.has(node)||node.alternate!==null&&commitPhaseBoundaries.has(node.alternate))){// If so, we should ignore this error.
return null;}// The error should propagate to the next boundary -— we keep looking.
boundary=null;willRetry=false;}node=node['return'];}}if(boundary!==null){// Add to the collection of failed boundaries. This lets us know that
// subsequent errors in this subtree should propagate to the next boundary.
if(failedBoundaries===null){failedBoundaries=new Set();}failedBoundaries.add(boundary);// This method is unsafe outside of the begin and complete phases.
// We might be in the commit phase when an error is captured.
// The risk is that the return path from this Fiber may not be accurate.
// That risk is acceptable given the benefit of providing users more context.
var _componentStack=getStackAddendumByWorkInProgressFiber(failedWork);var _componentName=getComponentName(failedWork);// Add to the collection of captured errors. This is stored as a global
// map of errors and their component stack location keyed by the boundaries
// that capture them. We mostly use this Map as a Set; it's a Map only to
// avoid adding a field to Fiber to store the error.
if(capturedErrors===null){capturedErrors=new Map();}var capturedError={componentName:_componentName,componentStack:_componentStack,error:error,errorBoundary:errorBoundaryFound?boundary.stateNode:null,errorBoundaryFound:errorBoundaryFound,errorBoundaryName:errorBoundaryName,willRetry:willRetry};capturedErrors.set(boundary,capturedError);try{logCapturedError(capturedError);}catch(e){// Prevent cycle if logCapturedError() throws.
// A cycle may still occur if logCapturedError renders a component that throws.
var suppressLogging=e&&e.suppressReactErrorLogging;if(!suppressLogging){console.error(e);}}// If we're in the commit phase, defer scheduling an update on the
// boundary until after the commit is complete
if(isCommitting){if(commitPhaseBoundaries===null){commitPhaseBoundaries=new Set();}commitPhaseBoundaries.add(boundary);}else{// Otherwise, schedule an update now.
// TODO: Is this actually necessary during the render phase? Is it
// possible to unwind and continue rendering at the same priority,
// without corrupting internal state?
scheduleErrorRecovery(boundary);}return boundary;}else if(firstUncaughtError===null){// If no boundary is found, we'll need to throw the error
firstUncaughtError=error;}return null;}function hasCapturedError(fiber){// TODO: capturedErrors should store the boundary instance, to avoid needing
// to check the alternate.
return capturedErrors!==null&&(capturedErrors.has(fiber)||fiber.alternate!==null&&capturedErrors.has(fiber.alternate));}function isFailedBoundary(fiber){// TODO: failedBoundaries should store the boundary instance, to avoid
// needing to check the alternate.
return failedBoundaries!==null&&(failedBoundaries.has(fiber)||fiber.alternate!==null&&failedBoundaries.has(fiber.alternate));}function commitErrorHandling(effectfulFiber){var capturedError=void 0;if(capturedErrors!==null){capturedError=capturedErrors.get(effectfulFiber);capturedErrors['delete'](effectfulFiber);if(capturedError==null){if(effectfulFiber.alternate!==null){effectfulFiber=effectfulFiber.alternate;capturedError=capturedErrors.get(effectfulFiber);capturedErrors['delete'](effectfulFiber);}}}!(capturedError!=null)?invariant(false,'No error for given unit of work. This error is likely caused by a bug in React. Please file an issue.'):void 0;switch(effectfulFiber.tag){case ClassComponent:var instance=effectfulFiber.stateNode;var info={componentStack:capturedError.componentStack};// Allow the boundary to handle the error, usually by scheduling
// an update to itself
instance.componentDidCatch(capturedError.error,info);return;case HostRoot:if(firstUncaughtError===null){firstUncaughtError=capturedError.error;}return;default:invariant(false,'Invalid type of work. This error is likely caused by a bug in React. Please file an issue.');}}function unwindContexts(from,to){var node=from;while(node!==null){switch(node.tag){case ClassComponent:popContextProvider(node);break;case HostComponent:popHostContext(node);break;case HostRoot:popHostContainer(node);break;case HostPortal:popHostContainer(node);break;}if(node===to||node.alternate===to){stopFailedWorkTimer(node);break;}else{stopWorkTimer(node);}node=node['return'];}}function computeAsyncExpiration(){// Given the current clock time, returns an expiration time. We use rounding
// to batch like updates together.
// Should complete within ~1000ms. 1200ms max.
var currentTime=recalculateCurrentTime();var expirationMs=1000;var bucketSizeMs=200;return computeExpirationBucket(currentTime,expirationMs,bucketSizeMs);}function computeExpirationForFiber(fiber){var expirationTime=void 0;if(expirationContext!==NoWork){// An explicit expiration context was set;
expirationTime=expirationContext;}else if(isWorking){if(isCommitting){// Updates that occur during the commit phase should have sync priority
// by default.
expirationTime=Sync;}else{// Updates during the render phase should expire at the same time as
// the work that is being rendered.
expirationTime=nextRenderExpirationTime;}}else{// No explicit expiration context was set, and we're not currently
// performing work. Calculate a new expiration time.
if(useSyncScheduling&&!(fiber.internalContextTag&AsyncUpdates)){// This is a sync update
expirationTime=Sync;}else{// This is an async update
expirationTime=computeAsyncExpiration();}}return expirationTime;}function scheduleWork(fiber,expirationTime){return scheduleWorkImpl(fiber,expirationTime,false);}function checkRootNeedsClearing(root,fiber,expirationTime){if(!isWorking&&root===nextRoot&&expirationTime<nextRenderExpirationTime){// Restart the root from the top.
if(nextUnitOfWork!==null){// This is an interruption. (Used for performance tracking.)
interruptedBy=fiber;}nextRoot=null;nextUnitOfWork=null;nextRenderExpirationTime=NoWork;}}function scheduleWorkImpl(fiber,expirationTime,isErrorRecovery){recordScheduleUpdate();{if(!isErrorRecovery&&fiber.tag===ClassComponent){var instance=fiber.stateNode;warnAboutInvalidUpdates(instance);}}var node=fiber;while(node!==null){// Walk the parent path to the root and update each node's
// expiration time.
if(node.expirationTime===NoWork||node.expirationTime>expirationTime){node.expirationTime=expirationTime;}if(node.alternate!==null){if(node.alternate.expirationTime===NoWork||node.alternate.expirationTime>expirationTime){node.alternate.expirationTime=expirationTime;}}if(node['return']===null){if(node.tag===HostRoot){var root=node.stateNode;checkRootNeedsClearing(root,fiber,expirationTime);requestWork(root,expirationTime);checkRootNeedsClearing(root,fiber,expirationTime);}else{{if(!isErrorRecovery&&fiber.tag===ClassComponent){warnAboutUpdateOnUnmounted(fiber);}}return;}}node=node['return'];}}function scheduleErrorRecovery(fiber){scheduleWorkImpl(fiber,Sync,true);}function recalculateCurrentTime(){// Subtract initial time so it fits inside 32bits
var ms=now()-startTime;mostRecentCurrentTime=msToExpirationTime(ms);return mostRecentCurrentTime;}function deferredUpdates(fn){var previousExpirationContext=expirationContext;expirationContext=computeAsyncExpiration();try{return fn();}finally{expirationContext=previousExpirationContext;}}function syncUpdates(fn){var previousExpirationContext=expirationContext;expirationContext=Sync;try{return fn();}finally{expirationContext=previousExpirationContext;}}// TODO: Everything below this is written as if it has been lifted to the
// renderers. I'll do this in a follow-up.
// Linked-list of roots
var firstScheduledRoot=null;var lastScheduledRoot=null;var callbackExpirationTime=NoWork;var callbackID=-1;var isRendering=false;var nextFlushedRoot=null;var nextFlushedExpirationTime=NoWork;var deadlineDidExpire=false;var hasUnhandledError=false;var unhandledError=null;var deadline=null;var isBatchingUpdates=false;var isUnbatchingUpdates=false;// Use these to prevent an infinite loop of nested updates
var NESTED_UPDATE_LIMIT=1000;var nestedUpdateCount=0;var timeHeuristicForUnitOfWork=1;function scheduleCallbackWithExpiration(expirationTime){if(callbackExpirationTime!==NoWork){// A callback is already scheduled. Check its expiration time (timeout).
if(expirationTime>callbackExpirationTime){// Existing callback has sufficient timeout. Exit.
return;}else{// Existing callback has insufficient timeout. Cancel and schedule a
// new one.
cancelDeferredCallback(callbackID);}// The request callback timer is already running. Don't start a new one.
}else{startRequestCallbackTimer();}// Compute a timeout for the given expiration time.
var currentMs=now()-startTime;var expirationMs=expirationTimeToMs(expirationTime);var timeout=expirationMs-currentMs;callbackExpirationTime=expirationTime;callbackID=scheduleDeferredCallback(performAsyncWork,{timeout:timeout});}// requestWork is called by the scheduler whenever a root receives an update.
// It's up to the renderer to call renderRoot at some point in the future.
function requestWork(root,expirationTime){if(nestedUpdateCount>NESTED_UPDATE_LIMIT){invariant(false,'Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.');}// Add the root to the schedule.
// Check if this root is already part of the schedule.
if(root.nextScheduledRoot===null){// This root is not already scheduled. Add it.
root.remainingExpirationTime=expirationTime;if(lastScheduledRoot===null){firstScheduledRoot=lastScheduledRoot=root;root.nextScheduledRoot=root;}else{lastScheduledRoot.nextScheduledRoot=root;lastScheduledRoot=root;lastScheduledRoot.nextScheduledRoot=firstScheduledRoot;}}else{// This root is already scheduled, but its priority may have increased.
var remainingExpirationTime=root.remainingExpirationTime;if(remainingExpirationTime===NoWork||expirationTime<remainingExpirationTime){// Update the priority.
root.remainingExpirationTime=expirationTime;}}if(isRendering){// Prevent reentrancy. Remaining work will be scheduled at the end of
// the currently rendering batch.
return;}if(isBatchingUpdates){// Flush work at the end of the batch.
if(isUnbatchingUpdates){// ...unless we're inside unbatchedUpdates, in which case we should
// flush it now.
nextFlushedRoot=root;nextFlushedExpirationTime=Sync;performWorkOnRoot(nextFlushedRoot,nextFlushedExpirationTime);}return;}// TODO: Get rid of Sync and use current time?
if(expirationTime===Sync){performWork(Sync,null);}else{scheduleCallbackWithExpiration(expirationTime);}}function findHighestPriorityRoot(){var highestPriorityWork=NoWork;var highestPriorityRoot=null;if(lastScheduledRoot!==null){var previousScheduledRoot=lastScheduledRoot;var root=firstScheduledRoot;while(root!==null){var remainingExpirationTime=root.remainingExpirationTime;if(remainingExpirationTime===NoWork){// This root no longer has work. Remove it from the scheduler.
// TODO: This check is redudant, but Flow is confused by the branch
// below where we set lastScheduledRoot to null, even though we break
// from the loop right after.
!(previousScheduledRoot!==null&&lastScheduledRoot!==null)?invariant(false,'Should have a previous and last root. This error is likely caused by a bug in React. Please file an issue.'):void 0;if(root===root.nextScheduledRoot){// This is the only root in the list.
root.nextScheduledRoot=null;firstScheduledRoot=lastScheduledRoot=null;break;}else if(root===firstScheduledRoot){// This is the first root in the list.
var next=root.nextScheduledRoot;firstScheduledRoot=next;lastScheduledRoot.nextScheduledRoot=next;root.nextScheduledRoot=null;}else if(root===lastScheduledRoot){// This is the last root in the list.
lastScheduledRoot=previousScheduledRoot;lastScheduledRoot.nextScheduledRoot=firstScheduledRoot;root.nextScheduledRoot=null;break;}else{previousScheduledRoot.nextScheduledRoot=root.nextScheduledRoot;root.nextScheduledRoot=null;}root=previousScheduledRoot.nextScheduledRoot;}else{if(highestPriorityWork===NoWork||remainingExpirationTime<highestPriorityWork){// Update the priority, if it's higher
highestPriorityWork=remainingExpirationTime;highestPriorityRoot=root;}if(root===lastScheduledRoot){break;}previousScheduledRoot=root;root=root.nextScheduledRoot;}}}// If the next root is the same as the previous root, this is a nested
// update. To prevent an infinite loop, increment the nested update count.
var previousFlushedRoot=nextFlushedRoot;if(previousFlushedRoot!==null&&previousFlushedRoot===highestPriorityRoot){nestedUpdateCount++;}else{// Reset whenever we switch roots.
nestedUpdateCount=0;}nextFlushedRoot=highestPriorityRoot;nextFlushedExpirationTime=highestPriorityWork;}function performAsyncWork(dl){performWork(NoWork,dl);}function performWork(minExpirationTime,dl){deadline=dl;// Keep working on roots until there's no more work, or until the we reach
// the deadline.
findHighestPriorityRoot();if(enableUserTimingAPI&&deadline!==null){var didExpire=nextFlushedExpirationTime<recalculateCurrentTime();stopRequestCallbackTimer(didExpire);}while(nextFlushedRoot!==null&&nextFlushedExpirationTime!==NoWork&&(minExpirationTime===NoWork||nextFlushedExpirationTime<=minExpirationTime)&&!deadlineDidExpire){performWorkOnRoot(nextFlushedRoot,nextFlushedExpirationTime);// Find the next highest priority work.
findHighestPriorityRoot();}// We're done flushing work. Either we ran out of time in this callback,
// or there's no more work left with sufficient priority.
// If we're inside a callback, set this to false since we just completed it.
if(deadline!==null){callbackExpirationTime=NoWork;callbackID=-1;}// If there's work left over, schedule a new callback.
if(nextFlushedExpirationTime!==NoWork){scheduleCallbackWithExpiration(nextFlushedExpirationTime);}// Clean-up.
deadline=null;deadlineDidExpire=false;nestedUpdateCount=0;if(hasUnhandledError){var _error4=unhandledError;unhandledError=null;hasUnhandledError=false;throw _error4;}}function performWorkOnRoot(root,expirationTime){!!isRendering?invariant(false,'performWorkOnRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.'):void 0;isRendering=true;// Check if this is async work or sync/expired work.
// TODO: Pass current time as argument to renderRoot, commitRoot
if(expirationTime<=recalculateCurrentTime()){// Flush sync work.
var finishedWork=root.finishedWork;if(finishedWork!==null){// This root is already complete. We can commit it.
root.finishedWork=null;root.remainingExpirationTime=commitRoot(finishedWork);}else{root.finishedWork=null;finishedWork=renderRoot(root,expirationTime);if(finishedWork!==null){// We've completed the root. Commit it.
root.remainingExpirationTime=commitRoot(finishedWork);}}}else{// Flush async work.
var _finishedWork=root.finishedWork;if(_finishedWork!==null){// This root is already complete. We can commit it.
root.finishedWork=null;root.remainingExpirationTime=commitRoot(_finishedWork);}else{root.finishedWork=null;_finishedWork=renderRoot(root,expirationTime);if(_finishedWork!==null){// We've completed the root. Check the deadline one more time
// before committing.
if(!shouldYield()){// Still time left. Commit the root.
root.remainingExpirationTime=commitRoot(_finishedWork);}else{// There's no time left. Mark this root as complete. We'll come
// back and commit it later.
root.finishedWork=_finishedWork;}}}}isRendering=false;}// When working on async work, the reconciler asks the renderer if it should
// yield execution. For DOM, we implement this with requestIdleCallback.
function shouldYield(){if(deadline===null){return false;}if(deadline.timeRemaining()>timeHeuristicForUnitOfWork){// Disregard deadline.didTimeout. Only expired work should be flushed
// during a timeout. This path is only hit for non-expired work.
return false;}deadlineDidExpire=true;return true;}// TODO: Not happy about this hook. Conceptually, renderRoot should return a
// tuple of (isReadyForCommit, didError, error)
function onUncaughtError(error){!(nextFlushedRoot!==null)?invariant(false,'Should be working on a root. This error is likely caused by a bug in React. Please file an issue.'):void 0;// Unschedule this root so we don't work on it again until there's
// another update.
nextFlushedRoot.remainingExpirationTime=NoWork;if(!hasUnhandledError){hasUnhandledError=true;unhandledError=error;}}// TODO: Batching should be implemented at the renderer level, not inside
// the reconciler.
function batchedUpdates(fn,a){var previousIsBatchingUpdates=isBatchingUpdates;isBatchingUpdates=true;try{return fn(a);}finally{isBatchingUpdates=previousIsBatchingUpdates;if(!isBatchingUpdates&&!isRendering){performWork(Sync,null);}}}// TODO: Batching should be implemented at the renderer level, not inside
// the reconciler.
function unbatchedUpdates(fn){if(isBatchingUpdates&&!isUnbatchingUpdates){isUnbatchingUpdates=true;try{return fn();}finally{isUnbatchingUpdates=false;}}return fn();}// TODO: Batching should be implemented at the renderer level, not within
// the reconciler.
function flushSync(fn){var previousIsBatchingUpdates=isBatchingUpdates;isBatchingUpdates=true;try{return syncUpdates(fn);}finally{isBatchingUpdates=previousIsBatchingUpdates;!!isRendering?invariant(false,'flushSync was called from inside a lifecycle method. It cannot be called when React is already rendering.'):void 0;performWork(Sync,null);}}return{computeAsyncExpiration:computeAsyncExpiration,computeExpirationForFiber:computeExpirationForFiber,scheduleWork:scheduleWork,batchedUpdates:batchedUpdates,unbatchedUpdates:unbatchedUpdates,flushSync:flushSync,deferredUpdates:deferredUpdates};};{var didWarnAboutNestedUpdates=false;}// 0 is PROD, 1 is DEV.
// Might add PROFILE later.
function getContextForSubtree(parentComponent){if(!parentComponent){return emptyObject;}var fiber=get(parentComponent);var parentContext=findCurrentUnmaskedContext(fiber);return isContextProvider(fiber)?processChildContext(fiber,parentContext):parentContext;}var ReactFiberReconciler$1=function ReactFiberReconciler$1(config){var getPublicInstance=config.getPublicInstance;var _ReactFiberScheduler=ReactFiberScheduler(config),computeAsyncExpiration=_ReactFiberScheduler.computeAsyncExpiration,computeExpirationForFiber=_ReactFiberScheduler.computeExpirationForFiber,scheduleWork=_ReactFiberScheduler.scheduleWork,batchedUpdates=_ReactFiberScheduler.batchedUpdates,unbatchedUpdates=_ReactFiberScheduler.unbatchedUpdates,flushSync=_ReactFiberScheduler.flushSync,deferredUpdates=_ReactFiberScheduler.deferredUpdates;function scheduleTopLevelUpdate(current,element,callback){{if(ReactDebugCurrentFiber.phase==='render'&&ReactDebugCurrentFiber.current!==null&&!didWarnAboutNestedUpdates){didWarnAboutNestedUpdates=true;warning(false,'Render methods should be a pure function of props and state; '+'triggering nested component updates from render is not allowed. '+'If necessary, trigger nested updates in componentDidUpdate.\n\n'+'Check the render method of %s.',getComponentName(ReactDebugCurrentFiber.current)||'Unknown');}}callback=callback===undefined?null:callback;{warning(callback===null||typeof callback==='function','render(...): Expected the last optional `callback` argument to be a '+'function. Instead received: %s.',callback);}var expirationTime=void 0;// Check if the top-level element is an async wrapper component. If so,
// treat updates to the root as async. This is a bit weird but lets us
// avoid a separate `renderAsync` API.
if(enableAsyncSubtreeAPI&&element!=null&&element.type!=null&&element.type.prototype!=null&&element.type.prototype.unstable_isAsyncReactComponent===true){expirationTime=computeAsyncExpiration();}else{expirationTime=computeExpirationForFiber(current);}var update={expirationTime:expirationTime,partialState:{element:element},callback:callback,isReplace:false,isForced:false,nextCallback:null,next:null};insertUpdateIntoFiber(current,update);scheduleWork(current,expirationTime);}function findHostInstance(fiber){var hostFiber=findCurrentHostFiber(fiber);if(hostFiber===null){return null;}return hostFiber.stateNode;}return{createContainer:function createContainer(containerInfo,hydrate){return createFiberRoot(containerInfo,hydrate);},updateContainer:function updateContainer(element,container,parentComponent,callback){// TODO: If this is a nested container, this won't be the root.
var current=container.current;{if(ReactFiberInstrumentation_1.debugTool){if(current.alternate===null){ReactFiberInstrumentation_1.debugTool.onMountContainer(container);}else if(element===null){ReactFiberInstrumentation_1.debugTool.onUnmountContainer(container);}else{ReactFiberInstrumentation_1.debugTool.onUpdateContainer(container);}}}var context=getContextForSubtree(parentComponent);if(container.context===null){container.context=context;}else{container.pendingContext=context;}scheduleTopLevelUpdate(current,element,callback);},batchedUpdates:batchedUpdates,unbatchedUpdates:unbatchedUpdates,deferredUpdates:deferredUpdates,flushSync:flushSync,getPublicRootInstance:function getPublicRootInstance(container){var containerFiber=container.current;if(!containerFiber.child){return null;}switch(containerFiber.child.tag){case HostComponent:return getPublicInstance(containerFiber.child.stateNode);default:return containerFiber.child.stateNode;}},findHostInstance:findHostInstance,findHostInstanceWithNoPortals:function findHostInstanceWithNoPortals(fiber){var hostFiber=findCurrentHostFiberWithNoPortals(fiber);if(hostFiber===null){return null;}return hostFiber.stateNode;},injectIntoDevTools:function injectIntoDevTools(devToolsConfig){var _findFiberByHostInstance=devToolsConfig.findFiberByHostInstance;return injectInternals(_assign({},devToolsConfig,{findHostInstanceByFiber:function findHostInstanceByFiber(fiber){return findHostInstance(fiber);},findFiberByHostInstance:function findFiberByHostInstance(instance){if(!_findFiberByHostInstance){// Might not be implemented by the renderer.
return null;}return _findFiberByHostInstance(instance);}}));}};};var ReactFiberReconciler$2=Object.freeze({default:ReactFiberReconciler$1});var ReactFiberReconciler$3=ReactFiberReconciler$2&&ReactFiberReconciler$1||ReactFiberReconciler$2;// TODO: bundle Flow types with the package.
// TODO: decide on the top-level export form.
// This is hacky but makes it work with both Rollup and Jest.
var reactReconciler=ReactFiberReconciler$3['default']?ReactFiberReconciler$3['default']:ReactFiberReconciler$3;function createPortal$1(children,containerInfo,// TODO: figure out the API for cross-renderer implementation.
implementation){var key=arguments.length>3&&arguments[3]!==undefined?arguments[3]:null;return{// This tag allow us to uniquely identify this as a React Portal
$$typeof:REACT_PORTAL_TYPE,key:key==null?null:''+key,children:children,containerInfo:containerInfo,implementation:implementation};}// TODO: this is special because it gets imported during build.
var ReactVersion='16.2.0';// a requestAnimationFrame, storing the time for the start of the frame, then
// scheduling a postMessage which gets scheduled after paint. Within the
// postMessage handler do as much work as possible until time + frame rate.
// By separating the idle call into a separate event tick we ensure that
// layout, paint and other browser work is counted against the available time.
// The frame rate is dynamically adjusted.
{if(ExecutionEnvironment.canUseDOM&&typeof requestAnimationFrame!=='function'){warning(false,'React depends on requestAnimationFrame. Make sure that you load a '+'polyfill in older browsers. http://fb.me/react-polyfills');}}var hasNativePerformanceNow=(typeof performance==='undefined'?'undefined':_typeof(performance))==='object'&&typeof performance.now==='function';var now=void 0;if(hasNativePerformanceNow){now=function now(){return performance.now();};}else{now=function now(){return Date.now();};}// TODO: There's no way to cancel, because Fiber doesn't atm.
var rIC=void 0;var cIC=void 0;if(!ExecutionEnvironment.canUseDOM){rIC=function rIC(frameCallback){return setTimeout(function(){frameCallback({timeRemaining:function timeRemaining(){return Infinity;}});});};cIC=function cIC(timeoutID){clearTimeout(timeoutID);};}else if(typeof requestIdleCallback!=='function'||typeof cancelIdleCallback!=='function'){// Polyfill requestIdleCallback and cancelIdleCallback
var scheduledRICCallback=null;var isIdleScheduled=false;var timeoutTime=-1;var isAnimationFrameScheduled=false;var frameDeadline=0;// We start out assuming that we run at 30fps but then the heuristic tracking
// will adjust this value to a faster fps if we get more frequent animation
// frames.
var previousFrameTime=33;var activeFrameTime=33;var frameDeadlineObject;if(hasNativePerformanceNow){frameDeadlineObject={didTimeout:false,timeRemaining:function timeRemaining(){// We assume that if we have a performance timer that the rAF callback
// gets a performance timer value. Not sure if this is always true.
var remaining=frameDeadline-performance.now();return remaining>0?remaining:0;}};}else{frameDeadlineObject={didTimeout:false,timeRemaining:function timeRemaining(){// Fallback to Date.now()
var remaining=frameDeadline-Date.now();return remaining>0?remaining:0;}};}// We use the postMessage trick to defer idle work until after the repaint.
var messageKey='__reactIdleCallback$'+Math.random().toString(36).slice(2);var idleTick=function idleTick(event){if(event.source!==window||event.data!==messageKey){return;}isIdleScheduled=false;var currentTime=now();if(frameDeadline-currentTime<=0){// There's no time left in this idle period. Check if the callback has
// a timeout and whether it's been exceeded.
if(timeoutTime!==-1&&timeoutTime<=currentTime){// Exceeded the timeout. Invoke the callback even though there's no
// time left.
frameDeadlineObject.didTimeout=true;}else{// No timeout.
if(!isAnimationFrameScheduled){// Schedule another animation callback so we retry later.
isAnimationFrameScheduled=true;requestAnimationFrame(animationTick);}// Exit without invoking the callback.
return;}}else{// There's still time left in this idle period.
frameDeadlineObject.didTimeout=false;}timeoutTime=-1;var callback=scheduledRICCallback;scheduledRICCallback=null;if(callback!==null){callback(frameDeadlineObject);}};// Assumes that we have addEventListener in this environment. Might need
// something better for old IE.
window.addEventListener('message',idleTick,false);var animationTick=function animationTick(rafTime){isAnimationFrameScheduled=false;var nextFrameTime=rafTime-frameDeadline+activeFrameTime;if(nextFrameTime<activeFrameTime&&previousFrameTime<activeFrameTime){if(nextFrameTime<8){// Defensive coding. We don't support higher frame rates than 120hz.
// If we get lower than that, it is probably a bug.
nextFrameTime=8;}// If one frame goes long, then the next one can be short to catch up.
// If two frames are short in a row, then that's an indication that we
// actually have a higher frame rate than what we're currently optimizing.
// We adjust our heuristic dynamically accordingly. For example, if we're
// running on 120hz display or 90hz VR display.
// Take the max of the two in case one of them was an anomaly due to
// missed frame deadlines.
activeFrameTime=nextFrameTime<previousFrameTime?previousFrameTime:nextFrameTime;}else{previousFrameTime=nextFrameTime;}frameDeadline=rafTime+activeFrameTime;if(!isIdleScheduled){isIdleScheduled=true;window.postMessage(messageKey,'*');}};rIC=function rIC(callback,options){// This assumes that we only schedule one callback at a time because that's
// how Fiber uses it.
scheduledRICCallback=callback;if(options!=null&&typeof options.timeout==='number'){timeoutTime=now()+options.timeout;}if(!isAnimationFrameScheduled){// If rAF didn't already schedule one, we need to schedule a frame.
// TODO: If this rAF doesn't materialize because the browser throttles, we
// might want to still have setTimeout trigger rIC as a backup to ensure
// that we keep performing work.
isAnimationFrameScheduled=true;requestAnimationFrame(animationTick);}return 0;};cIC=function cIC(){scheduledRICCallback=null;isIdleScheduled=false;timeoutTime=-1;};}else{rIC=window.requestIdleCallback;cIC=window.cancelIdleCallback;}/**
 * Forked from fbjs/warning:
 * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js
 *
 * Only change is we use console.warn instead of console.error,
 * and do nothing when 'console' is not supported.
 * This really simplifies the code.
 * ---
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */var lowPriorityWarning=function lowPriorityWarning(){};{var printWarning=function printWarning(format){for(var _len=arguments.length,args=Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){args[_key-1]=arguments[_key];}var argIndex=0;var message='Warning: '+format.replace(/%s/g,function(){return args[argIndex++];});if(typeof console!=='undefined'){console.warn(message);}try{// --- Welcome to debugging React ---
// This error was thrown as a convenience so that you can use this stack
// to find the callsite that caused this warning to fire.
throw new Error(message);}catch(x){}};lowPriorityWarning=function lowPriorityWarning(condition,format){if(format===undefined){throw new Error('`warning(condition, format, ...args)` requires a warning '+'message argument');}if(!condition){for(var _len2=arguments.length,args=Array(_len2>2?_len2-2:0),_key2=2;_key2<_len2;_key2++){args[_key2-2]=arguments[_key2];}printWarning.apply(undefined,[format].concat(args));}};}var lowPriorityWarning$1=lowPriorityWarning;// isAttributeNameSafe() is currently duplicated in DOMMarkupOperations.
// TODO: Find a better place for this.
var VALID_ATTRIBUTE_NAME_REGEX=new RegExp('^['+ATTRIBUTE_NAME_START_CHAR+']['+ATTRIBUTE_NAME_CHAR+']*$');var illegalAttributeNameCache={};var validatedAttributeNameCache={};function isAttributeNameSafe(attributeName){if(validatedAttributeNameCache.hasOwnProperty(attributeName)){return true;}if(illegalAttributeNameCache.hasOwnProperty(attributeName)){return false;}if(VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)){validatedAttributeNameCache[attributeName]=true;return true;}illegalAttributeNameCache[attributeName]=true;{warning(false,'Invalid attribute name: `%s`',attributeName);}return false;}// shouldIgnoreValue() is currently duplicated in DOMMarkupOperations.
// TODO: Find a better place for this.
function shouldIgnoreValue(propertyInfo,value){return value==null||propertyInfo.hasBooleanValue&&!value||propertyInfo.hasNumericValue&&isNaN(value)||propertyInfo.hasPositiveNumericValue&&value<1||propertyInfo.hasOverloadedBooleanValue&&value===false;}/**
 * Operations for dealing with DOM properties.
 *//**
 * Get the value for a property on a node. Only used in DEV for SSR validation.
 * The "expected" argument is used as a hint of what the expected value is.
 * Some properties have multiple equivalent values.
 */function getValueForProperty(node,name,expected){{var propertyInfo=getPropertyInfo(name);if(propertyInfo){var mutationMethod=propertyInfo.mutationMethod;if(mutationMethod||propertyInfo.mustUseProperty){return node[propertyInfo.propertyName];}else{var attributeName=propertyInfo.attributeName;var stringValue=null;if(propertyInfo.hasOverloadedBooleanValue){if(node.hasAttribute(attributeName)){var value=node.getAttribute(attributeName);if(value===''){return true;}if(shouldIgnoreValue(propertyInfo,expected)){return value;}if(value===''+expected){return expected;}return value;}}else if(node.hasAttribute(attributeName)){if(shouldIgnoreValue(propertyInfo,expected)){// We had an attribute but shouldn't have had one, so read it
// for the error message.
return node.getAttribute(attributeName);}if(propertyInfo.hasBooleanValue){// If this was a boolean, it doesn't matter what the value is
// the fact that we have it is the same as the expected.
return expected;}// Even if this property uses a namespace we use getAttribute
// because we assume its namespaced name is the same as our config.
// To use getAttributeNS we need the local name which we don't have
// in our config atm.
stringValue=node.getAttribute(attributeName);}if(shouldIgnoreValue(propertyInfo,expected)){return stringValue===null?expected:stringValue;}else if(stringValue===''+expected){return expected;}else{return stringValue;}}}}}/**
 * Get the value for a attribute on a node. Only used in DEV for SSR validation.
 * The third argument is used as a hint of what the expected value is. Some
 * attributes have multiple equivalent values.
 */function getValueForAttribute(node,name,expected){{if(!isAttributeNameSafe(name)){return;}if(!node.hasAttribute(name)){return expected===undefined?undefined:null;}var value=node.getAttribute(name);if(value===''+expected){return expected;}return value;}}/**
 * Sets the value for a property on a node.
 *
 * @param {DOMElement} node
 * @param {string} name
 * @param {*} value
 */function setValueForProperty(node,name,value){var propertyInfo=getPropertyInfo(name);if(propertyInfo&&shouldSetAttribute(name,value)){var mutationMethod=propertyInfo.mutationMethod;if(mutationMethod){mutationMethod(node,value);}else if(shouldIgnoreValue(propertyInfo,value)){deleteValueForProperty(node,name);return;}else if(propertyInfo.mustUseProperty){// Contrary to `setAttribute`, object properties are properly
// `toString`ed by IE8/9.
node[propertyInfo.propertyName]=value;}else{var attributeName=propertyInfo.attributeName;var namespace=propertyInfo.attributeNamespace;// `setAttribute` with objects becomes only `[object]` in IE8/9,
// ('' + value) makes it output the correct toString()-value.
if(namespace){node.setAttributeNS(namespace,attributeName,''+value);}else if(propertyInfo.hasBooleanValue||propertyInfo.hasOverloadedBooleanValue&&value===true){node.setAttribute(attributeName,'');}else{node.setAttribute(attributeName,''+value);}}}else{setValueForAttribute(node,name,shouldSetAttribute(name,value)?value:null);return;}{}}function setValueForAttribute(node,name,value){if(!isAttributeNameSafe(name)){return;}if(value==null){node.removeAttribute(name);}else{node.setAttribute(name,''+value);}{}}/**
 * Deletes an attributes from a node.
 *
 * @param {DOMElement} node
 * @param {string} name
 */function deleteValueForAttribute(node,name){node.removeAttribute(name);}/**
 * Deletes the value for a property on a node.
 *
 * @param {DOMElement} node
 * @param {string} name
 */function deleteValueForProperty(node,name){var propertyInfo=getPropertyInfo(name);if(propertyInfo){var mutationMethod=propertyInfo.mutationMethod;if(mutationMethod){mutationMethod(node,undefined);}else if(propertyInfo.mustUseProperty){var propName=propertyInfo.propertyName;if(propertyInfo.hasBooleanValue){node[propName]=false;}else{node[propName]='';}}else{node.removeAttribute(propertyInfo.attributeName);}}else{node.removeAttribute(name);}}var ReactControlledValuePropTypes={checkPropTypes:null};{var hasReadOnlyValue={button:true,checkbox:true,image:true,hidden:true,radio:true,reset:true,submit:true};var propTypes={value:function value(props,propName,componentName){if(!props[propName]||hasReadOnlyValue[props.type]||props.onChange||props.readOnly||props.disabled){return null;}return new Error('You provided a `value` prop to a form field without an '+'`onChange` handler. This will render a read-only field. If '+'the field should be mutable use `defaultValue`. Otherwise, '+'set either `onChange` or `readOnly`.');},checked:function checked(props,propName,componentName){if(!props[propName]||props.onChange||props.readOnly||props.disabled){return null;}return new Error('You provided a `checked` prop to a form field without an '+'`onChange` handler. This will render a read-only field. If '+'the field should be mutable use `defaultChecked`. Otherwise, '+'set either `onChange` or `readOnly`.');}};/**
   * Provide a linked `value` attribute for controlled forms. You should not use
   * this outside of the ReactDOM controlled form components.
   */ReactControlledValuePropTypes.checkPropTypes=function(tagName,props,getStack){checkPropTypes(propTypes,props,'prop',tagName,getStack);};}// TODO: direct imports like some-package/src/* are bad. Fix me.
var getCurrentFiberOwnerName$2=ReactDebugCurrentFiber.getCurrentFiberOwnerName;var getCurrentFiberStackAddendum$3=ReactDebugCurrentFiber.getCurrentFiberStackAddendum;var didWarnValueDefaultValue=false;var didWarnCheckedDefaultChecked=false;var didWarnControlledToUncontrolled=false;var didWarnUncontrolledToControlled=false;function isControlled(props){var usesChecked=props.type==='checkbox'||props.type==='radio';return usesChecked?props.checked!=null:props.value!=null;}/**
 * Implements an <input> host component that allows setting these optional
 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
 *
 * If `checked` or `value` are not supplied (or null/undefined), user actions
 * that affect the checked state or value will trigger updates to the element.
 *
 * If they are supplied (and not null/undefined), the rendered element will not
 * trigger updates to the element. Instead, the props must change in order for
 * the rendered element to be updated.
 *
 * The rendered element will be initialized as unchecked (or `defaultChecked`)
 * with an empty value (or `defaultValue`).
 *
 * See http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
 */function getHostProps(element,props){var node=element;var value=props.value;var checked=props.checked;var hostProps=_assign({// Make sure we set .type before any other properties (setting .value
// before .type means .value is lost in IE11 and below)
type:undefined,// Make sure we set .step before .value (setting .value before .step
// means .value is rounded on mount, based upon step precision)
step:undefined,// Make sure we set .min & .max before .value (to ensure proper order
// in corner cases such as min or max deriving from value, e.g. Issue #7170)
min:undefined,max:undefined},props,{defaultChecked:undefined,defaultValue:undefined,value:value!=null?value:node._wrapperState.initialValue,checked:checked!=null?checked:node._wrapperState.initialChecked});return hostProps;}function initWrapperState(element,props){{ReactControlledValuePropTypes.checkPropTypes('input',props,getCurrentFiberStackAddendum$3);if(props.checked!==undefined&&props.defaultChecked!==undefined&&!didWarnCheckedDefaultChecked){warning(false,'%s contains an input of type %s with both checked and defaultChecked props. '+'Input elements must be either controlled or uncontrolled '+'(specify either the checked prop, or the defaultChecked prop, but not '+'both). Decide between using a controlled or uncontrolled input '+'element and remove one of these props. More info: '+'https://fb.me/react-controlled-components',getCurrentFiberOwnerName$2()||'A component',props.type);didWarnCheckedDefaultChecked=true;}if(props.value!==undefined&&props.defaultValue!==undefined&&!didWarnValueDefaultValue){warning(false,'%s contains an input of type %s with both value and defaultValue props. '+'Input elements must be either controlled or uncontrolled '+'(specify either the value prop, or the defaultValue prop, but not '+'both). Decide between using a controlled or uncontrolled input '+'element and remove one of these props. More info: '+'https://fb.me/react-controlled-components',getCurrentFiberOwnerName$2()||'A component',props.type);didWarnValueDefaultValue=true;}}var defaultValue=props.defaultValue;var node=element;node._wrapperState={initialChecked:props.checked!=null?props.checked:props.defaultChecked,initialValue:props.value!=null?props.value:defaultValue,controlled:isControlled(props)};}function updateChecked(element,props){var node=element;var checked=props.checked;if(checked!=null){setValueForProperty(node,'checked',checked);}}function updateWrapper(element,props){var node=element;{var controlled=isControlled(props);if(!node._wrapperState.controlled&&controlled&&!didWarnUncontrolledToControlled){warning(false,'A component is changing an uncontrolled input of type %s to be controlled. '+'Input elements should not switch from uncontrolled to controlled (or vice versa). '+'Decide between using a controlled or uncontrolled input '+'element for the lifetime of the component. More info: https://fb.me/react-controlled-components%s',props.type,getCurrentFiberStackAddendum$3());didWarnUncontrolledToControlled=true;}if(node._wrapperState.controlled&&!controlled&&!didWarnControlledToUncontrolled){warning(false,'A component is changing a controlled input of type %s to be uncontrolled. '+'Input elements should not switch from controlled to uncontrolled (or vice versa). '+'Decide between using a controlled or uncontrolled input '+'element for the lifetime of the component. More info: https://fb.me/react-controlled-components%s',props.type,getCurrentFiberStackAddendum$3());didWarnControlledToUncontrolled=true;}}updateChecked(element,props);var value=props.value;if(value!=null){if(value===0&&node.value===''){node.value='0';// Note: IE9 reports a number inputs as 'text', so check props instead.
}else if(props.type==='number'){// Simulate `input.valueAsNumber`. IE9 does not support it
var valueAsNumber=parseFloat(node.value)||0;if(// eslint-disable-next-line
value!=valueAsNumber||// eslint-disable-next-line
value==valueAsNumber&&node.value!=value){// Cast `value` to a string to ensure the value is set correctly. While
// browsers typically do this as necessary, jsdom doesn't.
node.value=''+value;}}else if(node.value!==''+value){// Cast `value` to a string to ensure the value is set correctly. While
// browsers typically do this as necessary, jsdom doesn't.
node.value=''+value;}}else{if(props.value==null&&props.defaultValue!=null){// In Chrome, assigning defaultValue to certain input types triggers input validation.
// For number inputs, the display value loses trailing decimal points. For email inputs,
// Chrome raises "The specified value <x> is not a valid email address".
//
// Here we check to see if the defaultValue has actually changed, avoiding these problems
// when the user is inputting text
//
// https://github.com/facebook/react/issues/7253
if(node.defaultValue!==''+props.defaultValue){node.defaultValue=''+props.defaultValue;}}if(props.checked==null&&props.defaultChecked!=null){node.defaultChecked=!!props.defaultChecked;}}}function postMountWrapper(element,props){var node=element;// Detach value from defaultValue. We won't do anything if we're working on
// submit or reset inputs as those values & defaultValues are linked. They
// are not resetable nodes so this operation doesn't matter and actually
// removes browser-default values (eg "Submit Query") when no value is
// provided.
switch(props.type){case'submit':case'reset':break;case'color':case'date':case'datetime':case'datetime-local':case'month':case'time':case'week':// This fixes the no-show issue on iOS Safari and Android Chrome:
// https://github.com/facebook/react/issues/7233
node.value='';node.value=node.defaultValue;break;default:node.value=node.value;break;}// Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug
// this is needed to work around a chrome bug where setting defaultChecked
// will sometimes influence the value of checked (even after detachment).
// Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416
// We need to temporarily unset name to avoid disrupting radio button groups.
var name=node.name;if(name!==''){node.name='';}node.defaultChecked=!node.defaultChecked;node.defaultChecked=!node.defaultChecked;if(name!==''){node.name=name;}}function restoreControlledState$1(element,props){var node=element;updateWrapper(node,props);updateNamedCousins(node,props);}function updateNamedCousins(rootNode,props){var name=props.name;if(props.type==='radio'&&name!=null){var queryRoot=rootNode;while(queryRoot.parentNode){queryRoot=queryRoot.parentNode;}// If `rootNode.form` was non-null, then we could try `form.elements`,
// but that sometimes behaves strangely in IE8. We could also try using
// `form.getElementsByName`, but that will only return direct children
// and won't include inputs that use the HTML5 `form=` attribute. Since
// the input might not even be in a form. It might not even be in the
// document. Let's just use the local `querySelectorAll` to ensure we don't
// miss anything.
var group=queryRoot.querySelectorAll('input[name='+JSON.stringify(''+name)+'][type="radio"]');for(var i=0;i<group.length;i++){var otherNode=group[i];if(otherNode===rootNode||otherNode.form!==rootNode.form){continue;}// This will throw if radio buttons rendered by different copies of React
// and the same name are rendered into the same form (same as #1939).
// That's probably okay; we don't support it just as we don't support
// mixing React radio buttons with non-React ones.
var otherProps=getFiberCurrentPropsFromNode$1(otherNode);!otherProps?invariant(false,'ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.'):void 0;// We need update the tracked value on the named cousin since the value
// was changed but the input saw no event or value set
updateValueIfChanged(otherNode);// If this is a controlled radio button group, forcing the input that
// was previously checked to update will cause it to be come re-checked
// as appropriate.
updateWrapper(otherNode,otherProps);}}}function flattenChildren(children){var content='';// Flatten children and warn if they aren't strings or numbers;
// invalid types are ignored.
// We can silently skip them because invalid DOM nesting warning
// catches these cases in Fiber.
React.Children.forEach(children,function(child){if(child==null){return;}if(typeof child==='string'||typeof child==='number'){content+=child;}});return content;}/**
 * Implements an <option> host component that warns when `selected` is set.
 */function validateProps(element,props){// TODO (yungsters): Remove support for `selected` in <option>.
{warning(props.selected==null,'Use the `defaultValue` or `value` props on <select> instead of '+'setting `selected` on <option>.');}}function postMountWrapper$1(element,props){// value="" should make a value attribute (#6219)
if(props.value!=null){element.setAttribute('value',props.value);}}function getHostProps$1(element,props){var hostProps=_assign({children:undefined},props);var content=flattenChildren(props.children);if(content){hostProps.children=content;}return hostProps;}// TODO: direct imports like some-package/src/* are bad. Fix me.
var getCurrentFiberOwnerName$3=ReactDebugCurrentFiber.getCurrentFiberOwnerName;var getCurrentFiberStackAddendum$4=ReactDebugCurrentFiber.getCurrentFiberStackAddendum;{var didWarnValueDefaultValue$1=false;}function getDeclarationErrorAddendum(){var ownerName=getCurrentFiberOwnerName$3();if(ownerName){return'\n\nCheck the render method of `'+ownerName+'`.';}return'';}var valuePropNames=['value','defaultValue'];/**
 * Validation function for `value` and `defaultValue`.
 */function checkSelectPropTypes(props){ReactControlledValuePropTypes.checkPropTypes('select',props,getCurrentFiberStackAddendum$4);for(var i=0;i<valuePropNames.length;i++){var propName=valuePropNames[i];if(props[propName]==null){continue;}var isArray=Array.isArray(props[propName]);if(props.multiple&&!isArray){warning(false,'The `%s` prop supplied to <select> must be an array if '+'`multiple` is true.%s',propName,getDeclarationErrorAddendum());}else if(!props.multiple&&isArray){warning(false,'The `%s` prop supplied to <select> must be a scalar '+'value if `multiple` is false.%s',propName,getDeclarationErrorAddendum());}}}function updateOptions(node,multiple,propValue,setDefaultSelected){var options=node.options;if(multiple){var selectedValues=propValue;var selectedValue={};for(var i=0;i<selectedValues.length;i++){// Prefix to avoid chaos with special keys.
selectedValue['$'+selectedValues[i]]=true;}for(var _i=0;_i<options.length;_i++){var selected=selectedValue.hasOwnProperty('$'+options[_i].value);if(options[_i].selected!==selected){options[_i].selected=selected;}if(selected&&setDefaultSelected){options[_i].defaultSelected=true;}}}else{// Do not set `select.value` as exact behavior isn't consistent across all
// browsers for all cases.
var _selectedValue=''+propValue;var defaultSelected=null;for(var _i2=0;_i2<options.length;_i2++){if(options[_i2].value===_selectedValue){options[_i2].selected=true;if(setDefaultSelected){options[_i2].defaultSelected=true;}return;}if(defaultSelected===null&&!options[_i2].disabled){defaultSelected=options[_i2];}}if(defaultSelected!==null){defaultSelected.selected=true;}}}/**
 * Implements a <select> host component that allows optionally setting the
 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
 * stringable. If `multiple` is true, the prop must be an array of stringables.
 *
 * If `value` is not supplied (or null/undefined), user actions that change the
 * selected option will trigger updates to the rendered options.
 *
 * If it is supplied (and not null/undefined), the rendered options will not
 * update in response to user actions. Instead, the `value` prop must change in
 * order for the rendered options to update.
 *
 * If `defaultValue` is provided, any options with the supplied values will be
 * selected.
 */function getHostProps$2(element,props){return _assign({},props,{value:undefined});}function initWrapperState$1(element,props){var node=element;{checkSelectPropTypes(props);}var value=props.value;node._wrapperState={initialValue:value!=null?value:props.defaultValue,wasMultiple:!!props.multiple};{if(props.value!==undefined&&props.defaultValue!==undefined&&!didWarnValueDefaultValue$1){warning(false,'Select elements must be either controlled or uncontrolled '+'(specify either the value prop, or the defaultValue prop, but not '+'both). Decide between using a controlled or uncontrolled select '+'element and remove one of these props. More info: '+'https://fb.me/react-controlled-components');didWarnValueDefaultValue$1=true;}}}function postMountWrapper$2(element,props){var node=element;node.multiple=!!props.multiple;var value=props.value;if(value!=null){updateOptions(node,!!props.multiple,value,false);}else if(props.defaultValue!=null){updateOptions(node,!!props.multiple,props.defaultValue,true);}}function postUpdateWrapper(element,props){var node=element;// After the initial mount, we control selected-ness manually so don't pass
// this value down
node._wrapperState.initialValue=undefined;var wasMultiple=node._wrapperState.wasMultiple;node._wrapperState.wasMultiple=!!props.multiple;var value=props.value;if(value!=null){updateOptions(node,!!props.multiple,value,false);}else if(wasMultiple!==!!props.multiple){// For simplicity, reapply `defaultValue` if `multiple` is toggled.
if(props.defaultValue!=null){updateOptions(node,!!props.multiple,props.defaultValue,true);}else{// Revert the select back to its default unselected state.
updateOptions(node,!!props.multiple,props.multiple?[]:'',false);}}}function restoreControlledState$2(element,props){var node=element;var value=props.value;if(value!=null){updateOptions(node,!!props.multiple,value,false);}}// TODO: direct imports like some-package/src/* are bad. Fix me.
var getCurrentFiberStackAddendum$5=ReactDebugCurrentFiber.getCurrentFiberStackAddendum;var didWarnValDefaultVal=false;/**
 * Implements a <textarea> host component that allows setting `value`, and
 * `defaultValue`. This differs from the traditional DOM API because value is
 * usually set as PCDATA children.
 *
 * If `value` is not supplied (or null/undefined), user actions that affect the
 * value will trigger updates to the element.
 *
 * If `value` is supplied (and not null/undefined), the rendered element will
 * not trigger updates to the element. Instead, the `value` prop must change in
 * order for the rendered element to be updated.
 *
 * The rendered element will be initialized with an empty value, the prop
 * `defaultValue` if specified, or the children content (deprecated).
 */function getHostProps$3(element,props){var node=element;!(props.dangerouslySetInnerHTML==null)?invariant(false,'`dangerouslySetInnerHTML` does not make sense on <textarea>.'):void 0;// Always set children to the same thing. In IE9, the selection range will
// get reset if `textContent` is mutated.  We could add a check in setTextContent
// to only set the value if/when the value differs from the node value (which would
// completely solve this IE9 bug), but Sebastian+Sophie seemed to like this
// solution. The value can be a boolean or object so that's why it's forced
// to be a string.
var hostProps=_assign({},props,{value:undefined,defaultValue:undefined,children:''+node._wrapperState.initialValue});return hostProps;}function initWrapperState$2(element,props){var node=element;{ReactControlledValuePropTypes.checkPropTypes('textarea',props,getCurrentFiberStackAddendum$5);if(props.value!==undefined&&props.defaultValue!==undefined&&!didWarnValDefaultVal){warning(false,'Textarea elements must be either controlled or uncontrolled '+'(specify either the value prop, or the defaultValue prop, but not '+'both). Decide between using a controlled or uncontrolled textarea '+'and remove one of these props. More info: '+'https://fb.me/react-controlled-components');didWarnValDefaultVal=true;}}var initialValue=props.value;// Only bother fetching default value if we're going to use it
if(initialValue==null){var defaultValue=props.defaultValue;// TODO (yungsters): Remove support for children content in <textarea>.
var children=props.children;if(children!=null){{warning(false,'Use the `defaultValue` or `value` props instead of setting '+'children on <textarea>.');}!(defaultValue==null)?invariant(false,'If you supply `defaultValue` on a <textarea>, do not pass children.'):void 0;if(Array.isArray(children)){!(children.length<=1)?invariant(false,'<textarea> can only have at most one child.'):void 0;children=children[0];}defaultValue=''+children;}if(defaultValue==null){defaultValue='';}initialValue=defaultValue;}node._wrapperState={initialValue:''+initialValue};}function updateWrapper$1(element,props){var node=element;var value=props.value;if(value!=null){// Cast `value` to a string to ensure the value is set correctly. While
// browsers typically do this as necessary, jsdom doesn't.
var newValue=''+value;// To avoid side effects (such as losing text selection), only set value if changed
if(newValue!==node.value){node.value=newValue;}if(props.defaultValue==null){node.defaultValue=newValue;}}if(props.defaultValue!=null){node.defaultValue=props.defaultValue;}}function postMountWrapper$3(element,props){var node=element;// This is in postMount because we need access to the DOM node, which is not
// available until after the component has mounted.
var textContent=node.textContent;// Only set node.value if textContent is equal to the expected
// initial value. In IE10/IE11 there is a bug where the placeholder attribute
// will populate textContent as well.
// https://developer.microsoft.com/microsoft-edge/platform/issues/101525/
if(textContent===node._wrapperState.initialValue){node.value=textContent;}}function restoreControlledState$3(element,props){// DOM component is still mounted; update
updateWrapper$1(element,props);}var HTML_NAMESPACE$1='http://www.w3.org/1999/xhtml';var MATH_NAMESPACE='http://www.w3.org/1998/Math/MathML';var SVG_NAMESPACE='http://www.w3.org/2000/svg';var Namespaces={html:HTML_NAMESPACE$1,mathml:MATH_NAMESPACE,svg:SVG_NAMESPACE};// Assumes there is no parent namespace.
function getIntrinsicNamespace(type){switch(type){case'svg':return SVG_NAMESPACE;case'math':return MATH_NAMESPACE;default:return HTML_NAMESPACE$1;}}function getChildNamespace(parentNamespace,type){if(parentNamespace==null||parentNamespace===HTML_NAMESPACE$1){// No (or default) parent namespace: potential entry point.
return getIntrinsicNamespace(type);}if(parentNamespace===SVG_NAMESPACE&&type==='foreignObject'){// We're leaving SVG.
return HTML_NAMESPACE$1;}// By default, pass namespace below.
return parentNamespace;}/* globals MSApp *//**
 * Create a function which has 'unsafe' privileges (required by windows8 apps)
 */var createMicrosoftUnsafeLocalFunction=function createMicrosoftUnsafeLocalFunction(func){if(typeof MSApp!=='undefined'&&MSApp.execUnsafeLocalFunction){return function(arg0,arg1,arg2,arg3){MSApp.execUnsafeLocalFunction(function(){return func(arg0,arg1,arg2,arg3);});};}else{return func;}};// SVG temp container for IE lacking innerHTML
var reusableSVGContainer=void 0;/**
 * Set the innerHTML property of a node
 *
 * @param {DOMElement} node
 * @param {string} html
 * @internal
 */var setInnerHTML=createMicrosoftUnsafeLocalFunction(function(node,html){// IE does not have innerHTML for SVG nodes, so instead we inject the
// new markup in a temp node and then move the child nodes across into
// the target node
if(node.namespaceURI===Namespaces.svg&&!('innerHTML'in node)){reusableSVGContainer=reusableSVGContainer||document.createElement('div');reusableSVGContainer.innerHTML='<svg>'+html+'</svg>';var svgNode=reusableSVGContainer.firstChild;while(node.firstChild){node.removeChild(node.firstChild);}while(svgNode.firstChild){node.appendChild(svgNode.firstChild);}}else{node.innerHTML=html;}});/**
 * Set the textContent property of a node, ensuring that whitespace is preserved
 * even in IE8. innerText is a poor substitute for textContent and, among many
 * issues, inserts <br> instead of the literal newline chars. innerHTML behaves
 * as it should.
 *
 * @param {DOMElement} node
 * @param {string} text
 * @internal
 */var setTextContent=function setTextContent(node,text){if(text){var firstChild=node.firstChild;if(firstChild&&firstChild===node.lastChild&&firstChild.nodeType===TEXT_NODE){firstChild.nodeValue=text;return;}}node.textContent=text;};/**
 * CSS properties which accept numbers but are not in units of "px".
 */var isUnitlessNumber={animationIterationCount:true,borderImageOutset:true,borderImageSlice:true,borderImageWidth:true,boxFlex:true,boxFlexGroup:true,boxOrdinalGroup:true,columnCount:true,columns:true,flex:true,flexGrow:true,flexPositive:true,flexShrink:true,flexNegative:true,flexOrder:true,gridRow:true,gridRowEnd:true,gridRowSpan:true,gridRowStart:true,gridColumn:true,gridColumnEnd:true,gridColumnSpan:true,gridColumnStart:true,fontWeight:true,lineClamp:true,lineHeight:true,opacity:true,order:true,orphans:true,tabSize:true,widows:true,zIndex:true,zoom:true,// SVG-related properties
fillOpacity:true,floodOpacity:true,stopOpacity:true,strokeDasharray:true,strokeDashoffset:true,strokeMiterlimit:true,strokeOpacity:true,strokeWidth:true};/**
 * @param {string} prefix vendor-specific prefix, eg: Webkit
 * @param {string} key style name, eg: transitionDuration
 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
 * WebkitTransitionDuration
 */function prefixKey(prefix,key){return prefix+key.charAt(0).toUpperCase()+key.substring(1);}/**
 * Support style names that may come passed in prefixed by adding permutations
 * of vendor prefixes.
 */var prefixes=['Webkit','ms','Moz','O'];// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
// infinite loop, because it iterates over the newly added props too.
Object.keys(isUnitlessNumber).forEach(function(prop){prefixes.forEach(function(prefix){isUnitlessNumber[prefixKey(prefix,prop)]=isUnitlessNumber[prop];});});/**
 * Convert a value into the proper css writable value. The style name `name`
 * should be logical (no hyphens), as specified
 * in `CSSProperty.isUnitlessNumber`.
 *
 * @param {string} name CSS property name such as `topMargin`.
 * @param {*} value CSS property value such as `10px`.
 * @return {string} Normalized style value with dimensions applied.
 */function dangerousStyleValue(name,value,isCustomProperty){// Note that we've removed escapeTextForBrowser() calls here since the
// whole string will be escaped when the attribute is injected into
// the markup. If you provide unsafe user data here they can inject
// arbitrary CSS which may be problematic (I couldn't repro this):
// https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
// http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
// This is not an XSS hole but instead a potential CSS injection issue
// which has lead to a greater discussion about how we're going to
// trust URLs moving forward. See #2115901
var isEmpty=value==null||typeof value==='boolean'||value==='';if(isEmpty){return'';}if(!isCustomProperty&&typeof value==='number'&&value!==0&&!(isUnitlessNumber.hasOwnProperty(name)&&isUnitlessNumber[name])){return value+'px';// Presumes implicit 'px' suffix for unitless numbers
}return(''+value).trim();}var warnValidStyle=emptyFunction;{// 'msTransform' is correct, but the other prefixes should be capitalized
var badVendoredStyleNamePattern=/^(?:webkit|moz|o)[A-Z]/;// style values shouldn't contain a semicolon
var badStyleValueWithSemicolonPattern=/;\s*$/;var warnedStyleNames={};var warnedStyleValues={};var warnedForNaNValue=false;var warnedForInfinityValue=false;var warnHyphenatedStyleName=function warnHyphenatedStyleName(name,getStack){if(warnedStyleNames.hasOwnProperty(name)&&warnedStyleNames[name]){return;}warnedStyleNames[name]=true;warning(false,'Unsupported style property %s. Did you mean %s?%s',name,camelizeStyleName(name),getStack());};var warnBadVendoredStyleName=function warnBadVendoredStyleName(name,getStack){if(warnedStyleNames.hasOwnProperty(name)&&warnedStyleNames[name]){return;}warnedStyleNames[name]=true;warning(false,'Unsupported vendor-prefixed style property %s. Did you mean %s?%s',name,name.charAt(0).toUpperCase()+name.slice(1),getStack());};var warnStyleValueWithSemicolon=function warnStyleValueWithSemicolon(name,value,getStack){if(warnedStyleValues.hasOwnProperty(value)&&warnedStyleValues[value]){return;}warnedStyleValues[value]=true;warning(false,"Style property values shouldn't contain a semicolon. "+'Try "%s: %s" instead.%s',name,value.replace(badStyleValueWithSemicolonPattern,''),getStack());};var warnStyleValueIsNaN=function warnStyleValueIsNaN(name,value,getStack){if(warnedForNaNValue){return;}warnedForNaNValue=true;warning(false,'`NaN` is an invalid value for the `%s` css style property.%s',name,getStack());};var warnStyleValueIsInfinity=function warnStyleValueIsInfinity(name,value,getStack){if(warnedForInfinityValue){return;}warnedForInfinityValue=true;warning(false,'`Infinity` is an invalid value for the `%s` css style property.%s',name,getStack());};warnValidStyle=function warnValidStyle(name,value,getStack){if(name.indexOf('-')>-1){warnHyphenatedStyleName(name,getStack);}else if(badVendoredStyleNamePattern.test(name)){warnBadVendoredStyleName(name,getStack);}else if(badStyleValueWithSemicolonPattern.test(value)){warnStyleValueWithSemicolon(name,value,getStack);}if(typeof value==='number'){if(isNaN(value)){warnStyleValueIsNaN(name,value,getStack);}else if(!isFinite(value)){warnStyleValueIsInfinity(name,value,getStack);}}};}var warnValidStyle$1=warnValidStyle;/**
 * Operations for dealing with CSS properties.
 *//**
 * This creates a string that is expected to be equivalent to the style
 * attribute generated by server-side rendering. It by-passes warnings and
 * security checks so it's not safe to use this value for anything other than
 * comparison. It is only used in DEV for SSR validation.
 */function createDangerousStringForStyles(styles){{var serialized='';var delimiter='';for(var styleName in styles){if(!styles.hasOwnProperty(styleName)){continue;}var styleValue=styles[styleName];if(styleValue!=null){var isCustomProperty=styleName.indexOf('--')===0;serialized+=delimiter+hyphenateStyleName(styleName)+':';serialized+=dangerousStyleValue(styleName,styleValue,isCustomProperty);delimiter=';';}}return serialized||null;}}/**
 * Sets the value for multiple styles on a node.  If a value is specified as
 * '' (empty string), the corresponding style property will be unset.
 *
 * @param {DOMElement} node
 * @param {object} styles
 */function setValueForStyles(node,styles,getStack){var style=node.style;for(var styleName in styles){if(!styles.hasOwnProperty(styleName)){continue;}var isCustomProperty=styleName.indexOf('--')===0;{if(!isCustomProperty){warnValidStyle$1(styleName,styles[styleName],getStack);}}var styleValue=dangerousStyleValue(styleName,styles[styleName],isCustomProperty);if(styleName==='float'){styleName='cssFloat';}if(isCustomProperty){style.setProperty(styleName,styleValue);}else{style[styleName]=styleValue;}}}// For HTML, certain tags should omit their close tag. We keep a whitelist for
// those special-case tags.
var omittedCloseTags={area:true,base:true,br:true,col:true,embed:true,hr:true,img:true,input:true,keygen:true,link:true,meta:true,param:true,source:true,track:true,wbr:true};// For HTML, certain tags cannot have children. This has the same purpose as
// `omittedCloseTags` except that `menuitem` should still have its closing tag.
var voidElementTags=_assign({menuitem:true},omittedCloseTags);var HTML$1='__html';function assertValidProps(tag,props,getStack){if(!props){return;}// Note the use of `==` which checks for null or undefined.
if(voidElementTags[tag]){!(props.children==null&&props.dangerouslySetInnerHTML==null)?invariant(false,'%s is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.%s',tag,getStack()):void 0;}if(props.dangerouslySetInnerHTML!=null){!(props.children==null)?invariant(false,'Can only set one of `children` or `props.dangerouslySetInnerHTML`.'):void 0;!(_typeof(props.dangerouslySetInnerHTML)==='object'&&HTML$1 in props.dangerouslySetInnerHTML)?invariant(false,'`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://fb.me/react-invariant-dangerously-set-inner-html for more information.'):void 0;}{warning(props.suppressContentEditableWarning||!props.contentEditable||props.children==null,'A component is `contentEditable` and contains `children` managed by '+'React. It is now your responsibility to guarantee that none of '+'those nodes are unexpectedly modified or duplicated. This is '+'probably not intentional.%s',getStack());}!(props.style==null||_typeof(props.style)==='object')?invariant(false,'The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + \'em\'}} when using JSX.%s',getStack()):void 0;}function isCustomComponent(tagName,props){if(tagName.indexOf('-')===-1){return typeof props.is==='string';}switch(tagName){// These are reserved SVG and MathML elements.
// We don't mind this whitelist too much because we expect it to never grow.
// The alternative is to track the namespace in a few places which is convoluted.
// https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts
case'annotation-xml':case'color-profile':case'font-face':case'font-face-src':case'font-face-uri':case'font-face-format':case'font-face-name':case'missing-glyph':return false;default:return true;}}var ariaProperties={'aria-current':0,// state
'aria-details':0,'aria-disabled':0,// state
'aria-hidden':0,// state
'aria-invalid':0,// state
'aria-keyshortcuts':0,'aria-label':0,'aria-roledescription':0,// Widget Attributes
'aria-autocomplete':0,'aria-checked':0,'aria-expanded':0,'aria-haspopup':0,'aria-level':0,'aria-modal':0,'aria-multiline':0,'aria-multiselectable':0,'aria-orientation':0,'aria-placeholder':0,'aria-pressed':0,'aria-readonly':0,'aria-required':0,'aria-selected':0,'aria-sort':0,'aria-valuemax':0,'aria-valuemin':0,'aria-valuenow':0,'aria-valuetext':0,// Live Region Attributes
'aria-atomic':0,'aria-busy':0,'aria-live':0,'aria-relevant':0,// Drag-and-Drop Attributes
'aria-dropeffect':0,'aria-grabbed':0,// Relationship Attributes
'aria-activedescendant':0,'aria-colcount':0,'aria-colindex':0,'aria-colspan':0,'aria-controls':0,'aria-describedby':0,'aria-errormessage':0,'aria-flowto':0,'aria-labelledby':0,'aria-owns':0,'aria-posinset':0,'aria-rowcount':0,'aria-rowindex':0,'aria-rowspan':0,'aria-setsize':0};var warnedProperties={};var rARIA=new RegExp('^(aria)-['+ATTRIBUTE_NAME_CHAR+']*$');var rARIACamel=new RegExp('^(aria)[A-Z]['+ATTRIBUTE_NAME_CHAR+']*$');var hasOwnProperty=Object.prototype.hasOwnProperty;function getStackAddendum(){var stack=ReactDebugCurrentFrame.getStackAddendum();return stack!=null?stack:'';}function validateProperty(tagName,name){if(hasOwnProperty.call(warnedProperties,name)&&warnedProperties[name]){return true;}if(rARIACamel.test(name)){var ariaName='aria-'+name.slice(4).toLowerCase();var correctName=ariaProperties.hasOwnProperty(ariaName)?ariaName:null;// If this is an aria-* attribute, but is not listed in the known DOM
// DOM properties, then it is an invalid aria-* attribute.
if(correctName==null){warning(false,'Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.%s',name,getStackAddendum());warnedProperties[name]=true;return true;}// aria-* attributes should be lowercase; suggest the lowercase version.
if(name!==correctName){warning(false,'Invalid ARIA attribute `%s`. Did you mean `%s`?%s',name,correctName,getStackAddendum());warnedProperties[name]=true;return true;}}if(rARIA.test(name)){var lowerCasedName=name.toLowerCase();var standardName=ariaProperties.hasOwnProperty(lowerCasedName)?lowerCasedName:null;// If this is an aria-* attribute, but is not listed in the known DOM
// DOM properties, then it is an invalid aria-* attribute.
if(standardName==null){warnedProperties[name]=true;return false;}// aria-* attributes should be lowercase; suggest the lowercase version.
if(name!==standardName){warning(false,'Unknown ARIA attribute `%s`. Did you mean `%s`?%s',name,standardName,getStackAddendum());warnedProperties[name]=true;return true;}}return true;}function warnInvalidARIAProps(type,props){var invalidProps=[];for(var key in props){var isValid=validateProperty(type,key);if(!isValid){invalidProps.push(key);}}var unknownPropString=invalidProps.map(function(prop){return'`'+prop+'`';}).join(', ');if(invalidProps.length===1){warning(false,'Invalid aria prop %s on <%s> tag. '+'For details, see https://fb.me/invalid-aria-prop%s',unknownPropString,type,getStackAddendum());}else if(invalidProps.length>1){warning(false,'Invalid aria props %s on <%s> tag. '+'For details, see https://fb.me/invalid-aria-prop%s',unknownPropString,type,getStackAddendum());}}function validateProperties(type,props){if(isCustomComponent(type,props)){return;}warnInvalidARIAProps(type,props);}var didWarnValueNull=false;function getStackAddendum$1(){var stack=ReactDebugCurrentFrame.getStackAddendum();return stack!=null?stack:'';}function validateProperties$1(type,props){if(type!=='input'&&type!=='textarea'&&type!=='select'){return;}if(props!=null&&props.value===null&&!didWarnValueNull){didWarnValueNull=true;if(type==='select'&&props.multiple){warning(false,'`value` prop on `%s` should not be null. '+'Consider using an empty array when `multiple` is set to `true` '+'to clear the component or `undefined` for uncontrolled components.%s',type,getStackAddendum$1());}else{warning(false,'`value` prop on `%s` should not be null. '+'Consider using an empty string to clear the component or `undefined` '+'for uncontrolled components.%s',type,getStackAddendum$1());}}}// When adding attributes to the HTML or SVG whitelist, be sure to
// also add them to this module to ensure casing and incorrect name
// warnings.
var possibleStandardNames={// HTML
accept:'accept',acceptcharset:'acceptCharset','accept-charset':'acceptCharset',accesskey:'accessKey',action:'action',allowfullscreen:'allowFullScreen',alt:'alt',as:'as',async:'async',autocapitalize:'autoCapitalize',autocomplete:'autoComplete',autocorrect:'autoCorrect',autofocus:'autoFocus',autoplay:'autoPlay',autosave:'autoSave',capture:'capture',cellpadding:'cellPadding',cellspacing:'cellSpacing',challenge:'challenge',charset:'charSet',checked:'checked',children:'children',cite:'cite','class':'className',classid:'classID',classname:'className',cols:'cols',colspan:'colSpan',content:'content',contenteditable:'contentEditable',contextmenu:'contextMenu',controls:'controls',controlslist:'controlsList',coords:'coords',crossorigin:'crossOrigin',dangerouslysetinnerhtml:'dangerouslySetInnerHTML',data:'data',datetime:'dateTime','default':'default',defaultchecked:'defaultChecked',defaultvalue:'defaultValue',defer:'defer',dir:'dir',disabled:'disabled',download:'download',draggable:'draggable',enctype:'encType','for':'htmlFor',form:'form',formmethod:'formMethod',formaction:'formAction',formenctype:'formEncType',formnovalidate:'formNoValidate',formtarget:'formTarget',frameborder:'frameBorder',headers:'headers',height:'height',hidden:'hidden',high:'high',href:'href',hreflang:'hrefLang',htmlfor:'htmlFor',httpequiv:'httpEquiv','http-equiv':'httpEquiv',icon:'icon',id:'id',innerhtml:'innerHTML',inputmode:'inputMode',integrity:'integrity',is:'is',itemid:'itemID',itemprop:'itemProp',itemref:'itemRef',itemscope:'itemScope',itemtype:'itemType',keyparams:'keyParams',keytype:'keyType',kind:'kind',label:'label',lang:'lang',list:'list',loop:'loop',low:'low',manifest:'manifest',marginwidth:'marginWidth',marginheight:'marginHeight',max:'max',maxlength:'maxLength',media:'media',mediagroup:'mediaGroup',method:'method',min:'min',minlength:'minLength',multiple:'multiple',muted:'muted',name:'name',nonce:'nonce',novalidate:'noValidate',open:'open',optimum:'optimum',pattern:'pattern',placeholder:'placeholder',playsinline:'playsInline',poster:'poster',preload:'preload',profile:'profile',radiogroup:'radioGroup',readonly:'readOnly',referrerpolicy:'referrerPolicy',rel:'rel',required:'required',reversed:'reversed',role:'role',rows:'rows',rowspan:'rowSpan',sandbox:'sandbox',scope:'scope',scoped:'scoped',scrolling:'scrolling',seamless:'seamless',selected:'selected',shape:'shape',size:'size',sizes:'sizes',span:'span',spellcheck:'spellCheck',src:'src',srcdoc:'srcDoc',srclang:'srcLang',srcset:'srcSet',start:'start',step:'step',style:'style',summary:'summary',tabindex:'tabIndex',target:'target',title:'title',type:'type',usemap:'useMap',value:'value',width:'width',wmode:'wmode',wrap:'wrap',// SVG
about:'about',accentheight:'accentHeight','accent-height':'accentHeight',accumulate:'accumulate',additive:'additive',alignmentbaseline:'alignmentBaseline','alignment-baseline':'alignmentBaseline',allowreorder:'allowReorder',alphabetic:'alphabetic',amplitude:'amplitude',arabicform:'arabicForm','arabic-form':'arabicForm',ascent:'ascent',attributename:'attributeName',attributetype:'attributeType',autoreverse:'autoReverse',azimuth:'azimuth',basefrequency:'baseFrequency',baselineshift:'baselineShift','baseline-shift':'baselineShift',baseprofile:'baseProfile',bbox:'bbox',begin:'begin',bias:'bias',by:'by',calcmode:'calcMode',capheight:'capHeight','cap-height':'capHeight',clip:'clip',clippath:'clipPath','clip-path':'clipPath',clippathunits:'clipPathUnits',cliprule:'clipRule','clip-rule':'clipRule',color:'color',colorinterpolation:'colorInterpolation','color-interpolation':'colorInterpolation',colorinterpolationfilters:'colorInterpolationFilters','color-interpolation-filters':'colorInterpolationFilters',colorprofile:'colorProfile','color-profile':'colorProfile',colorrendering:'colorRendering','color-rendering':'colorRendering',contentscripttype:'contentScriptType',contentstyletype:'contentStyleType',cursor:'cursor',cx:'cx',cy:'cy',d:'d',datatype:'datatype',decelerate:'decelerate',descent:'descent',diffuseconstant:'diffuseConstant',direction:'direction',display:'display',divisor:'divisor',dominantbaseline:'dominantBaseline','dominant-baseline':'dominantBaseline',dur:'dur',dx:'dx',dy:'dy',edgemode:'edgeMode',elevation:'elevation',enablebackground:'enableBackground','enable-background':'enableBackground',end:'end',exponent:'exponent',externalresourcesrequired:'externalResourcesRequired',fill:'fill',fillopacity:'fillOpacity','fill-opacity':'fillOpacity',fillrule:'fillRule','fill-rule':'fillRule',filter:'filter',filterres:'filterRes',filterunits:'filterUnits',floodopacity:'floodOpacity','flood-opacity':'floodOpacity',floodcolor:'floodColor','flood-color':'floodColor',focusable:'focusable',fontfamily:'fontFamily','font-family':'fontFamily',fontsize:'fontSize','font-size':'fontSize',fontsizeadjust:'fontSizeAdjust','font-size-adjust':'fontSizeAdjust',fontstretch:'fontStretch','font-stretch':'fontStretch',fontstyle:'fontStyle','font-style':'fontStyle',fontvariant:'fontVariant','font-variant':'fontVariant',fontweight:'fontWeight','font-weight':'fontWeight',format:'format',from:'from',fx:'fx',fy:'fy',g1:'g1',g2:'g2',glyphname:'glyphName','glyph-name':'glyphName',glyphorientationhorizontal:'glyphOrientationHorizontal','glyph-orientation-horizontal':'glyphOrientationHorizontal',glyphorientationvertical:'glyphOrientationVertical','glyph-orientation-vertical':'glyphOrientationVertical',glyphref:'glyphRef',gradienttransform:'gradientTransform',gradientunits:'gradientUnits',hanging:'hanging',horizadvx:'horizAdvX','horiz-adv-x':'horizAdvX',horizoriginx:'horizOriginX','horiz-origin-x':'horizOriginX',ideographic:'ideographic',imagerendering:'imageRendering','image-rendering':'imageRendering',in2:'in2','in':'in',inlist:'inlist',intercept:'intercept',k1:'k1',k2:'k2',k3:'k3',k4:'k4',k:'k',kernelmatrix:'kernelMatrix',kernelunitlength:'kernelUnitLength',kerning:'kerning',keypoints:'keyPoints',keysplines:'keySplines',keytimes:'keyTimes',lengthadjust:'lengthAdjust',letterspacing:'letterSpacing','letter-spacing':'letterSpacing',lightingcolor:'lightingColor','lighting-color':'lightingColor',limitingconeangle:'limitingConeAngle',local:'local',markerend:'markerEnd','marker-end':'markerEnd',markerheight:'markerHeight',markermid:'markerMid','marker-mid':'markerMid',markerstart:'markerStart','marker-start':'markerStart',markerunits:'markerUnits',markerwidth:'markerWidth',mask:'mask',maskcontentunits:'maskContentUnits',maskunits:'maskUnits',mathematical:'mathematical',mode:'mode',numoctaves:'numOctaves',offset:'offset',opacity:'opacity',operator:'operator',order:'order',orient:'orient',orientation:'orientation',origin:'origin',overflow:'overflow',overlineposition:'overlinePosition','overline-position':'overlinePosition',overlinethickness:'overlineThickness','overline-thickness':'overlineThickness',paintorder:'paintOrder','paint-order':'paintOrder',panose1:'panose1','panose-1':'panose1',pathlength:'pathLength',patterncontentunits:'patternContentUnits',patterntransform:'patternTransform',patternunits:'patternUnits',pointerevents:'pointerEvents','pointer-events':'pointerEvents',points:'points',pointsatx:'pointsAtX',pointsaty:'pointsAtY',pointsatz:'pointsAtZ',prefix:'prefix',preservealpha:'preserveAlpha',preserveaspectratio:'preserveAspectRatio',primitiveunits:'primitiveUnits',property:'property',r:'r',radius:'radius',refx:'refX',refy:'refY',renderingintent:'renderingIntent','rendering-intent':'renderingIntent',repeatcount:'repeatCount',repeatdur:'repeatDur',requiredextensions:'requiredExtensions',requiredfeatures:'requiredFeatures',resource:'resource',restart:'restart',result:'result',results:'results',rotate:'rotate',rx:'rx',ry:'ry',scale:'scale',security:'security',seed:'seed',shaperendering:'shapeRendering','shape-rendering':'shapeRendering',slope:'slope',spacing:'spacing',specularconstant:'specularConstant',specularexponent:'specularExponent',speed:'speed',spreadmethod:'spreadMethod',startoffset:'startOffset',stddeviation:'stdDeviation',stemh:'stemh',stemv:'stemv',stitchtiles:'stitchTiles',stopcolor:'stopColor','stop-color':'stopColor',stopopacity:'stopOpacity','stop-opacity':'stopOpacity',strikethroughposition:'strikethroughPosition','strikethrough-position':'strikethroughPosition',strikethroughthickness:'strikethroughThickness','strikethrough-thickness':'strikethroughThickness',string:'string',stroke:'stroke',strokedasharray:'strokeDasharray','stroke-dasharray':'strokeDasharray',strokedashoffset:'strokeDashoffset','stroke-dashoffset':'strokeDashoffset',strokelinecap:'strokeLinecap','stroke-linecap':'strokeLinecap',strokelinejoin:'strokeLinejoin','stroke-linejoin':'strokeLinejoin',strokemiterlimit:'strokeMiterlimit','stroke-miterlimit':'strokeMiterlimit',strokewidth:'strokeWidth','stroke-width':'strokeWidth',strokeopacity:'strokeOpacity','stroke-opacity':'strokeOpacity',suppresscontenteditablewarning:'suppressContentEditableWarning',suppresshydrationwarning:'suppressHydrationWarning',surfacescale:'surfaceScale',systemlanguage:'systemLanguage',tablevalues:'tableValues',targetx:'targetX',targety:'targetY',textanchor:'textAnchor','text-anchor':'textAnchor',textdecoration:'textDecoration','text-decoration':'textDecoration',textlength:'textLength',textrendering:'textRendering','text-rendering':'textRendering',to:'to',transform:'transform','typeof':'typeof',u1:'u1',u2:'u2',underlineposition:'underlinePosition','underline-position':'underlinePosition',underlinethickness:'underlineThickness','underline-thickness':'underlineThickness',unicode:'unicode',unicodebidi:'unicodeBidi','unicode-bidi':'unicodeBidi',unicoderange:'unicodeRange','unicode-range':'unicodeRange',unitsperem:'unitsPerEm','units-per-em':'unitsPerEm',unselectable:'unselectable',valphabetic:'vAlphabetic','v-alphabetic':'vAlphabetic',values:'values',vectoreffect:'vectorEffect','vector-effect':'vectorEffect',version:'version',vertadvy:'vertAdvY','vert-adv-y':'vertAdvY',vertoriginx:'vertOriginX','vert-origin-x':'vertOriginX',vertoriginy:'vertOriginY','vert-origin-y':'vertOriginY',vhanging:'vHanging','v-hanging':'vHanging',videographic:'vIdeographic','v-ideographic':'vIdeographic',viewbox:'viewBox',viewtarget:'viewTarget',visibility:'visibility',vmathematical:'vMathematical','v-mathematical':'vMathematical',vocab:'vocab',widths:'widths',wordspacing:'wordSpacing','word-spacing':'wordSpacing',writingmode:'writingMode','writing-mode':'writingMode',x1:'x1',x2:'x2',x:'x',xchannelselector:'xChannelSelector',xheight:'xHeight','x-height':'xHeight',xlinkactuate:'xlinkActuate','xlink:actuate':'xlinkActuate',xlinkarcrole:'xlinkArcrole','xlink:arcrole':'xlinkArcrole',xlinkhref:'xlinkHref','xlink:href':'xlinkHref',xlinkrole:'xlinkRole','xlink:role':'xlinkRole',xlinkshow:'xlinkShow','xlink:show':'xlinkShow',xlinktitle:'xlinkTitle','xlink:title':'xlinkTitle',xlinktype:'xlinkType','xlink:type':'xlinkType',xmlbase:'xmlBase','xml:base':'xmlBase',xmllang:'xmlLang','xml:lang':'xmlLang',xmlns:'xmlns','xml:space':'xmlSpace',xmlnsxlink:'xmlnsXlink','xmlns:xlink':'xmlnsXlink',xmlspace:'xmlSpace',y1:'y1',y2:'y2',y:'y',ychannelselector:'yChannelSelector',z:'z',zoomandpan:'zoomAndPan'};function getStackAddendum$2(){var stack=ReactDebugCurrentFrame.getStackAddendum();return stack!=null?stack:'';}{var warnedProperties$1={};var hasOwnProperty$1=Object.prototype.hasOwnProperty;var EVENT_NAME_REGEX=/^on./;var INVALID_EVENT_NAME_REGEX=/^on[^A-Z]/;var rARIA$1=new RegExp('^(aria)-['+ATTRIBUTE_NAME_CHAR+']*$');var rARIACamel$1=new RegExp('^(aria)[A-Z]['+ATTRIBUTE_NAME_CHAR+']*$');var validateProperty$1=function validateProperty$1(tagName,name,value,canUseEventSystem){if(hasOwnProperty$1.call(warnedProperties$1,name)&&warnedProperties$1[name]){return true;}var lowerCasedName=name.toLowerCase();if(lowerCasedName==='onfocusin'||lowerCasedName==='onfocusout'){warning(false,'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. '+'All React events are normalized to bubble, so onFocusIn and onFocusOut '+'are not needed/supported by React.');warnedProperties$1[name]=true;return true;}// We can't rely on the event system being injected on the server.
if(canUseEventSystem){if(registrationNameModules.hasOwnProperty(name)){return true;}var registrationName=possibleRegistrationNames.hasOwnProperty(lowerCasedName)?possibleRegistrationNames[lowerCasedName]:null;if(registrationName!=null){warning(false,'Invalid event handler property `%s`. Did you mean `%s`?%s',name,registrationName,getStackAddendum$2());warnedProperties$1[name]=true;return true;}if(EVENT_NAME_REGEX.test(name)){warning(false,'Unknown event handler property `%s`. It will be ignored.%s',name,getStackAddendum$2());warnedProperties$1[name]=true;return true;}}else if(EVENT_NAME_REGEX.test(name)){// If no event plugins have been injected, we are in a server environment.
// So we can't tell if the event name is correct for sure, but we can filter
// out known bad ones like `onclick`. We can't suggest a specific replacement though.
if(INVALID_EVENT_NAME_REGEX.test(name)){warning(false,'Invalid event handler property `%s`. '+'React events use the camelCase naming convention, for example `onClick`.%s',name,getStackAddendum$2());}warnedProperties$1[name]=true;return true;}// Let the ARIA attribute hook validate ARIA attributes
if(rARIA$1.test(name)||rARIACamel$1.test(name)){return true;}if(lowerCasedName==='innerhtml'){warning(false,'Directly setting property `innerHTML` is not permitted. '+'For more information, lookup documentation on `dangerouslySetInnerHTML`.');warnedProperties$1[name]=true;return true;}if(lowerCasedName==='aria'){warning(false,'The `aria` attribute is reserved for future use in React. '+'Pass individual `aria-` attributes instead.');warnedProperties$1[name]=true;return true;}if(lowerCasedName==='is'&&value!==null&&value!==undefined&&typeof value!=='string'){warning(false,'Received a `%s` for a string attribute `is`. If this is expected, cast '+'the value to a string.%s',typeof value==='undefined'?'undefined':_typeof(value),getStackAddendum$2());warnedProperties$1[name]=true;return true;}if(typeof value==='number'&&isNaN(value)){warning(false,'Received NaN for the `%s` attribute. If this is expected, cast '+'the value to a string.%s',name,getStackAddendum$2());warnedProperties$1[name]=true;return true;}var isReserved=isReservedProp(name);// Known attributes should match the casing specified in the property config.
if(possibleStandardNames.hasOwnProperty(lowerCasedName)){var standardName=possibleStandardNames[lowerCasedName];if(standardName!==name){warning(false,'Invalid DOM property `%s`. Did you mean `%s`?%s',name,standardName,getStackAddendum$2());warnedProperties$1[name]=true;return true;}}else if(!isReserved&&name!==lowerCasedName){// Unknown attributes should have lowercase casing since that's how they
// will be cased anyway with server rendering.
warning(false,'React does not recognize the `%s` prop on a DOM element. If you '+'intentionally want it to appear in the DOM as a custom '+'attribute, spell it as lowercase `%s` instead. '+'If you accidentally passed it from a parent component, remove '+'it from the DOM element.%s',name,lowerCasedName,getStackAddendum$2());warnedProperties$1[name]=true;return true;}if(typeof value==='boolean'&&!shouldAttributeAcceptBooleanValue(name)){if(value){warning(false,'Received `%s` for a non-boolean attribute `%s`.\n\n'+'If you want to write it to the DOM, pass a string instead: '+'%s="%s" or %s={value.toString()}.%s',value,name,name,value,name,getStackAddendum$2());}else{warning(false,'Received `%s` for a non-boolean attribute `%s`.\n\n'+'If you want to write it to the DOM, pass a string instead: '+'%s="%s" or %s={value.toString()}.\n\n'+'If you used to conditionally omit it with %s={condition && value}, '+'pass %s={condition ? value : undefined} instead.%s',value,name,name,value,name,name,name,getStackAddendum$2());}warnedProperties$1[name]=true;return true;}// Now that we've validated casing, do not validate
// data types for reserved props
if(isReserved){return true;}// Warn when a known attribute is a bad type
if(!shouldSetAttribute(name,value)){warnedProperties$1[name]=true;return false;}return true;};}var warnUnknownProperties=function warnUnknownProperties(type,props,canUseEventSystem){var unknownProps=[];for(var key in props){var isValid=validateProperty$1(type,key,props[key],canUseEventSystem);if(!isValid){unknownProps.push(key);}}var unknownPropString=unknownProps.map(function(prop){return'`'+prop+'`';}).join(', ');if(unknownProps.length===1){warning(false,'Invalid value for prop %s on <%s> tag. Either remove it from the element, '+'or pass a string or number value to keep it in the DOM. '+'For details, see https://fb.me/react-attribute-behavior%s',unknownPropString,type,getStackAddendum$2());}else if(unknownProps.length>1){warning(false,'Invalid values for props %s on <%s> tag. Either remove them from the element, '+'or pass a string or number value to keep them in the DOM. '+'For details, see https://fb.me/react-attribute-behavior%s',unknownPropString,type,getStackAddendum$2());}};function validateProperties$2(type,props,canUseEventSystem){if(isCustomComponent(type,props)){return;}warnUnknownProperties(type,props,canUseEventSystem);}// TODO: direct imports like some-package/src/* are bad. Fix me.
var getCurrentFiberOwnerName$1=ReactDebugCurrentFiber.getCurrentFiberOwnerName;var getCurrentFiberStackAddendum$2=ReactDebugCurrentFiber.getCurrentFiberStackAddendum;var didWarnInvalidHydration=false;var didWarnShadyDOM=false;var DANGEROUSLY_SET_INNER_HTML='dangerouslySetInnerHTML';var SUPPRESS_CONTENT_EDITABLE_WARNING='suppressContentEditableWarning';var SUPPRESS_HYDRATION_WARNING$1='suppressHydrationWarning';var AUTOFOCUS='autoFocus';var CHILDREN='children';var STYLE='style';var HTML='__html';var HTML_NAMESPACE=Namespaces.html;var getStack=emptyFunction.thatReturns('');{getStack=getCurrentFiberStackAddendum$2;var warnedUnknownTags={// Chrome is the only major browser not shipping <time>. But as of July
// 2017 it intends to ship it due to widespread usage. We intentionally
// *don't* warn for <time> even if it's unrecognized by Chrome because
// it soon will be, and many apps have been using it anyway.
time:true,// There are working polyfills for <dialog>. Let people use it.
dialog:true};var validatePropertiesInDevelopment=function validatePropertiesInDevelopment(type,props){validateProperties(type,props);validateProperties$1(type,props);validateProperties$2(type,props,/* canUseEventSystem */true);};// HTML parsing normalizes CR and CRLF to LF.
// It also can turn \u0000 into \uFFFD inside attributes.
// https://www.w3.org/TR/html5/single-page.html#preprocessing-the-input-stream
// If we have a mismatch, it might be caused by that.
// We will still patch up in this case but not fire the warning.
var NORMALIZE_NEWLINES_REGEX=/\r\n?/g;var NORMALIZE_NULL_AND_REPLACEMENT_REGEX=/\u0000|\uFFFD/g;var normalizeMarkupForTextOrAttribute=function normalizeMarkupForTextOrAttribute(markup){var markupString=typeof markup==='string'?markup:''+markup;return markupString.replace(NORMALIZE_NEWLINES_REGEX,'\n').replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX,'');};var warnForTextDifference=function warnForTextDifference(serverText,clientText){if(didWarnInvalidHydration){return;}var normalizedClientText=normalizeMarkupForTextOrAttribute(clientText);var normalizedServerText=normalizeMarkupForTextOrAttribute(serverText);if(normalizedServerText===normalizedClientText){return;}didWarnInvalidHydration=true;warning(false,'Text content did not match. Server: "%s" Client: "%s"',normalizedServerText,normalizedClientText);};var warnForPropDifference=function warnForPropDifference(propName,serverValue,clientValue){if(didWarnInvalidHydration){return;}var normalizedClientValue=normalizeMarkupForTextOrAttribute(clientValue);var normalizedServerValue=normalizeMarkupForTextOrAttribute(serverValue);if(normalizedServerValue===normalizedClientValue){return;}didWarnInvalidHydration=true;warning(false,'Prop `%s` did not match. Server: %s Client: %s',propName,JSON.stringify(normalizedServerValue),JSON.stringify(normalizedClientValue));};var warnForExtraAttributes=function warnForExtraAttributes(attributeNames){if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;var names=[];attributeNames.forEach(function(name){names.push(name);});warning(false,'Extra attributes from the server: %s',names);};var warnForInvalidEventListener=function warnForInvalidEventListener(registrationName,listener){if(listener===false){warning(false,'Expected `%s` listener to be a function, instead got `false`.\n\n'+'If you used to conditionally omit it with %s={condition && value}, '+'pass %s={condition ? value : undefined} instead.%s',registrationName,registrationName,registrationName,getCurrentFiberStackAddendum$2());}else{warning(false,'Expected `%s` listener to be a function, instead got a value of `%s` type.%s',registrationName,typeof listener==='undefined'?'undefined':_typeof(listener),getCurrentFiberStackAddendum$2());}};// Parse the HTML and read it back to normalize the HTML string so that it
// can be used for comparison.
var normalizeHTML=function normalizeHTML(parent,html){// We could have created a separate document here to avoid
// re-initializing custom elements if they exist. But this breaks
// how <noscript> is being handled. So we use the same document.
// See the discussion in https://github.com/facebook/react/pull/11157.
var testElement=parent.namespaceURI===HTML_NAMESPACE?parent.ownerDocument.createElement(parent.tagName):parent.ownerDocument.createElementNS(parent.namespaceURI,parent.tagName);testElement.innerHTML=html;return testElement.innerHTML;};}function ensureListeningTo(rootContainerElement,registrationName){var isDocumentOrFragment=rootContainerElement.nodeType===DOCUMENT_NODE||rootContainerElement.nodeType===DOCUMENT_FRAGMENT_NODE;var doc=isDocumentOrFragment?rootContainerElement:rootContainerElement.ownerDocument;listenTo(registrationName,doc);}function getOwnerDocumentFromRootContainer(rootContainerElement){return rootContainerElement.nodeType===DOCUMENT_NODE?rootContainerElement:rootContainerElement.ownerDocument;}// There are so many media events, it makes sense to just
// maintain a list rather than create a `trapBubbledEvent` for each
var mediaEvents={topAbort:'abort',topCanPlay:'canplay',topCanPlayThrough:'canplaythrough',topDurationChange:'durationchange',topEmptied:'emptied',topEncrypted:'encrypted',topEnded:'ended',topError:'error',topLoadedData:'loadeddata',topLoadedMetadata:'loadedmetadata',topLoadStart:'loadstart',topPause:'pause',topPlay:'play',topPlaying:'playing',topProgress:'progress',topRateChange:'ratechange',topSeeked:'seeked',topSeeking:'seeking',topStalled:'stalled',topSuspend:'suspend',topTimeUpdate:'timeupdate',topVolumeChange:'volumechange',topWaiting:'waiting'};function trapClickOnNonInteractiveElement(node){// Mobile Safari does not fire properly bubble click events on
// non-interactive elements, which means delegated click listeners do not
// fire. The workaround for this bug involves attaching an empty click
// listener on the target node.
// http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
// Just set it using the onclick property so that we don't have to manage any
// bookkeeping for it. Not sure if we need to clear it when the listener is
// removed.
// TODO: Only do this for the relevant Safaris maybe?
node.onclick=emptyFunction;}function setInitialDOMProperties(tag,domElement,rootContainerElement,nextProps,isCustomComponentTag){for(var propKey in nextProps){if(!nextProps.hasOwnProperty(propKey)){continue;}var nextProp=nextProps[propKey];if(propKey===STYLE){{if(nextProp){// Freeze the next style object so that we can assume it won't be
// mutated. We have already warned for this in the past.
Object.freeze(nextProp);}}// Relies on `updateStylesByID` not mutating `styleUpdates`.
setValueForStyles(domElement,nextProp,getStack);}else if(propKey===DANGEROUSLY_SET_INNER_HTML){var nextHtml=nextProp?nextProp[HTML]:undefined;if(nextHtml!=null){setInnerHTML(domElement,nextHtml);}}else if(propKey===CHILDREN){if(typeof nextProp==='string'){// Avoid setting initial textContent when the text is empty. In IE11 setting
// textContent on a <textarea> will cause the placeholder to not
// show within the <textarea> until it has been focused and blurred again.
// https://github.com/facebook/react/issues/6731#issuecomment-254874553
var canSetTextContent=tag!=='textarea'||nextProp!=='';if(canSetTextContent){setTextContent(domElement,nextProp);}}else if(typeof nextProp==='number'){setTextContent(domElement,''+nextProp);}}else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING$1){// Noop
}else if(propKey===AUTOFOCUS){// We polyfill it separately on the client during commit.
// We blacklist it here rather than in the property list because we emit it in SSR.
}else if(registrationNameModules.hasOwnProperty(propKey)){if(nextProp!=null){if(true&&typeof nextProp!=='function'){warnForInvalidEventListener(propKey,nextProp);}ensureListeningTo(rootContainerElement,propKey);}}else if(isCustomComponentTag){setValueForAttribute(domElement,propKey,nextProp);}else if(nextProp!=null){// If we're updating to null or undefined, we should remove the property
// from the DOM node instead of inadvertently setting to a string. This
// brings us in line with the same behavior we have on initial render.
setValueForProperty(domElement,propKey,nextProp);}}}function updateDOMProperties(domElement,updatePayload,wasCustomComponentTag,isCustomComponentTag){// TODO: Handle wasCustomComponentTag
for(var i=0;i<updatePayload.length;i+=2){var propKey=updatePayload[i];var propValue=updatePayload[i+1];if(propKey===STYLE){setValueForStyles(domElement,propValue,getStack);}else if(propKey===DANGEROUSLY_SET_INNER_HTML){setInnerHTML(domElement,propValue);}else if(propKey===CHILDREN){setTextContent(domElement,propValue);}else if(isCustomComponentTag){if(propValue!=null){setValueForAttribute(domElement,propKey,propValue);}else{deleteValueForAttribute(domElement,propKey);}}else if(propValue!=null){setValueForProperty(domElement,propKey,propValue);}else{// If we're updating to null or undefined, we should remove the property
// from the DOM node instead of inadvertently setting to a string. This
// brings us in line with the same behavior we have on initial render.
deleteValueForProperty(domElement,propKey);}}}function createElement$1(type,props,rootContainerElement,parentNamespace){// We create tags in the namespace of their parent container, except HTML
var ownerDocument=getOwnerDocumentFromRootContainer(rootContainerElement);var domElement;var namespaceURI=parentNamespace;if(namespaceURI===HTML_NAMESPACE){namespaceURI=getIntrinsicNamespace(type);}if(namespaceURI===HTML_NAMESPACE){{var isCustomComponentTag=isCustomComponent(type,props);// Should this check be gated by parent namespace? Not sure we want to
// allow <SVG> or <mATH>.
warning(isCustomComponentTag||type===type.toLowerCase(),'<%s /> is using uppercase HTML. Always use lowercase HTML tags '+'in React.',type);}if(type==='script'){// Create the script via .innerHTML so its "parser-inserted" flag is
// set to true and it does not execute
var div=ownerDocument.createElement('div');div.innerHTML='<script><'+'/script>';// eslint-disable-line
// This is guaranteed to yield a script element.
var firstChild=div.firstChild;domElement=div.removeChild(firstChild);}else if(typeof props.is==='string'){// $FlowIssue `createElement` should be updated for Web Components
domElement=ownerDocument.createElement(type,{is:props.is});}else{// Separate else branch instead of using `props.is || undefined` above because of a Firefox bug.
// See discussion in https://github.com/facebook/react/pull/6896
// and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240
domElement=ownerDocument.createElement(type);}}else{domElement=ownerDocument.createElementNS(namespaceURI,type);}{if(namespaceURI===HTML_NAMESPACE){if(!isCustomComponentTag&&Object.prototype.toString.call(domElement)==='[object HTMLUnknownElement]'&&!Object.prototype.hasOwnProperty.call(warnedUnknownTags,type)){warnedUnknownTags[type]=true;warning(false,'The tag <%s> is unrecognized in this browser. '+'If you meant to render a React component, start its name with '+'an uppercase letter.',type);}}}return domElement;}function createTextNode$1(text,rootContainerElement){return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);}function setInitialProperties$1(domElement,tag,rawProps,rootContainerElement){var isCustomComponentTag=isCustomComponent(tag,rawProps);{validatePropertiesInDevelopment(tag,rawProps);if(isCustomComponentTag&&!didWarnShadyDOM&&domElement.shadyRoot){warning(false,'%s is using shady DOM. Using shady DOM with React can '+'cause things to break subtly.',getCurrentFiberOwnerName$1()||'A component');didWarnShadyDOM=true;}}// TODO: Make sure that we check isMounted before firing any of these events.
var props;switch(tag){case'iframe':case'object':trapBubbledEvent('topLoad','load',domElement);props=rawProps;break;case'video':case'audio':// Create listener for each media event
for(var event in mediaEvents){if(mediaEvents.hasOwnProperty(event)){trapBubbledEvent(event,mediaEvents[event],domElement);}}props=rawProps;break;case'source':trapBubbledEvent('topError','error',domElement);props=rawProps;break;case'img':case'image':trapBubbledEvent('topError','error',domElement);trapBubbledEvent('topLoad','load',domElement);props=rawProps;break;case'form':trapBubbledEvent('topReset','reset',domElement);trapBubbledEvent('topSubmit','submit',domElement);props=rawProps;break;case'details':trapBubbledEvent('topToggle','toggle',domElement);props=rawProps;break;case'input':initWrapperState(domElement,rawProps);props=getHostProps(domElement,rawProps);trapBubbledEvent('topInvalid','invalid',domElement);// For controlled components we always need to ensure we're listening
// to onChange. Even if there is no listener.
ensureListeningTo(rootContainerElement,'onChange');break;case'option':validateProps(domElement,rawProps);props=getHostProps$1(domElement,rawProps);break;case'select':initWrapperState$1(domElement,rawProps);props=getHostProps$2(domElement,rawProps);trapBubbledEvent('topInvalid','invalid',domElement);// For controlled components we always need to ensure we're listening
// to onChange. Even if there is no listener.
ensureListeningTo(rootContainerElement,'onChange');break;case'textarea':initWrapperState$2(domElement,rawProps);props=getHostProps$3(domElement,rawProps);trapBubbledEvent('topInvalid','invalid',domElement);// For controlled components we always need to ensure we're listening
// to onChange. Even if there is no listener.
ensureListeningTo(rootContainerElement,'onChange');break;default:props=rawProps;}assertValidProps(tag,props,getStack);setInitialDOMProperties(tag,domElement,rootContainerElement,props,isCustomComponentTag);switch(tag){case'input':// TODO: Make sure we check if this is still unmounted or do any clean
// up necessary since we never stop tracking anymore.
track(domElement);postMountWrapper(domElement,rawProps);break;case'textarea':// TODO: Make sure we check if this is still unmounted or do any clean
// up necessary since we never stop tracking anymore.
track(domElement);postMountWrapper$3(domElement,rawProps);break;case'option':postMountWrapper$1(domElement,rawProps);break;case'select':postMountWrapper$2(domElement,rawProps);break;default:if(typeof props.onClick==='function'){// TODO: This cast may not be sound for SVG, MathML or custom elements.
trapClickOnNonInteractiveElement(domElement);}break;}}// Calculate the diff between the two objects.
function diffProperties$1(domElement,tag,lastRawProps,nextRawProps,rootContainerElement){{validatePropertiesInDevelopment(tag,nextRawProps);}var updatePayload=null;var lastProps;var nextProps;switch(tag){case'input':lastProps=getHostProps(domElement,lastRawProps);nextProps=getHostProps(domElement,nextRawProps);updatePayload=[];break;case'option':lastProps=getHostProps$1(domElement,lastRawProps);nextProps=getHostProps$1(domElement,nextRawProps);updatePayload=[];break;case'select':lastProps=getHostProps$2(domElement,lastRawProps);nextProps=getHostProps$2(domElement,nextRawProps);updatePayload=[];break;case'textarea':lastProps=getHostProps$3(domElement,lastRawProps);nextProps=getHostProps$3(domElement,nextRawProps);updatePayload=[];break;default:lastProps=lastRawProps;nextProps=nextRawProps;if(typeof lastProps.onClick!=='function'&&typeof nextProps.onClick==='function'){// TODO: This cast may not be sound for SVG, MathML or custom elements.
trapClickOnNonInteractiveElement(domElement);}break;}assertValidProps(tag,nextProps,getStack);var propKey;var styleName;var styleUpdates=null;for(propKey in lastProps){if(nextProps.hasOwnProperty(propKey)||!lastProps.hasOwnProperty(propKey)||lastProps[propKey]==null){continue;}if(propKey===STYLE){var lastStyle=lastProps[propKey];for(styleName in lastStyle){if(lastStyle.hasOwnProperty(styleName)){if(!styleUpdates){styleUpdates={};}styleUpdates[styleName]='';}}}else if(propKey===DANGEROUSLY_SET_INNER_HTML||propKey===CHILDREN){// Noop. This is handled by the clear text mechanism.
}else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING$1){// Noop
}else if(propKey===AUTOFOCUS){// Noop. It doesn't work on updates anyway.
}else if(registrationNameModules.hasOwnProperty(propKey)){// This is a special case. If any listener updates we need to ensure
// that the "current" fiber pointer gets updated so we need a commit
// to update this element.
if(!updatePayload){updatePayload=[];}}else{// For all other deleted properties we add it to the queue. We use
// the whitelist in the commit phase instead.
(updatePayload=updatePayload||[]).push(propKey,null);}}for(propKey in nextProps){var nextProp=nextProps[propKey];var lastProp=lastProps!=null?lastProps[propKey]:undefined;if(!nextProps.hasOwnProperty(propKey)||nextProp===lastProp||nextProp==null&&lastProp==null){continue;}if(propKey===STYLE){{if(nextProp){// Freeze the next style object so that we can assume it won't be
// mutated. We have already warned for this in the past.
Object.freeze(nextProp);}}if(lastProp){// Unset styles on `lastProp` but not on `nextProp`.
for(styleName in lastProp){if(lastProp.hasOwnProperty(styleName)&&(!nextProp||!nextProp.hasOwnProperty(styleName))){if(!styleUpdates){styleUpdates={};}styleUpdates[styleName]='';}}// Update styles that changed since `lastProp`.
for(styleName in nextProp){if(nextProp.hasOwnProperty(styleName)&&lastProp[styleName]!==nextProp[styleName]){if(!styleUpdates){styleUpdates={};}styleUpdates[styleName]=nextProp[styleName];}}}else{// Relies on `updateStylesByID` not mutating `styleUpdates`.
if(!styleUpdates){if(!updatePayload){updatePayload=[];}updatePayload.push(propKey,styleUpdates);}styleUpdates=nextProp;}}else if(propKey===DANGEROUSLY_SET_INNER_HTML){var nextHtml=nextProp?nextProp[HTML]:undefined;var lastHtml=lastProp?lastProp[HTML]:undefined;if(nextHtml!=null){if(lastHtml!==nextHtml){(updatePayload=updatePayload||[]).push(propKey,''+nextHtml);}}else{// TODO: It might be too late to clear this if we have children
// inserted already.
}}else if(propKey===CHILDREN){if(lastProp!==nextProp&&(typeof nextProp==='string'||typeof nextProp==='number')){(updatePayload=updatePayload||[]).push(propKey,''+nextProp);}}else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING$1){// Noop
}else if(registrationNameModules.hasOwnProperty(propKey)){if(nextProp!=null){// We eagerly listen to this even though we haven't committed yet.
if(true&&typeof nextProp!=='function'){warnForInvalidEventListener(propKey,nextProp);}ensureListeningTo(rootContainerElement,propKey);}if(!updatePayload&&lastProp!==nextProp){// This is a special case. If any listener updates we need to ensure
// that the "current" props pointer gets updated so we need a commit
// to update this element.
updatePayload=[];}}else{// For any other property we always add it to the queue and then we
// filter it out using the whitelist during the commit.
(updatePayload=updatePayload||[]).push(propKey,nextProp);}}if(styleUpdates){(updatePayload=updatePayload||[]).push(STYLE,styleUpdates);}return updatePayload;}// Apply the diff.
function updateProperties$1(domElement,updatePayload,tag,lastRawProps,nextRawProps){// Update checked *before* name.
// In the middle of an update, it is possible to have multiple checked.
// When a checked radio tries to change name, browser makes another radio's checked false.
if(tag==='input'&&nextRawProps.type==='radio'&&nextRawProps.name!=null){updateChecked(domElement,nextRawProps);}var wasCustomComponentTag=isCustomComponent(tag,lastRawProps);var isCustomComponentTag=isCustomComponent(tag,nextRawProps);// Apply the diff.
updateDOMProperties(domElement,updatePayload,wasCustomComponentTag,isCustomComponentTag);// TODO: Ensure that an update gets scheduled if any of the special props
// changed.
switch(tag){case'input':// Update the wrapper around inputs *after* updating props. This has to
// happen after `updateDOMProperties`. Otherwise HTML5 input validations
// raise warnings and prevent the new value from being assigned.
updateWrapper(domElement,nextRawProps);break;case'textarea':updateWrapper$1(domElement,nextRawProps);break;case'select':// <select> value update needs to occur after <option> children
// reconciliation
postUpdateWrapper(domElement,nextRawProps);break;}}function diffHydratedProperties$1(domElement,tag,rawProps,parentNamespace,rootContainerElement){{var suppressHydrationWarning=rawProps[SUPPRESS_HYDRATION_WARNING$1]===true;var isCustomComponentTag=isCustomComponent(tag,rawProps);validatePropertiesInDevelopment(tag,rawProps);if(isCustomComponentTag&&!didWarnShadyDOM&&domElement.shadyRoot){warning(false,'%s is using shady DOM. Using shady DOM with React can '+'cause things to break subtly.',getCurrentFiberOwnerName$1()||'A component');didWarnShadyDOM=true;}}// TODO: Make sure that we check isMounted before firing any of these events.
switch(tag){case'iframe':case'object':trapBubbledEvent('topLoad','load',domElement);break;case'video':case'audio':// Create listener for each media event
for(var event in mediaEvents){if(mediaEvents.hasOwnProperty(event)){trapBubbledEvent(event,mediaEvents[event],domElement);}}break;case'source':trapBubbledEvent('topError','error',domElement);break;case'img':case'image':trapBubbledEvent('topError','error',domElement);trapBubbledEvent('topLoad','load',domElement);break;case'form':trapBubbledEvent('topReset','reset',domElement);trapBubbledEvent('topSubmit','submit',domElement);break;case'details':trapBubbledEvent('topToggle','toggle',domElement);break;case'input':initWrapperState(domElement,rawProps);trapBubbledEvent('topInvalid','invalid',domElement);// For controlled components we always need to ensure we're listening
// to onChange. Even if there is no listener.
ensureListeningTo(rootContainerElement,'onChange');break;case'option':validateProps(domElement,rawProps);break;case'select':initWrapperState$1(domElement,rawProps);trapBubbledEvent('topInvalid','invalid',domElement);// For controlled components we always need to ensure we're listening
// to onChange. Even if there is no listener.
ensureListeningTo(rootContainerElement,'onChange');break;case'textarea':initWrapperState$2(domElement,rawProps);trapBubbledEvent('topInvalid','invalid',domElement);// For controlled components we always need to ensure we're listening
// to onChange. Even if there is no listener.
ensureListeningTo(rootContainerElement,'onChange');break;}assertValidProps(tag,rawProps,getStack);{var extraAttributeNames=new Set();var attributes=domElement.attributes;for(var i=0;i<attributes.length;i++){var name=attributes[i].name.toLowerCase();switch(name){// Built-in SSR attribute is whitelisted
case'data-reactroot':break;// Controlled attributes are not validated
// TODO: Only ignore them on controlled tags.
case'value':break;case'checked':break;case'selected':break;default:// Intentionally use the original name.
// See discussion in https://github.com/facebook/react/pull/10676.
extraAttributeNames.add(attributes[i].name);}}}var updatePayload=null;for(var propKey in rawProps){if(!rawProps.hasOwnProperty(propKey)){continue;}var nextProp=rawProps[propKey];if(propKey===CHILDREN){// For text content children we compare against textContent. This
// might match additional HTML that is hidden when we read it using
// textContent. E.g. "foo" will match "f<span>oo</span>" but that still
// satisfies our requirement. Our requirement is not to produce perfect
// HTML and attributes. Ideally we should preserve structure but it's
// ok not to if the visible content is still enough to indicate what
// even listeners these nodes might be wired up to.
// TODO: Warn if there is more than a single textNode as a child.
// TODO: Should we use domElement.firstChild.nodeValue to compare?
if(typeof nextProp==='string'){if(domElement.textContent!==nextProp){if(true&&!suppressHydrationWarning){warnForTextDifference(domElement.textContent,nextProp);}updatePayload=[CHILDREN,nextProp];}}else if(typeof nextProp==='number'){if(domElement.textContent!==''+nextProp){if(true&&!suppressHydrationWarning){warnForTextDifference(domElement.textContent,nextProp);}updatePayload=[CHILDREN,''+nextProp];}}}else if(registrationNameModules.hasOwnProperty(propKey)){if(nextProp!=null){if(true&&typeof nextProp!=='function'){warnForInvalidEventListener(propKey,nextProp);}ensureListeningTo(rootContainerElement,propKey);}}else{// Validate that the properties correspond to their expected values.
var serverValue;var propertyInfo;if(suppressHydrationWarning){// Don't bother comparing. We're ignoring all these warnings.
}else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING$1||// Controlled attributes are not validated
// TODO: Only ignore them on controlled tags.
propKey==='value'||propKey==='checked'||propKey==='selected'){// Noop
}else if(propKey===DANGEROUSLY_SET_INNER_HTML){var rawHtml=nextProp?nextProp[HTML]||'':'';var serverHTML=domElement.innerHTML;var expectedHTML=normalizeHTML(domElement,rawHtml);if(expectedHTML!==serverHTML){warnForPropDifference(propKey,serverHTML,expectedHTML);}}else if(propKey===STYLE){// $FlowFixMe - Should be inferred as not undefined.
extraAttributeNames['delete'](propKey);var expectedStyle=createDangerousStringForStyles(nextProp);serverValue=domElement.getAttribute('style');if(expectedStyle!==serverValue){warnForPropDifference(propKey,serverValue,expectedStyle);}}else if(isCustomComponentTag){// $FlowFixMe - Should be inferred as not undefined.
extraAttributeNames['delete'](propKey.toLowerCase());serverValue=getValueForAttribute(domElement,propKey,nextProp);if(nextProp!==serverValue){warnForPropDifference(propKey,serverValue,nextProp);}}else if(shouldSetAttribute(propKey,nextProp)){if(propertyInfo=getPropertyInfo(propKey)){// $FlowFixMe - Should be inferred as not undefined.
extraAttributeNames['delete'](propertyInfo.attributeName);serverValue=getValueForProperty(domElement,propKey,nextProp);}else{var ownNamespace=parentNamespace;if(ownNamespace===HTML_NAMESPACE){ownNamespace=getIntrinsicNamespace(tag);}if(ownNamespace===HTML_NAMESPACE){// $FlowFixMe - Should be inferred as not undefined.
extraAttributeNames['delete'](propKey.toLowerCase());}else{// $FlowFixMe - Should be inferred as not undefined.
extraAttributeNames['delete'](propKey);}serverValue=getValueForAttribute(domElement,propKey,nextProp);}if(nextProp!==serverValue){warnForPropDifference(propKey,serverValue,nextProp);}}}}{// $FlowFixMe - Should be inferred as not undefined.
if(extraAttributeNames.size>0&&!suppressHydrationWarning){// $FlowFixMe - Should be inferred as not undefined.
warnForExtraAttributes(extraAttributeNames);}}switch(tag){case'input':// TODO: Make sure we check if this is still unmounted or do any clean
// up necessary since we never stop tracking anymore.
track(domElement);postMountWrapper(domElement,rawProps);break;case'textarea':// TODO: Make sure we check if this is still unmounted or do any clean
// up necessary since we never stop tracking anymore.
track(domElement);postMountWrapper$3(domElement,rawProps);break;case'select':case'option':// For input and textarea we current always set the value property at
// post mount to force it to diverge from attributes. However, for
// option and select we don't quite do the same thing and select
// is not resilient to the DOM state changing so we don't do that here.
// TODO: Consider not doing this for input and textarea.
break;default:if(typeof rawProps.onClick==='function'){// TODO: This cast may not be sound for SVG, MathML or custom elements.
trapClickOnNonInteractiveElement(domElement);}break;}return updatePayload;}function diffHydratedText$1(textNode,text){var isDifferent=textNode.nodeValue!==text;return isDifferent;}function warnForUnmatchedText$1(textNode,text){{warnForTextDifference(textNode.nodeValue,text);}}function warnForDeletedHydratableElement$1(parentNode,child){{if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;warning(false,'Did not expect server HTML to contain a <%s> in <%s>.',child.nodeName.toLowerCase(),parentNode.nodeName.toLowerCase());}}function warnForDeletedHydratableText$1(parentNode,child){{if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;warning(false,'Did not expect server HTML to contain the text node "%s" in <%s>.',child.nodeValue,parentNode.nodeName.toLowerCase());}}function warnForInsertedHydratedElement$1(parentNode,tag,props){{if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;warning(false,'Expected server HTML to contain a matching <%s> in <%s>.',tag,parentNode.nodeName.toLowerCase());}}function warnForInsertedHydratedText$1(parentNode,text){{if(text===''){// We expect to insert empty text nodes since they're not represented in
// the HTML.
// TODO: Remove this special case if we can just avoid inserting empty
// text nodes.
return;}if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;warning(false,'Expected server HTML to contain a matching text node for "%s" in <%s>.',text,parentNode.nodeName.toLowerCase());}}function restoreControlledState(domElement,tag,props){switch(tag){case'input':restoreControlledState$1(domElement,props);return;case'textarea':restoreControlledState$3(domElement,props);return;case'select':restoreControlledState$2(domElement,props);return;}}var ReactDOMFiberComponent=Object.freeze({createElement:createElement$1,createTextNode:createTextNode$1,setInitialProperties:setInitialProperties$1,diffProperties:diffProperties$1,updateProperties:updateProperties$1,diffHydratedProperties:diffHydratedProperties$1,diffHydratedText:diffHydratedText$1,warnForUnmatchedText:warnForUnmatchedText$1,warnForDeletedHydratableElement:warnForDeletedHydratableElement$1,warnForDeletedHydratableText:warnForDeletedHydratableText$1,warnForInsertedHydratedElement:warnForInsertedHydratedElement$1,warnForInsertedHydratedText:warnForInsertedHydratedText$1,restoreControlledState:restoreControlledState});// TODO: direct imports like some-package/src/* are bad. Fix me.
var getCurrentFiberStackAddendum$6=ReactDebugCurrentFiber.getCurrentFiberStackAddendum;var validateDOMNesting=emptyFunction;{// This validation code was written based on the HTML5 parsing spec:
// https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
//
// Note: this does not catch all invalid nesting, nor does it try to (as it's
// not clear what practical benefit doing so provides); instead, we warn only
// for cases where the parser will give a parse tree differing from what React
// intended. For example, <b><div></div></b> is invalid but we don't warn
// because it still parses correctly; we do warn for other cases like nested
// <p> tags where the beginning of the second element implicitly closes the
// first, causing a confusing mess.
// https://html.spec.whatwg.org/multipage/syntax.html#special
var specialTags=['address','applet','area','article','aside','base','basefont','bgsound','blockquote','body','br','button','caption','center','col','colgroup','dd','details','dir','div','dl','dt','embed','fieldset','figcaption','figure','footer','form','frame','frameset','h1','h2','h3','h4','h5','h6','head','header','hgroup','hr','html','iframe','img','input','isindex','li','link','listing','main','marquee','menu','menuitem','meta','nav','noembed','noframes','noscript','object','ol','p','param','plaintext','pre','script','section','select','source','style','summary','table','tbody','td','template','textarea','tfoot','th','thead','title','tr','track','ul','wbr','xmp'];// https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
var inScopeTags=['applet','caption','html','table','td','th','marquee','object','template',// https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
// TODO: Distinguish by namespace here -- for <title>, including it here
// errs on the side of fewer warnings
'foreignObject','desc','title'];// https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope
var buttonScopeTags=inScopeTags.concat(['button']);// https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags
var impliedEndTags=['dd','dt','li','option','optgroup','p','rp','rt'];var emptyAncestorInfo={current:null,formTag:null,aTagInScope:null,buttonTagInScope:null,nobrTagInScope:null,pTagInButtonScope:null,listItemTagAutoclosing:null,dlItemTagAutoclosing:null};var updatedAncestorInfo$1=function updatedAncestorInfo$1(oldInfo,tag,instance){var ancestorInfo=_assign({},oldInfo||emptyAncestorInfo);var info={tag:tag,instance:instance};if(inScopeTags.indexOf(tag)!==-1){ancestorInfo.aTagInScope=null;ancestorInfo.buttonTagInScope=null;ancestorInfo.nobrTagInScope=null;}if(buttonScopeTags.indexOf(tag)!==-1){ancestorInfo.pTagInButtonScope=null;}// See rules for 'li', 'dd', 'dt' start tags in
// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
if(specialTags.indexOf(tag)!==-1&&tag!=='address'&&tag!=='div'&&tag!=='p'){ancestorInfo.listItemTagAutoclosing=null;ancestorInfo.dlItemTagAutoclosing=null;}ancestorInfo.current=info;if(tag==='form'){ancestorInfo.formTag=info;}if(tag==='a'){ancestorInfo.aTagInScope=info;}if(tag==='button'){ancestorInfo.buttonTagInScope=info;}if(tag==='nobr'){ancestorInfo.nobrTagInScope=info;}if(tag==='p'){ancestorInfo.pTagInButtonScope=info;}if(tag==='li'){ancestorInfo.listItemTagAutoclosing=info;}if(tag==='dd'||tag==='dt'){ancestorInfo.dlItemTagAutoclosing=info;}return ancestorInfo;};/**
   * Returns whether
   */var isTagValidWithParent=function isTagValidWithParent(tag,parentTag){// First, let's check if we're in an unusual parsing mode...
switch(parentTag){// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
case'select':return tag==='option'||tag==='optgroup'||tag==='#text';case'optgroup':return tag==='option'||tag==='#text';// Strictly speaking, seeing an <option> doesn't mean we're in a <select>
// but
case'option':return tag==='#text';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
// No special behavior since these rules fall back to "in body" mode for
// all except special table nodes which cause bad parsing behavior anyway.
// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
case'tr':return tag==='th'||tag==='td'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
case'tbody':case'thead':case'tfoot':return tag==='tr'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
case'colgroup':return tag==='col'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
case'table':return tag==='caption'||tag==='colgroup'||tag==='tbody'||tag==='tfoot'||tag==='thead'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
case'head':return tag==='base'||tag==='basefont'||tag==='bgsound'||tag==='link'||tag==='meta'||tag==='title'||tag==='noscript'||tag==='noframes'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
case'html':return tag==='head'||tag==='body';case'#document':return tag==='html';}// Probably in the "in body" parsing mode, so we outlaw only tag combos
// where the parsing rules cause implicit opens or closes to be added.
// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
switch(tag){case'h1':case'h2':case'h3':case'h4':case'h5':case'h6':return parentTag!=='h1'&&parentTag!=='h2'&&parentTag!=='h3'&&parentTag!=='h4'&&parentTag!=='h5'&&parentTag!=='h6';case'rp':case'rt':return impliedEndTags.indexOf(parentTag)===-1;case'body':case'caption':case'col':case'colgroup':case'frame':case'head':case'html':case'tbody':case'td':case'tfoot':case'th':case'thead':case'tr':// These tags are only valid with a few parents that have special child
// parsing rules -- if we're down here, then none of those matched and
// so we allow it only if we don't know what the parent is, as all other
// cases are invalid.
return parentTag==null;}return true;};/**
   * Returns whether
   */var findInvalidAncestorForTag=function findInvalidAncestorForTag(tag,ancestorInfo){switch(tag){case'address':case'article':case'aside':case'blockquote':case'center':case'details':case'dialog':case'dir':case'div':case'dl':case'fieldset':case'figcaption':case'figure':case'footer':case'header':case'hgroup':case'main':case'menu':case'nav':case'ol':case'p':case'section':case'summary':case'ul':case'pre':case'listing':case'table':case'hr':case'xmp':case'h1':case'h2':case'h3':case'h4':case'h5':case'h6':return ancestorInfo.pTagInButtonScope;case'form':return ancestorInfo.formTag||ancestorInfo.pTagInButtonScope;case'li':return ancestorInfo.listItemTagAutoclosing;case'dd':case'dt':return ancestorInfo.dlItemTagAutoclosing;case'button':return ancestorInfo.buttonTagInScope;case'a':// Spec says something about storing a list of markers, but it sounds
// equivalent to this check.
return ancestorInfo.aTagInScope;case'nobr':return ancestorInfo.nobrTagInScope;}return null;};var didWarn={};validateDOMNesting=function validateDOMNesting(childTag,childText,ancestorInfo){ancestorInfo=ancestorInfo||emptyAncestorInfo;var parentInfo=ancestorInfo.current;var parentTag=parentInfo&&parentInfo.tag;if(childText!=null){warning(childTag==null,'validateDOMNesting: when childText is passed, childTag should be null');childTag='#text';}var invalidParent=isTagValidWithParent(childTag,parentTag)?null:parentInfo;var invalidAncestor=invalidParent?null:findInvalidAncestorForTag(childTag,ancestorInfo);var invalidParentOrAncestor=invalidParent||invalidAncestor;if(!invalidParentOrAncestor){return;}var ancestorTag=invalidParentOrAncestor.tag;var addendum=getCurrentFiberStackAddendum$6();var warnKey=!!invalidParent+'|'+childTag+'|'+ancestorTag+'|'+addendum;if(didWarn[warnKey]){return;}didWarn[warnKey]=true;var tagDisplayName=childTag;var whitespaceInfo='';if(childTag==='#text'){if(/\S/.test(childText)){tagDisplayName='Text nodes';}else{tagDisplayName='Whitespace text nodes';whitespaceInfo=" Make sure you don't have any extra whitespace between tags on "+'each line of your source code.';}}else{tagDisplayName='<'+childTag+'>';}if(invalidParent){var info='';if(ancestorTag==='table'&&childTag==='tr'){info+=' Add a <tbody> to your code to match the DOM tree generated by '+'the browser.';}warning(false,'validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s%s',tagDisplayName,ancestorTag,whitespaceInfo,info,addendum);}else{warning(false,'validateDOMNesting(...): %s cannot appear as a descendant of '+'<%s>.%s',tagDisplayName,ancestorTag,addendum);}};// TODO: turn this into a named export
validateDOMNesting.updatedAncestorInfo=updatedAncestorInfo$1;// For testing
validateDOMNesting.isTagValidInContext=function(tag,ancestorInfo){ancestorInfo=ancestorInfo||emptyAncestorInfo;var parentInfo=ancestorInfo.current;var parentTag=parentInfo&&parentInfo.tag;return isTagValidWithParent(tag,parentTag)&&!findInvalidAncestorForTag(tag,ancestorInfo);};}var validateDOMNesting$1=validateDOMNesting;// TODO: direct imports like some-package/src/* are bad. Fix me.
var createElement=createElement$1;var createTextNode=createTextNode$1;var setInitialProperties=setInitialProperties$1;var diffProperties=diffProperties$1;var updateProperties=updateProperties$1;var diffHydratedProperties=diffHydratedProperties$1;var diffHydratedText=diffHydratedText$1;var warnForUnmatchedText=warnForUnmatchedText$1;var warnForDeletedHydratableElement=warnForDeletedHydratableElement$1;var warnForDeletedHydratableText=warnForDeletedHydratableText$1;var warnForInsertedHydratedElement=warnForInsertedHydratedElement$1;var warnForInsertedHydratedText=warnForInsertedHydratedText$1;var updatedAncestorInfo=validateDOMNesting$1.updatedAncestorInfo;var precacheFiberNode=precacheFiberNode$1;var updateFiberProps=updateFiberProps$1;{var SUPPRESS_HYDRATION_WARNING='suppressHydrationWarning';if(typeof Map!=='function'||Map.prototype==null||typeof Map.prototype.forEach!=='function'||typeof Set!=='function'||Set.prototype==null||typeof Set.prototype.clear!=='function'||typeof Set.prototype.forEach!=='function'){warning(false,'React depends on Map and Set built-in types. Make sure that you load a '+'polyfill in older browsers. http://fb.me/react-polyfills');}}injection$3.injectFiberControlledHostComponent(ReactDOMFiberComponent);var eventsEnabled=null;var selectionInformation=null;/**
 * True if the supplied DOM node is a valid node element.
 *
 * @param {?DOMElement} node The candidate DOM node.
 * @return {boolean} True if the DOM is a valid DOM node.
 * @internal
 */function isValidContainer(node){return!!(node&&(node.nodeType===ELEMENT_NODE||node.nodeType===DOCUMENT_NODE||node.nodeType===DOCUMENT_FRAGMENT_NODE||node.nodeType===COMMENT_NODE&&node.nodeValue===' react-mount-point-unstable '));}function getReactRootElementInContainer(container){if(!container){return null;}if(container.nodeType===DOCUMENT_NODE){return container.documentElement;}else{return container.firstChild;}}function shouldHydrateDueToLegacyHeuristic(container){var rootElement=getReactRootElementInContainer(container);return!!(rootElement&&rootElement.nodeType===ELEMENT_NODE&&rootElement.hasAttribute(ROOT_ATTRIBUTE_NAME));}function shouldAutoFocusHostComponent(type,props){switch(type){case'button':case'input':case'select':case'textarea':return!!props.autoFocus;}return false;}var DOMRenderer=reactReconciler({getRootHostContext:function getRootHostContext(rootContainerInstance){var type=void 0;var namespace=void 0;var nodeType=rootContainerInstance.nodeType;switch(nodeType){case DOCUMENT_NODE:case DOCUMENT_FRAGMENT_NODE:{type=nodeType===DOCUMENT_NODE?'#document':'#fragment';var root=rootContainerInstance.documentElement;namespace=root?root.namespaceURI:getChildNamespace(null,'');break;}default:{var container=nodeType===COMMENT_NODE?rootContainerInstance.parentNode:rootContainerInstance;var ownNamespace=container.namespaceURI||null;type=container.tagName;namespace=getChildNamespace(ownNamespace,type);break;}}{var validatedTag=type.toLowerCase();var _ancestorInfo=updatedAncestorInfo(null,validatedTag,null);return{namespace:namespace,ancestorInfo:_ancestorInfo};}return namespace;},getChildHostContext:function getChildHostContext(parentHostContext,type){{var parentHostContextDev=parentHostContext;var _namespace=getChildNamespace(parentHostContextDev.namespace,type);var _ancestorInfo2=updatedAncestorInfo(parentHostContextDev.ancestorInfo,type,null);return{namespace:_namespace,ancestorInfo:_ancestorInfo2};}var parentNamespace=parentHostContext;return getChildNamespace(parentNamespace,type);},getPublicInstance:function getPublicInstance(instance){return instance;},prepareForCommit:function prepareForCommit(){eventsEnabled=isEnabled();selectionInformation=getSelectionInformation();setEnabled(false);},resetAfterCommit:function resetAfterCommit(){restoreSelection(selectionInformation);selectionInformation=null;setEnabled(eventsEnabled);eventsEnabled=null;},createInstance:function createInstance(type,props,rootContainerInstance,hostContext,internalInstanceHandle){var parentNamespace=void 0;{// TODO: take namespace into account when validating.
var hostContextDev=hostContext;validateDOMNesting$1(type,null,hostContextDev.ancestorInfo);if(typeof props.children==='string'||typeof props.children==='number'){var string=''+props.children;var ownAncestorInfo=updatedAncestorInfo(hostContextDev.ancestorInfo,type,null);validateDOMNesting$1(null,string,ownAncestorInfo);}parentNamespace=hostContextDev.namespace;}var domElement=createElement(type,props,rootContainerInstance,parentNamespace);precacheFiberNode(internalInstanceHandle,domElement);updateFiberProps(domElement,props);return domElement;},appendInitialChild:function appendInitialChild(parentInstance,child){parentInstance.appendChild(child);},finalizeInitialChildren:function finalizeInitialChildren(domElement,type,props,rootContainerInstance){setInitialProperties(domElement,type,props,rootContainerInstance);return shouldAutoFocusHostComponent(type,props);},prepareUpdate:function prepareUpdate(domElement,type,oldProps,newProps,rootContainerInstance,hostContext){{var hostContextDev=hostContext;if(_typeof(newProps.children)!==_typeof(oldProps.children)&&(typeof newProps.children==='string'||typeof newProps.children==='number')){var string=''+newProps.children;var ownAncestorInfo=updatedAncestorInfo(hostContextDev.ancestorInfo,type,null);validateDOMNesting$1(null,string,ownAncestorInfo);}}return diffProperties(domElement,type,oldProps,newProps,rootContainerInstance);},shouldSetTextContent:function shouldSetTextContent(type,props){return type==='textarea'||typeof props.children==='string'||typeof props.children==='number'||_typeof(props.dangerouslySetInnerHTML)==='object'&&props.dangerouslySetInnerHTML!==null&&typeof props.dangerouslySetInnerHTML.__html==='string';},shouldDeprioritizeSubtree:function shouldDeprioritizeSubtree(type,props){return!!props.hidden;},createTextInstance:function createTextInstance(text,rootContainerInstance,hostContext,internalInstanceHandle){{var hostContextDev=hostContext;validateDOMNesting$1(null,text,hostContextDev.ancestorInfo);}var textNode=createTextNode(text,rootContainerInstance);precacheFiberNode(internalInstanceHandle,textNode);return textNode;},now:now,mutation:{commitMount:function commitMount(domElement,type,newProps,internalInstanceHandle){domElement.focus();},commitUpdate:function commitUpdate(domElement,updatePayload,type,oldProps,newProps,internalInstanceHandle){// Update the props handle so that we know which props are the ones with
// with current event handlers.
updateFiberProps(domElement,newProps);// Apply the diff to the DOM node.
updateProperties(domElement,updatePayload,type,oldProps,newProps);},resetTextContent:function resetTextContent(domElement){domElement.textContent='';},commitTextUpdate:function commitTextUpdate(textInstance,oldText,newText){textInstance.nodeValue=newText;},appendChild:function appendChild(parentInstance,child){parentInstance.appendChild(child);},appendChildToContainer:function appendChildToContainer(container,child){if(container.nodeType===COMMENT_NODE){container.parentNode.insertBefore(child,container);}else{container.appendChild(child);}},insertBefore:function insertBefore(parentInstance,child,beforeChild){parentInstance.insertBefore(child,beforeChild);},insertInContainerBefore:function insertInContainerBefore(container,child,beforeChild){if(container.nodeType===COMMENT_NODE){container.parentNode.insertBefore(child,beforeChild);}else{container.insertBefore(child,beforeChild);}},removeChild:function removeChild(parentInstance,child){parentInstance.removeChild(child);},removeChildFromContainer:function removeChildFromContainer(container,child){if(container.nodeType===COMMENT_NODE){container.parentNode.removeChild(child);}else{container.removeChild(child);}}},hydration:{canHydrateInstance:function canHydrateInstance(instance,type,props){if(instance.nodeType!==ELEMENT_NODE||type.toLowerCase()!==instance.nodeName.toLowerCase()){return null;}// This has now been refined to an element node.
return instance;},canHydrateTextInstance:function canHydrateTextInstance(instance,text){if(text===''||instance.nodeType!==TEXT_NODE){// Empty strings are not parsed by HTML so there won't be a correct match here.
return null;}// This has now been refined to a text node.
return instance;},getNextHydratableSibling:function getNextHydratableSibling(instance){var node=instance.nextSibling;// Skip non-hydratable nodes.
while(node&&node.nodeType!==ELEMENT_NODE&&node.nodeType!==TEXT_NODE){node=node.nextSibling;}return node;},getFirstHydratableChild:function getFirstHydratableChild(parentInstance){var next=parentInstance.firstChild;// Skip non-hydratable nodes.
while(next&&next.nodeType!==ELEMENT_NODE&&next.nodeType!==TEXT_NODE){next=next.nextSibling;}return next;},hydrateInstance:function hydrateInstance(instance,type,props,rootContainerInstance,hostContext,internalInstanceHandle){precacheFiberNode(internalInstanceHandle,instance);// TODO: Possibly defer this until the commit phase where all the events
// get attached.
updateFiberProps(instance,props);var parentNamespace=void 0;{var hostContextDev=hostContext;parentNamespace=hostContextDev.namespace;}return diffHydratedProperties(instance,type,props,parentNamespace,rootContainerInstance);},hydrateTextInstance:function hydrateTextInstance(textInstance,text,internalInstanceHandle){precacheFiberNode(internalInstanceHandle,textInstance);return diffHydratedText(textInstance,text);},didNotMatchHydratedContainerTextInstance:function didNotMatchHydratedContainerTextInstance(parentContainer,textInstance,text){{warnForUnmatchedText(textInstance,text);}},didNotMatchHydratedTextInstance:function didNotMatchHydratedTextInstance(parentType,parentProps,parentInstance,textInstance,text){if(true&&parentProps[SUPPRESS_HYDRATION_WARNING]!==true){warnForUnmatchedText(textInstance,text);}},didNotHydrateContainerInstance:function didNotHydrateContainerInstance(parentContainer,instance){{if(instance.nodeType===1){warnForDeletedHydratableElement(parentContainer,instance);}else{warnForDeletedHydratableText(parentContainer,instance);}}},didNotHydrateInstance:function didNotHydrateInstance(parentType,parentProps,parentInstance,instance){if(true&&parentProps[SUPPRESS_HYDRATION_WARNING]!==true){if(instance.nodeType===1){warnForDeletedHydratableElement(parentInstance,instance);}else{warnForDeletedHydratableText(parentInstance,instance);}}},didNotFindHydratableContainerInstance:function didNotFindHydratableContainerInstance(parentContainer,type,props){{warnForInsertedHydratedElement(parentContainer,type,props);}},didNotFindHydratableContainerTextInstance:function didNotFindHydratableContainerTextInstance(parentContainer,text){{warnForInsertedHydratedText(parentContainer,text);}},didNotFindHydratableInstance:function didNotFindHydratableInstance(parentType,parentProps,parentInstance,type,props){if(true&&parentProps[SUPPRESS_HYDRATION_WARNING]!==true){warnForInsertedHydratedElement(parentInstance,type,props);}},didNotFindHydratableTextInstance:function didNotFindHydratableTextInstance(parentType,parentProps,parentInstance,text){if(true&&parentProps[SUPPRESS_HYDRATION_WARNING]!==true){warnForInsertedHydratedText(parentInstance,text);}}},scheduleDeferredCallback:rIC,cancelDeferredCallback:cIC,useSyncScheduling:!enableAsyncSchedulingByDefaultInReactDOM});injection$4.injectFiberBatchedUpdates(DOMRenderer.batchedUpdates);var warnedAboutHydrateAPI=false;function renderSubtreeIntoContainer(parentComponent,children,container,forceHydrate,callback){!isValidContainer(container)?invariant(false,'Target container is not a DOM element.'):void 0;{if(container._reactRootContainer&&container.nodeType!==COMMENT_NODE){var hostInstance=DOMRenderer.findHostInstanceWithNoPortals(container._reactRootContainer.current);if(hostInstance){warning(hostInstance.parentNode===container,'render(...): It looks like the React-rendered content of this '+'container was removed without using React. This is not '+'supported and will cause errors. Instead, call '+'ReactDOM.unmountComponentAtNode to empty a container.');}}var isRootRenderedBySomeReact=!!container._reactRootContainer;var rootEl=getReactRootElementInContainer(container);var hasNonRootReactChild=!!(rootEl&&getInstanceFromNode$1(rootEl));warning(!hasNonRootReactChild||isRootRenderedBySomeReact,'render(...): Replacing React-rendered children with a new root '+'component. If you intended to update the children of this node, '+'you should instead have the existing children update their state '+'and render the new components instead of calling ReactDOM.render.');warning(container.nodeType!==ELEMENT_NODE||!container.tagName||container.tagName.toUpperCase()!=='BODY','render(): Rendering components directly into document.body is '+'discouraged, since its children are often manipulated by third-party '+'scripts and browser extensions. This may lead to subtle '+'reconciliation issues. Try rendering into a container element created '+'for your app.');}var root=container._reactRootContainer;if(!root){var shouldHydrate=forceHydrate||shouldHydrateDueToLegacyHeuristic(container);// First clear any existing content.
if(!shouldHydrate){var warned=false;var rootSibling=void 0;while(rootSibling=container.lastChild){{if(!warned&&rootSibling.nodeType===ELEMENT_NODE&&rootSibling.hasAttribute(ROOT_ATTRIBUTE_NAME)){warned=true;warning(false,'render(): Target node has markup rendered by React, but there '+'are unrelated nodes as well. This is most commonly caused by '+'white-space inserted around server-rendered markup.');}}container.removeChild(rootSibling);}}{if(shouldHydrate&&!forceHydrate&&!warnedAboutHydrateAPI){warnedAboutHydrateAPI=true;lowPriorityWarning$1(false,'render(): Calling ReactDOM.render() to hydrate server-rendered markup '+'will stop working in React v17. Replace the ReactDOM.render() call '+'with ReactDOM.hydrate() if you want React to attach to the server HTML.');}}var newRoot=DOMRenderer.createContainer(container,shouldHydrate);root=container._reactRootContainer=newRoot;// Initial mount should not be batched.
DOMRenderer.unbatchedUpdates(function(){DOMRenderer.updateContainer(children,newRoot,parentComponent,callback);});}else{DOMRenderer.updateContainer(children,root,parentComponent,callback);}return DOMRenderer.getPublicRootInstance(root);}function createPortal(children,container){var key=arguments.length>2&&arguments[2]!==undefined?arguments[2]:null;!isValidContainer(container)?invariant(false,'Target container is not a DOM element.'):void 0;// TODO: pass ReactDOM portal implementation as third argument
return createPortal$1(children,container,null,key);}function ReactRoot(container,hydrate){var root=DOMRenderer.createContainer(container,hydrate);this._reactRootContainer=root;}ReactRoot.prototype.render=function(children,callback){var root=this._reactRootContainer;DOMRenderer.updateContainer(children,root,null,callback);};ReactRoot.prototype.unmount=function(callback){var root=this._reactRootContainer;DOMRenderer.updateContainer(null,root,null,callback);};var ReactDOM={createPortal:createPortal,findDOMNode:function findDOMNode(componentOrElement){{var owner=ReactCurrentOwner.current;if(owner!==null){var warnedAboutRefsInRender=owner.stateNode._warnedAboutRefsInRender;warning(warnedAboutRefsInRender,'%s is accessing findDOMNode inside its render(). '+'render() should be a pure function of props and state. It should '+'never access something that requires stale data from the previous '+'render, such as refs. Move this logic to componentDidMount and '+'componentDidUpdate instead.',getComponentName(owner)||'A component');owner.stateNode._warnedAboutRefsInRender=true;}}if(componentOrElement==null){return null;}if(componentOrElement.nodeType===ELEMENT_NODE){return componentOrElement;}var inst=get(componentOrElement);if(inst){return DOMRenderer.findHostInstance(inst);}if(typeof componentOrElement.render==='function'){invariant(false,'Unable to find node on an unmounted component.');}else{invariant(false,'Element appears to be neither ReactComponent nor DOMNode. Keys: %s',Object.keys(componentOrElement));}},hydrate:function hydrate(element,container,callback){// TODO: throw or warn if we couldn't hydrate?
return renderSubtreeIntoContainer(null,element,container,true,callback);},render:function render(element,container,callback){return renderSubtreeIntoContainer(null,element,container,false,callback);},unstable_renderSubtreeIntoContainer:function unstable_renderSubtreeIntoContainer(parentComponent,element,containerNode,callback){!(parentComponent!=null&&has(parentComponent))?invariant(false,'parentComponent must be a valid React Component'):void 0;return renderSubtreeIntoContainer(parentComponent,element,containerNode,false,callback);},unmountComponentAtNode:function unmountComponentAtNode(container){!isValidContainer(container)?invariant(false,'unmountComponentAtNode(...): Target container is not a DOM element.'):void 0;if(container._reactRootContainer){{var rootEl=getReactRootElementInContainer(container);var renderedByDifferentReact=rootEl&&!getInstanceFromNode$1(rootEl);warning(!renderedByDifferentReact,"unmountComponentAtNode(): The node you're attempting to unmount "+'was rendered by another copy of React.');}// Unmount should not be batched.
DOMRenderer.unbatchedUpdates(function(){renderSubtreeIntoContainer(null,null,container,false,function(){container._reactRootContainer=null;});});// If you call unmountComponentAtNode twice in quick succession, you'll
// get `true` twice. That's probably fine?
return true;}else{{var _rootEl=getReactRootElementInContainer(container);var hasNonRootReactChild=!!(_rootEl&&getInstanceFromNode$1(_rootEl));// Check if the container itself is a React root node.
var isContainerReactRoot=container.nodeType===1&&isValidContainer(container.parentNode)&&!!container.parentNode._reactRootContainer;warning(!hasNonRootReactChild,"unmountComponentAtNode(): The node you're attempting to unmount "+'was rendered by React and is not a top-level container. %s',isContainerReactRoot?'You may have accidentally passed in a React root node instead '+'of its container.':'Instead, have the parent component update its state and '+'rerender in order to remove this component.');}return false;}},// Temporary alias since we already shipped React 16 RC with it.
// TODO: remove in React 17.
unstable_createPortal:createPortal,unstable_batchedUpdates:batchedUpdates,unstable_deferredUpdates:DOMRenderer.deferredUpdates,flushSync:DOMRenderer.flushSync,__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:{// For TapEventPlugin which is popular in open source
EventPluginHub:EventPluginHub,// Used by test-utils
EventPluginRegistry:EventPluginRegistry,EventPropagators:EventPropagators,ReactControlledComponent:ReactControlledComponent,ReactDOMComponentTree:ReactDOMComponentTree,ReactDOMEventListener:ReactDOMEventListener}};if(enableCreateRoot){ReactDOM.createRoot=function createRoot(container,options){var hydrate=options!=null&&options.hydrate===true;return new ReactRoot(container,hydrate);};}var foundDevTools=DOMRenderer.injectIntoDevTools({findFiberByHostInstance:getClosestInstanceFromNode,bundleType:1,version:ReactVersion,rendererPackageName:'react-dom'});{if(!foundDevTools&&ExecutionEnvironment.canUseDOM&&window.top===window.self){// If we're in Chrome or Firefox, provide a download link if not installed.
if(navigator.userAgent.indexOf('Chrome')>-1&&navigator.userAgent.indexOf('Edge')===-1||navigator.userAgent.indexOf('Firefox')>-1){var protocol=window.location.protocol;// Don't warn in exotic cases like chrome-extension://.
if(/^(https?|file):$/.test(protocol)){console.info('%cDownload the React DevTools '+'for a better development experience: '+'https://fb.me/react-devtools'+(protocol==='file:'?'\nYou might need to use a local HTTP server (instead of file://): '+'https://fb.me/react-devtools-faq':''),'font-weight:bold');}}}}var ReactDOM$2=Object.freeze({default:ReactDOM});var ReactDOM$3=ReactDOM$2&&ReactDOM||ReactDOM$2;// TODO: decide on the top-level export form.
// This is hacky but makes it work with both Rollup and Jest.
var reactDom=ReactDOM$3['default']?ReactDOM$3['default']:ReactDOM$3;module.exports=reactDom;})();}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */



var hyphenate = __webpack_require__(55);

var msPattern = /^ms-/;

/**
 * Hyphenates a camelcased CSS property name, for example:
 *
 *   > hyphenateStyleName('backgroundColor')
 *   < "background-color"
 *   > hyphenateStyleName('MozTransition')
 *   < "-moz-transition"
 *   > hyphenateStyleName('msTransition')
 *   < "-ms-transition"
 *
 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
 * is converted to `-ms-`.
 *
 * @param {string} string
 * @return {string}
 */
function hyphenateStyleName(string) {
  return hyphenate(string).replace(msPattern, '-ms-');
}

module.exports = hyphenateStyleName;

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var _uppercasePattern = /([A-Z])/g;

/**
 * Hyphenates a camelcased string, for example:
 *
 *   > hyphenate('backgroundColor')
 *   < "background-color"
 *
 * For CSS style names, use `hyphenateStyleName` instead which works properly
 * with all vendor prefixes, including `ms`.
 *
 * @param {string} string
 * @return {string}
 */
function hyphenate(string) {
  return string.replace(_uppercasePattern, '-$1').toLowerCase();
}

module.exports = hyphenate;

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */



var camelize = __webpack_require__(57);

var msPattern = /^-ms-/;

/**
 * Camelcases a hyphenated CSS property name, for example:
 *
 *   > camelizeStyleName('background-color')
 *   < "backgroundColor"
 *   > camelizeStyleName('-moz-transition')
 *   < "MozTransition"
 *   > camelizeStyleName('-ms-transition')
 *   < "msTransition"
 *
 * As Andi Smith suggests
 * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
 * is converted to lowercase `ms`.
 *
 * @param {string} string
 * @return {string}
 */
function camelizeStyleName(string) {
  return camelize(string.replace(msPattern, 'ms-'));
}

module.exports = camelizeStyleName;

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var _hyphenPattern = /-(.)/g;

/**
 * Camelcases a hyphenated string, for example:
 *
 *   > camelize('background-color')
 *   < "backgroundColor"
 *
 * @param {string} string
 * @return {string}
 */
function camelize(string) {
  return string.replace(_hyphenPattern, function (_, character) {
    return character.toUpperCase();
  });
}

module.exports = camelize;

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(59);
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {"hmr":true}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(6)(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../node_modules/css-loader/index.js!./index.css", function() {
			var newContent = require("!!../node_modules/css-loader/index.js!./index.css");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(5)(false);
// imports


// module
exports.push([module.i, "body {\n  margin: 0;\n  padding: 0;\n  font-family: sans-serif;\n}\n", ""]);

// exports


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
	// get current location
	var location = typeof window !== "undefined" && window.location;

	if (!location) {
		throw new Error("fixUrls requires window.location");
	}

	// blank or null?
	if (!css || typeof css !== "string") {
		return css;
	}

	var baseUrl = location.protocol + "//" + location.host;
	var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
 This regular expression is just a way to recursively match brackets within
 a string.
 	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
    (  = Start a capturing group
      (?:  = Start a non-capturing group
          [^)(]  = Match anything that isn't a parentheses
          |  = OR
          \(  = Match a start parentheses
              (?:  = Start another non-capturing groups
                  [^)(]+  = Match anything that isn't a parentheses
                  |  = OR
                  \(  = Match a start parentheses
                      [^)(]*  = Match anything that isn't a parentheses
                  \)  = Match a end parentheses
              )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
  \)  = Match a close parens
 	 /gi  = Get all matches, not the first.  Be case insensitive.
  */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function (fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl.trim().replace(/^"(.*)"$/, function (o, $1) {
			return $1;
		}).replace(/^'(.*)'$/, function (o, $1) {
			return $1;
		});

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/)/i.test(unquotedOrigUrl)) {
			return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
			//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(62);
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {"hmr":true}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(6)(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../node_modules/css-loader/index.js!./ChatApp.css", function() {
			var newContent = require("!!../../../node_modules/css-loader/index.js!./ChatApp.css");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(5)(false);
// imports


// module
exports.push([module.i, ".App {\n  text-align: center;\n}\n\n.App-logo {\n  animation: App-logo-spin infinite 20s linear;\n  height: 80px;\n}\n\n.App-header {\n  background-color: #222;\n  height: 150px;\n  padding: 20px;\n  color: white;\n}\n\n.App-title {\n  font-size: 1.5em;\n}\n\n.App-intro {\n  font-size: large;\n}\n\n@keyframes App-logo-spin {\n  from { transform: rotate(0deg); }\n  to { transform: rotate(360deg); }\n}\n\n.main-wrap {\n  width: 1170px;\n}", ""]);

// exports


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(64);
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {"hmr":true}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(6)(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../node_modules/css-loader/index.js!./Header.css", function() {
			var newContent = require("!!../../../node_modules/css-loader/index.js!./Header.css");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(5)(false);
// imports


// module
exports.push([module.i, ".app-logo {\n  width: 50px;\n  height: 50px;\n}\n\n.username {\n  margin-top: 8px;\n}", ""]);

// exports


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * Module dependencies.
 */

var url = __webpack_require__(66);
var parser = __webpack_require__(16);
var Manager = __webpack_require__(32);
var debug = __webpack_require__(2)('socket.io-client');

/**
 * Module exports.
 */

module.exports = exports = lookup;

/**
 * Managers cache.
 */

var cache = exports.managers = {};

/**
 * Looks up an existing `Manager` for multiplexing.
 * If the user summons:
 *
 *   `io('http://localhost/a');`
 *   `io('http://localhost/b');`
 *
 * We reuse the existing instance based on same scheme/port/host,
 * and we initialize sockets for each namespace.
 *
 * @api public
 */

function lookup(uri, opts) {
  if ((typeof uri === 'undefined' ? 'undefined' : _typeof(uri)) === 'object') {
    opts = uri;
    uri = undefined;
  }

  opts = opts || {};

  var parsed = url(uri);
  var source = parsed.source;
  var id = parsed.id;
  var path = parsed.path;
  var sameNamespace = cache[id] && path in cache[id].nsps;
  var newConnection = opts.forceNew || opts['force new connection'] || false === opts.multiplex || sameNamespace;

  var io;

  if (newConnection) {
    debug('ignoring socket cache for %s', source);
    io = Manager(source, opts);
  } else {
    if (!cache[id]) {
      debug('new io instance for %s', source);
      cache[id] = Manager(source, opts);
    }
    io = cache[id];
  }
  if (parsed.query && !opts.query) {
    opts.query = parsed.query;
  }
  return io.socket(parsed.path, opts);
}

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = parser.protocol;

/**
 * `connect`.
 *
 * @param {String} uri
 * @api public
 */

exports.connect = lookup;

/**
 * Expose constructors for standalone build.
 *
 * @api public
 */

exports.Manager = __webpack_require__(32);
exports.Socket = __webpack_require__(38);

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

/**
 * Module dependencies.
 */

var parseuri = __webpack_require__(29);
var debug = __webpack_require__(2)('socket.io-client:url');

/**
 * Module exports.
 */

module.exports = url;

/**
 * URL parser.
 *
 * @param {String} url
 * @param {Object} An object meant to mimic window.location.
 *                 Defaults to window.location.
 * @api public
 */

function url(uri, loc) {
  var obj = uri;

  // default to window.location
  loc = loc || global.location;
  if (null == uri) uri = loc.protocol + '//' + loc.host;

  // relative path support
  if ('string' === typeof uri) {
    if ('/' === uri.charAt(0)) {
      if ('/' === uri.charAt(1)) {
        uri = loc.protocol + uri;
      } else {
        uri = loc.host + uri;
      }
    }

    if (!/^(https?|wss?):\/\//.test(uri)) {
      debug('protocol-less url %s', uri);
      if ('undefined' !== typeof loc) {
        uri = loc.protocol + '//' + uri;
      } else {
        uri = 'https://' + uri;
      }
    }

    // parse
    debug('parse %s', uri);
    obj = parseuri(uri);
  }

  // make sure we treat `localhost:80` and `localhost` equally
  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = '80';
    } else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = '443';
    }
  }

  obj.path = obj.path || '/';

  var ipv6 = obj.host.indexOf(':') !== -1;
  var host = ipv6 ? '[' + obj.host + ']' : obj.host;

  // define unique id
  obj.id = obj.protocol + '://' + host + ':' + obj.port;
  // define href
  obj.href = obj.protocol + '://' + host + (loc && loc.port === obj.port ? '' : ':' + obj.port);

  return obj;
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = __webpack_require__(68);

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0,
      i;

  for (i in namespace) {
    hash = (hash << 5) - hash + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  return debug;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function (val, options) {
  options = options || {};
  var type = typeof val === 'undefined' ? 'undefined' : _typeof(val);
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') || plural(ms, h, 'hour') || plural(ms, m, 'minute') || plural(ms, s, 'second') || ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return;
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }
  return Math.ceil(ms / n) + ' ' + name + 's';
}

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*global Blob,File*/

/**
 * Module requirements
 */

var isArray = __webpack_require__(71);
var isBuf = __webpack_require__(31);
var toString = Object.prototype.toString;
var withNativeBlob = typeof global.Blob === 'function' || toString.call(global.Blob) === '[object BlobConstructor]';
var withNativeFile = typeof global.File === 'function' || toString.call(global.File) === '[object FileConstructor]';

/**
 * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
 * Anything with blobs or files should be fed through removeBlobs before coming
 * here.
 *
 * @param {Object} packet - socket.io event packet
 * @return {Object} with deconstructed packet and list of buffers
 * @api public
 */

exports.deconstructPacket = function (packet) {
  var buffers = [];
  var packetData = packet.data;
  var pack = packet;
  pack.data = _deconstructPacket(packetData, buffers);
  pack.attachments = buffers.length; // number of binary 'attachments'
  return { packet: pack, buffers: buffers };
};

function _deconstructPacket(data, buffers) {
  if (!data) return data;

  if (isBuf(data)) {
    var placeholder = { _placeholder: true, num: buffers.length };
    buffers.push(data);
    return placeholder;
  } else if (isArray(data)) {
    var newData = new Array(data.length);
    for (var i = 0; i < data.length; i++) {
      newData[i] = _deconstructPacket(data[i], buffers);
    }
    return newData;
  } else if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object' && !(data instanceof Date)) {
    var newData = {};
    for (var key in data) {
      newData[key] = _deconstructPacket(data[key], buffers);
    }
    return newData;
  }
  return data;
}

/**
 * Reconstructs a binary packet from its placeholder packet and buffers
 *
 * @param {Object} packet - event packet with placeholders
 * @param {Array} buffers - binary buffers to put in placeholder positions
 * @return {Object} reconstructed packet
 * @api public
 */

exports.reconstructPacket = function (packet, buffers) {
  packet.data = _reconstructPacket(packet.data, buffers);
  packet.attachments = undefined; // no longer useful
  return packet;
};

function _reconstructPacket(data, buffers) {
  if (!data) return data;

  if (data && data._placeholder) {
    return buffers[data.num]; // appropriate buffer (should be natural order anyway)
  } else if (isArray(data)) {
    for (var i = 0; i < data.length; i++) {
      data[i] = _reconstructPacket(data[i], buffers);
    }
  } else if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object') {
    for (var key in data) {
      data[key] = _reconstructPacket(data[key], buffers);
    }
  }

  return data;
}

/**
 * Asynchronously removes Blobs or Files from data via
 * FileReader's readAsArrayBuffer method. Used before encoding
 * data as msgpack. Calls callback with the blobless data.
 *
 * @param {Object} data
 * @param {Function} callback
 * @api private
 */

exports.removeBlobs = function (data, callback) {
  function _removeBlobs(obj, curKey, containingObject) {
    if (!obj) return obj;

    // convert any blob
    if (withNativeBlob && obj instanceof Blob || withNativeFile && obj instanceof File) {
      pendingBlobs++;

      // async filereader
      var fileReader = new FileReader();
      fileReader.onload = function () {
        // this.result == arraybuffer
        if (containingObject) {
          containingObject[curKey] = this.result;
        } else {
          bloblessData = this.result;
        }

        // if nothing pending its callback time
        if (! --pendingBlobs) {
          callback(bloblessData);
        }
      };

      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer
    } else if (isArray(obj)) {
      // handle array
      for (var i = 0; i < obj.length; i++) {
        _removeBlobs(obj[i], i, obj);
      }
    } else if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && !isBuf(obj)) {
      // and object
      for (var key in obj) {
        _removeBlobs(obj[key], key, obj);
      }
    }
  }

  var pendingBlobs = 0;
  var bloblessData = data;
  _removeBlobs(bloblessData);
  if (!pendingBlobs) {
    callback(bloblessData);
  }
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(73);

/**
 * Exports parser
 *
 * @api public
 *
 */
module.exports.parser = __webpack_require__(8);

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * Module dependencies.
 */

var transports = __webpack_require__(33);
var Emitter = __webpack_require__(7);
var debug = __webpack_require__(2)('engine.io-client:socket');
var index = __webpack_require__(37);
var parser = __webpack_require__(8);
var parseuri = __webpack_require__(29);
var parseqs = __webpack_require__(11);

/**
 * Module exports.
 */

module.exports = Socket;

/**
 * Socket constructor.
 *
 * @param {String|Object} uri or options
 * @param {Object} options
 * @api public
 */

function Socket(uri, opts) {
  if (!(this instanceof Socket)) return new Socket(uri, opts);

  opts = opts || {};

  if (uri && 'object' === (typeof uri === 'undefined' ? 'undefined' : _typeof(uri))) {
    opts = uri;
    uri = null;
  }

  if (uri) {
    uri = parseuri(uri);
    opts.hostname = uri.host;
    opts.secure = uri.protocol === 'https' || uri.protocol === 'wss';
    opts.port = uri.port;
    if (uri.query) opts.query = uri.query;
  } else if (opts.host) {
    opts.hostname = parseuri(opts.host).host;
  }

  this.secure = null != opts.secure ? opts.secure : global.location && 'https:' === location.protocol;

  if (opts.hostname && !opts.port) {
    // if no port is specified manually, use the protocol default
    opts.port = this.secure ? '443' : '80';
  }

  this.agent = opts.agent || false;
  this.hostname = opts.hostname || (global.location ? location.hostname : 'localhost');
  this.port = opts.port || (global.location && location.port ? location.port : this.secure ? 443 : 80);
  this.query = opts.query || {};
  if ('string' === typeof this.query) this.query = parseqs.decode(this.query);
  this.upgrade = false !== opts.upgrade;
  this.path = (opts.path || '/engine.io').replace(/\/$/, '') + '/';
  this.forceJSONP = !!opts.forceJSONP;
  this.jsonp = false !== opts.jsonp;
  this.forceBase64 = !!opts.forceBase64;
  this.enablesXDR = !!opts.enablesXDR;
  this.timestampParam = opts.timestampParam || 't';
  this.timestampRequests = opts.timestampRequests;
  this.transports = opts.transports || ['polling', 'websocket'];
  this.transportOptions = opts.transportOptions || {};
  this.readyState = '';
  this.writeBuffer = [];
  this.prevBufferLen = 0;
  this.policyPort = opts.policyPort || 843;
  this.rememberUpgrade = opts.rememberUpgrade || false;
  this.binaryType = null;
  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;
  this.perMessageDeflate = false !== opts.perMessageDeflate ? opts.perMessageDeflate || {} : false;

  if (true === this.perMessageDeflate) this.perMessageDeflate = {};
  if (this.perMessageDeflate && null == this.perMessageDeflate.threshold) {
    this.perMessageDeflate.threshold = 1024;
  }

  // SSL options for Node.js client
  this.pfx = opts.pfx || null;
  this.key = opts.key || null;
  this.passphrase = opts.passphrase || null;
  this.cert = opts.cert || null;
  this.ca = opts.ca || null;
  this.ciphers = opts.ciphers || null;
  this.rejectUnauthorized = opts.rejectUnauthorized === undefined ? true : opts.rejectUnauthorized;
  this.forceNode = !!opts.forceNode;

  // other options for Node.js client
  var freeGlobal = (typeof global === 'undefined' ? 'undefined' : _typeof(global)) === 'object' && global;
  if (freeGlobal.global === freeGlobal) {
    if (opts.extraHeaders && Object.keys(opts.extraHeaders).length > 0) {
      this.extraHeaders = opts.extraHeaders;
    }

    if (opts.localAddress) {
      this.localAddress = opts.localAddress;
    }
  }

  // set on handshake
  this.id = null;
  this.upgrades = null;
  this.pingInterval = null;
  this.pingTimeout = null;

  // set on heartbeat
  this.pingIntervalTimer = null;
  this.pingTimeoutTimer = null;

  this.open();
}

Socket.priorWebsocketSuccess = false;

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Protocol version.
 *
 * @api public
 */

Socket.protocol = parser.protocol; // this is an int

/**
 * Expose deps for legacy compatibility
 * and standalone browser access.
 */

Socket.Socket = Socket;
Socket.Transport = __webpack_require__(18);
Socket.transports = __webpack_require__(33);
Socket.parser = __webpack_require__(8);

/**
 * Creates transport of the given type.
 *
 * @param {String} transport name
 * @return {Transport}
 * @api private
 */

Socket.prototype.createTransport = function (name) {
  debug('creating transport "%s"', name);
  var query = clone(this.query);

  // append engine.io protocol identifier
  query.EIO = parser.protocol;

  // transport name
  query.transport = name;

  // per-transport options
  var options = this.transportOptions[name] || {};

  // session id if we already have one
  if (this.id) query.sid = this.id;

  var transport = new transports[name]({
    query: query,
    socket: this,
    agent: options.agent || this.agent,
    hostname: options.hostname || this.hostname,
    port: options.port || this.port,
    secure: options.secure || this.secure,
    path: options.path || this.path,
    forceJSONP: options.forceJSONP || this.forceJSONP,
    jsonp: options.jsonp || this.jsonp,
    forceBase64: options.forceBase64 || this.forceBase64,
    enablesXDR: options.enablesXDR || this.enablesXDR,
    timestampRequests: options.timestampRequests || this.timestampRequests,
    timestampParam: options.timestampParam || this.timestampParam,
    policyPort: options.policyPort || this.policyPort,
    pfx: options.pfx || this.pfx,
    key: options.key || this.key,
    passphrase: options.passphrase || this.passphrase,
    cert: options.cert || this.cert,
    ca: options.ca || this.ca,
    ciphers: options.ciphers || this.ciphers,
    rejectUnauthorized: options.rejectUnauthorized || this.rejectUnauthorized,
    perMessageDeflate: options.perMessageDeflate || this.perMessageDeflate,
    extraHeaders: options.extraHeaders || this.extraHeaders,
    forceNode: options.forceNode || this.forceNode,
    localAddress: options.localAddress || this.localAddress,
    requestTimeout: options.requestTimeout || this.requestTimeout,
    protocols: options.protocols || void 0
  });

  return transport;
};

function clone(obj) {
  var o = {};
  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      o[i] = obj[i];
    }
  }
  return o;
}

/**
 * Initializes transport to use and starts probe.
 *
 * @api private
 */
Socket.prototype.open = function () {
  var transport;
  if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') !== -1) {
    transport = 'websocket';
  } else if (0 === this.transports.length) {
    // Emit error on next tick so it can be listened to
    var self = this;
    setTimeout(function () {
      self.emit('error', 'No transports available');
    }, 0);
    return;
  } else {
    transport = this.transports[0];
  }
  this.readyState = 'opening';

  // Retry with the next transport if the transport is disabled (jsonp: false)
  try {
    transport = this.createTransport(transport);
  } catch (e) {
    this.transports.shift();
    this.open();
    return;
  }

  transport.open();
  this.setTransport(transport);
};

/**
 * Sets the current transport. Disables the existing one (if any).
 *
 * @api private
 */

Socket.prototype.setTransport = function (transport) {
  debug('setting transport %s', transport.name);
  var self = this;

  if (this.transport) {
    debug('clearing existing transport %s', this.transport.name);
    this.transport.removeAllListeners();
  }

  // set up transport
  this.transport = transport;

  // set up transport listeners
  transport.on('drain', function () {
    self.onDrain();
  }).on('packet', function (packet) {
    self.onPacket(packet);
  }).on('error', function (e) {
    self.onError(e);
  }).on('close', function () {
    self.onClose('transport close');
  });
};

/**
 * Probes a transport.
 *
 * @param {String} transport name
 * @api private
 */

Socket.prototype.probe = function (name) {
  debug('probing transport "%s"', name);
  var transport = this.createTransport(name, { probe: 1 });
  var failed = false;
  var self = this;

  Socket.priorWebsocketSuccess = false;

  function onTransportOpen() {
    if (self.onlyBinaryUpgrades) {
      var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;
      failed = failed || upgradeLosesBinary;
    }
    if (failed) return;

    debug('probe transport "%s" opened', name);
    transport.send([{ type: 'ping', data: 'probe' }]);
    transport.once('packet', function (msg) {
      if (failed) return;
      if ('pong' === msg.type && 'probe' === msg.data) {
        debug('probe transport "%s" pong', name);
        self.upgrading = true;
        self.emit('upgrading', transport);
        if (!transport) return;
        Socket.priorWebsocketSuccess = 'websocket' === transport.name;

        debug('pausing current transport "%s"', self.transport.name);
        self.transport.pause(function () {
          if (failed) return;
          if ('closed' === self.readyState) return;
          debug('changing transport and sending upgrade packet');

          cleanup();

          self.setTransport(transport);
          transport.send([{ type: 'upgrade' }]);
          self.emit('upgrade', transport);
          transport = null;
          self.upgrading = false;
          self.flush();
        });
      } else {
        debug('probe transport "%s" failed', name);
        var err = new Error('probe error');
        err.transport = transport.name;
        self.emit('upgradeError', err);
      }
    });
  }

  function freezeTransport() {
    if (failed) return;

    // Any callback called by transport should be ignored since now
    failed = true;

    cleanup();

    transport.close();
    transport = null;
  }

  // Handle any error that happens while probing
  function onerror(err) {
    var error = new Error('probe error: ' + err);
    error.transport = transport.name;

    freezeTransport();

    debug('probe transport "%s" failed because of error: %s', name, err);

    self.emit('upgradeError', error);
  }

  function onTransportClose() {
    onerror('transport closed');
  }

  // When the socket is closed while we're probing
  function onclose() {
    onerror('socket closed');
  }

  // When the socket is upgraded while we're probing
  function onupgrade(to) {
    if (transport && to.name !== transport.name) {
      debug('"%s" works - aborting "%s"', to.name, transport.name);
      freezeTransport();
    }
  }

  // Remove all listeners on the transport and on self
  function cleanup() {
    transport.removeListener('open', onTransportOpen);
    transport.removeListener('error', onerror);
    transport.removeListener('close', onTransportClose);
    self.removeListener('close', onclose);
    self.removeListener('upgrading', onupgrade);
  }

  transport.once('open', onTransportOpen);
  transport.once('error', onerror);
  transport.once('close', onTransportClose);

  this.once('close', onclose);
  this.once('upgrading', onupgrade);

  transport.open();
};

/**
 * Called when connection is deemed open.
 *
 * @api public
 */

Socket.prototype.onOpen = function () {
  debug('socket open');
  this.readyState = 'open';
  Socket.priorWebsocketSuccess = 'websocket' === this.transport.name;
  this.emit('open');
  this.flush();

  // we check for `readyState` in case an `open`
  // listener already closed the socket
  if ('open' === this.readyState && this.upgrade && this.transport.pause) {
    debug('starting upgrade probes');
    for (var i = 0, l = this.upgrades.length; i < l; i++) {
      this.probe(this.upgrades[i]);
    }
  }
};

/**
 * Handles a packet.
 *
 * @api private
 */

Socket.prototype.onPacket = function (packet) {
  if ('opening' === this.readyState || 'open' === this.readyState || 'closing' === this.readyState) {
    debug('socket receive: type "%s", data "%s"', packet.type, packet.data);

    this.emit('packet', packet);

    // Socket is live - any packet counts
    this.emit('heartbeat');

    switch (packet.type) {
      case 'open':
        this.onHandshake(JSON.parse(packet.data));
        break;

      case 'pong':
        this.setPing();
        this.emit('pong');
        break;

      case 'error':
        var err = new Error('server error');
        err.code = packet.data;
        this.onError(err);
        break;

      case 'message':
        this.emit('data', packet.data);
        this.emit('message', packet.data);
        break;
    }
  } else {
    debug('packet received with socket readyState "%s"', this.readyState);
  }
};

/**
 * Called upon handshake completion.
 *
 * @param {Object} handshake obj
 * @api private
 */

Socket.prototype.onHandshake = function (data) {
  this.emit('handshake', data);
  this.id = data.sid;
  this.transport.query.sid = data.sid;
  this.upgrades = this.filterUpgrades(data.upgrades);
  this.pingInterval = data.pingInterval;
  this.pingTimeout = data.pingTimeout;
  this.onOpen();
  // In case open handler closes socket
  if ('closed' === this.readyState) return;
  this.setPing();

  // Prolong liveness of socket on heartbeat
  this.removeListener('heartbeat', this.onHeartbeat);
  this.on('heartbeat', this.onHeartbeat);
};

/**
 * Resets ping timeout.
 *
 * @api private
 */

Socket.prototype.onHeartbeat = function (timeout) {
  clearTimeout(this.pingTimeoutTimer);
  var self = this;
  self.pingTimeoutTimer = setTimeout(function () {
    if ('closed' === self.readyState) return;
    self.onClose('ping timeout');
  }, timeout || self.pingInterval + self.pingTimeout);
};

/**
 * Pings server every `this.pingInterval` and expects response
 * within `this.pingTimeout` or closes connection.
 *
 * @api private
 */

Socket.prototype.setPing = function () {
  var self = this;
  clearTimeout(self.pingIntervalTimer);
  self.pingIntervalTimer = setTimeout(function () {
    debug('writing ping packet - expecting pong within %sms', self.pingTimeout);
    self.ping();
    self.onHeartbeat(self.pingTimeout);
  }, self.pingInterval);
};

/**
* Sends a ping packet.
*
* @api private
*/

Socket.prototype.ping = function () {
  var self = this;
  this.sendPacket('ping', function () {
    self.emit('ping');
  });
};

/**
 * Called on `drain` event
 *
 * @api private
 */

Socket.prototype.onDrain = function () {
  this.writeBuffer.splice(0, this.prevBufferLen);

  // setting prevBufferLen = 0 is very important
  // for example, when upgrading, upgrade packet is sent over,
  // and a nonzero prevBufferLen could cause problems on `drain`
  this.prevBufferLen = 0;

  if (0 === this.writeBuffer.length) {
    this.emit('drain');
  } else {
    this.flush();
  }
};

/**
 * Flush write buffers.
 *
 * @api private
 */

Socket.prototype.flush = function () {
  if ('closed' !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
    debug('flushing %d packets in socket', this.writeBuffer.length);
    this.transport.send(this.writeBuffer);
    // keep track of current length of writeBuffer
    // splice writeBuffer and callbackBuffer on `drain`
    this.prevBufferLen = this.writeBuffer.length;
    this.emit('flush');
  }
};

/**
 * Sends a message.
 *
 * @param {String} message.
 * @param {Function} callback function.
 * @param {Object} options.
 * @return {Socket} for chaining.
 * @api public
 */

Socket.prototype.write = Socket.prototype.send = function (msg, options, fn) {
  this.sendPacket('message', msg, options, fn);
  return this;
};

/**
 * Sends a packet.
 *
 * @param {String} packet type.
 * @param {String} data.
 * @param {Object} options.
 * @param {Function} callback function.
 * @api private
 */

Socket.prototype.sendPacket = function (type, data, options, fn) {
  if ('function' === typeof data) {
    fn = data;
    data = undefined;
  }

  if ('function' === typeof options) {
    fn = options;
    options = null;
  }

  if ('closing' === this.readyState || 'closed' === this.readyState) {
    return;
  }

  options = options || {};
  options.compress = false !== options.compress;

  var packet = {
    type: type,
    data: data,
    options: options
  };
  this.emit('packetCreate', packet);
  this.writeBuffer.push(packet);
  if (fn) this.once('flush', fn);
  this.flush();
};

/**
 * Closes the connection.
 *
 * @api private
 */

Socket.prototype.close = function () {
  if ('opening' === this.readyState || 'open' === this.readyState) {
    this.readyState = 'closing';

    var self = this;

    if (this.writeBuffer.length) {
      this.once('drain', function () {
        if (this.upgrading) {
          waitForUpgrade();
        } else {
          close();
        }
      });
    } else if (this.upgrading) {
      waitForUpgrade();
    } else {
      close();
    }
  }

  function close() {
    self.onClose('forced close');
    debug('socket closing - telling transport to close');
    self.transport.close();
  }

  function cleanupAndClose() {
    self.removeListener('upgrade', cleanupAndClose);
    self.removeListener('upgradeError', cleanupAndClose);
    close();
  }

  function waitForUpgrade() {
    // wait for upgrade to finish since we can't send packets while pausing a transport
    self.once('upgrade', cleanupAndClose);
    self.once('upgradeError', cleanupAndClose);
  }

  return this;
};

/**
 * Called upon transport error
 *
 * @api private
 */

Socket.prototype.onError = function (err) {
  debug('socket error %j', err);
  Socket.priorWebsocketSuccess = false;
  this.emit('error', err);
  this.onClose('transport error', err);
};

/**
 * Called upon transport close.
 *
 * @api private
 */

Socket.prototype.onClose = function (reason, desc) {
  if ('opening' === this.readyState || 'open' === this.readyState || 'closing' === this.readyState) {
    debug('socket close with reason: "%s"', reason);
    var self = this;

    // clear timers
    clearTimeout(this.pingIntervalTimer);
    clearTimeout(this.pingTimeoutTimer);

    // stop event from firing again for transport
    this.transport.removeAllListeners('close');

    // ensure transport won't stay open
    this.transport.close();

    // ignore further transport communication
    this.transport.removeAllListeners();

    // set ready state
    this.readyState = 'closed';

    // clear session id
    this.id = null;

    // emit close event
    this.emit('close', reason, desc);

    // clean buffers after, so users can still
    // grab the buffers on `close` event
    self.writeBuffer = [];
    self.prevBufferLen = 0;
  }
};

/**
 * Filters upgrades, returning only those matching client transports.
 *
 * @param {Array} server upgrades
 * @api private
 *
 */

Socket.prototype.filterUpgrades = function (upgrades) {
  var filteredUpgrades = [];
  for (var i = 0, j = upgrades.length; i < j; i++) {
    if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);
  }
  return filteredUpgrades;
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Module exports.
 *
 * Logic borrowed from Modernizr:
 *
 *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
 */

try {
  module.exports = typeof XMLHttpRequest !== 'undefined' && 'withCredentials' in new XMLHttpRequest();
} catch (err) {
  // if XMLHttp support is disabled in IE then it will throw
  // when trying to create
  module.exports = false;
}

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

/**
 * Module requirements.
 */

var XMLHttpRequest = __webpack_require__(17);
var Polling = __webpack_require__(34);
var Emitter = __webpack_require__(7);
var inherit = __webpack_require__(12);
var debug = __webpack_require__(2)('engine.io-client:polling-xhr');

/**
 * Module exports.
 */

module.exports = XHR;
module.exports.Request = Request;

/**
 * Empty function
 */

function empty() {}

/**
 * XHR Polling constructor.
 *
 * @param {Object} opts
 * @api public
 */

function XHR(opts) {
  Polling.call(this, opts);
  this.requestTimeout = opts.requestTimeout;
  this.extraHeaders = opts.extraHeaders;

  if (global.location) {
    var isSSL = 'https:' === location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    this.xd = opts.hostname !== global.location.hostname || port !== opts.port;
    this.xs = opts.secure !== isSSL;
  }
}

/**
 * Inherits from Polling.
 */

inherit(XHR, Polling);

/**
 * XHR supports binary
 */

XHR.prototype.supportsBinary = true;

/**
 * Creates a request.
 *
 * @param {String} method
 * @api private
 */

XHR.prototype.request = function (opts) {
  opts = opts || {};
  opts.uri = this.uri();
  opts.xd = this.xd;
  opts.xs = this.xs;
  opts.agent = this.agent || false;
  opts.supportsBinary = this.supportsBinary;
  opts.enablesXDR = this.enablesXDR;

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;
  opts.requestTimeout = this.requestTimeout;

  // other options for Node.js client
  opts.extraHeaders = this.extraHeaders;

  return new Request(opts);
};

/**
 * Sends data.
 *
 * @param {String} data to send.
 * @param {Function} called upon flush.
 * @api private
 */

XHR.prototype.doWrite = function (data, fn) {
  var isBinary = typeof data !== 'string' && data !== undefined;
  var req = this.request({ method: 'POST', data: data, isBinary: isBinary });
  var self = this;
  req.on('success', fn);
  req.on('error', function (err) {
    self.onError('xhr post error', err);
  });
  this.sendXhr = req;
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

XHR.prototype.doPoll = function () {
  debug('xhr poll');
  var req = this.request();
  var self = this;
  req.on('data', function (data) {
    self.onData(data);
  });
  req.on('error', function (err) {
    self.onError('xhr poll error', err);
  });
  this.pollXhr = req;
};

/**
 * Request constructor
 *
 * @param {Object} options
 * @api public
 */

function Request(opts) {
  this.method = opts.method || 'GET';
  this.uri = opts.uri;
  this.xd = !!opts.xd;
  this.xs = !!opts.xs;
  this.async = false !== opts.async;
  this.data = undefined !== opts.data ? opts.data : null;
  this.agent = opts.agent;
  this.isBinary = opts.isBinary;
  this.supportsBinary = opts.supportsBinary;
  this.enablesXDR = opts.enablesXDR;
  this.requestTimeout = opts.requestTimeout;

  // SSL options for Node.js client
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;

  // other options for Node.js client
  this.extraHeaders = opts.extraHeaders;

  this.create();
}

/**
 * Mix in `Emitter`.
 */

Emitter(Request.prototype);

/**
 * Creates the XHR object and sends the request.
 *
 * @api private
 */

Request.prototype.create = function () {
  var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;

  var xhr = this.xhr = new XMLHttpRequest(opts);
  var self = this;

  try {
    debug('xhr open %s: %s', this.method, this.uri);
    xhr.open(this.method, this.uri, this.async);
    try {
      if (this.extraHeaders) {
        xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
        for (var i in this.extraHeaders) {
          if (this.extraHeaders.hasOwnProperty(i)) {
            xhr.setRequestHeader(i, this.extraHeaders[i]);
          }
        }
      }
    } catch (e) {}

    if ('POST' === this.method) {
      try {
        if (this.isBinary) {
          xhr.setRequestHeader('Content-type', 'application/octet-stream');
        } else {
          xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
        }
      } catch (e) {}
    }

    try {
      xhr.setRequestHeader('Accept', '*/*');
    } catch (e) {}

    // ie6 check
    if ('withCredentials' in xhr) {
      xhr.withCredentials = true;
    }

    if (this.requestTimeout) {
      xhr.timeout = this.requestTimeout;
    }

    if (this.hasXDR()) {
      xhr.onload = function () {
        self.onLoad();
      };
      xhr.onerror = function () {
        self.onError(xhr.responseText);
      };
    } else {
      xhr.onreadystatechange = function () {
        if (xhr.readyState === 2) {
          var contentType;
          try {
            contentType = xhr.getResponseHeader('Content-Type');
          } catch (e) {}
          if (contentType === 'application/octet-stream') {
            xhr.responseType = 'arraybuffer';
          }
        }
        if (4 !== xhr.readyState) return;
        if (200 === xhr.status || 1223 === xhr.status) {
          self.onLoad();
        } else {
          // make sure the `error` event handler that's user-set
          // does not throw in the same tick and gets caught here
          setTimeout(function () {
            self.onError(xhr.status);
          }, 0);
        }
      };
    }

    debug('xhr data %s', this.data);
    xhr.send(this.data);
  } catch (e) {
    // Need to defer since .create() is called directly fhrom the constructor
    // and thus the 'error' event can only be only bound *after* this exception
    // occurs.  Therefore, also, we cannot throw here at all.
    setTimeout(function () {
      self.onError(e);
    }, 0);
    return;
  }

  if (global.document) {
    this.index = Request.requestsCount++;
    Request.requests[this.index] = this;
  }
};

/**
 * Called upon successful response.
 *
 * @api private
 */

Request.prototype.onSuccess = function () {
  this.emit('success');
  this.cleanup();
};

/**
 * Called if we have data.
 *
 * @api private
 */

Request.prototype.onData = function (data) {
  this.emit('data', data);
  this.onSuccess();
};

/**
 * Called upon error.
 *
 * @api private
 */

Request.prototype.onError = function (err) {
  this.emit('error', err);
  this.cleanup(true);
};

/**
 * Cleans up house.
 *
 * @api private
 */

Request.prototype.cleanup = function (fromError) {
  if ('undefined' === typeof this.xhr || null === this.xhr) {
    return;
  }
  // xmlhttprequest
  if (this.hasXDR()) {
    this.xhr.onload = this.xhr.onerror = empty;
  } else {
    this.xhr.onreadystatechange = empty;
  }

  if (fromError) {
    try {
      this.xhr.abort();
    } catch (e) {}
  }

  if (global.document) {
    delete Request.requests[this.index];
  }

  this.xhr = null;
};

/**
 * Called upon load.
 *
 * @api private
 */

Request.prototype.onLoad = function () {
  var data;
  try {
    var contentType;
    try {
      contentType = this.xhr.getResponseHeader('Content-Type');
    } catch (e) {}
    if (contentType === 'application/octet-stream') {
      data = this.xhr.response || this.xhr.responseText;
    } else {
      data = this.xhr.responseText;
    }
  } catch (e) {
    this.onError(e);
  }
  if (null != data) {
    this.onData(data);
  }
};

/**
 * Check if it has XDomainRequest.
 *
 * @api private
 */

Request.prototype.hasXDR = function () {
  return 'undefined' !== typeof global.XDomainRequest && !this.xs && this.enablesXDR;
};

/**
 * Aborts the request.
 *
 * @api public
 */

Request.prototype.abort = function () {
  this.cleanup();
};

/**
 * Aborts pending requests when unloading the window. This is needed to prevent
 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
 * emitted.
 */

Request.requestsCount = 0;
Request.requests = {};

if (global.document) {
  if (global.attachEvent) {
    global.attachEvent('onunload', unloadHandler);
  } else if (global.addEventListener) {
    global.addEventListener('beforeunload', unloadHandler, false);
  }
}

function unloadHandler() {
  for (var i in Request.requests) {
    if (Request.requests.hasOwnProperty(i)) {
      Request.requests[i].abort();
    }
  }
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Gets the keys for an object.
 *
 * @return {Array} keys
 * @api private
 */

module.exports = Object.keys || function keys(obj) {
  var arr = [];
  var has = Object.prototype.hasOwnProperty;

  for (var i in obj) {
    if (has.call(obj, i)) {
      arr.push(i);
    }
  }
  return arr;
};

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * An abstraction for slicing an arraybuffer even when
 * ArrayBuffer.prototype.slice is not supported
 *
 * @api public
 */

module.exports = function (arraybuffer, start, end) {
  var bytes = arraybuffer.byteLength;
  start = start || 0;
  end = end || bytes;

  if (arraybuffer.slice) {
    return arraybuffer.slice(start, end);
  }

  if (start < 0) {
    start += bytes;
  }
  if (end < 0) {
    end += bytes;
  }
  if (end > bytes) {
    end = bytes;
  }

  if (start >= bytes || start >= end || bytes === 0) {
    return new ArrayBuffer(0);
  }

  var abv = new Uint8Array(arraybuffer);
  var result = new Uint8Array(end - start);
  for (var i = start, ii = 0; i < end; i++, ii++) {
    result[ii] = abv[i];
  }
  return result.buffer;
};

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = after;

function after(count, callback, err_cb) {
    var bail = false;
    err_cb = err_cb || noop;
    proxy.count = count;

    return count === 0 ? callback() : proxy;

    function proxy(err, result) {
        if (proxy.count <= 0) {
            throw new Error('after called too many times');
        }
        --proxy.count;

        // after first error, rest are passed to err_cb
        if (err) {
            bail = true;
            callback(err);
            // future error callbacks will go to error handler
            callback = err_cb;
        } else if (proxy.count === 0 && !bail) {
            callback(null, result);
        }
    }
}

function noop() {}

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*! https://mths.be/utf8js v2.1.2 by @mathias */
;(function (root) {

	// Detect free variables `exports`
	var freeExports = ( false ? 'undefined' : _typeof(exports)) == 'object' && exports;

	// Detect free variable `module`
	var freeModule = ( false ? 'undefined' : _typeof(module)) == 'object' && module && module.exports == freeExports && module;

	// Detect free variable `global`, from Node.js or Browserified code,
	// and use it as `root`
	var freeGlobal = (typeof global === 'undefined' ? 'undefined' : _typeof(global)) == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
		root = freeGlobal;
	}

	/*--------------------------------------------------------------------------*/

	var stringFromCharCode = String.fromCharCode;

	// Taken from https://mths.be/punycode
	function ucs2decode(string) {
		var output = [];
		var counter = 0;
		var length = string.length;
		var value;
		var extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) {
					// low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	// Taken from https://mths.be/punycode
	function ucs2encode(array) {
		var length = array.length;
		var index = -1;
		var value;
		var output = '';
		while (++index < length) {
			value = array[index];
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
		}
		return output;
	}

	function checkScalarValue(codePoint, strict) {
		if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
			if (strict) {
				throw Error('Lone surrogate U+' + codePoint.toString(16).toUpperCase() + ' is not a scalar value');
			}
			return false;
		}
		return true;
	}
	/*--------------------------------------------------------------------------*/

	function createByte(codePoint, shift) {
		return stringFromCharCode(codePoint >> shift & 0x3F | 0x80);
	}

	function encodeCodePoint(codePoint, strict) {
		if ((codePoint & 0xFFFFFF80) == 0) {
			// 1-byte sequence
			return stringFromCharCode(codePoint);
		}
		var symbol = '';
		if ((codePoint & 0xFFFFF800) == 0) {
			// 2-byte sequence
			symbol = stringFromCharCode(codePoint >> 6 & 0x1F | 0xC0);
		} else if ((codePoint & 0xFFFF0000) == 0) {
			// 3-byte sequence
			if (!checkScalarValue(codePoint, strict)) {
				codePoint = 0xFFFD;
			}
			symbol = stringFromCharCode(codePoint >> 12 & 0x0F | 0xE0);
			symbol += createByte(codePoint, 6);
		} else if ((codePoint & 0xFFE00000) == 0) {
			// 4-byte sequence
			symbol = stringFromCharCode(codePoint >> 18 & 0x07 | 0xF0);
			symbol += createByte(codePoint, 12);
			symbol += createByte(codePoint, 6);
		}
		symbol += stringFromCharCode(codePoint & 0x3F | 0x80);
		return symbol;
	}

	function utf8encode(string, opts) {
		opts = opts || {};
		var strict = false !== opts.strict;

		var codePoints = ucs2decode(string);
		var length = codePoints.length;
		var index = -1;
		var codePoint;
		var byteString = '';
		while (++index < length) {
			codePoint = codePoints[index];
			byteString += encodeCodePoint(codePoint, strict);
		}
		return byteString;
	}

	/*--------------------------------------------------------------------------*/

	function readContinuationByte() {
		if (byteIndex >= byteCount) {
			throw Error('Invalid byte index');
		}

		var continuationByte = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		if ((continuationByte & 0xC0) == 0x80) {
			return continuationByte & 0x3F;
		}

		// If we end up here, it’s not a continuation byte
		throw Error('Invalid continuation byte');
	}

	function decodeSymbol(strict) {
		var byte1;
		var byte2;
		var byte3;
		var byte4;
		var codePoint;

		if (byteIndex > byteCount) {
			throw Error('Invalid byte index');
		}

		if (byteIndex == byteCount) {
			return false;
		}

		// Read first byte
		byte1 = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		// 1-byte sequence (no continuation bytes)
		if ((byte1 & 0x80) == 0) {
			return byte1;
		}

		// 2-byte sequence
		if ((byte1 & 0xE0) == 0xC0) {
			byte2 = readContinuationByte();
			codePoint = (byte1 & 0x1F) << 6 | byte2;
			if (codePoint >= 0x80) {
				return codePoint;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 3-byte sequence (may include unpaired surrogates)
		if ((byte1 & 0xF0) == 0xE0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			codePoint = (byte1 & 0x0F) << 12 | byte2 << 6 | byte3;
			if (codePoint >= 0x0800) {
				return checkScalarValue(codePoint, strict) ? codePoint : 0xFFFD;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 4-byte sequence
		if ((byte1 & 0xF8) == 0xF0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			byte4 = readContinuationByte();
			codePoint = (byte1 & 0x07) << 0x12 | byte2 << 0x0C | byte3 << 0x06 | byte4;
			if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
				return codePoint;
			}
		}

		throw Error('Invalid UTF-8 detected');
	}

	var byteArray;
	var byteCount;
	var byteIndex;
	function utf8decode(byteString, opts) {
		opts = opts || {};
		var strict = false !== opts.strict;

		byteArray = ucs2decode(byteString);
		byteCount = byteArray.length;
		byteIndex = 0;
		var codePoints = [];
		var tmp;
		while ((tmp = decodeSymbol(strict)) !== false) {
			codePoints.push(tmp);
		}
		return ucs2encode(codePoints);
	}

	/*--------------------------------------------------------------------------*/

	var utf8 = {
		'version': '2.1.2',
		'encode': utf8encode,
		'decode': utf8decode
	};

	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if ("function" == 'function' && _typeof(__webpack_require__(35)) == 'object' && __webpack_require__(35)) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
			return utf8;
		}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else if (freeExports && !freeExports.nodeType) {
		if (freeModule) {
			// in Node.js or RingoJS v0.8.0+
			freeModule.exports = utf8;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			var object = {};
			var hasOwnProperty = object.hasOwnProperty;
			for (var key in utf8) {
				hasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.utf8 = utf8;
	}
})(undefined);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(80)(module), __webpack_require__(0)))

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function () {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function get() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function get() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
 * base64-arraybuffer
 * https://github.com/niklasvh/base64-arraybuffer
 *
 * Copyright (c) 2012 Niklas von Hertzen
 * Licensed under the MIT license.
 */
(function () {
  "use strict";

  var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

  // Use a lookup table to find the index.
  var lookup = new Uint8Array(256);
  for (var i = 0; i < chars.length; i++) {
    lookup[chars.charCodeAt(i)] = i;
  }

  exports.encode = function (arraybuffer) {
    var bytes = new Uint8Array(arraybuffer),
        i,
        len = bytes.length,
        base64 = "";

    for (i = 0; i < len; i += 3) {
      base64 += chars[bytes[i] >> 2];
      base64 += chars[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
      base64 += chars[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
      base64 += chars[bytes[i + 2] & 63];
    }

    if (len % 3 === 2) {
      base64 = base64.substring(0, base64.length - 1) + "=";
    } else if (len % 3 === 1) {
      base64 = base64.substring(0, base64.length - 2) + "==";
    }

    return base64;
  };

  exports.decode = function (base64) {
    var bufferLength = base64.length * 0.75,
        len = base64.length,
        i,
        p = 0,
        encoded1,
        encoded2,
        encoded3,
        encoded4;

    if (base64[base64.length - 1] === "=") {
      bufferLength--;
      if (base64[base64.length - 2] === "=") {
        bufferLength--;
      }
    }

    var arraybuffer = new ArrayBuffer(bufferLength),
        bytes = new Uint8Array(arraybuffer);

    for (i = 0; i < len; i += 4) {
      encoded1 = lookup[base64.charCodeAt(i)];
      encoded2 = lookup[base64.charCodeAt(i + 1)];
      encoded3 = lookup[base64.charCodeAt(i + 2)];
      encoded4 = lookup[base64.charCodeAt(i + 3)];

      bytes[p++] = encoded1 << 2 | encoded2 >> 4;
      bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
      bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
    }

    return arraybuffer;
  };
})();

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

/**
 * Create a blob builder even when vendor prefixes exist
 */

var BlobBuilder = global.BlobBuilder || global.WebKitBlobBuilder || global.MSBlobBuilder || global.MozBlobBuilder;

/**
 * Check if Blob constructor is supported
 */

var blobSupported = function () {
  try {
    var a = new Blob(['hi']);
    return a.size === 2;
  } catch (e) {
    return false;
  }
}();

/**
 * Check if Blob constructor supports ArrayBufferViews
 * Fails in Safari 6, so we need to map to ArrayBuffers there.
 */

var blobSupportsArrayBufferView = blobSupported && function () {
  try {
    var b = new Blob([new Uint8Array([1, 2])]);
    return b.size === 2;
  } catch (e) {
    return false;
  }
}();

/**
 * Check if BlobBuilder is supported
 */

var blobBuilderSupported = BlobBuilder && BlobBuilder.prototype.append && BlobBuilder.prototype.getBlob;

/**
 * Helper function that maps ArrayBufferViews to ArrayBuffers
 * Used by BlobBuilder constructor and old browsers that didn't
 * support it in the Blob constructor.
 */

function mapArrayBufferViews(ary) {
  for (var i = 0; i < ary.length; i++) {
    var chunk = ary[i];
    if (chunk.buffer instanceof ArrayBuffer) {
      var buf = chunk.buffer;

      // if this is a subarray, make a copy so we only
      // include the subarray region from the underlying buffer
      if (chunk.byteLength !== buf.byteLength) {
        var copy = new Uint8Array(chunk.byteLength);
        copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));
        buf = copy.buffer;
      }

      ary[i] = buf;
    }
  }
}

function BlobBuilderConstructor(ary, options) {
  options = options || {};

  var bb = new BlobBuilder();
  mapArrayBufferViews(ary);

  for (var i = 0; i < ary.length; i++) {
    bb.append(ary[i]);
  }

  return options.type ? bb.getBlob(options.type) : bb.getBlob();
};

function BlobConstructor(ary, options) {
  mapArrayBufferViews(ary);
  return new Blob(ary, options || {});
};

module.exports = function () {
  if (blobSupported) {
    return blobSupportsArrayBufferView ? global.Blob : BlobConstructor;
  } else if (blobBuilderSupported) {
    return BlobBuilderConstructor;
  } else {
    return undefined;
  }
}();
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

/**
 * Module requirements.
 */

var Polling = __webpack_require__(34);
var inherit = __webpack_require__(12);

/**
 * Module exports.
 */

module.exports = JSONPPolling;

/**
 * Cached regular expressions.
 */

var rNewline = /\n/g;
var rEscapedNewline = /\\n/g;

/**
 * Global JSONP callbacks.
 */

var callbacks;

/**
 * Noop.
 */

function empty() {}

/**
 * JSONP Polling constructor.
 *
 * @param {Object} opts.
 * @api public
 */

function JSONPPolling(opts) {
  Polling.call(this, opts);

  this.query = this.query || {};

  // define global callbacks array if not present
  // we do this here (lazily) to avoid unneeded global pollution
  if (!callbacks) {
    // we need to consider multiple engines in the same page
    if (!global.___eio) global.___eio = [];
    callbacks = global.___eio;
  }

  // callback identifier
  this.index = callbacks.length;

  // add callback to jsonp global
  var self = this;
  callbacks.push(function (msg) {
    self.onData(msg);
  });

  // append to query string
  this.query.j = this.index;

  // prevent spurious errors from being emitted when the window is unloaded
  if (global.document && global.addEventListener) {
    global.addEventListener('beforeunload', function () {
      if (self.script) self.script.onerror = empty;
    }, false);
  }
}

/**
 * Inherits from Polling.
 */

inherit(JSONPPolling, Polling);

/*
 * JSONP only supports binary as base64 encoded strings
 */

JSONPPolling.prototype.supportsBinary = false;

/**
 * Closes the socket.
 *
 * @api private
 */

JSONPPolling.prototype.doClose = function () {
  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  if (this.form) {
    this.form.parentNode.removeChild(this.form);
    this.form = null;
    this.iframe = null;
  }

  Polling.prototype.doClose.call(this);
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

JSONPPolling.prototype.doPoll = function () {
  var self = this;
  var script = document.createElement('script');

  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  script.async = true;
  script.src = this.uri();
  script.onerror = function (e) {
    self.onError('jsonp poll error', e);
  };

  var insertAt = document.getElementsByTagName('script')[0];
  if (insertAt) {
    insertAt.parentNode.insertBefore(script, insertAt);
  } else {
    (document.head || document.body).appendChild(script);
  }
  this.script = script;

  var isUAgecko = 'undefined' !== typeof navigator && /gecko/i.test(navigator.userAgent);

  if (isUAgecko) {
    setTimeout(function () {
      var iframe = document.createElement('iframe');
      document.body.appendChild(iframe);
      document.body.removeChild(iframe);
    }, 100);
  }
};

/**
 * Writes with a hidden iframe.
 *
 * @param {String} data to send
 * @param {Function} called upon flush.
 * @api private
 */

JSONPPolling.prototype.doWrite = function (data, fn) {
  var self = this;

  if (!this.form) {
    var form = document.createElement('form');
    var area = document.createElement('textarea');
    var id = this.iframeId = 'eio_iframe_' + this.index;
    var iframe;

    form.className = 'socketio';
    form.style.position = 'absolute';
    form.style.top = '-1000px';
    form.style.left = '-1000px';
    form.target = id;
    form.method = 'POST';
    form.setAttribute('accept-charset', 'utf-8');
    area.name = 'd';
    form.appendChild(area);
    document.body.appendChild(form);

    this.form = form;
    this.area = area;
  }

  this.form.action = this.uri();

  function complete() {
    initIframe();
    fn();
  }

  function initIframe() {
    if (self.iframe) {
      try {
        self.form.removeChild(self.iframe);
      } catch (e) {
        self.onError('jsonp polling iframe removal error', e);
      }
    }

    try {
      // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
      var html = '<iframe src="javascript:0" name="' + self.iframeId + '">';
      iframe = document.createElement(html);
    } catch (e) {
      iframe = document.createElement('iframe');
      iframe.name = self.iframeId;
      iframe.src = 'javascript:0';
    }

    iframe.id = self.iframeId;

    self.form.appendChild(iframe);
    self.iframe = iframe;
  }

  initIframe();

  // escape \n to prevent it from being converted into \r\n by some UAs
  // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side
  data = data.replace(rEscapedNewline, '\\\n');
  this.area.value = data.replace(rNewline, '\\n');

  try {
    this.form.submit();
  } catch (e) {}

  if (this.iframe.attachEvent) {
    this.iframe.onreadystatechange = function () {
      if (self.iframe.readyState === 'complete') {
        complete();
      }
    };
  } else {
    this.iframe.onload = complete;
  }
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

/**
 * Module dependencies.
 */

var Transport = __webpack_require__(18);
var parser = __webpack_require__(8);
var parseqs = __webpack_require__(11);
var inherit = __webpack_require__(12);
var yeast = __webpack_require__(36);
var debug = __webpack_require__(2)('engine.io-client:websocket');
var BrowserWebSocket = global.WebSocket || global.MozWebSocket;
var NodeWebSocket;
if (typeof window === 'undefined') {
  try {
    NodeWebSocket = __webpack_require__(85);
  } catch (e) {}
}

/**
 * Get either the `WebSocket` or `MozWebSocket` globals
 * in the browser or try to resolve WebSocket-compatible
 * interface exposed by `ws` for Node-like environment.
 */

var WebSocket = BrowserWebSocket;
if (!WebSocket && typeof window === 'undefined') {
  WebSocket = NodeWebSocket;
}

/**
 * Module exports.
 */

module.exports = WS;

/**
 * WebSocket transport constructor.
 *
 * @api {Object} connection options
 * @api public
 */

function WS(opts) {
  var forceBase64 = opts && opts.forceBase64;
  if (forceBase64) {
    this.supportsBinary = false;
  }
  this.perMessageDeflate = opts.perMessageDeflate;
  this.usingBrowserWebSocket = BrowserWebSocket && !opts.forceNode;
  this.protocols = opts.protocols;
  if (!this.usingBrowserWebSocket) {
    WebSocket = NodeWebSocket;
  }
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(WS, Transport);

/**
 * Transport name.
 *
 * @api public
 */

WS.prototype.name = 'websocket';

/*
 * WebSockets support binary
 */

WS.prototype.supportsBinary = true;

/**
 * Opens socket.
 *
 * @api private
 */

WS.prototype.doOpen = function () {
  if (!this.check()) {
    // let probe timeout
    return;
  }

  var uri = this.uri();
  var protocols = this.protocols;
  var opts = {
    agent: this.agent,
    perMessageDeflate: this.perMessageDeflate
  };

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;
  if (this.extraHeaders) {
    opts.headers = this.extraHeaders;
  }
  if (this.localAddress) {
    opts.localAddress = this.localAddress;
  }

  try {
    this.ws = this.usingBrowserWebSocket ? protocols ? new WebSocket(uri, protocols) : new WebSocket(uri) : new WebSocket(uri, protocols, opts);
  } catch (err) {
    return this.emit('error', err);
  }

  if (this.ws.binaryType === undefined) {
    this.supportsBinary = false;
  }

  if (this.ws.supports && this.ws.supports.binary) {
    this.supportsBinary = true;
    this.ws.binaryType = 'nodebuffer';
  } else {
    this.ws.binaryType = 'arraybuffer';
  }

  this.addEventListeners();
};

/**
 * Adds event listeners to the socket
 *
 * @api private
 */

WS.prototype.addEventListeners = function () {
  var self = this;

  this.ws.onopen = function () {
    self.onOpen();
  };
  this.ws.onclose = function () {
    self.onClose();
  };
  this.ws.onmessage = function (ev) {
    self.onData(ev.data);
  };
  this.ws.onerror = function (e) {
    self.onError('websocket error', e);
  };
};

/**
 * Writes data to socket.
 *
 * @param {Array} array of packets.
 * @api private
 */

WS.prototype.write = function (packets) {
  var self = this;
  this.writable = false;

  // encodePacket efficient as it uses WS framing
  // no need for encodePayload
  var total = packets.length;
  for (var i = 0, l = total; i < l; i++) {
    (function (packet) {
      parser.encodePacket(packet, self.supportsBinary, function (data) {
        if (!self.usingBrowserWebSocket) {
          // always create a new object (GH-437)
          var opts = {};
          if (packet.options) {
            opts.compress = packet.options.compress;
          }

          if (self.perMessageDeflate) {
            var len = 'string' === typeof data ? global.Buffer.byteLength(data) : data.length;
            if (len < self.perMessageDeflate.threshold) {
              opts.compress = false;
            }
          }
        }

        // Sometimes the websocket has already been closed but the browser didn't
        // have a chance of informing us about it yet, in that case send will
        // throw an error
        try {
          if (self.usingBrowserWebSocket) {
            // TypeError is thrown when passing the second argument on Safari
            self.ws.send(data);
          } else {
            self.ws.send(data, opts);
          }
        } catch (e) {
          debug('websocket closed before onclose event');
        }

        --total || done();
      });
    })(packets[i]);
  }

  function done() {
    self.emit('flush');

    // fake drain
    // defer to next tick to allow Socket to clear writeBuffer
    setTimeout(function () {
      self.writable = true;
      self.emit('drain');
    }, 0);
  }
};

/**
 * Called upon close
 *
 * @api private
 */

WS.prototype.onClose = function () {
  Transport.prototype.onClose.call(this);
};

/**
 * Closes socket.
 *
 * @api private
 */

WS.prototype.doClose = function () {
  if (typeof this.ws !== 'undefined') {
    this.ws.close();
  }
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

WS.prototype.uri = function () {
  var query = this.query || {};
  var schema = this.secure ? 'wss' : 'ws';
  var port = '';

  // avoid port if default for schema
  if (this.port && ('wss' === schema && Number(this.port) !== 443 || 'ws' === schema && Number(this.port) !== 80)) {
    port = ':' + this.port;
  }

  // append timestamp to URI
  if (this.timestampRequests) {
    query[this.timestampParam] = yeast();
  }

  // communicate binary support capabilities
  if (!this.supportsBinary) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // prepend ? to query
  if (query.length) {
    query = '?' + query;
  }

  var ipv6 = this.hostname.indexOf(':') !== -1;
  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
};

/**
 * Feature detection for WebSocket.
 *
 * @return {Boolean} whether this transport is available.
 * @api public
 */

WS.prototype.check = function () {
  return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name);
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 85 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = toArray;

function toArray(list, index) {
    var array = [];

    index = index || 0;

    for (var i = index || 0; i < list.length; i++) {
        array[i - index] = list[i];
    }

    return array;
}

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Expose `Backoff`.
 */

module.exports = Backoff;

/**
 * Initialize backoff timer with `opts`.
 *
 * - `min` initial timeout in milliseconds [100]
 * - `max` max timeout [10000]
 * - `jitter` [0]
 * - `factor` [2]
 *
 * @param {Object} opts
 * @api public
 */

function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 10000;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}

/**
 * Return the backoff duration.
 *
 * @return {Number}
 * @api public
 */

Backoff.prototype.duration = function () {
  var ms = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand = Math.random();
    var deviation = Math.floor(rand * this.jitter * ms);
    ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;
  }
  return Math.min(ms, this.max) | 0;
};

/**
 * Reset the number of attempts.
 *
 * @api public
 */

Backoff.prototype.reset = function () {
  this.attempts = 0;
};

/**
 * Set the minimum duration
 *
 * @api public
 */

Backoff.prototype.setMin = function (min) {
  this.ms = min;
};

/**
 * Set the maximum duration
 *
 * @api public
 */

Backoff.prototype.setMax = function (max) {
  this.max = max;
};

/**
 * Set the jitter
 *
 * @api public
 */

Backoff.prototype.setJitter = function (jitter) {
  this.jitter = jitter;
};

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(89);
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {"hmr":true}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(6)(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../node_modules/css-loader/index.js!./ChatArea.css", function() {
			var newContent = require("!!../../../node_modules/css-loader/index.js!./ChatArea.css");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(5)(false);
// imports


// module
exports.push([module.i, "", ""]);

// exports


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(91);
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {"hmr":true}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(6)(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../node_modules/css-loader/index.js!./ChatLog.css", function() {
			var newContent = require("!!../../../node_modules/css-loader/index.js!./ChatLog.css");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(5)(false);
// imports


// module
exports.push([module.i, ".chatlog {\n  background-color: palegreen;\n  overflow-y: scroll;\n  height: 70vh;\n}\n", ""]);

// exports


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(93);
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {"hmr":true}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(6)(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../node_modules/css-loader/index.js!./ChatUsers.css", function() {
			var newContent = require("!!../../../node_modules/css-loader/index.js!./ChatUsers.css");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(5)(false);
// imports


// module
exports.push([module.i, ".chatusers {\n  overflow-y: scroll;\n  height: 70vh;\n}\n\n.chatusers > ul{\n  list-style: none;\n  padding-left: 0;\n  padding-top: 0;\n}\n\n.tmpmessage {\n  background-color: lightcoral;\n}", ""]);

// exports


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var MessageHolder = function () {
  function MessageHolder() {
    _classCallCheck(this, MessageHolder);
  }

  _createClass(MessageHolder, null, [{
    key: "addMessage",
    value: function addMessage(name, colorCode, body) {
      MessageHolder.list.push({
        name: name,
        colorCode: colorCode,
        body: body
      });
    }
  }, {
    key: "getMessages",
    value: function getMessages() {
      return MessageHolder.list;
    }
  }]);

  return MessageHolder;
}();

exports.default = MessageHolder;


MessageHolder.list = [];

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgNTE3ZDMxMWYyODJmMTY2MWIwNzYiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2VtcHR5RnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29tcG9uZW50LWVtaXR0ZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1wYXJzZXIvbGliL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29iamVjdC1hc3NpZ24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2VtcHR5T2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wYXJzZXFzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb21wb25lbnQtaW5oZXJpdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaW52YXJpYW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi93YXJuaW5nLmpzIiwid2VicGFjazovLy8uL3NyYy93cy9jbGllbnQvQ29ubmVjdGlvbk1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1wYXJzZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3htbGh0dHByZXF1ZXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL0V2ZW50TGlzdGVuZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2dldEFjdGl2ZUVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL3NoYWxsb3dFcXVhbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvY29udGFpbnNOb2RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9mb2N1c05vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvY2hhdC9DaGF0QXBwLmpzIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL2hlYWRlci9IZWFkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3BhcnNldXJpL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oYXMtYmluYXJ5Mi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9pcy1idWZmZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbGliL21hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvcG9sbGluZy5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vYW1kLW9wdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3llYXN0L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmRleG9mL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L2xpYi9zb2NrZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbGliL29uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb21wb25lbnQtYmluZC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZGF0YS9Vc2VyLmpzIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL2NoYXQvQ2hhdEFyZWEuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvY2hhdC9DaGF0TG9nLmpzIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL2NoYXQvQ2hhdFVzZXJzLmpzIiwid2VicGFjazovLy8uL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LnByb2R1Y3Rpb24ubWluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC9janMvcmVhY3QuZGV2ZWxvcG1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vY2pzL3JlYWN0LWRvbS5wcm9kdWN0aW9uLm1pbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaXNUZXh0Tm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaXNOb2RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vY2pzL3JlYWN0LWRvbS5kZXZlbG9wbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaHlwaGVuYXRlU3R5bGVOYW1lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9oeXBoZW5hdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2NhbWVsaXplU3R5bGVOYW1lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9jYW1lbGl6ZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguY3NzPzVkMTUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2luZGV4LmNzcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi91cmxzLmpzIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL2NoYXQvQ2hhdEFwcC5jc3M/Mjg3NiIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9jaGF0L0NoYXRBcHAuY3NzIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL2hlYWRlci9IZWFkZXIuY3NzP2Q5M2UiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvaGVhZGVyL0hlYWRlci5jc3MiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L2xpYi91cmwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9kZWJ1Zy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hhcy1iaW5hcnkyL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tcGFyc2VyL2JpbmFyeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9ub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3NvY2tldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGFzLWNvcnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvcG9sbGluZy14aHIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1wYXJzZXIvbGliL2tleXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FycmF5YnVmZmVyLnNsaWNlL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hZnRlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLXBhcnNlci9saWIvdXRmOC5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYXNlNjQtYXJyYXlidWZmZXIvbGliL2Jhc2U2NC1hcnJheWJ1ZmZlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmxvYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy9wb2xsaW5nLWpzb25wLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL3dlYnNvY2tldC5qcyIsIndlYnBhY2s6Ly8vd3MgKGlnbm9yZWQpIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90by1hcnJheS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFja28yL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL2NoYXQvQ2hhdEFyZWEuY3NzPzMxOTciLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvY2hhdC9DaGF0QXJlYS5jc3MiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvY2hhdC9DaGF0TG9nLmNzcz8xZGQwIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL2NoYXQvQ2hhdExvZy5jc3MiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvY2hhdC9DaGF0VXNlcnMuY3NzP2FmNmMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvY2hhdC9DaGF0VXNlcnMuY3NzIiwid2VicGFjazovLy8uL3NyYy9kYXRhL01lc3NhZ2VIb2xkZXIuanMiXSwibmFtZXMiOlsiZyIsIkZ1bmN0aW9uIiwiZXZhbCIsImUiLCJ3aW5kb3ciLCJtb2R1bGUiLCJleHBvcnRzIiwicHJvY2VzcyIsImNhY2hlZFNldFRpbWVvdXQiLCJjYWNoZWRDbGVhclRpbWVvdXQiLCJkZWZhdWx0U2V0VGltb3V0IiwiRXJyb3IiLCJkZWZhdWx0Q2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsImNsZWFyVGltZW91dCIsInJ1blRpbWVvdXQiLCJmdW4iLCJjYWxsIiwicnVuQ2xlYXJUaW1lb3V0IiwibWFya2VyIiwicXVldWUiLCJkcmFpbmluZyIsImN1cnJlbnRRdWV1ZSIsInF1ZXVlSW5kZXgiLCJjbGVhblVwTmV4dFRpY2siLCJsZW5ndGgiLCJjb25jYXQiLCJkcmFpblF1ZXVlIiwidGltZW91dCIsImxlbiIsInJ1biIsIm5leHRUaWNrIiwiYXJncyIsIkFycmF5IiwiYXJndW1lbnRzIiwiaSIsInB1c2giLCJJdGVtIiwiYXJyYXkiLCJwcm90b3R5cGUiLCJhcHBseSIsInRpdGxlIiwiYnJvd3NlciIsImVudiIsImFyZ3YiLCJ2ZXJzaW9uIiwidmVyc2lvbnMiLCJub29wIiwib24iLCJhZGRMaXN0ZW5lciIsIm9uY2UiLCJvZmYiLCJyZW1vdmVMaXN0ZW5lciIsInJlbW92ZUFsbExpc3RlbmVycyIsImVtaXQiLCJwcmVwZW5kTGlzdGVuZXIiLCJwcmVwZW5kT25jZUxpc3RlbmVyIiwibGlzdGVuZXJzIiwibmFtZSIsImJpbmRpbmciLCJjd2QiLCJjaGRpciIsImRpciIsInVtYXNrIiwicmVxdWlyZSIsImxvZyIsImZvcm1hdEFyZ3MiLCJzYXZlIiwibG9hZCIsInVzZUNvbG9ycyIsInN0b3JhZ2UiLCJjaHJvbWUiLCJsb2NhbCIsImxvY2Fsc3RvcmFnZSIsImNvbG9ycyIsInR5cGUiLCJkb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsInN0eWxlIiwiV2Via2l0QXBwZWFyYW5jZSIsImNvbnNvbGUiLCJmaXJlYnVnIiwiZXhjZXB0aW9uIiwidGFibGUiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJ0b0xvd2VyQ2FzZSIsIm1hdGNoIiwicGFyc2VJbnQiLCJSZWdFeHAiLCIkMSIsImZvcm1hdHRlcnMiLCJqIiwidiIsIkpTT04iLCJzdHJpbmdpZnkiLCJlcnIiLCJtZXNzYWdlIiwibmFtZXNwYWNlIiwiaHVtYW5pemUiLCJkaWZmIiwiYyIsImNvbG9yIiwic3BsaWNlIiwiaW5kZXgiLCJsYXN0QyIsInJlcGxhY2UiLCJuYW1lc3BhY2VzIiwicmVtb3ZlSXRlbSIsImRlYnVnIiwiciIsIkRFQlVHIiwiZW5hYmxlIiwibG9jYWxTdG9yYWdlIiwiTk9ERV9FTlYiLCJtYWtlRW1wdHlGdW5jdGlvbiIsImFyZyIsImVtcHR5RnVuY3Rpb24iLCJ0aGF0UmV0dXJucyIsInRoYXRSZXR1cm5zRmFsc2UiLCJ0aGF0UmV0dXJuc1RydWUiLCJ0aGF0UmV0dXJuc051bGwiLCJ0aGF0UmV0dXJuc1RoaXMiLCJ0aGF0UmV0dXJuc0FyZ3VtZW50IiwidXNlU291cmNlTWFwIiwibGlzdCIsInRvU3RyaW5nIiwibWFwIiwiaXRlbSIsImNvbnRlbnQiLCJjc3NXaXRoTWFwcGluZ1RvU3RyaW5nIiwiam9pbiIsIm1vZHVsZXMiLCJtZWRpYVF1ZXJ5IiwiYWxyZWFkeUltcG9ydGVkTW9kdWxlcyIsImlkIiwiY3NzTWFwcGluZyIsImJ0b2EiLCJzb3VyY2VNYXBwaW5nIiwidG9Db21tZW50Iiwic291cmNlVVJMcyIsInNvdXJjZXMiLCJzb3VyY2UiLCJzb3VyY2VSb290Iiwic291cmNlTWFwIiwiYmFzZTY0IiwidW5lc2NhcGUiLCJlbmNvZGVVUklDb21wb25lbnQiLCJkYXRhIiwiRW1pdHRlciIsIm9iaiIsIm1peGluIiwia2V5IiwiYWRkRXZlbnRMaXN0ZW5lciIsImV2ZW50IiwiZm4iLCJfY2FsbGJhY2tzIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImNhbGxiYWNrcyIsImNiIiwic2xpY2UiLCJoYXNMaXN0ZW5lcnMiLCJrZXlzIiwiaGFzQmluYXJ5Iiwic2xpY2VCdWZmZXIiLCJhZnRlciIsInV0ZjgiLCJiYXNlNjRlbmNvZGVyIiwiZ2xvYmFsIiwiQXJyYXlCdWZmZXIiLCJpc0FuZHJvaWQiLCJ0ZXN0IiwiaXNQaGFudG9tSlMiLCJkb250U2VuZEJsb2JzIiwicHJvdG9jb2wiLCJwYWNrZXRzIiwib3BlbiIsImNsb3NlIiwicGluZyIsInBvbmciLCJ1cGdyYWRlIiwicGFja2V0c2xpc3QiLCJCbG9iIiwiZW5jb2RlUGFja2V0IiwicGFja2V0Iiwic3VwcG9ydHNCaW5hcnkiLCJ1dGY4ZW5jb2RlIiwiY2FsbGJhY2siLCJ1bmRlZmluZWQiLCJidWZmZXIiLCJlbmNvZGVBcnJheUJ1ZmZlciIsImVuY29kZUJsb2IiLCJlbmNvZGVCYXNlNjRPYmplY3QiLCJlbmNvZGVkIiwiZW5jb2RlIiwiU3RyaW5nIiwic3RyaWN0IiwiZW5jb2RlQmFzZTY0UGFja2V0IiwiY29udGVudEFycmF5IiwiVWludDhBcnJheSIsInJlc3VsdEJ1ZmZlciIsImJ5dGVMZW5ndGgiLCJlbmNvZGVCbG9iQXNBcnJheUJ1ZmZlciIsImZyIiwiRmlsZVJlYWRlciIsIm9ubG9hZCIsInJlc3VsdCIsInJlYWRBc0FycmF5QnVmZmVyIiwiYmxvYiIsImI2NCIsInNwbGl0IiwicmVhZEFzRGF0YVVSTCIsImI2NGRhdGEiLCJmcm9tQ2hhckNvZGUiLCJ0eXBlZCIsImJhc2ljIiwiZGVjb2RlUGFja2V0IiwiYmluYXJ5VHlwZSIsInV0ZjhkZWNvZGUiLCJjaGFyQXQiLCJkZWNvZGVCYXNlNjRQYWNrZXQiLCJzdWJzdHIiLCJ0cnlEZWNvZGUiLCJOdW1iZXIiLCJzdWJzdHJpbmciLCJhc0FycmF5IiwicmVzdCIsImRlY29kZSIsIm1zZyIsImVuY29kZVBheWxvYWQiLCJpc0JpbmFyeSIsImVuY29kZVBheWxvYWRBc0Jsb2IiLCJlbmNvZGVQYXlsb2FkQXNBcnJheUJ1ZmZlciIsInNldExlbmd0aEhlYWRlciIsImVuY29kZU9uZSIsImRvbmVDYWxsYmFjayIsInJlc3VsdHMiLCJhcnkiLCJlYWNoIiwiZG9uZSIsIm5leHQiLCJlYWNoV2l0aEluZGV4IiwiZWwiLCJlcnJvciIsImRlY29kZVBheWxvYWQiLCJkZWNvZGVQYXlsb2FkQXNCaW5hcnkiLCJuIiwibCIsImNociIsInJldCIsImVuY29kZWRQYWNrZXRzIiwidG90YWxMZW5ndGgiLCJyZWR1Y2UiLCJhY2MiLCJwIiwicmVzdWx0QXJyYXkiLCJidWZmZXJJbmRleCIsImZvckVhY2giLCJpc1N0cmluZyIsImFiIiwidmlldyIsImNoYXJDb2RlQXQiLCJsZW5TdHIiLCJiaW5hcnlJZGVudGlmaWVyIiwic2l6ZSIsImxlbmd0aEFyeSIsImJ1ZmZlclRhaWwiLCJidWZmZXJzIiwidGFpbEFycmF5IiwibXNnTGVuZ3RoIiwidG90YWwiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJPYmplY3QiLCJoYXNPd25Qcm9wZXJ0eSIsInByb3BJc0VudW1lcmFibGUiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsInRvT2JqZWN0IiwidmFsIiwiVHlwZUVycm9yIiwic2hvdWxkVXNlTmF0aXZlIiwiYXNzaWduIiwidGVzdDEiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwidGVzdDIiLCJvcmRlcjIiLCJ0ZXN0MyIsImxldHRlciIsInRhcmdldCIsImZyb20iLCJ0byIsInN5bWJvbHMiLCJzIiwiZW1wdHlPYmplY3QiLCJmcmVlemUiLCJzdHIiLCJxcyIsInFyeSIsInBhaXJzIiwicGFpciIsImRlY29kZVVSSUNvbXBvbmVudCIsImEiLCJiIiwiY29uc3RydWN0b3IiLCJ2YWxpZGF0ZUZvcm1hdCIsImZvcm1hdCIsImludmFyaWFudCIsImNvbmRpdGlvbiIsImQiLCJmIiwiYXJnSW5kZXgiLCJmcmFtZXNUb1BvcCIsIndhcm5pbmciLCJwcmludFdhcm5pbmciLCJfbGVuIiwiX2tleSIsIngiLCJpbmRleE9mIiwiX2xlbjIiLCJfa2V5MiIsIkNvbm5lY3Rpb25NYW5hZ2VyIiwic29ja2V0IiwiY29ubmVjdCIsImRpc2Nvbm5lY3QiLCJoYXNCaW4iLCJiaW5hcnkiLCJpc0J1ZiIsInR5cGVzIiwiQ09OTkVDVCIsIkRJU0NPTk5FQ1QiLCJFVkVOVCIsIkFDSyIsIkVSUk9SIiwiQklOQVJZX0VWRU5UIiwiQklOQVJZX0FDSyIsIkVuY29kZXIiLCJEZWNvZGVyIiwiZW5jb2RlQXNCaW5hcnkiLCJlbmNvZGluZyIsImVuY29kZUFzU3RyaW5nIiwiYXR0YWNobWVudHMiLCJuc3AiLCJ3cml0ZUVuY29kaW5nIiwiYmxvYmxlc3NEYXRhIiwiZGVjb25zdHJ1Y3Rpb24iLCJkZWNvbnN0cnVjdFBhY2tldCIsInBhY2siLCJ1bnNoaWZ0IiwicmVtb3ZlQmxvYnMiLCJyZWNvbnN0cnVjdG9yIiwiYWRkIiwiZGVjb2RlU3RyaW5nIiwiQmluYXJ5UmVjb25zdHJ1Y3RvciIsInJlY29uUGFjayIsInRha2VCaW5hcnlEYXRhIiwiYnVmIiwidHJ5UGFyc2UiLCJwYXJzZSIsImRlc3Ryb3kiLCJmaW5pc2hlZFJlY29uc3RydWN0aW9uIiwiYmluRGF0YSIsInJlY29uc3RydWN0UGFja2V0IiwiaGFzQ09SUyIsIm9wdHMiLCJ4ZG9tYWluIiwieHNjaGVtZSIsImVuYWJsZXNYRFIiLCJYTUxIdHRwUmVxdWVzdCIsIlhEb21haW5SZXF1ZXN0IiwicGFyc2VyIiwiVHJhbnNwb3J0IiwicGF0aCIsImhvc3RuYW1lIiwicG9ydCIsInNlY3VyZSIsInF1ZXJ5IiwidGltZXN0YW1wUGFyYW0iLCJ0aW1lc3RhbXBSZXF1ZXN0cyIsInJlYWR5U3RhdGUiLCJhZ2VudCIsInBmeCIsInBhc3NwaHJhc2UiLCJjZXJ0IiwiY2EiLCJjaXBoZXJzIiwicmVqZWN0VW5hdXRob3JpemVkIiwiZm9yY2VOb2RlIiwiZXh0cmFIZWFkZXJzIiwibG9jYWxBZGRyZXNzIiwib25FcnJvciIsImRlc2MiLCJkZXNjcmlwdGlvbiIsImRvT3BlbiIsImRvQ2xvc2UiLCJvbkNsb3NlIiwic2VuZCIsIndyaXRlIiwib25PcGVuIiwid3JpdGFibGUiLCJvbkRhdGEiLCJvblBhY2tldCIsIlJlYWN0UHJvcFR5cGVzU2VjcmV0IiwibG9nZ2VkVHlwZUZhaWx1cmVzIiwiY2hlY2tQcm9wVHlwZXMiLCJ0eXBlU3BlY3MiLCJ2YWx1ZXMiLCJsb2NhdGlvbiIsImNvbXBvbmVudE5hbWUiLCJnZXRTdGFjayIsInR5cGVTcGVjTmFtZSIsImV4Iiwic3RhY2siLCJjaGVja0RDRSIsIl9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyIsImNhblVzZURPTSIsImNyZWF0ZUVsZW1lbnQiLCJFeGVjdXRpb25FbnZpcm9ubWVudCIsImNhblVzZVdvcmtlcnMiLCJXb3JrZXIiLCJjYW5Vc2VFdmVudExpc3RlbmVycyIsImF0dGFjaEV2ZW50IiwiY2FuVXNlVmlld3BvcnQiLCJzY3JlZW4iLCJpc0luV29ya2VyIiwiRXZlbnRMaXN0ZW5lciIsImxpc3RlbiIsImV2ZW50VHlwZSIsInJlbW92ZSIsImRldGFjaEV2ZW50IiwiY2FwdHVyZSIsInJlZ2lzdGVyRGVmYXVsdCIsImdldEFjdGl2ZUVsZW1lbnQiLCJkb2MiLCJhY3RpdmVFbGVtZW50IiwiYm9keSIsImlzIiwieSIsInNoYWxsb3dFcXVhbCIsIm9iakEiLCJvYmpCIiwia2V5c0EiLCJrZXlzQiIsImlzVGV4dE5vZGUiLCJjb250YWluc05vZGUiLCJvdXRlck5vZGUiLCJpbm5lck5vZGUiLCJwYXJlbnROb2RlIiwiY29udGFpbnMiLCJjb21wYXJlRG9jdW1lbnRQb3NpdGlvbiIsImZvY3VzTm9kZSIsIm5vZGUiLCJmb2N1cyIsIkNoYXRBcHAiLCJwcm9wcyIsInN0YXRlIiwiaXNKb2luIiwibWVzc2FnZXMiLCJnZXRNZXNzYWdlcyIsInVzZXJzIiwiZ2V0Q29ubmVjdGlvbiIsImVzdGFibGlzaFdTIiwic2V0U3RhdGUiLCJhZGRNZXNzYWdlIiwiY29sb3JDb2RlIiwib25Kb2luIiwib25MZWF2ZSIsIkhlYWRlciIsImxhYmVsIiwibG9naW4iLCJ1c2VybmFtZSIsInZhbHVlIiwic2V0TmFtZSIsInVwZGF0ZSIsIm9uU3RhdGVDbGljayIsInJlIiwicGFydHMiLCJwYXJzZXVyaSIsInNyYyIsIm0iLCJleGVjIiwidXJpIiwiaG9zdCIsImF1dGhvcml0eSIsImlwdjZ1cmkiLCJpc0FycmF5Iiwid2l0aE5hdGl2ZUJsb2IiLCJ3aXRoTmF0aXZlRmlsZSIsIkZpbGUiLCJCdWZmZXIiLCJpc0J1ZmZlciIsInRvSlNPTiIsImVpbyIsIlNvY2tldCIsImJpbmQiLCJCYWNrb2ZmIiwiaGFzIiwiTWFuYWdlciIsIm5zcHMiLCJzdWJzIiwicmVjb25uZWN0aW9uIiwicmVjb25uZWN0aW9uQXR0ZW1wdHMiLCJJbmZpbml0eSIsInJlY29ubmVjdGlvbkRlbGF5IiwicmVjb25uZWN0aW9uRGVsYXlNYXgiLCJyYW5kb21pemF0aW9uRmFjdG9yIiwiYmFja29mZiIsIm1pbiIsIm1heCIsImppdHRlciIsImNvbm5lY3RpbmciLCJsYXN0UGluZyIsInBhY2tldEJ1ZmZlciIsIl9wYXJzZXIiLCJlbmNvZGVyIiwiZGVjb2RlciIsImF1dG9Db25uZWN0IiwiZW1pdEFsbCIsInVwZGF0ZVNvY2tldElkcyIsImdlbmVyYXRlSWQiLCJlbmdpbmUiLCJfcmVjb25uZWN0aW9uIiwiX3JlY29ubmVjdGlvbkF0dGVtcHRzIiwiX3JlY29ubmVjdGlvbkRlbGF5Iiwic2V0TWluIiwiX3JhbmRvbWl6YXRpb25GYWN0b3IiLCJzZXRKaXR0ZXIiLCJfcmVjb25uZWN0aW9uRGVsYXlNYXgiLCJzZXRNYXgiLCJfdGltZW91dCIsIm1heWJlUmVjb25uZWN0T25PcGVuIiwicmVjb25uZWN0aW5nIiwiYXR0ZW1wdHMiLCJyZWNvbm5lY3QiLCJzZWxmIiwic2tpcFJlY29ubmVjdCIsIm9wZW5TdWIiLCJvbm9wZW4iLCJlcnJvclN1YiIsImNsZWFudXAiLCJ0aW1lciIsIm9ucGluZyIsIkRhdGUiLCJvbnBvbmciLCJvbmRhdGEiLCJvbmRlY29kZWQiLCJvbmVycm9yIiwib25Db25uZWN0aW5nIiwib3B0aW9ucyIsInByb2Nlc3NQYWNrZXRRdWV1ZSIsInNoaWZ0Iiwic3Vic0xlbmd0aCIsInN1YiIsInJlc2V0Iiwib25jbG9zZSIsInJlYXNvbiIsImRlbGF5IiwiZHVyYXRpb24iLCJvbnJlY29ubmVjdCIsImF0dGVtcHQiLCJYSFIiLCJKU09OUCIsIndlYnNvY2tldCIsInBvbGxpbmciLCJ4aHIiLCJ4ZCIsInhzIiwianNvbnAiLCJpc1NTTCIsImZvcmNlSlNPTlAiLCJwYXJzZXFzIiwiaW5oZXJpdCIsInllYXN0IiwiUG9sbGluZyIsImhhc1hIUjIiLCJyZXNwb25zZVR5cGUiLCJmb3JjZUJhc2U2NCIsInBvbGwiLCJwYXVzZSIsIm9uUGF1c2UiLCJkb1BvbGwiLCJjYWxsYmFja2ZuIiwiZG9Xcml0ZSIsInNjaGVtYSIsInNpZCIsImlwdjYiLCJhbHBoYWJldCIsInNlZWQiLCJwcmV2IiwibnVtIiwiTWF0aCIsImZsb29yIiwiZGVjb2RlZCIsIm5vdyIsImFyciIsInRvQXJyYXkiLCJldmVudHMiLCJjb25uZWN0X2Vycm9yIiwiY29ubmVjdF90aW1lb3V0IiwicmVjb25uZWN0X2F0dGVtcHQiLCJyZWNvbm5lY3RfZmFpbGVkIiwicmVjb25uZWN0X2Vycm9yIiwiaW8iLCJqc29uIiwiaWRzIiwiYWNrcyIsInJlY2VpdmVCdWZmZXIiLCJzZW5kQnVmZmVyIiwiY29ubmVjdGVkIiwiZGlzY29ubmVjdGVkIiwic3ViRXZlbnRzIiwiZXYiLCJjb21wcmVzcyIsImZsYWdzIiwicG9wIiwib25wYWNrZXQiLCJvbmNvbm5lY3QiLCJvbmV2ZW50Iiwib25hY2siLCJvbmRpc2Nvbm5lY3QiLCJhY2siLCJzZW50IiwiZW1pdEJ1ZmZlcmVkIiwiVXNlciIsImluZm8iLCJDaGF0QXJlYSIsIkNoYXRMb2ciLCJkaXNhYmxlZCIsInRtcG1lc3NhZ2UiLCJmaW5kRE9NTm9kZSIsInJlZnMiLCJzY3JvbGxUb3AiLCJzY3JvbGxIZWlnaHQiLCJuZXh0UHJvcHMiLCJ3aGljaCIsImdldE5hbWUiLCJvbklucHV0Iiwib25LZXlQcmVzcyIsIkNoYXRVc2VycyIsInJlbmRlciIsImdldEVsZW1lbnRCeUlkIiwicSIsIlN5bWJvbCIsInQiLCJ1IiwidyIsIml0ZXJhdG9yIiwieiIsImlzTW91bnRlZCIsImVucXVldWVGb3JjZVVwZGF0ZSIsImVucXVldWVSZXBsYWNlU3RhdGUiLCJlbnF1ZXVlU2V0U3RhdGUiLCJBIiwiY29udGV4dCIsInVwZGF0ZXIiLCJpc1JlYWN0Q29tcG9uZW50IiwiZm9yY2VVcGRhdGUiLCJCIiwiQyIsIkQiLCJpc1B1cmVSZWFjdENvbXBvbmVudCIsIkUiLCJGIiwidW5zdGFibGVfaXNBc3luY1JlYWN0Q29tcG9uZW50IiwiY2hpbGRyZW4iLCJHIiwiY3VycmVudCIsIkgiLCJJIiwicmVmIiwiX19zZWxmIiwiX19zb3VyY2UiLCJKIiwiayIsImgiLCJkZWZhdWx0UHJvcHMiLCIkJHR5cGVvZiIsIl9vd25lciIsIksiLCJlc2NhcGUiLCJMIiwiTSIsIk4iLCJrZXlQcmVmaXgiLCJmdW5jIiwiY291bnQiLCJPIiwiUCIsIlEiLCJSIiwiUyIsIlQiLCJVIiwiQ2hpbGRyZW4iLCJvbmx5IiwiQ29tcG9uZW50IiwiUHVyZUNvbXBvbmVudCIsInVuc3RhYmxlX0FzeW5jQ29tcG9uZW50IiwiRnJhZ21lbnQiLCJjbG9uZUVsZW1lbnQiLCJjcmVhdGVGYWN0b3J5IiwiaXNWYWxpZEVsZW1lbnQiLCJfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCIsIlJlYWN0Q3VycmVudE93bmVyIiwiViIsImRlZmF1bHQiLCJXIiwiX2Fzc2lnbiIsIlJlYWN0VmVyc2lvbiIsImhhc1N5bWJvbCIsIlJFQUNUX0VMRU1FTlRfVFlQRSIsIlJFQUNUX0NBTExfVFlQRSIsIlJFQUNUX1JFVFVSTl9UWVBFIiwiUkVBQ1RfUE9SVEFMX1RZUEUiLCJSRUFDVF9GUkFHTUVOVF9UWVBFIiwiTUFZQkVfSVRFUkFUT1JfU1lNQk9MIiwiRkFVWF9JVEVSQVRPUl9TWU1CT0wiLCJnZXRJdGVyYXRvckZuIiwibWF5YmVJdGVyYWJsZSIsIm1heWJlSXRlcmF0b3IiLCJsb3dQcmlvcml0eVdhcm5pbmciLCJ3YXJuIiwibG93UHJpb3JpdHlXYXJuaW5nJDEiLCJkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnQiLCJ3YXJuTm9vcCIsInB1YmxpY0luc3RhbmNlIiwiY2FsbGVyTmFtZSIsImRpc3BsYXlOYW1lIiwid2FybmluZ0tleSIsIlJlYWN0Tm9vcFVwZGF0ZVF1ZXVlIiwiY29tcGxldGVTdGF0ZSIsInBhcnRpYWxTdGF0ZSIsImRlcHJlY2F0ZWRBUElzIiwicmVwbGFjZVN0YXRlIiwiZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nIiwibWV0aG9kTmFtZSIsImRlZmluZVByb3BlcnR5IiwiZ2V0IiwiZm5OYW1lIiwiQ29tcG9uZW50RHVtbXkiLCJwdXJlQ29tcG9uZW50UHJvdG90eXBlIiwiQXN5bmNDb21wb25lbnQiLCJhc3luY0NvbXBvbmVudFByb3RvdHlwZSIsIlJFU0VSVkVEX1BST1BTIiwic3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24iLCJzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biIsImhhc1ZhbGlkUmVmIiwiY29uZmlnIiwiZ2V0dGVyIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiaXNSZWFjdFdhcm5pbmciLCJoYXNWYWxpZEtleSIsImRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyIiwid2FybkFib3V0QWNjZXNzaW5nS2V5IiwiY29uZmlndXJhYmxlIiwiZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIiLCJ3YXJuQWJvdXRBY2Nlc3NpbmdSZWYiLCJSZWFjdEVsZW1lbnQiLCJvd25lciIsImVsZW1lbnQiLCJfc3RvcmUiLCJlbnVtZXJhYmxlIiwicHJvcE5hbWUiLCJjaGlsZHJlbkxlbmd0aCIsImNoaWxkQXJyYXkiLCJjbG9uZUFuZFJlcGxhY2VLZXkiLCJvbGRFbGVtZW50IiwibmV3S2V5IiwibmV3RWxlbWVudCIsIl9zZWxmIiwiX3NvdXJjZSIsIm9iamVjdCIsIlJlYWN0RGVidWdDdXJyZW50RnJhbWUiLCJnZXRDdXJyZW50U3RhY2siLCJnZXRTdGFja0FkZGVuZHVtIiwiaW1wbCIsIlNFUEFSQVRPUiIsIlNVQlNFUEFSQVRPUiIsImVzY2FwZVJlZ2V4IiwiZXNjYXBlckxvb2t1cCIsImVzY2FwZWRTdHJpbmciLCJkaWRXYXJuQWJvdXRNYXBzIiwidXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXgiLCJlc2NhcGVVc2VyUHJvdmlkZWRLZXkiLCJ0ZXh0IiwiUE9PTF9TSVpFIiwidHJhdmVyc2VDb250ZXh0UG9vbCIsImdldFBvb2xlZFRyYXZlcnNlQ29udGV4dCIsIm1hcFJlc3VsdCIsIm1hcEZ1bmN0aW9uIiwibWFwQ29udGV4dCIsInRyYXZlcnNlQ29udGV4dCIsInJlbGVhc2VUcmF2ZXJzZUNvbnRleHQiLCJ0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbCIsIm5hbWVTb0ZhciIsImludm9rZUNhbGxiYWNrIiwiZ2V0Q29tcG9uZW50S2V5IiwiY2hpbGQiLCJuZXh0TmFtZSIsInN1YnRyZWVDb3VudCIsIm5leHROYW1lUHJlZml4IiwiaXRlcmF0b3JGbiIsImVudHJpZXMiLCJzdGVwIiwiaWkiLCJhZGRlbmR1bSIsImNoaWxkcmVuU3RyaW5nIiwidHJhdmVyc2VBbGxDaGlsZHJlbiIsImNvbXBvbmVudCIsImZvckVhY2hTaW5nbGVDaGlsZCIsImJvb2tLZWVwaW5nIiwiZm9yRWFjaENoaWxkcmVuIiwiZm9yRWFjaEZ1bmMiLCJmb3JFYWNoQ29udGV4dCIsIm1hcFNpbmdsZUNoaWxkSW50b0NvbnRleHQiLCJjaGlsZEtleSIsIm1hcHBlZENoaWxkIiwibWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbCIsInByZWZpeCIsImVzY2FwZWRQcmVmaXgiLCJtYXBDaGlsZHJlbiIsImNvdW50Q2hpbGRyZW4iLCJvbmx5Q2hpbGQiLCJkZXNjcmliZUNvbXBvbmVudEZyYW1lIiwib3duZXJOYW1lIiwiZmlsZU5hbWUiLCJsaW5lTnVtYmVyIiwiZ2V0Q29tcG9uZW50TmFtZSIsImZpYmVyIiwiY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQiLCJwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biIsImdldERpc3BsYXlOYW1lIiwiVkFMSURfRlJBR01FTlRfUFJPUFMiLCJNYXAiLCJnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0iLCJnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bSIsImVsZW1lbnRQcm9wcyIsIm93bmVySGFzS2V5VXNlV2FybmluZyIsImdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8iLCJwYXJlbnRUeXBlIiwicGFyZW50TmFtZSIsInZhbGlkYXRlRXhwbGljaXRLZXkiLCJ2YWxpZGF0ZWQiLCJjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvIiwiY2hpbGRPd25lciIsInZhbGlkYXRlQ2hpbGRLZXlzIiwidmFsaWRhdGVQcm9wVHlwZXMiLCJjb21wb25lbnRDbGFzcyIsInByb3BUeXBlcyIsIlByb3BUeXBlcyIsImdldERlZmF1bHRQcm9wcyIsImlzUmVhY3RDbGFzc0FwcHJvdmVkIiwidmFsaWRhdGVGcmFnbWVudFByb3BzIiwiZnJhZ21lbnQiLCJfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uIiwiX2RpZEl0ZXJhdG9yRXJyb3IiLCJfaXRlcmF0b3JFcnJvciIsIl9pdGVyYXRvciIsIl9zdGVwIiwiY3JlYXRlRWxlbWVudFdpdGhWYWxpZGF0aW9uIiwidmFsaWRUeXBlIiwic291cmNlSW5mbyIsImNyZWF0ZUZhY3RvcnlXaXRoVmFsaWRhdGlvbiIsInZhbGlkYXRlZEZhY3RvcnkiLCJjbG9uZUVsZW1lbnRXaXRoVmFsaWRhdGlvbiIsIlJlYWN0IiwiUmVhY3RDb21wb25lbnRUcmVlSG9vayIsIlJlYWN0JDIiLCJSZWFjdCQzIiwicmVhY3QiLCJhYSIsImJhIiwiZGEiLCJlYSIsImZhIiwiaWEiLCJvYSIsImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIiwiZGVmYXVsdFZhbHVlIiwiZGVmYXVsdENoZWNrZWQiLCJpbm5lckhUTUwiLCJzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmciLCJzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmciLCJwYSIsInRhIiwiTVVTVF9VU0VfUFJPUEVSVFkiLCJIQVNfQk9PTEVBTl9WQUxVRSIsIkhBU19OVU1FUklDX1ZBTFVFIiwiSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUiLCJIQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFIiwiSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFIiwiaW5qZWN0RE9NUHJvcGVydHlDb25maWciLCJQcm9wZXJ0aWVzIiwiRE9NQXR0cmlidXRlTmFtZXNwYWNlcyIsIkRPTUF0dHJpYnV0ZU5hbWVzIiwiRE9NTXV0YXRpb25NZXRob2RzIiwidWEiLCJhdHRyaWJ1dGVOYW1lIiwiYXR0cmlidXRlTmFtZXNwYWNlIiwicHJvcGVydHlOYW1lIiwibXV0YXRpb25NZXRob2QiLCJtdXN0VXNlUHJvcGVydHkiLCJoYXNCb29sZWFuVmFsdWUiLCJoYXNOdW1lcmljVmFsdWUiLCJoYXNQb3NpdGl2ZU51bWVyaWNWYWx1ZSIsImhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWUiLCJoYXNTdHJpbmdCb29sZWFuVmFsdWUiLCJ2YSIsIndhIiwieGEiLCJ5YSIsInphIiwiQWEiLCJCYSIsIkNhIiwiRGEiLCJhbGxvd0Z1bGxTY3JlZW4iLCJhc3luYyIsImF1dG9Gb2N1cyIsImF1dG9QbGF5IiwiY2hlY2tlZCIsImNvbHMiLCJjb250ZW50RWRpdGFibGUiLCJjb250cm9scyIsImRlZmVyIiwiZG93bmxvYWQiLCJkcmFnZ2FibGUiLCJmb3JtTm9WYWxpZGF0ZSIsImhpZGRlbiIsImxvb3AiLCJtdWx0aXBsZSIsIm11dGVkIiwibm9WYWxpZGF0ZSIsInBsYXlzSW5saW5lIiwicmVhZE9ubHkiLCJyZXF1aXJlZCIsInJldmVyc2VkIiwicm93cyIsInJvd1NwYW4iLCJzY29wZWQiLCJzZWFtbGVzcyIsInNlbGVjdGVkIiwic3RhcnQiLCJzcGFuIiwic3BlbGxDaGVjayIsInRhYkluZGV4IiwiaXRlbVNjb3BlIiwiYWNjZXB0Q2hhcnNldCIsImNsYXNzTmFtZSIsImh0bWxGb3IiLCJodHRwRXF1aXYiLCJyZW1vdmVBdHRyaWJ1dGUiLCJoYXNBdHRyaWJ1dGUiLCJzZXRBdHRyaWJ1dGUiLCJ2YWxpZGl0eSIsImJhZElucHV0Iiwib3duZXJEb2N1bWVudCIsIkVhIiwieGxpbmsiLCJ4bWwiLCJHYSIsImF1dG9SZXZlcnNlIiwiZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCIsInByZXNlcnZlQWxwaGEiLCJ4bGlua0FjdHVhdGUiLCJ4bGlua0FyY3JvbGUiLCJ4bGlua0hyZWYiLCJ4bGlua1JvbGUiLCJ4bGlua1Nob3ciLCJ4bGlua1RpdGxlIiwieGxpbmtUeXBlIiwieG1sQmFzZSIsInhtbExhbmciLCJ4bWxTcGFjZSIsIkhhIiwiSWEiLCJ0b1VwcGVyQ2FzZSIsIl9jYXVnaHRFcnJvciIsIl9oYXNDYXVnaHRFcnJvciIsIl9yZXRocm93RXJyb3IiLCJfaGFzUmV0aHJvd0Vycm9yIiwiaW5qZWN0aW9uIiwiaW5qZWN0RXJyb3JVdGlscyIsImludm9rZUd1YXJkZWRDYWxsYmFjayIsIkphIiwiaW52b2tlR3VhcmRlZENhbGxiYWNrQW5kQ2F0Y2hGaXJzdEVycm9yIiwiaGFzQ2F1Z2h0RXJyb3IiLCJjbGVhckNhdWdodEVycm9yIiwicmV0aHJvd0NhdWdodEVycm9yIiwiS2EiLCJMYSIsIk1hIiwiTmEiLCJPYSIsImV4dHJhY3RFdmVudHMiLCJldmVudFR5cGVzIiwiUGEiLCJwaGFzZWRSZWdpc3RyYXRpb25OYW1lcyIsIlFhIiwicmVnaXN0cmF0aW9uTmFtZSIsIlJhIiwiU2EiLCJkZXBlbmRlbmNpZXMiLCJUYSIsIlVhIiwiVmEiLCJwbHVnaW5zIiwiZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzIiwicmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMiLCJyZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzIiwicG9zc2libGVSZWdpc3RyYXRpb25OYW1lcyIsImluamVjdEV2ZW50UGx1Z2luT3JkZXIiLCJpbmplY3RFdmVudFBsdWdpbnNCeU5hbWUiLCJXYSIsIlhhIiwiWWEiLCJaYSIsImN1cnJlbnRUYXJnZXQiLCIkYSIsImJiIiwiX2Rpc3BhdGNoTGlzdGVuZXJzIiwiX2Rpc3BhdGNoSW5zdGFuY2VzIiwiaXNQcm9wYWdhdGlvblN0b3BwZWQiLCJpc1BlcnNpc3RlbnQiLCJyZWxlYXNlIiwiZGIiLCJnYiIsImhiIiwiaWIiLCJzdGF0ZU5vZGUiLCJqYiIsImtiIiwibGIiLCJtYiIsImdldExpc3RlbmVyIiwiZW5xdWV1ZUV2ZW50cyIsInByb2Nlc3NFdmVudFF1ZXVlIiwibmIiLCJyYW5kb20iLCJvYiIsInBiIiwidGFnIiwicWIiLCJyYiIsInNiIiwicHJlY2FjaGVGaWJlck5vZGUiLCJnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZSIsImdldEluc3RhbmNlRnJvbU5vZGUiLCJnZXROb2RlRnJvbUluc3RhbmNlIiwiZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZSIsInVwZGF0ZUZpYmVyUHJvcHMiLCJ0YiIsInViIiwidmIiLCJkaXNwYXRjaENvbmZpZyIsIndiIiwiX3RhcmdldEluc3QiLCJ4YiIsInliIiwiemIiLCJBYiIsIkJiIiwiYWx0ZXJuYXRlIiwiQ2IiLCJhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzIiwiYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NraXBUYXJnZXQiLCJhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXMiLCJhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlcyIsIkRiIiwiRWIiLCJfcm9vdCIsIl9zdGFydFRleHQiLCJfZmFsbGJhY2tUZXh0IiwiRmIiLCJHYiIsIkhiIiwiSWIiLCJldmVudFBoYXNlIiwiYnViYmxlcyIsImNhbmNlbGFibGUiLCJ0aW1lU3RhbXAiLCJkZWZhdWx0UHJldmVudGVkIiwiaXNUcnVzdGVkIiwibmF0aXZlRXZlbnQiLCJJbnRlcmZhY2UiLCJpc0RlZmF1bHRQcmV2ZW50ZWQiLCJyZXR1cm5WYWx1ZSIsInByZXZlbnREZWZhdWx0Iiwic3RvcFByb3BhZ2F0aW9uIiwiY2FuY2VsQnViYmxlIiwicGVyc2lzdCIsImRlc3RydWN0b3IiLCJhdWdtZW50Q2xhc3MiLCJKYiIsIktiIiwiZXZlbnRQb29sIiwiTGIiLCJnZXRQb29sZWQiLCJNYiIsIk5iIiwiUGIiLCJWYiIsIldiIiwiZG9jdW1lbnRNb2RlIiwiWGIiLCJZYiIsIm9wZXJhIiwiWmIiLCIkYiIsImFjIiwiYmMiLCJiZWZvcmVJbnB1dCIsImJ1YmJsZWQiLCJjYXB0dXJlZCIsImNvbXBvc2l0aW9uRW5kIiwiY29tcG9zaXRpb25TdGFydCIsImNvbXBvc2l0aW9uVXBkYXRlIiwiY2MiLCJkYyIsImtleUNvZGUiLCJlYyIsImRldGFpbCIsImZjIiwiZ2MiLCJoYyIsImN0cmxLZXkiLCJhbHRLZXkiLCJtZXRhS2V5IiwiY2hhciIsImljIiwiamMiLCJrYyIsImxjIiwibWMiLCJyZXN0b3JlQ29udHJvbGxlZFN0YXRlIiwibmMiLCJpbmplY3RGaWJlckNvbnRyb2xsZWRIb3N0Q29tcG9uZW50Iiwib2MiLCJwYyIsInFjIiwiZW5xdWV1ZVN0YXRlUmVzdG9yZSIsInJlc3RvcmVTdGF0ZUlmTmVlZGVkIiwicmMiLCJzYyIsInRjIiwidWMiLCJkYXRlIiwiZGF0ZXRpbWUiLCJlbWFpbCIsIm1vbnRoIiwibnVtYmVyIiwicGFzc3dvcmQiLCJyYW5nZSIsInNlYXJjaCIsInRlbCIsInRpbWUiLCJ1cmwiLCJ3ZWVrIiwidmMiLCJub2RlTmFtZSIsIndjIiwic3JjRWxlbWVudCIsImNvcnJlc3BvbmRpbmdVc2VFbGVtZW50Iiwibm9kZVR5cGUiLCJ4YyIsImltcGxlbWVudGF0aW9uIiwiaGFzRmVhdHVyZSIsInljIiwiemMiLCJBYyIsInNldCIsImdldFZhbHVlIiwic2V0VmFsdWUiLCJzdG9wVHJhY2tpbmciLCJfdmFsdWVUcmFja2VyIiwiQmMiLCJDYyIsIkRjIiwiY2hhbmdlIiwiRWMiLCJGYyIsIkdjIiwiSGMiLCJJYyIsIkpjIiwiS2MiLCJMYyIsIk1jIiwiTmMiLCJPYyIsIlBjIiwiJGMiLCJhZCIsIl9pc0lucHV0RXZlbnRTdXBwb3J0ZWQiLCJfd3JhcHBlclN0YXRlIiwiY29udHJvbGxlZCIsImdldEF0dHJpYnV0ZSIsImJkIiwiY2QiLCJBbHQiLCJDb250cm9sIiwiTWV0YSIsIlNoaWZ0IiwiZGQiLCJnZXRNb2RpZmllclN0YXRlIiwiZWQiLCJmZCIsInNjcmVlblgiLCJzY3JlZW5ZIiwiY2xpZW50WCIsImNsaWVudFkiLCJwYWdlWCIsInBhZ2VZIiwic2hpZnRLZXkiLCJidXR0b24iLCJidXR0b25zIiwicmVsYXRlZFRhcmdldCIsImZyb21FbGVtZW50IiwidG9FbGVtZW50IiwiZ2QiLCJtb3VzZUVudGVyIiwibW91c2VMZWF2ZSIsImhkIiwiZGVmYXVsdFZpZXciLCJwYXJlbnRXaW5kb3ciLCJqZCIsImtkIiwiZWZmZWN0VGFnIiwibGQiLCJfcmVhY3RJbnRlcm5hbEZpYmVyIiwibWQiLCJuZCIsInNpYmxpbmciLCJvZCIsInBkIiwicWQiLCJyZCIsInRhcmdldEluc3QiLCJhbmNlc3RvcnMiLCJjb250YWluZXJJbmZvIiwic2QiLCJ0b3BMZXZlbFR5cGUiLCJ0ZCIsInVkIiwidmQiLCJ3ZCIsIl9lbmFibGVkIiwiX2hhbmRsZVRvcExldmVsIiwic2V0SGFuZGxlVG9wTGV2ZWwiLCJzZXRFbmFibGVkIiwiaXNFbmFibGVkIiwidHJhcEJ1YmJsZWRFdmVudCIsInRyYXBDYXB0dXJlZEV2ZW50IiwiZGlzcGF0Y2hFdmVudCIsInlkIiwiemQiLCJhbmltYXRpb25lbmQiLCJhbmltYXRpb25pdGVyYXRpb24iLCJhbmltYXRpb25zdGFydCIsInRyYW5zaXRpb25lbmQiLCJBZCIsIkJkIiwiYW5pbWF0aW9uIiwidHJhbnNpdGlvbiIsIkNkIiwiRGQiLCJ0b3BBYm9ydCIsInRvcEFuaW1hdGlvbkVuZCIsInRvcEFuaW1hdGlvbkl0ZXJhdGlvbiIsInRvcEFuaW1hdGlvblN0YXJ0IiwidG9wQmx1ciIsInRvcENhbmNlbCIsInRvcENhblBsYXkiLCJ0b3BDYW5QbGF5VGhyb3VnaCIsInRvcENoYW5nZSIsInRvcENsaWNrIiwidG9wQ2xvc2UiLCJ0b3BDb21wb3NpdGlvbkVuZCIsInRvcENvbXBvc2l0aW9uU3RhcnQiLCJ0b3BDb21wb3NpdGlvblVwZGF0ZSIsInRvcENvbnRleHRNZW51IiwidG9wQ29weSIsInRvcEN1dCIsInRvcERvdWJsZUNsaWNrIiwidG9wRHJhZyIsInRvcERyYWdFbmQiLCJ0b3BEcmFnRW50ZXIiLCJ0b3BEcmFnRXhpdCIsInRvcERyYWdMZWF2ZSIsInRvcERyYWdPdmVyIiwidG9wRHJhZ1N0YXJ0IiwidG9wRHJvcCIsInRvcER1cmF0aW9uQ2hhbmdlIiwidG9wRW1wdGllZCIsInRvcEVuY3J5cHRlZCIsInRvcEVuZGVkIiwidG9wRXJyb3IiLCJ0b3BGb2N1cyIsInRvcElucHV0IiwidG9wS2V5RG93biIsInRvcEtleVByZXNzIiwidG9wS2V5VXAiLCJ0b3BMb2FkZWREYXRhIiwidG9wTG9hZCIsInRvcExvYWRlZE1ldGFkYXRhIiwidG9wTG9hZFN0YXJ0IiwidG9wTW91c2VEb3duIiwidG9wTW91c2VNb3ZlIiwidG9wTW91c2VPdXQiLCJ0b3BNb3VzZU92ZXIiLCJ0b3BNb3VzZVVwIiwidG9wUGFzdGUiLCJ0b3BQYXVzZSIsInRvcFBsYXkiLCJ0b3BQbGF5aW5nIiwidG9wUHJvZ3Jlc3MiLCJ0b3BSYXRlQ2hhbmdlIiwidG9wU2Nyb2xsIiwidG9wU2Vla2VkIiwidG9wU2Vla2luZyIsInRvcFNlbGVjdGlvbkNoYW5nZSIsInRvcFN0YWxsZWQiLCJ0b3BTdXNwZW5kIiwidG9wVGV4dElucHV0IiwidG9wVGltZVVwZGF0ZSIsInRvcFRvZ2dsZSIsInRvcFRvdWNoQ2FuY2VsIiwidG9wVG91Y2hFbmQiLCJ0b3BUb3VjaE1vdmUiLCJ0b3BUb3VjaFN0YXJ0IiwidG9wVHJhbnNpdGlvbkVuZCIsInRvcFZvbHVtZUNoYW5nZSIsInRvcFdhaXRpbmciLCJ0b3BXaGVlbCIsIkVkIiwiRmQiLCJHZCIsIkhkIiwiSWQiLCJmaXJzdENoaWxkIiwiSmQiLCJ0ZXh0Q29udGVudCIsIm9mZnNldCIsIm5leHRTaWJsaW5nIiwiS2QiLCJMZCIsIk1kIiwic2VsZWN0IiwiTmQiLCJPZCIsIlBkIiwiUWQiLCJSZCIsInNlbGVjdGlvblN0YXJ0IiwiZW5kIiwic2VsZWN0aW9uRW5kIiwiZ2V0U2VsZWN0aW9uIiwiYW5jaG9yTm9kZSIsImFuY2hvck9mZnNldCIsImZvY3VzT2Zmc2V0IiwiU2QiLCJvblNlbGVjdCIsIlRkIiwiYW5pbWF0aW9uTmFtZSIsImVsYXBzZWRUaW1lIiwicHNldWRvRWxlbWVudCIsIlVkIiwiY2xpcGJvYXJkRGF0YSIsIlZkIiwiV2QiLCJjaGFyQ29kZSIsIlhkIiwiRXNjIiwiU3BhY2ViYXIiLCJMZWZ0IiwiVXAiLCJSaWdodCIsIkRvd24iLCJEZWwiLCJXaW4iLCJNZW51IiwiQXBwcyIsIlNjcm9sbCIsIk1velByaW50YWJsZUtleSIsIllkIiwiWmQiLCJyZXBlYXQiLCJsb2NhbGUiLCIkZCIsImRhdGFUcmFuc2ZlciIsImFlIiwidG91Y2hlcyIsInRhcmdldFRvdWNoZXMiLCJjaGFuZ2VkVG91Y2hlcyIsImJlIiwiY2UiLCJkZWx0YVgiLCJ3aGVlbERlbHRhWCIsImRlbHRhWSIsIndoZWVsRGVsdGFZIiwid2hlZWxEZWx0YSIsImRlbHRhWiIsImRlbHRhTW9kZSIsImRlIiwiZWUiLCJmZSIsIlNpbXBsZUV2ZW50UGx1Z2luIiwiRW50ZXJMZWF2ZUV2ZW50UGx1Z2luIiwiQ2hhbmdlRXZlbnRQbHVnaW4iLCJTZWxlY3RFdmVudFBsdWdpbiIsIkJlZm9yZUlucHV0RXZlbnRQbHVnaW4iLCJnZSIsImhlIiwiU2V0IiwiaWUiLCJYIiwiamUiLCJrZSIsImxlIiwibWUiLCJjb250ZXh0VHlwZXMiLCJfX3JlYWN0SW50ZXJuYWxNZW1vaXplZFVubWFza2VkQ2hpbGRDb250ZXh0IiwiX19yZWFjdEludGVybmFsTWVtb2l6ZWRNYXNrZWRDaGlsZENvbnRleHQiLCJjaGlsZENvbnRleHRUeXBlcyIsIm5lIiwib2UiLCJjdXJzb3IiLCJwZSIsImdldENoaWxkQ29udGV4dCIsInFlIiwiX19yZWFjdEludGVybmFsTWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQiLCJZIiwibWVtb2l6ZWRTdGF0ZSIsInVwZGF0ZVF1ZXVlIiwibWVtb2l6ZWRQcm9wcyIsInBlbmRpbmdQcm9wcyIsImludGVybmFsQ29udGV4dFRhZyIsImxhc3RFZmZlY3QiLCJmaXJzdEVmZmVjdCIsIm5leHRFZmZlY3QiLCJleHBpcmF0aW9uVGltZSIsInNlIiwidGUiLCJ1ZSIsInZlIiwid2UiLCJoYW5kbGVyIiwieGUiLCJ5ZSIsInBlbmRpbmdDaGlsZHJlbiIsInplIiwiQWUiLCJCZSIsIkNlIiwiaXNEaXNhYmxlZCIsInN1cHBvcnRzRmliZXIiLCJpbmplY3QiLCJvbkNvbW1pdEZpYmVyUm9vdCIsIm9uQ29tbWl0RmliZXJVbm1vdW50IiwiRGUiLCJFZSIsIkZlIiwiYmFzZVN0YXRlIiwiZmlyc3QiLCJsYXN0IiwiY2FsbGJhY2tMaXN0IiwiaGFzRm9yY2VVcGRhdGUiLCJpc0luaXRpYWxpemVkIiwiR2UiLCJIZSIsIkllIiwiSmUiLCJpc1JlcGxhY2UiLCJpc0ZvcmNlZCIsIktlIiwiTGUiLCJuZXh0Q2FsbGJhY2siLCJhZG9wdENsYXNzSW5zdGFuY2UiLCJjb25zdHJ1Y3RDbGFzc0luc3RhbmNlIiwibW91bnRDbGFzc0luc3RhbmNlIiwiY29tcG9uZW50V2lsbE1vdW50IiwiY29tcG9uZW50RGlkTW91bnQiLCJ1cGRhdGVDbGFzc0luc3RhbmNlIiwiY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyIsImNvbXBvbmVudERpZFVwZGF0ZSIsInNob3VsZENvbXBvbmVudFVwZGF0ZSIsImNvbXBvbmVudFdpbGxVcGRhdGUiLCJRZSIsIlJlIiwiU2UiLCJUZSIsIlVlIiwiVmUiLCJXZSIsIlhlIiwiWWUiLCJaZSIsIl9zdHJpbmdSZWYiLCIkZSIsImFmIiwiYmYiLCJjZiIsImRmIiwicGVuZGluZ0NvbnRleHQiLCJzaG91bGRTZXRUZXh0Q29udGVudCIsInVzZVN5bmNTY2hlZHVsaW5nIiwic2hvdWxkRGVwcmlvcml0aXplU3VidHJlZSIsInB1c2hIb3N0Q29udGV4dCIsInB1c2hIb3N0Q29udGFpbmVyIiwiZW50ZXJIeWRyYXRpb25TdGF0ZSIsInJlc2V0SHlkcmF0aW9uU3RhdGUiLCJ0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZSIsIk9iIiwiYmVnaW5Xb3JrIiwiaHlkcmF0ZSIsImJlZ2luRmFpbGVkV29yayIsImVmIiwiY3JlYXRlSW5zdGFuY2UiLCJjcmVhdGVUZXh0SW5zdGFuY2UiLCJhcHBlbmRJbml0aWFsQ2hpbGQiLCJmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbiIsInByZXBhcmVVcGRhdGUiLCJwZXJzaXN0ZW5jZSIsImdldFJvb3RIb3N0Q29udGFpbmVyIiwicG9wSG9zdENvbnRleHQiLCJnZXRIb3N0Q29udGV4dCIsInBvcEhvc3RDb250YWluZXIiLCJwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlIiwicHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2UiLCJwb3BIeWRyYXRpb25TdGF0ZSIsIm11dGF0aW9uIiwiY29tcGxldGVXb3JrIiwiZmYiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsImdldFB1YmxpY0luc3RhbmNlIiwiY29tbWl0TW91bnQiLCJjb21taXRVcGRhdGUiLCJyZXNldFRleHRDb250ZW50IiwiY29tbWl0VGV4dFVwZGF0ZSIsImFwcGVuZENoaWxkIiwiYXBwZW5kQ2hpbGRUb0NvbnRhaW5lciIsImluc2VydEJlZm9yZSIsImluc2VydEluQ29udGFpbmVyQmVmb3JlIiwicmVtb3ZlQ2hpbGQiLCJyZW1vdmVDaGlsZEZyb21Db250YWluZXIiLCJjb21taXRSZXNldFRleHRDb250ZW50IiwiY29tbWl0UGxhY2VtZW50IiwiY29tbWl0RGVsZXRpb24iLCJjb21taXRXb3JrIiwiY29tbWl0TGlmZUN5Y2xlcyIsImNvbW1pdEF0dGFjaFJlZiIsImNvbW1pdERldGFjaFJlZiIsImdmIiwiaGYiLCJnZXRDaGlsZEhvc3RDb250ZXh0IiwiZ2V0Um9vdEhvc3RDb250ZXh0IiwicmVzZXRIb3N0Q29udGFpbmVyIiwiamYiLCJoeWRyYXRpb24iLCJjYW5IeWRyYXRlSW5zdGFuY2UiLCJjYW5IeWRyYXRlVGV4dEluc3RhbmNlIiwiZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nIiwiZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGQiLCJoeWRyYXRlSW5zdGFuY2UiLCJoeWRyYXRlVGV4dEluc3RhbmNlIiwia2YiLCJRYiIsImphIiwiaXNSZWFkeUZvckNvbW1pdCIsInlnIiwiemciLCJBZyIsIk5lIiwiT2UiLCJTYyIsIkJnIiwiVGMiLCJEZyIsIkVnIiwiY29tcG9uZW50RGlkQ2F0Y2giLCJjb21wb25lbnRTdGFjayIsIlFjIiwiaGEiLCJxYSIsIkZnIiwicmciLCJHZyIsIlVjIiwicmEiLCJSYyIsImViIiwicWciLCJfZGVidWdPd25lciIsIl9kZWJ1Z1NvdXJjZSIsImVycm9yQm91bmRhcnkiLCJlcnJvckJvdW5kYXJ5Rm91bmQiLCJlcnJvckJvdW5kYXJ5TmFtZSIsIndpbGxSZXRyeSIsInN1cHByZXNzUmVhY3RFcnJvckxvZ2dpbmciLCJWYyIsImthIiwiSGciLCJSYiIsIklnIiwibmV4dFNjaGVkdWxlZFJvb3QiLCJyZW1haW5pbmdFeHBpcmF0aW9uVGltZSIsInNhIiwibGEiLCJTYiIsIm1hIiwibmEiLCJXYyIsIlBlIiwiVGIiLCJKZyIsIlhjIiwiS2ciLCJmYiIsIlljIiwiVWIiLCJaYyIsIkZhIiwiZmluaXNoZWRXb3JrIiwidGltZVJlbWFpbmluZyIsIkxnIiwiTWUiLCJzY2hlZHVsZURlZmVycmVkQ2FsbGJhY2siLCJjYW5jZWxEZWZlcnJlZENhbGxiYWNrIiwicHJlcGFyZUZvckNvbW1pdCIsIkNnIiwicmVzZXRBZnRlckNvbW1pdCIsImNvbXB1dGVBc3luY0V4cGlyYXRpb24iLCJjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyIiwic2NoZWR1bGVXb3JrIiwiYmF0Y2hlZFVwZGF0ZXMiLCJ1bmJhdGNoZWRVcGRhdGVzIiwiZmx1c2hTeW5jIiwiZGVmZXJyZWRVcGRhdGVzIiwibGYiLCJjcmVhdGVDb250YWluZXIiLCJ1cGRhdGVDb250YWluZXIiLCJnZXRQdWJsaWNSb290SW5zdGFuY2UiLCJmaW5kSG9zdEluc3RhbmNlIiwiZmluZEhvc3RJbnN0YW5jZVdpdGhOb1BvcnRhbHMiLCJpbmplY3RJbnRvRGV2VG9vbHMiLCJmaW5kRmliZXJCeUhvc3RJbnN0YW5jZSIsImZpbmRIb3N0SW5zdGFuY2VCeUZpYmVyIiwibWYiLCJuZiIsIm9mIiwicGYiLCJxZiIsInBlcmZvcm1hbmNlIiwicmYiLCJzZiIsInRmIiwicmVxdWVzdElkbGVDYWxsYmFjayIsImNhbmNlbElkbGVDYWxsYmFjayIsInVmIiwidmYiLCJ3ZiIsInhmIiwieWYiLCJ6ZiIsIkFmIiwiQmYiLCJkaWRUaW1lb3V0IiwiQ2YiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJEZiIsInBvc3RNZXNzYWdlIiwiRWYiLCJGZiIsIkdmIiwiSGYiLCJJZiIsImlzTmFOIiwiSmYiLCJzZXRBdHRyaWJ1dGVOUyIsIktmIiwiTGYiLCJpbml0aWFsVmFsdWUiLCJpbml0aWFsQ2hlY2tlZCIsIk1mIiwiTmYiLCJPZiIsInBhcnNlRmxvYXQiLCJQZiIsIlFmIiwiUmYiLCJTZiIsImRlZmF1bHRTZWxlY3RlZCIsIlRmIiwid2FzTXVsdGlwbGUiLCJVZiIsIlZmIiwiV2YiLCJYZiIsIllmIiwiaHRtbCIsIm1hdGhtbCIsInN2ZyIsIlpmIiwiJGYiLCJhZyIsImJnIiwiTVNBcHAiLCJleGVjVW5zYWZlTG9jYWxGdW5jdGlvbiIsIm5hbWVzcGFjZVVSSSIsImNnIiwibGFzdENoaWxkIiwibm9kZVZhbHVlIiwiZGciLCJhbmltYXRpb25JdGVyYXRpb25Db3VudCIsImJvcmRlckltYWdlT3V0c2V0IiwiYm9yZGVySW1hZ2VTbGljZSIsImJvcmRlckltYWdlV2lkdGgiLCJib3hGbGV4IiwiYm94RmxleEdyb3VwIiwiYm94T3JkaW5hbEdyb3VwIiwiY29sdW1uQ291bnQiLCJjb2x1bW5zIiwiZmxleCIsImZsZXhHcm93IiwiZmxleFBvc2l0aXZlIiwiZmxleFNocmluayIsImZsZXhOZWdhdGl2ZSIsImZsZXhPcmRlciIsImdyaWRSb3ciLCJncmlkUm93RW5kIiwiZ3JpZFJvd1NwYW4iLCJncmlkUm93U3RhcnQiLCJncmlkQ29sdW1uIiwiZ3JpZENvbHVtbkVuZCIsImdyaWRDb2x1bW5TcGFuIiwiZ3JpZENvbHVtblN0YXJ0IiwiZm9udFdlaWdodCIsImxpbmVDbGFtcCIsImxpbmVIZWlnaHQiLCJvcGFjaXR5Iiwib3JkZXIiLCJvcnBoYW5zIiwidGFiU2l6ZSIsIndpZG93cyIsInpJbmRleCIsInpvb20iLCJmaWxsT3BhY2l0eSIsImZsb29kT3BhY2l0eSIsInN0b3BPcGFjaXR5Iiwic3Ryb2tlRGFzaGFycmF5Iiwic3Ryb2tlRGFzaG9mZnNldCIsInN0cm9rZU1pdGVybGltaXQiLCJzdHJva2VPcGFjaXR5Iiwic3Ryb2tlV2lkdGgiLCJlZyIsImZnIiwidHJpbSIsInNldFByb3BlcnR5IiwiZ2ciLCJtZW51aXRlbSIsImFyZWEiLCJiYXNlIiwiYnIiLCJjb2wiLCJlbWJlZCIsImhyIiwiaW1nIiwiaW5wdXQiLCJrZXlnZW4iLCJsaW5rIiwibWV0YSIsInBhcmFtIiwidHJhY2siLCJ3YnIiLCJoZyIsImlnIiwiamciLCJrZyIsImxnIiwibWciLCJuZyIsImNyZWF0ZUVsZW1lbnROUyIsIm9nIiwiY3JlYXRlVGV4dE5vZGUiLCJwZyIsIl9faHRtbCIsIm9uQ2xpY2siLCJvbmNsaWNrIiwic2ciLCJ0ZyIsInVnIiwidmciLCJ3ZyIsInNldEluaXRpYWxQcm9wZXJ0aWVzIiwiZGlmZlByb3BlcnRpZXMiLCJ1cGRhdGVQcm9wZXJ0aWVzIiwiZGlmZkh5ZHJhdGVkUHJvcGVydGllcyIsImRpZmZIeWRyYXRlZFRleHQiLCJ3YXJuRm9yVW5tYXRjaGVkVGV4dCIsIndhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZUVsZW1lbnQiLCJ3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0Iiwid2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50Iiwid2FybkZvckluc2VydGVkSHlkcmF0ZWRUZXh0IiwicXVlcnlTZWxlY3RvckFsbCIsImZvcm0iLCJ4ZyIsIk1nIiwiTmciLCJPZyIsIloiLCJ0YWdOYW1lIiwicmFuZ2VDb3VudCIsImZvY3VzZWRFbGVtIiwic2VsZWN0aW9uUmFuZ2UiLCJleHRlbmQiLCJjcmVhdGVSYW5nZSIsInNldFN0YXJ0IiwicmVtb3ZlQWxsUmFuZ2VzIiwiYWRkUmFuZ2UiLCJzZXRFbmQiLCJsZWZ0Iiwic2Nyb2xsTGVmdCIsInRvcCIsImRpZE5vdE1hdGNoSHlkcmF0ZWRDb250YWluZXJUZXh0SW5zdGFuY2UiLCJkaWROb3RNYXRjaEh5ZHJhdGVkVGV4dEluc3RhbmNlIiwiZGlkTm90SHlkcmF0ZUNvbnRhaW5lckluc3RhbmNlIiwiZGlkTm90SHlkcmF0ZUluc3RhbmNlIiwiZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJJbnN0YW5jZSIsImRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVyVGV4dEluc3RhbmNlIiwiZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZSIsImRpZE5vdEZpbmRIeWRyYXRhYmxlVGV4dEluc3RhbmNlIiwiUGciLCJfcmVhY3RSb290Q29udGFpbmVyIiwiUWciLCJSZyIsInVubW91bnQiLCJTZyIsImNyZWF0ZVBvcnRhbCIsInVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyIiwidW5tb3VudENvbXBvbmVudEF0Tm9kZSIsInVuc3RhYmxlX2NyZWF0ZVBvcnRhbCIsInVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzIiwidW5zdGFibGVfZGVmZXJyZWRVcGRhdGVzIiwiRXZlbnRQbHVnaW5IdWIiLCJFdmVudFBsdWdpblJlZ2lzdHJ5IiwiRXZlbnRQcm9wYWdhdG9ycyIsIlJlYWN0Q29udHJvbGxlZENvbXBvbmVudCIsIlJlYWN0RE9NQ29tcG9uZW50VHJlZSIsIlJlYWN0RE9NRXZlbnRMaXN0ZW5lciIsImJ1bmRsZVR5cGUiLCJyZW5kZXJlclBhY2thZ2VOYW1lIiwiVGciLCJVZyIsImlzTm9kZSIsIk5vZGUiLCJoeXBoZW5hdGVTdHlsZU5hbWUiLCJjYW1lbGl6ZVN0eWxlTmFtZSIsImNoZWNrTWFzayIsImJpdG1hc2siLCJET01Qcm9wZXJ0eUluamVjdGlvbiIsImRvbVByb3BlcnR5Q29uZmlnIiwiSW5qZWN0aW9uIiwicHJvcGVydGllcyIsImxvd2VyQ2FzZWQiLCJwcm9wQ29uZmlnIiwicHJvcGVydHlJbmZvIiwiQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiIsIkFUVFJJQlVURV9OQU1FX0NIQVIiLCJST09UX0FUVFJJQlVURV9OQU1FIiwic2hvdWxkU2V0QXR0cmlidXRlIiwiaXNSZXNlcnZlZFByb3AiLCJzaG91bGRBdHRyaWJ1dGVBY2NlcHRCb29sZWFuVmFsdWUiLCJnZXRQcm9wZXJ0eUluZm8iLCJIVE1MRE9NUHJvcGVydHlDb25maWciLCJIQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUUkMSIsIk5TIiwiQVRUUlMiLCJTVkdET01Qcm9wZXJ0eUNvbmZpZyIsIkNBTUVMSVpFIiwiY2FwaXRhbGl6ZSIsInRva2VuIiwib3JpZ2luYWwiLCJyZWFjdE5hbWUiLCJSZWFjdEVycm9yVXRpbHMiLCJpbmplY3RlZEVycm9yVXRpbHMiLCJmdW5jQXJncyIsImNyZWF0ZUV2ZW50IiwiZmFrZU5vZGUiLCJpbnZva2VHdWFyZGVkQ2FsbGJhY2tEZXYiLCJkaWRFcnJvciIsImNhbGxDYWxsYmFjayIsImV2dFR5cGUiLCJkaWRTZXRFcnJvciIsImlzQ3Jvc3NPcmlnaW5FcnJvciIsImNvbG5vIiwibGluZW5vIiwiZXZ0IiwiaW5pdEV2ZW50IiwiZXZlbnRQbHVnaW5PcmRlciIsIm5hbWVzVG9QbHVnaW5zIiwicmVjb21wdXRlUGx1Z2luT3JkZXJpbmciLCJwbHVnaW5OYW1lIiwicGx1Z2luTW9kdWxlIiwicGx1Z2luSW5kZXgiLCJwdWJsaXNoZWRFdmVudHMiLCJldmVudE5hbWUiLCJwdWJsaXNoRXZlbnRGb3JQbHVnaW4iLCJwaGFzZU5hbWUiLCJwaGFzZWRSZWdpc3RyYXRpb25OYW1lIiwicHVibGlzaFJlZ2lzdHJhdGlvbk5hbWUiLCJsb3dlckNhc2VkTmFtZSIsIm9uZGJsY2xpY2siLCJpbmplY3RlZEV2ZW50UGx1Z2luT3JkZXIiLCJpbmplY3RlZE5hbWVzVG9QbHVnaW5zIiwiaXNPcmRlcmluZ0RpcnR5IiwiaW5qZWN0aW9uJDIiLCJpbmplY3RDb21wb25lbnRUcmVlIiwiSW5qZWN0ZWQiLCJ2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcyIsImRpc3BhdGNoTGlzdGVuZXJzIiwiZGlzcGF0Y2hJbnN0YW5jZXMiLCJsaXN0ZW5lcnNJc0FyciIsImxpc3RlbmVyc0xlbiIsImluc3RhbmNlc0lzQXJyIiwiaW5zdGFuY2VzTGVuIiwiZXhlY3V0ZURpc3BhdGNoIiwic2ltdWxhdGVkIiwibGlzdGVuZXIiLCJpbnN0IiwiZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyIiwiYWNjdW11bGF0ZUludG8iLCJmb3JFYWNoQWNjdW11bGF0ZWQiLCJzY29wZSIsImV2ZW50UXVldWUiLCJleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2UiLCJleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VTaW11bGF0ZWQiLCJleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VUb3BMZXZlbCIsImlzSW50ZXJhY3RpdmUiLCJzaG91bGRQcmV2ZW50TW91c2VFdmVudCIsImluamVjdGlvbiQxIiwibmF0aXZlRXZlbnRUYXJnZXQiLCJwb3NzaWJsZVBsdWdpbiIsImV4dHJhY3RlZEV2ZW50cyIsInByb2Nlc3NpbmdFdmVudFF1ZXVlIiwiSW5kZXRlcm1pbmF0ZUNvbXBvbmVudCIsIkZ1bmN0aW9uYWxDb21wb25lbnQiLCJDbGFzc0NvbXBvbmVudCIsIkhvc3RSb290IiwiSG9zdFBvcnRhbCIsIkhvc3RDb21wb25lbnQiLCJIb3N0VGV4dCIsIkNhbGxDb21wb25lbnQiLCJDYWxsSGFuZGxlclBoYXNlIiwiUmV0dXJuQ29tcG9uZW50IiwicmFuZG9tS2V5IiwiaW50ZXJuYWxJbnN0YW5jZUtleSIsImludGVybmFsRXZlbnRIYW5kbGVyc0tleSIsInByZWNhY2hlRmliZXJOb2RlJDEiLCJob3N0SW5zdCIsInBhcmVudHMiLCJjbG9zZXN0IiwiZ2V0SW5zdGFuY2VGcm9tTm9kZSQxIiwiZ2V0Tm9kZUZyb21JbnN0YW5jZSQxIiwiZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZSQxIiwidXBkYXRlRmliZXJQcm9wcyQxIiwiZ2V0UGFyZW50IiwiZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IiLCJpbnN0QSIsImluc3RCIiwiZGVwdGhBIiwidGVtcEEiLCJkZXB0aEIiLCJ0ZW1wQiIsImRlcHRoIiwiZ2V0UGFyZW50SW5zdGFuY2UiLCJ0cmF2ZXJzZVR3b1BoYXNlIiwidHJhdmVyc2VFbnRlckxlYXZlIiwiYXJnRnJvbSIsImFyZ1RvIiwiY29tbW9uIiwicGF0aEZyb20iLCJwYXRoVG8iLCJfYWx0ZXJuYXRlIiwiX2kiLCJsaXN0ZW5lckF0UGhhc2UiLCJwcm9wYWdhdGlvblBoYXNlIiwiYWNjdW11bGF0ZURpcmVjdGlvbmFsRGlzcGF0Y2hlcyIsInBoYXNlIiwiYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZSIsImFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGVTa2lwVGFyZ2V0IiwicGFyZW50SW5zdCIsImFjY3VtdWxhdGVEaXNwYXRjaGVzIiwiaWdub3JlZERpcmVjdGlvbiIsImFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzU2luZ2xlIiwibGVhdmUiLCJlbnRlciIsImNvbnRlbnRLZXkiLCJnZXRUZXh0Q29udGVudEFjY2Vzc29yIiwiY29tcG9zaXRpb25TdGF0ZSIsImluaXRpYWxpemUiLCJnZXRUZXh0IiwiZ2V0RGF0YSIsInN0YXJ0VmFsdWUiLCJzdGFydExlbmd0aCIsImVuZFZhbHVlIiwiZW5kTGVuZ3RoIiwibWluRW5kIiwic2xpY2VUYWlsIiwiZGlkV2FybkZvckFkZGVkTmV3UHJvcGVydHkiLCJpc1Byb3h5U3VwcG9ydGVkIiwiUHJveHkiLCJFVkVOVF9QT09MX1NJWkUiLCJzaG91bGRCZVJlbGVhc2VkUHJvcGVydGllcyIsIkV2ZW50SW50ZXJmYWNlIiwiU3ludGhldGljRXZlbnQiLCJub3JtYWxpemUiLCJnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uIiwiQ2xhc3MiLCJTdXBlciIsImFkZEV2ZW50UG9vbGluZ1RvIiwiY29uc3RydWN0IiwiY3JlYXRlIiwidGhhdCIsInByb3AiLCJnZXRWYWwiLCJpc0Z1bmN0aW9uIiwiYWN0aW9uIiwid2FybmluZ0NvbmRpdGlvbiIsImdldFBvb2xlZEV2ZW50IiwibmF0aXZlSW5zdCIsIkV2ZW50Q29uc3RydWN0b3IiLCJpbnN0YW5jZSIsInJlbGVhc2VQb29sZWRFdmVudCIsIlN5bnRoZXRpY0V2ZW50JDEiLCJDb21wb3NpdGlvbkV2ZW50SW50ZXJmYWNlIiwiU3ludGhldGljQ29tcG9zaXRpb25FdmVudCIsImRpc3BhdGNoTWFya2VyIiwiSW5wdXRFdmVudEludGVyZmFjZSIsIlN5bnRoZXRpY0lucHV0RXZlbnQiLCJFTkRfS0VZQ09ERVMiLCJTVEFSVF9LRVlDT0RFIiwiY2FuVXNlQ29tcG9zaXRpb25FdmVudCIsImNhblVzZVRleHRJbnB1dEV2ZW50IiwiaXNQcmVzdG8iLCJ1c2VGYWxsYmFja0NvbXBvc2l0aW9uRGF0YSIsIlNQQUNFQkFSX0NPREUiLCJTUEFDRUJBUl9DSEFSIiwiaGFzU3BhY2VLZXlwcmVzcyIsImlzS2V5cHJlc3NDb21tYW5kIiwiZ2V0Q29tcG9zaXRpb25FdmVudFR5cGUiLCJpc0ZhbGxiYWNrQ29tcG9zaXRpb25TdGFydCIsImlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZCIsImdldERhdGFGcm9tQ3VzdG9tRXZlbnQiLCJpc0NvbXBvc2luZyIsImV4dHJhY3RDb21wb3NpdGlvbkV2ZW50IiwiZmFsbGJhY2tEYXRhIiwiY3VzdG9tRGF0YSIsImdldE5hdGl2ZUJlZm9yZUlucHV0Q2hhcnMiLCJjaGFycyIsImdldEZhbGxiYWNrQmVmb3JlSW5wdXRDaGFycyIsImV4dHJhY3RCZWZvcmVJbnB1dEV2ZW50IiwiZmliZXJIb3N0Q29tcG9uZW50IiwiUmVhY3RDb250cm9sbGVkQ29tcG9uZW50SW5qZWN0aW9uIiwiaG9zdENvbXBvbmVudEltcGwiLCJyZXN0b3JlVGFyZ2V0IiwicmVzdG9yZVF1ZXVlIiwicmVzdG9yZVN0YXRlT2ZUYXJnZXQiLCJpbnRlcm5hbEluc3RhbmNlIiwiaW5qZWN0aW9uJDMiLCJxdWV1ZWRUYXJnZXRzIiwiZmliZXJCYXRjaGVkVXBkYXRlcyIsImJvb2trZWVwaW5nIiwiaXNOZXN0aW5nQmF0Y2hlZCIsIlJlYWN0R2VuZXJpY0JhdGNoaW5nSW5qZWN0aW9uIiwiaW5qZWN0RmliZXJCYXRjaGVkVXBkYXRlcyIsIl9iYXRjaGVkVXBkYXRlcyIsImluamVjdGlvbiQ0Iiwic3VwcG9ydGVkSW5wdXRUeXBlcyIsImlzVGV4dElucHV0RWxlbWVudCIsImVsZW0iLCJFTEVNRU5UX05PREUiLCJURVhUX05PREUiLCJDT01NRU5UX05PREUiLCJET0NVTUVOVF9OT0RFIiwiRE9DVU1FTlRfRlJBR01FTlRfTk9ERSIsImdldEV2ZW50VGFyZ2V0IiwidXNlSGFzRmVhdHVyZSIsImlzRXZlbnRTdXBwb3J0ZWQiLCJldmVudE5hbWVTdWZmaXgiLCJpc1N1cHBvcnRlZCIsImlzQ2hlY2thYmxlIiwiZ2V0VHJhY2tlciIsImRldGFjaFRyYWNrZXIiLCJnZXRWYWx1ZUZyb21Ob2RlIiwidHJhY2tWYWx1ZU9uTm9kZSIsInZhbHVlRmllbGQiLCJkZXNjcmlwdG9yIiwiY3VycmVudFZhbHVlIiwidHJhY2tlciIsInVwZGF0ZVZhbHVlSWZDaGFuZ2VkIiwibGFzdFZhbHVlIiwibmV4dFZhbHVlIiwiZXZlbnRUeXBlcyQxIiwiY3JlYXRlQW5kQWNjdW11bGF0ZUNoYW5nZUV2ZW50IiwiYWN0aXZlRWxlbWVudEluc3QiLCJzaG91bGRVc2VDaGFuZ2VFdmVudCIsIm1hbnVhbERpc3BhdGNoQ2hhbmdlRXZlbnQiLCJydW5FdmVudEluQmF0Y2giLCJnZXRJbnN0SWZWYWx1ZUNoYW5nZWQiLCJ0YXJnZXROb2RlIiwiZ2V0VGFyZ2V0SW5zdEZvckNoYW5nZUV2ZW50IiwiaXNJbnB1dEV2ZW50U3VwcG9ydGVkIiwic3RhcnRXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlIiwiaGFuZGxlUHJvcGVydHlDaGFuZ2UiLCJzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSIsImhhbmRsZUV2ZW50c0ZvcklucHV0RXZlbnRQb2x5ZmlsbCIsImdldFRhcmdldEluc3RGb3JJbnB1dEV2ZW50UG9seWZpbGwiLCJzaG91bGRVc2VDbGlja0V2ZW50IiwiZ2V0VGFyZ2V0SW5zdEZvckNsaWNrRXZlbnQiLCJnZXRUYXJnZXRJbnN0Rm9ySW5wdXRPckNoYW5nZUV2ZW50IiwiaGFuZGxlQ29udHJvbGxlZElucHV0Qmx1ciIsImdldFRhcmdldEluc3RGdW5jIiwiaGFuZGxlRXZlbnRGdW5jIiwiRE9NRXZlbnRQbHVnaW5PcmRlciIsIlVJRXZlbnRJbnRlcmZhY2UiLCJTeW50aGV0aWNVSUV2ZW50IiwibW9kaWZpZXJLZXlUb1Byb3AiLCJtb2RpZmllclN0YXRlR2V0dGVyIiwia2V5QXJnIiwic3ludGhldGljRXZlbnQiLCJrZXlQcm9wIiwiZ2V0RXZlbnRNb2RpZmllclN0YXRlIiwiTW91c2VFdmVudEludGVyZmFjZSIsIlN5bnRoZXRpY01vdXNlRXZlbnQiLCJldmVudFR5cGVzJDIiLCJ3aW4iLCJyZWxhdGVkIiwiZnJvbU5vZGUiLCJ0b05vZGUiLCJSZWFjdEludGVybmFscyIsIk5vRWZmZWN0IiwiUGVyZm9ybWVkV29yayIsIlBsYWNlbWVudCIsIlVwZGF0ZSIsIlBsYWNlbWVudEFuZFVwZGF0ZSIsIkRlbGV0aW9uIiwiQ29udGVudFJlc2V0IiwiQ2FsbGJhY2siLCJFcnIiLCJSZWYiLCJNT1VOVElORyIsIk1PVU5URUQiLCJVTk1PVU5URUQiLCJpc0ZpYmVyTW91bnRlZEltcGwiLCJpc0ZpYmVyTW91bnRlZCIsIm93bmVyRmliZXIiLCJfd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIiLCJhc3NlcnRJc01vdW50ZWQiLCJmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aCIsInBhcmVudEEiLCJwYXJlbnRCIiwiZGlkRmluZENoaWxkIiwiX2NoaWxkIiwiZmluZEN1cnJlbnRIb3N0RmliZXIiLCJwYXJlbnQiLCJjdXJyZW50UGFyZW50IiwiZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzIiwiQ0FMTEJBQ0tfQk9PS0tFRVBJTkdfUE9PTF9TSVpFIiwiY2FsbGJhY2tCb29ra2VlcGluZ1Bvb2wiLCJmaW5kUm9vdENvbnRhaW5lck5vZGUiLCJnZXRUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmciLCJyZWxlYXNlVG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nIiwiaGFuZGxlVG9wTGV2ZWxJbXBsIiwiYW5jZXN0b3IiLCJyb290IiwiaGFuZGxlVG9wTGV2ZWwiLCJlbmFibGVkIiwiaGFuZGxlckJhc2VOYW1lIiwibWFrZVByZWZpeE1hcCIsInN0eWxlUHJvcCIsInByZWZpeGVzIiwidmVuZG9yUHJlZml4ZXMiLCJwcmVmaXhlZEV2ZW50TmFtZXMiLCJnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSIsInByZWZpeE1hcCIsInRvcExldmVsVHlwZXMkMSIsIkJyb3dzZXJFdmVudENvbnN0YW50cyIsInRvcExldmVsVHlwZXMiLCJydW5FdmVudFF1ZXVlSW5CYXRjaCIsImFscmVhZHlMaXN0ZW5pbmdUbyIsInJlYWN0VG9wTGlzdGVuZXJzQ291bnRlciIsInRvcExpc3RlbmVyc0lES2V5IiwiZ2V0TGlzdGVuaW5nRm9yRG9jdW1lbnQiLCJtb3VudEF0IiwibGlzdGVuVG8iLCJjb250ZW50RG9jdW1lbnRIYW5kbGUiLCJpc0xpc3RlbmluZyIsImRlcGVuZGVuY3kiLCJpc0xpc3RlbmluZ1RvQWxsRGVwZW5kZW5jaWVzIiwiZ2V0TGVhZk5vZGUiLCJnZXRTaWJsaW5nTm9kZSIsImdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQiLCJub2RlU3RhcnQiLCJub2RlRW5kIiwiZ2V0T2Zmc2V0cyIsInNlbGVjdGlvbiIsImZvY3VzTm9kZSQkMSIsImdldE1vZGVybk9mZnNldHNGcm9tUG9pbnRzIiwiaW5kZXhXaXRoaW5BbmNob3IiLCJpbmRleFdpdGhpbkZvY3VzIiwib3V0ZXIiLCJzZXRPZmZzZXRzIiwib2Zmc2V0cyIsInRlbXAiLCJzdGFydE1hcmtlciIsImVuZE1hcmtlciIsImlzSW5Eb2N1bWVudCIsImhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyIsImdldFNlbGVjdGlvbkluZm9ybWF0aW9uIiwiZ2V0U2VsZWN0aW9uJDEiLCJyZXN0b3JlU2VsZWN0aW9uIiwicHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbiIsImN1ckZvY3VzZWRFbGVtIiwicHJpb3JGb2N1c2VkRWxlbSIsInByaW9yU2VsZWN0aW9uUmFuZ2UiLCJzZXRTZWxlY3Rpb24iLCJza2lwU2VsZWN0aW9uQ2hhbmdlRXZlbnQiLCJldmVudFR5cGVzJDMiLCJhY3RpdmVFbGVtZW50JDEiLCJhY3RpdmVFbGVtZW50SW5zdCQxIiwibGFzdFNlbGVjdGlvbiIsIm1vdXNlRG93biIsImNvbnN0cnVjdFNlbGVjdEV2ZW50IiwiY3VycmVudFNlbGVjdGlvbiIsIkFuaW1hdGlvbkV2ZW50SW50ZXJmYWNlIiwiU3ludGhldGljQW5pbWF0aW9uRXZlbnQiLCJDbGlwYm9hcmRFdmVudEludGVyZmFjZSIsIlN5bnRoZXRpY0NsaXBib2FyZEV2ZW50IiwiRm9jdXNFdmVudEludGVyZmFjZSIsIlN5bnRoZXRpY0ZvY3VzRXZlbnQiLCJnZXRFdmVudENoYXJDb2RlIiwibm9ybWFsaXplS2V5IiwidHJhbnNsYXRlVG9LZXkiLCJnZXRFdmVudEtleSIsIktleWJvYXJkRXZlbnRJbnRlcmZhY2UiLCJTeW50aGV0aWNLZXlib2FyZEV2ZW50IiwiRHJhZ0V2ZW50SW50ZXJmYWNlIiwiU3ludGhldGljRHJhZ0V2ZW50IiwiVG91Y2hFdmVudEludGVyZmFjZSIsIlN5bnRoZXRpY1RvdWNoRXZlbnQiLCJUcmFuc2l0aW9uRXZlbnRJbnRlcmZhY2UiLCJTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQiLCJXaGVlbEV2ZW50SW50ZXJmYWNlIiwiU3ludGhldGljV2hlZWxFdmVudCIsImV2ZW50VHlwZXMkNCIsInRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZyIsImNhcGl0YWxpemVkRXZlbnQiLCJvbkV2ZW50IiwidG9wRXZlbnQiLCJrbm93bkhUTUxUb3BMZXZlbFR5cGVzIiwiZW5hYmxlQXN5bmNTdWJ0cmVlQVBJIiwiZW5hYmxlQXN5bmNTY2hlZHVsaW5nQnlEZWZhdWx0SW5SZWFjdERPTSIsImVuYWJsZUNyZWF0ZVJvb3QiLCJlbmFibGVVc2VyVGltaW5nQVBJIiwiZW5hYmxlTXV0YXRpbmdSZWNvbmNpbGVyIiwiZW5hYmxlTm9vcFJlY29uY2lsZXIiLCJlbmFibGVQZXJzaXN0ZW50UmVjb25jaWxlciIsImRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0cyIsInZhbHVlU3RhY2siLCJmaWJlclN0YWNrIiwiY3JlYXRlQ3Vyc29yIiwicmVzZXQkMSIsImRlc2NyaWJlRmliZXIiLCJnZXRTdGFja0FkZGVuZHVtQnlXb3JrSW5Qcm9ncmVzc0ZpYmVyIiwid29ya0luUHJvZ3Jlc3MiLCJnZXRDdXJyZW50RmliZXJPd25lck5hbWUiLCJSZWFjdERlYnVnQ3VycmVudEZpYmVyIiwiZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSIsInJlc2V0Q3VycmVudEZpYmVyIiwic2V0Q3VycmVudEZpYmVyIiwic2V0Q3VycmVudFBoYXNlIiwicmVhY3RFbW9qaSIsIndhcm5pbmdFbW9qaSIsInN1cHBvcnRzVXNlclRpbWluZyIsIm1hcmsiLCJjbGVhck1hcmtzIiwibWVhc3VyZSIsImNsZWFyTWVhc3VyZXMiLCJjdXJyZW50RmliZXIiLCJjdXJyZW50UGhhc2UiLCJjdXJyZW50UGhhc2VGaWJlciIsImlzQ29tbWl0dGluZyIsImhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudENvbW1pdCIsImhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudFBoYXNlIiwiY29tbWl0Q291bnRJbkN1cnJlbnRXb3JrTG9vcCIsImVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0IiwiaXNXYWl0aW5nRm9yQ2FsbGJhY2siLCJsYWJlbHNJbkN1cnJlbnRDb21taXQiLCJmb3JtYXRNYXJrTmFtZSIsIm1hcmtOYW1lIiwiZm9ybWF0TGFiZWwiLCJ3YXJuaW5nJCQxIiwic3VmZml4IiwiYmVnaW5NYXJrIiwiY2xlYXJNYXJrIiwiZW5kTWFyayIsImZvcm1hdHRlZE1hcmtOYW1lIiwiZm9ybWF0dGVkTGFiZWwiLCJnZXRGaWJlck1hcmtOYW1lIiwiZGVidWdJRCIsImdldEZpYmVyTGFiZWwiLCJiZWdpbkZpYmVyTWFyayIsIl9kZWJ1Z0lEIiwiY2xlYXJGaWJlck1hcmsiLCJlbmRGaWJlck1hcmsiLCJzaG91bGRJZ25vcmVGaWJlciIsImNsZWFyUGVuZGluZ1BoYXNlTWVhc3VyZW1lbnQiLCJwYXVzZVRpbWVycyIsIl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nIiwicmVzdW1lVGltZXJzUmVjdXJzaXZlbHkiLCJyZXN1bWVUaW1lcnMiLCJyZWNvcmRFZmZlY3QiLCJyZWNvcmRTY2hlZHVsZVVwZGF0ZSIsInN0YXJ0UmVxdWVzdENhbGxiYWNrVGltZXIiLCJzdG9wUmVxdWVzdENhbGxiYWNrVGltZXIiLCJkaWRFeHBpcmUiLCJzdGFydFdvcmtUaW1lciIsImNhbmNlbFdvcmtUaW1lciIsInN0b3BXb3JrVGltZXIiLCJzdG9wRmFpbGVkV29ya1RpbWVyIiwic3RhcnRQaGFzZVRpbWVyIiwic3RvcFBoYXNlVGltZXIiLCJzdGFydFdvcmtMb29wVGltZXIiLCJuZXh0VW5pdE9mV29yayIsInN0b3BXb3JrTG9vcFRpbWVyIiwiaW50ZXJydXB0ZWRCeSIsInN0YXJ0Q29tbWl0VGltZXIiLCJjbGVhciIsInN0b3BDb21taXRUaW1lciIsInN0YXJ0Q29tbWl0SG9zdEVmZmVjdHNUaW1lciIsInN0b3BDb21taXRIb3N0RWZmZWN0c1RpbWVyIiwic3RhcnRDb21taXRMaWZlQ3ljbGVzVGltZXIiLCJzdG9wQ29tbWl0TGlmZUN5Y2xlc1RpbWVyIiwid2FybmVkQWJvdXRNaXNzaW5nR2V0Q2hpbGRDb250ZXh0IiwiY29udGV4dFN0YWNrQ3Vyc29yIiwiZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciIsInByZXZpb3VzQ29udGV4dCIsImdldFVubWFza2VkQ29udGV4dCIsImhhc093bkNvbnRleHQiLCJpc0NvbnRleHRQcm92aWRlciIsImNhY2hlQ29udGV4dCIsInVubWFza2VkQ29udGV4dCIsIm1hc2tlZENvbnRleHQiLCJnZXRNYXNrZWRDb250ZXh0IiwiaGFzQ29udGV4dENoYW5nZWQiLCJpc0NvbnRleHRDb25zdW1lciIsInBvcENvbnRleHRQcm92aWRlciIsInBvcFRvcExldmVsQ29udGV4dE9iamVjdCIsInB1c2hUb3BMZXZlbENvbnRleHRPYmplY3QiLCJkaWRDaGFuZ2UiLCJwcm9jZXNzQ2hpbGRDb250ZXh0IiwicGFyZW50Q29udGV4dCIsImNoaWxkQ29udGV4dCIsImNvbnRleHRLZXkiLCJwdXNoQ29udGV4dFByb3ZpZGVyIiwibWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQiLCJpbnZhbGlkYXRlQ29udGV4dFByb3ZpZGVyIiwibWVyZ2VkQ29udGV4dCIsInJlc2V0Q29udGV4dCIsImZpbmRDdXJyZW50VW5tYXNrZWRDb250ZXh0IiwiTm9Xb3JrIiwiU3luYyIsIk5ldmVyIiwiVU5JVF9TSVpFIiwiTUFHSUNfTlVNQkVSX09GRlNFVCIsIm1zVG9FeHBpcmF0aW9uVGltZSIsIm1zIiwiZXhwaXJhdGlvblRpbWVUb01zIiwiY2VpbGluZyIsInByZWNpc2lvbiIsImNvbXB1dGVFeHBpcmF0aW9uQnVja2V0IiwiY3VycmVudFRpbWUiLCJleHBpcmF0aW9uSW5NcyIsImJ1Y2tldFNpemVNcyIsIk5vQ29udGV4dCIsIkFzeW5jVXBkYXRlcyIsImhhc0JhZE1hcFBvbHlmaWxsIiwibm9uRXh0ZW5zaWJsZU9iamVjdCIsInByZXZlbnRFeHRlbnNpb25zIiwiZGVidWdDb3VudGVyIiwiRmliZXJOb2RlIiwiY3JlYXRlRmliZXIiLCJzaG91bGRDb25zdHJ1Y3QiLCJjcmVhdGVXb3JrSW5Qcm9ncmVzcyIsImNyZWF0ZUhvc3RSb290RmliZXIiLCJjcmVhdGVGaWJlckZyb21FbGVtZW50IiwiY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQiLCJlbGVtZW50cyIsImNyZWF0ZUZpYmVyRnJvbVRleHQiLCJjcmVhdGVGaWJlckZyb21Ib3N0SW5zdGFuY2VGb3JEZWxldGlvbiIsImNyZWF0ZUZpYmVyRnJvbUNhbGwiLCJjcmVhdGVGaWJlckZyb21SZXR1cm4iLCJyZXR1cm5Ob2RlIiwiY3JlYXRlRmliZXJGcm9tUG9ydGFsIiwicG9ydGFsIiwiY3JlYXRlRmliZXJSb290IiwidW5pbml0aWFsaXplZEZpYmVyIiwiaGFzTG9nZ2VkRXJyb3IiLCJjYXRjaEVycm9ycyIsImluamVjdEludGVybmFscyIsImludGVybmFscyIsImhvb2siLCJyZW5kZXJlcklEIiwib25Db21taXRSb290Iiwib25Db21taXRVbm1vdW50IiwiZGlkV2FyblVwZGF0ZUluc2lkZVVwZGF0ZSIsImNyZWF0ZVVwZGF0ZVF1ZXVlIiwiaXNQcm9jZXNzaW5nIiwiaW5zZXJ0VXBkYXRlSW50b1F1ZXVlIiwiaW5zZXJ0VXBkYXRlSW50b0ZpYmVyIiwiYWx0ZXJuYXRlRmliZXIiLCJxdWV1ZTEiLCJxdWV1ZTIiLCJnZXRVcGRhdGVFeHBpcmF0aW9uVGltZSIsImdldFN0YXRlRnJvbVVwZGF0ZSIsInByZXZTdGF0ZSIsInVwZGF0ZUZuIiwicHJvY2Vzc1VwZGF0ZVF1ZXVlIiwicmVuZGVyRXhwaXJhdGlvblRpbWUiLCJkb250TXV0YXRlUHJldlN0YXRlIiwiZGlkU2tpcCIsInVwZGF0ZUV4cGlyYXRpb25UaW1lIiwiX3BhcnRpYWxTdGF0ZSIsIl9jYWxsYmFja0xpc3QiLCJjb21taXRDYWxsYmFja3MiLCJfY2FsbGJhY2siLCJmYWtlSW50ZXJuYWxJbnN0YW5jZSIsImRpZFdhcm5BYm91dFN0YXRlQXNzaWdubWVudEZvckNvbXBvbmVudCIsIndhcm5PbkludmFsaWRDYWxsYmFjayIsIlJlYWN0RmliZXJDbGFzc0NvbXBvbmVudCIsIm1lbW9pemVQcm9wcyIsIm1lbW9pemVTdGF0ZSIsImNoZWNrU2hvdWxkQ29tcG9uZW50VXBkYXRlIiwib2xkUHJvcHMiLCJuZXdQcm9wcyIsIm9sZFN0YXRlIiwibmV3U3RhdGUiLCJuZXdDb250ZXh0Iiwic2hvdWxkVXBkYXRlIiwiY2hlY2tDbGFzc0luc3RhbmNlIiwicmVuZGVyUHJlc2VudCIsIm5vR2V0SW5pdGlhbFN0YXRlT25FUzYiLCJnZXRJbml0aWFsU3RhdGUiLCJub0dldERlZmF1bHRQcm9wc09uRVM2Iiwibm9JbnN0YW5jZVByb3BUeXBlcyIsIm5vSW5zdGFuY2VDb250ZXh0VHlwZXMiLCJub0NvbXBvbmVudFNob3VsZFVwZGF0ZSIsImNvbXBvbmVudFNob3VsZFVwZGF0ZSIsIm5vQ29tcG9uZW50RGlkVW5tb3VudCIsImNvbXBvbmVudERpZFVubW91bnQiLCJub0NvbXBvbmVudERpZFJlY2VpdmVQcm9wcyIsImNvbXBvbmVudERpZFJlY2VpdmVQcm9wcyIsIm5vQ29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyIsImNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMiLCJoYXNNdXRhdGVkUHJvcHMiLCJub0luc3RhbmNlRGVmYXVsdFByb3BzIiwicmVzZXRJbnB1dFBvaW50ZXJzIiwiX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSIsImN0b3IiLCJuZWVkc0NvbnRleHQiLCJjYWxsQ29tcG9uZW50V2lsbE1vdW50IiwiY2FsbENvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMiLCJvbGRDb250ZXh0IiwibmV3VW5tYXNrZWRDb250ZXh0IiwiZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQxIiwib3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nIiwid2FybkZvck1pc3NpbmdLZXkiLCJpc0FycmF5JDEiLCJjb2VyY2VSZWYiLCJtaXhlZFJlZiIsInN0cmluZ1JlZiIsInRocm93T25JbnZhbGlkT2JqZWN0VHlwZSIsInJldHVybkZpYmVyIiwibmV3Q2hpbGQiLCJ3YXJuT25GdW5jdGlvblR5cGUiLCJDaGlsZFJlY29uY2lsZXIiLCJzaG91bGRUcmFja1NpZGVFZmZlY3RzIiwiZGVsZXRlQ2hpbGQiLCJjaGlsZFRvRGVsZXRlIiwiZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4iLCJjdXJyZW50Rmlyc3RDaGlsZCIsIm1hcFJlbWFpbmluZ0NoaWxkcmVuIiwiZXhpc3RpbmdDaGlsZHJlbiIsImV4aXN0aW5nQ2hpbGQiLCJ1c2VGaWJlciIsImNsb25lIiwicGxhY2VDaGlsZCIsIm5ld0ZpYmVyIiwibGFzdFBsYWNlZEluZGV4IiwibmV3SW5kZXgiLCJvbGRJbmRleCIsInBsYWNlU2luZ2xlQ2hpbGQiLCJ1cGRhdGVUZXh0Tm9kZSIsImNyZWF0ZWQiLCJleGlzdGluZyIsInVwZGF0ZUVsZW1lbnQiLCJ1cGRhdGVDYWxsIiwidXBkYXRlUmV0dXJuIiwidXBkYXRlUG9ydGFsIiwidXBkYXRlRnJhZ21lbnQiLCJjcmVhdGVDaGlsZCIsIl9jcmVhdGVkIiwiX2NyZWF0ZWQyIiwiX2NyZWF0ZWQzIiwiX2NyZWF0ZWQ0IiwiX2NyZWF0ZWQ1IiwiX2NyZWF0ZWQ2IiwidXBkYXRlU2xvdCIsIm9sZEZpYmVyIiwidXBkYXRlRnJvbU1hcCIsIm5ld0lkeCIsIm1hdGNoZWRGaWJlciIsIl9tYXRjaGVkRmliZXIiLCJfbWF0Y2hlZEZpYmVyMiIsIl9tYXRjaGVkRmliZXIzIiwiX21hdGNoZWRGaWJlcjQiLCJfbWF0Y2hlZEZpYmVyNSIsIndhcm5PbkludmFsaWRLZXkiLCJrbm93bktleXMiLCJyZWNvbmNpbGVDaGlsZHJlbkFycmF5IiwibmV3Q2hpbGRyZW4iLCJyZXN1bHRpbmdGaXJzdENoaWxkIiwicHJldmlvdXNOZXdGaWJlciIsIm5leHRPbGRGaWJlciIsIl9uZXdGaWJlciIsIl9uZXdGaWJlcjIiLCJyZWNvbmNpbGVDaGlsZHJlbkl0ZXJhdG9yIiwibmV3Q2hpbGRyZW5JdGVyYWJsZSIsInBvc3NpYmxlTWFwIiwiX25ld0NoaWxkcmVuIiwiX25ld0ZpYmVyMyIsIl9uZXdGaWJlcjQiLCJyZWNvbmNpbGVTaW5nbGVUZXh0Tm9kZSIsInJlY29uY2lsZVNpbmdsZUVsZW1lbnQiLCJfY3JlYXRlZDciLCJyZWNvbmNpbGVTaW5nbGVDYWxsIiwicmVjb25jaWxlU2luZ2xlUmV0dXJuIiwicmVjb25jaWxlU2luZ2xlUG9ydGFsIiwicmVjb25jaWxlQ2hpbGRGaWJlcnMiLCJpc09iamVjdCIsIl9pc01vY2tGdW5jdGlvbiIsIm1vdW50Q2hpbGRGaWJlcnMiLCJjbG9uZUNoaWxkRmliZXJzIiwiY3VycmVudENoaWxkIiwid2FybmVkQWJvdXRTdGF0ZWxlc3NSZWZzIiwiUmVhY3RGaWJlckJlZ2luV29yayIsImhvc3RDb250ZXh0IiwiaHlkcmF0aW9uQ29udGV4dCIsIl9SZWFjdEZpYmVyQ2xhc3NDb21wbyIsInJlY29uY2lsZUNoaWxkcmVuIiwibmV4dENoaWxkcmVuIiwicmVjb25jaWxlQ2hpbGRyZW5BdEV4cGlyYXRpb25UaW1lIiwiYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayIsIm1hcmtSZWYiLCJ1cGRhdGVGdW5jdGlvbmFsQ29tcG9uZW50IiwidXBkYXRlQ2xhc3NDb21wb25lbnQiLCJoYXNDb250ZXh0IiwiZmluaXNoQ2xhc3NDb21wb25lbnQiLCJwdXNoSG9zdFJvb3RDb250ZXh0IiwidXBkYXRlSG9zdFJvb3QiLCJ1cGRhdGVIb3N0Q29tcG9uZW50IiwicHJldlByb3BzIiwiaXNEaXJlY3RUZXh0Q2hpbGQiLCJ1cGRhdGVIb3N0VGV4dCIsIm1vdW50SW5kZXRlcm1pbmF0ZUNvbXBvbmVudCIsImRlYnVnU291cmNlIiwidXBkYXRlQ2FsbENvbXBvbmVudCIsIm5leHRDYWxsIiwidXBkYXRlUG9ydGFsQ29tcG9uZW50IiwiYmFpbG91dE9uTG93UHJpb3JpdHkiLCJuZXh0U3RhdGUiLCJSZWFjdEZpYmVyQ29tcGxldGVXb3JrIiwibWFya1VwZGF0ZSIsImFwcGVuZEFsbFJldHVybnMiLCJyZXR1cm5zIiwibW92ZUNhbGxUb0hhbmRsZXJQaGFzZSIsImFwcGVuZEFsbENoaWxkcmVuIiwidXBkYXRlSG9zdENvbnRhaW5lciIsInVwZGF0ZVBheWxvYWQiLCJyb290Q29udGFpbmVySW5zdGFuY2UiLCJvbGRUZXh0IiwibmV3VGV4dCIsImNsb25lSW5zdGFuY2UiLCJjcmVhdGVDb250YWluZXJDaGlsZFNldCIsImFwcGVuZENoaWxkVG9Db250YWluZXJDaGlsZFNldCIsImZpbmFsaXplQ29udGFpbmVyQ2hpbGRyZW4iLCJhcHBlbmRBbGxDaGlsZHJlblRvQ29udGFpbmVyIiwiY29udGFpbmVyQ2hpbGRTZXQiLCJwb3J0YWxPclJvb3QiLCJjaGlsZHJlblVuY2hhbmdlZCIsImNvbnRhaW5lciIsIm5ld0NoaWxkU2V0IiwiY3VycmVudEluc3RhbmNlIiwicmVjeWNsYWJsZUluc3RhbmNlIiwibmV3SW5zdGFuY2UiLCJjdXJyZW50SG9zdENvbnRleHQiLCJmaWJlclJvb3QiLCJfY3VycmVudEhvc3RDb250ZXh0Iiwid2FzSHlkcmF0ZWQiLCJfaW5zdGFuY2UiLCJfcm9vdENvbnRhaW5lckluc3RhbmNlIiwiX2N1cnJlbnRIb3N0Q29udGV4dDIiLCJfd2FzSHlkcmF0ZWQiLCJpbnZva2VHdWFyZGVkQ2FsbGJhY2skMiIsImhhc0NhdWdodEVycm9yJDEiLCJjbGVhckNhdWdodEVycm9yJDEiLCJSZWFjdEZpYmVyQ29tbWl0V29yayIsImNhcHR1cmVFcnJvciIsImNhbGxDb21wb25lbnRXaWxsVW5tb3VudFdpdGhUaW1lciIsInNhZmVseUNhbGxDb21wb25lbnRXaWxsVW5tb3VudCIsInVubW91bnRFcnJvciIsInNhZmVseURldGFjaFJlZiIsInJlZkVycm9yIiwiX3VwZGF0ZVF1ZXVlIiwiX2luc3RhbmNlMiIsImN1cnJlbnRSZWYiLCJjb21taXRVbm1vdW50IiwiY29tbWl0TmVzdGVkVW5tb3VudHMiLCJ1bm1vdW50SG9zdENvbXBvbmVudHMiLCJlbXB0eVBvcnRhbENvbnRhaW5lciIsImRldGFjaEZpYmVyIiwiY29tbWl0Q29udGFpbmVyIiwicmVwbGFjZUNvbnRhaW5lckNoaWxkcmVuIiwiZW1wdHlDaGlsZFNldCIsIl9wZW5kaW5nQ2hpbGRyZW4iLCJnZXRIb3N0UGFyZW50RmliZXIiLCJpc0hvc3RQYXJlbnQiLCJnZXRIb3N0U2libGluZyIsInNpYmxpbmdzIiwicGFyZW50RmliZXIiLCJpc0NvbnRhaW5lciIsImJlZm9yZSIsImN1cnJlbnRQYXJlbnRJc1ZhbGlkIiwiY3VycmVudFBhcmVudElzQ29udGFpbmVyIiwiZmluZFBhcmVudCIsInRleHRJbnN0YW5jZSIsIk5PX0NPTlRFWFQiLCJSZWFjdEZpYmVySG9zdENvbnRleHQiLCJjb250ZXh0RmliZXJTdGFja0N1cnNvciIsInJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yIiwicmVxdWlyZWRDb250ZXh0Iiwicm9vdEluc3RhbmNlIiwibmV4dFJvb3RJbnN0YW5jZSIsIm5leHRSb290Q29udGV4dCIsIm5leHRDb250ZXh0IiwiUmVhY3RGaWJlckh5ZHJhdGlvbkNvbnRleHQiLCJoeWRyYXRpb25QYXJlbnRGaWJlciIsIm5leHRIeWRyYXRhYmxlSW5zdGFuY2UiLCJpc0h5ZHJhdGluZyIsInBhcmVudEluc3RhbmNlIiwiZGVsZXRlSHlkcmF0YWJsZUluc3RhbmNlIiwiaW5zZXJ0Tm9uSHlkcmF0ZWRJbnN0YW5jZSIsInBhcmVudENvbnRhaW5lciIsInBhcmVudFByb3BzIiwiX3R5cGUiLCJfcHJvcHMiLCJfdGV4dCIsInRyeUh5ZHJhdGUiLCJuZXh0SW5zdGFuY2UiLCJwb3BUb05leHRIb3N0UGFyZW50IiwiUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbiIsImRlYnVnVG9vbCIsIlJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMSIsImRlZmF1bHRTaG93RGlhbG9nIiwiY2FwdHVyZWRFcnJvciIsInNob3dEaWFsb2ciLCJsb2dDYXB0dXJlZEVycm9yIiwibG9nRXJyb3IiLCJzdXBwcmVzc0xvZ2dpbmciLCJjb21wb25lbnROYW1lTWVzc2FnZSIsImVycm9yQm91bmRhcnlNZXNzYWdlIiwiY29tYmluZWRNZXNzYWdlIiwiaW52b2tlR3VhcmRlZENhbGxiYWNrJDEiLCJkaWRXYXJuQWJvdXRTdGF0ZVRyYW5zaXRpb24iLCJkaWRXYXJuU2V0U3RhdGVDaGlsZENvbnRleHQiLCJ3YXJuQWJvdXRVcGRhdGVPblVubW91bnRlZCIsIndhcm5BYm91dEludmFsaWRVcGRhdGVzIiwiUmVhY3RGaWJlclNjaGVkdWxlciIsIl9SZWFjdEZpYmVyQmVnaW5Xb3JrIiwiX1JlYWN0RmliZXJDb21wbGV0ZVdvIiwiX1JlYWN0RmliZXJDb21taXRXb3JrIiwic3RhcnRUaW1lIiwibW9zdFJlY2VudEN1cnJlbnRUaW1lIiwiZXhwaXJhdGlvbkNvbnRleHQiLCJpc1dvcmtpbmciLCJuZXh0Um9vdCIsIm5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSIsImNhcHR1cmVkRXJyb3JzIiwiZmFpbGVkQm91bmRhcmllcyIsImNvbW1pdFBoYXNlQm91bmRhcmllcyIsImZpcnN0VW5jYXVnaHRFcnJvciIsImRpZEZhdGFsIiwiaXNVbm1vdW50aW5nIiwicmVzZXRDb250ZXh0U3RhY2siLCJjb21taXRBbGxIb3N0RWZmZWN0cyIsInByaW1hcnlFZmZlY3RUYWciLCJfY3VycmVudCIsIl9jdXJyZW50MiIsImNvbW1pdEFsbExpZmVDeWNsZXMiLCJjb21taXRFcnJvckhhbmRsaW5nIiwiY29tbWl0Um9vdCIsIl9lcnJvciIsIl9kaWRFcnJvciIsIl9lcnJvcjIiLCJvbkNvbW1pdFdvcmsiLCJzY2hlZHVsZUVycm9yUmVjb3ZlcnkiLCJfZXJyb3IzIiwib25VbmNhdWdodEVycm9yIiwicmVtYWluaW5nVGltZSIsInJlc2V0RXhwaXJhdGlvblRpbWUiLCJyZW5kZXJUaW1lIiwibmV3RXhwaXJhdGlvblRpbWUiLCJjb21wbGV0ZVVuaXRPZldvcmsiLCJzaWJsaW5nRmliZXIiLCJvbkNvbXBsZXRlV29yayIsInBlcmZvcm1Vbml0T2ZXb3JrIiwib25CZWdpbldvcmsiLCJwZXJmb3JtRmFpbGVkVW5pdE9mV29yayIsIndvcmtMb29wIiwic2xvd1dvcmtMb29wVGhhdENoZWNrc0ZvckZhaWxlZFdvcmsiLCJzaG91bGRZaWVsZCIsImhhc0NhcHR1cmVkRXJyb3IiLCJyZW5kZXJSb290Q2F0Y2hCbG9jayIsImZhaWxlZFdvcmsiLCJib3VuZGFyeSIsInVud2luZENvbnRleHRzIiwicmVuZGVyUm9vdCIsInVuY2F1Z2h0RXJyb3IiLCJpc0ZhaWxlZEJvdW5kYXJ5IiwiX2NvbXBvbmVudFN0YWNrIiwiX2NvbXBvbmVudE5hbWUiLCJlZmZlY3RmdWxGaWJlciIsInJlY2FsY3VsYXRlQ3VycmVudFRpbWUiLCJleHBpcmF0aW9uTXMiLCJzY2hlZHVsZVdvcmtJbXBsIiwiY2hlY2tSb290TmVlZHNDbGVhcmluZyIsImlzRXJyb3JSZWNvdmVyeSIsInJlcXVlc3RXb3JrIiwicHJldmlvdXNFeHBpcmF0aW9uQ29udGV4dCIsInN5bmNVcGRhdGVzIiwiZmlyc3RTY2hlZHVsZWRSb290IiwibGFzdFNjaGVkdWxlZFJvb3QiLCJjYWxsYmFja0V4cGlyYXRpb25UaW1lIiwiY2FsbGJhY2tJRCIsImlzUmVuZGVyaW5nIiwibmV4dEZsdXNoZWRSb290IiwibmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSIsImRlYWRsaW5lRGlkRXhwaXJlIiwiaGFzVW5oYW5kbGVkRXJyb3IiLCJ1bmhhbmRsZWRFcnJvciIsImRlYWRsaW5lIiwiaXNCYXRjaGluZ1VwZGF0ZXMiLCJpc1VuYmF0Y2hpbmdVcGRhdGVzIiwiTkVTVEVEX1VQREFURV9MSU1JVCIsIm5lc3RlZFVwZGF0ZUNvdW50IiwidGltZUhldXJpc3RpY0ZvclVuaXRPZldvcmsiLCJzY2hlZHVsZUNhbGxiYWNrV2l0aEV4cGlyYXRpb24iLCJjdXJyZW50TXMiLCJwZXJmb3JtQXN5bmNXb3JrIiwicGVyZm9ybVdvcmtPblJvb3QiLCJwZXJmb3JtV29yayIsImZpbmRIaWdoZXN0UHJpb3JpdHlSb290IiwiaGlnaGVzdFByaW9yaXR5V29yayIsImhpZ2hlc3RQcmlvcml0eVJvb3QiLCJwcmV2aW91c1NjaGVkdWxlZFJvb3QiLCJwcmV2aW91c0ZsdXNoZWRSb290IiwiZGwiLCJtaW5FeHBpcmF0aW9uVGltZSIsIl9lcnJvcjQiLCJfZmluaXNoZWRXb3JrIiwicHJldmlvdXNJc0JhdGNoaW5nVXBkYXRlcyIsImRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXMiLCJnZXRDb250ZXh0Rm9yU3VidHJlZSIsInBhcmVudENvbXBvbmVudCIsIlJlYWN0RmliZXJSZWNvbmNpbGVyJDEiLCJfUmVhY3RGaWJlclNjaGVkdWxlciIsInNjaGVkdWxlVG9wTGV2ZWxVcGRhdGUiLCJob3N0RmliZXIiLCJvbk1vdW50Q29udGFpbmVyIiwib25Vbm1vdW50Q29udGFpbmVyIiwib25VcGRhdGVDb250YWluZXIiLCJjb250YWluZXJGaWJlciIsImRldlRvb2xzQ29uZmlnIiwiUmVhY3RGaWJlclJlY29uY2lsZXIkMiIsIlJlYWN0RmliZXJSZWNvbmNpbGVyJDMiLCJyZWFjdFJlY29uY2lsZXIiLCJjcmVhdGVQb3J0YWwkMSIsImhhc05hdGl2ZVBlcmZvcm1hbmNlTm93IiwicklDIiwiY0lDIiwiZnJhbWVDYWxsYmFjayIsInRpbWVvdXRJRCIsInNjaGVkdWxlZFJJQ0NhbGxiYWNrIiwiaXNJZGxlU2NoZWR1bGVkIiwidGltZW91dFRpbWUiLCJpc0FuaW1hdGlvbkZyYW1lU2NoZWR1bGVkIiwiZnJhbWVEZWFkbGluZSIsInByZXZpb3VzRnJhbWVUaW1lIiwiYWN0aXZlRnJhbWVUaW1lIiwiZnJhbWVEZWFkbGluZU9iamVjdCIsInJlbWFpbmluZyIsIm1lc3NhZ2VLZXkiLCJpZGxlVGljayIsImFuaW1hdGlvblRpY2siLCJyYWZUaW1lIiwibmV4dEZyYW1lVGltZSIsIlZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYIiwiaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZSIsInZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZSIsImlzQXR0cmlidXRlTmFtZVNhZmUiLCJzaG91bGRJZ25vcmVWYWx1ZSIsImdldFZhbHVlRm9yUHJvcGVydHkiLCJleHBlY3RlZCIsInN0cmluZ1ZhbHVlIiwiZ2V0VmFsdWVGb3JBdHRyaWJ1dGUiLCJzZXRWYWx1ZUZvclByb3BlcnR5IiwiZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eSIsInNldFZhbHVlRm9yQXR0cmlidXRlIiwiZGVsZXRlVmFsdWVGb3JBdHRyaWJ1dGUiLCJSZWFjdENvbnRyb2xsZWRWYWx1ZVByb3BUeXBlcyIsImhhc1JlYWRPbmx5VmFsdWUiLCJjaGVja2JveCIsImltYWdlIiwicmFkaW8iLCJzdWJtaXQiLCJvbkNoYW5nZSIsImdldEN1cnJlbnRGaWJlck93bmVyTmFtZSQyIiwiZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQzIiwiZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlIiwiZGlkV2FybkNoZWNrZWREZWZhdWx0Q2hlY2tlZCIsImRpZFdhcm5Db250cm9sbGVkVG9VbmNvbnRyb2xsZWQiLCJkaWRXYXJuVW5jb250cm9sbGVkVG9Db250cm9sbGVkIiwiaXNDb250cm9sbGVkIiwidXNlc0NoZWNrZWQiLCJnZXRIb3N0UHJvcHMiLCJob3N0UHJvcHMiLCJpbml0V3JhcHBlclN0YXRlIiwidXBkYXRlQ2hlY2tlZCIsInVwZGF0ZVdyYXBwZXIiLCJ2YWx1ZUFzTnVtYmVyIiwicG9zdE1vdW50V3JhcHBlciIsInJlc3RvcmVDb250cm9sbGVkU3RhdGUkMSIsInVwZGF0ZU5hbWVkQ291c2lucyIsInJvb3ROb2RlIiwicXVlcnlSb290IiwiZ3JvdXAiLCJvdGhlck5vZGUiLCJvdGhlclByb3BzIiwiZmxhdHRlbkNoaWxkcmVuIiwidmFsaWRhdGVQcm9wcyIsInBvc3RNb3VudFdyYXBwZXIkMSIsImdldEhvc3RQcm9wcyQxIiwiZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lJDMiLCJnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDQiLCJkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUkMSIsInZhbHVlUHJvcE5hbWVzIiwiY2hlY2tTZWxlY3RQcm9wVHlwZXMiLCJ1cGRhdGVPcHRpb25zIiwicHJvcFZhbHVlIiwic2V0RGVmYXVsdFNlbGVjdGVkIiwic2VsZWN0ZWRWYWx1ZXMiLCJzZWxlY3RlZFZhbHVlIiwiX3NlbGVjdGVkVmFsdWUiLCJfaTIiLCJnZXRIb3N0UHJvcHMkMiIsImluaXRXcmFwcGVyU3RhdGUkMSIsInBvc3RNb3VudFdyYXBwZXIkMiIsInBvc3RVcGRhdGVXcmFwcGVyIiwicmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSQyIiwiZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQ1IiwiZGlkV2FyblZhbERlZmF1bHRWYWwiLCJnZXRIb3N0UHJvcHMkMyIsImluaXRXcmFwcGVyU3RhdGUkMiIsInVwZGF0ZVdyYXBwZXIkMSIsIm5ld1ZhbHVlIiwicG9zdE1vdW50V3JhcHBlciQzIiwicmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSQzIiwiSFRNTF9OQU1FU1BBQ0UkMSIsIk1BVEhfTkFNRVNQQUNFIiwiU1ZHX05BTUVTUEFDRSIsIk5hbWVzcGFjZXMiLCJnZXRJbnRyaW5zaWNOYW1lc3BhY2UiLCJnZXRDaGlsZE5hbWVzcGFjZSIsInBhcmVudE5hbWVzcGFjZSIsImNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24iLCJhcmcwIiwiYXJnMSIsImFyZzIiLCJhcmczIiwicmV1c2FibGVTVkdDb250YWluZXIiLCJzZXRJbm5lckhUTUwiLCJzdmdOb2RlIiwic2V0VGV4dENvbnRlbnQiLCJpc1VuaXRsZXNzTnVtYmVyIiwicHJlZml4S2V5IiwiZGFuZ2Vyb3VzU3R5bGVWYWx1ZSIsImlzQ3VzdG9tUHJvcGVydHkiLCJpc0VtcHR5Iiwid2FyblZhbGlkU3R5bGUiLCJiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4iLCJiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4iLCJ3YXJuZWRTdHlsZU5hbWVzIiwid2FybmVkU3R5bGVWYWx1ZXMiLCJ3YXJuZWRGb3JOYU5WYWx1ZSIsIndhcm5lZEZvckluZmluaXR5VmFsdWUiLCJ3YXJuSHlwaGVuYXRlZFN0eWxlTmFtZSIsIndhcm5CYWRWZW5kb3JlZFN0eWxlTmFtZSIsIndhcm5TdHlsZVZhbHVlV2l0aFNlbWljb2xvbiIsIndhcm5TdHlsZVZhbHVlSXNOYU4iLCJ3YXJuU3R5bGVWYWx1ZUlzSW5maW5pdHkiLCJpc0Zpbml0ZSIsIndhcm5WYWxpZFN0eWxlJDEiLCJjcmVhdGVEYW5nZXJvdXNTdHJpbmdGb3JTdHlsZXMiLCJzdHlsZXMiLCJzZXJpYWxpemVkIiwiZGVsaW1pdGVyIiwic3R5bGVOYW1lIiwic3R5bGVWYWx1ZSIsInNldFZhbHVlRm9yU3R5bGVzIiwib21pdHRlZENsb3NlVGFncyIsInZvaWRFbGVtZW50VGFncyIsIkhUTUwkMSIsImFzc2VydFZhbGlkUHJvcHMiLCJpc0N1c3RvbUNvbXBvbmVudCIsImFyaWFQcm9wZXJ0aWVzIiwid2FybmVkUHJvcGVydGllcyIsInJBUklBIiwickFSSUFDYW1lbCIsInZhbGlkYXRlUHJvcGVydHkiLCJhcmlhTmFtZSIsImNvcnJlY3ROYW1lIiwic3RhbmRhcmROYW1lIiwid2FybkludmFsaWRBUklBUHJvcHMiLCJpbnZhbGlkUHJvcHMiLCJpc1ZhbGlkIiwidW5rbm93blByb3BTdHJpbmciLCJ2YWxpZGF0ZVByb3BlcnRpZXMiLCJkaWRXYXJuVmFsdWVOdWxsIiwiZ2V0U3RhY2tBZGRlbmR1bSQxIiwidmFsaWRhdGVQcm9wZXJ0aWVzJDEiLCJwb3NzaWJsZVN0YW5kYXJkTmFtZXMiLCJhY2NlcHQiLCJhY2NlcHRjaGFyc2V0IiwiYWNjZXNza2V5IiwiYWxsb3dmdWxsc2NyZWVuIiwiYWx0IiwiYXMiLCJhdXRvY2FwaXRhbGl6ZSIsImF1dG9jb21wbGV0ZSIsImF1dG9jb3JyZWN0IiwiYXV0b2ZvY3VzIiwiYXV0b3BsYXkiLCJhdXRvc2F2ZSIsImNlbGxwYWRkaW5nIiwiY2VsbHNwYWNpbmciLCJjaGFsbGVuZ2UiLCJjaGFyc2V0IiwiY2l0ZSIsImNsYXNzaWQiLCJjbGFzc25hbWUiLCJjb2xzcGFuIiwiY29udGVudGVkaXRhYmxlIiwiY29udGV4dG1lbnUiLCJjb250cm9sc2xpc3QiLCJjb29yZHMiLCJjcm9zc29yaWdpbiIsImRhbmdlcm91c2x5c2V0aW5uZXJodG1sIiwiZGVmYXVsdGNoZWNrZWQiLCJkZWZhdWx0dmFsdWUiLCJlbmN0eXBlIiwiZm9ybW1ldGhvZCIsImZvcm1hY3Rpb24iLCJmb3JtZW5jdHlwZSIsImZvcm1ub3ZhbGlkYXRlIiwiZm9ybXRhcmdldCIsImZyYW1lYm9yZGVyIiwiaGVhZGVycyIsImhlaWdodCIsImhpZ2giLCJocmVmIiwiaHJlZmxhbmciLCJodG1sZm9yIiwiaHR0cGVxdWl2IiwiaWNvbiIsImlubmVyaHRtbCIsImlucHV0bW9kZSIsImludGVncml0eSIsIml0ZW1pZCIsIml0ZW1wcm9wIiwiaXRlbXJlZiIsIml0ZW1zY29wZSIsIml0ZW10eXBlIiwia2V5cGFyYW1zIiwia2V5dHlwZSIsImtpbmQiLCJsYW5nIiwibG93IiwibWFuaWZlc3QiLCJtYXJnaW53aWR0aCIsIm1hcmdpbmhlaWdodCIsIm1heGxlbmd0aCIsIm1lZGlhIiwibWVkaWFncm91cCIsIm1ldGhvZCIsIm1pbmxlbmd0aCIsIm5vbmNlIiwibm92YWxpZGF0ZSIsIm9wdGltdW0iLCJwYXR0ZXJuIiwicGxhY2Vob2xkZXIiLCJwbGF5c2lubGluZSIsInBvc3RlciIsInByZWxvYWQiLCJwcm9maWxlIiwicmFkaW9ncm91cCIsInJlYWRvbmx5IiwicmVmZXJyZXJwb2xpY3kiLCJyZWwiLCJyb2xlIiwicm93c3BhbiIsInNhbmRib3giLCJzY3JvbGxpbmciLCJzaGFwZSIsInNpemVzIiwic3BlbGxjaGVjayIsInNyY2RvYyIsInNyY2xhbmciLCJzcmNzZXQiLCJzdW1tYXJ5IiwidGFiaW5kZXgiLCJ1c2VtYXAiLCJ3aWR0aCIsIndtb2RlIiwid3JhcCIsImFib3V0IiwiYWNjZW50aGVpZ2h0IiwiYWNjdW11bGF0ZSIsImFkZGl0aXZlIiwiYWxpZ25tZW50YmFzZWxpbmUiLCJhbGxvd3Jlb3JkZXIiLCJhbHBoYWJldGljIiwiYW1wbGl0dWRlIiwiYXJhYmljZm9ybSIsImFzY2VudCIsImF0dHJpYnV0ZW5hbWUiLCJhdHRyaWJ1dGV0eXBlIiwiYXV0b3JldmVyc2UiLCJhemltdXRoIiwiYmFzZWZyZXF1ZW5jeSIsImJhc2VsaW5lc2hpZnQiLCJiYXNlcHJvZmlsZSIsImJib3giLCJiZWdpbiIsImJpYXMiLCJieSIsImNhbGNtb2RlIiwiY2FwaGVpZ2h0IiwiY2xpcCIsImNsaXBwYXRoIiwiY2xpcHBhdGh1bml0cyIsImNsaXBydWxlIiwiY29sb3JpbnRlcnBvbGF0aW9uIiwiY29sb3JpbnRlcnBvbGF0aW9uZmlsdGVycyIsImNvbG9ycHJvZmlsZSIsImNvbG9ycmVuZGVyaW5nIiwiY29udGVudHNjcmlwdHR5cGUiLCJjb250ZW50c3R5bGV0eXBlIiwiY3giLCJjeSIsImRhdGF0eXBlIiwiZGVjZWxlcmF0ZSIsImRlc2NlbnQiLCJkaWZmdXNlY29uc3RhbnQiLCJkaXJlY3Rpb24iLCJkaXNwbGF5IiwiZGl2aXNvciIsImRvbWluYW50YmFzZWxpbmUiLCJkdXIiLCJkeCIsImR5IiwiZWRnZW1vZGUiLCJlbGV2YXRpb24iLCJlbmFibGViYWNrZ3JvdW5kIiwiZXhwb25lbnQiLCJleHRlcm5hbHJlc291cmNlc3JlcXVpcmVkIiwiZmlsbCIsImZpbGxvcGFjaXR5IiwiZmlsbHJ1bGUiLCJmaWx0ZXIiLCJmaWx0ZXJyZXMiLCJmaWx0ZXJ1bml0cyIsImZsb29kb3BhY2l0eSIsImZsb29kY29sb3IiLCJmb2N1c2FibGUiLCJmb250ZmFtaWx5IiwiZm9udHNpemUiLCJmb250c2l6ZWFkanVzdCIsImZvbnRzdHJldGNoIiwiZm9udHN0eWxlIiwiZm9udHZhcmlhbnQiLCJmb250d2VpZ2h0IiwiZngiLCJmeSIsImcxIiwiZzIiLCJnbHlwaG5hbWUiLCJnbHlwaG9yaWVudGF0aW9uaG9yaXpvbnRhbCIsImdseXBob3JpZW50YXRpb252ZXJ0aWNhbCIsImdseXBocmVmIiwiZ3JhZGllbnR0cmFuc2Zvcm0iLCJncmFkaWVudHVuaXRzIiwiaGFuZ2luZyIsImhvcml6YWR2eCIsImhvcml6b3JpZ2lueCIsImlkZW9ncmFwaGljIiwiaW1hZ2VyZW5kZXJpbmciLCJpbjIiLCJpbmxpc3QiLCJpbnRlcmNlcHQiLCJrMSIsImsyIiwiazMiLCJrNCIsImtlcm5lbG1hdHJpeCIsImtlcm5lbHVuaXRsZW5ndGgiLCJrZXJuaW5nIiwia2V5cG9pbnRzIiwia2V5c3BsaW5lcyIsImtleXRpbWVzIiwibGVuZ3RoYWRqdXN0IiwibGV0dGVyc3BhY2luZyIsImxpZ2h0aW5nY29sb3IiLCJsaW1pdGluZ2NvbmVhbmdsZSIsIm1hcmtlcmVuZCIsIm1hcmtlcmhlaWdodCIsIm1hcmtlcm1pZCIsIm1hcmtlcnN0YXJ0IiwibWFya2VydW5pdHMiLCJtYXJrZXJ3aWR0aCIsIm1hc2siLCJtYXNrY29udGVudHVuaXRzIiwibWFza3VuaXRzIiwibWF0aGVtYXRpY2FsIiwibW9kZSIsIm51bW9jdGF2ZXMiLCJvcGVyYXRvciIsIm9yaWVudCIsIm9yaWVudGF0aW9uIiwib3JpZ2luIiwib3ZlcmZsb3ciLCJvdmVybGluZXBvc2l0aW9uIiwib3ZlcmxpbmV0aGlja25lc3MiLCJwYWludG9yZGVyIiwicGFub3NlMSIsInBhdGhsZW5ndGgiLCJwYXR0ZXJuY29udGVudHVuaXRzIiwicGF0dGVybnRyYW5zZm9ybSIsInBhdHRlcm51bml0cyIsInBvaW50ZXJldmVudHMiLCJwb2ludHMiLCJwb2ludHNhdHgiLCJwb2ludHNhdHkiLCJwb2ludHNhdHoiLCJwcmVzZXJ2ZWFscGhhIiwicHJlc2VydmVhc3BlY3RyYXRpbyIsInByaW1pdGl2ZXVuaXRzIiwicHJvcGVydHkiLCJyYWRpdXMiLCJyZWZ4IiwicmVmeSIsInJlbmRlcmluZ2ludGVudCIsInJlcGVhdGNvdW50IiwicmVwZWF0ZHVyIiwicmVxdWlyZWRleHRlbnNpb25zIiwicmVxdWlyZWRmZWF0dXJlcyIsInJlc291cmNlIiwicmVzdGFydCIsInJvdGF0ZSIsInJ4IiwicnkiLCJzY2FsZSIsInNlY3VyaXR5Iiwic2hhcGVyZW5kZXJpbmciLCJzbG9wZSIsInNwYWNpbmciLCJzcGVjdWxhcmNvbnN0YW50Iiwic3BlY3VsYXJleHBvbmVudCIsInNwZWVkIiwic3ByZWFkbWV0aG9kIiwic3RhcnRvZmZzZXQiLCJzdGRkZXZpYXRpb24iLCJzdGVtaCIsInN0ZW12Iiwic3RpdGNodGlsZXMiLCJzdG9wY29sb3IiLCJzdG9wb3BhY2l0eSIsInN0cmlrZXRocm91Z2hwb3NpdGlvbiIsInN0cmlrZXRocm91Z2h0aGlja25lc3MiLCJzdHJpbmciLCJzdHJva2UiLCJzdHJva2VkYXNoYXJyYXkiLCJzdHJva2VkYXNob2Zmc2V0Iiwic3Ryb2tlbGluZWNhcCIsInN0cm9rZWxpbmVqb2luIiwic3Ryb2tlbWl0ZXJsaW1pdCIsInN0cm9rZXdpZHRoIiwic3Ryb2tlb3BhY2l0eSIsInN1cHByZXNzY29udGVudGVkaXRhYmxld2FybmluZyIsInN1cHByZXNzaHlkcmF0aW9ud2FybmluZyIsInN1cmZhY2VzY2FsZSIsInN5c3RlbWxhbmd1YWdlIiwidGFibGV2YWx1ZXMiLCJ0YXJnZXR4IiwidGFyZ2V0eSIsInRleHRhbmNob3IiLCJ0ZXh0ZGVjb3JhdGlvbiIsInRleHRsZW5ndGgiLCJ0ZXh0cmVuZGVyaW5nIiwidHJhbnNmb3JtIiwidTEiLCJ1MiIsInVuZGVybGluZXBvc2l0aW9uIiwidW5kZXJsaW5ldGhpY2tuZXNzIiwidW5pY29kZSIsInVuaWNvZGViaWRpIiwidW5pY29kZXJhbmdlIiwidW5pdHNwZXJlbSIsInVuc2VsZWN0YWJsZSIsInZhbHBoYWJldGljIiwidmVjdG9yZWZmZWN0IiwidmVydGFkdnkiLCJ2ZXJ0b3JpZ2lueCIsInZlcnRvcmlnaW55IiwidmhhbmdpbmciLCJ2aWRlb2dyYXBoaWMiLCJ2aWV3Ym94Iiwidmlld3RhcmdldCIsInZpc2liaWxpdHkiLCJ2bWF0aGVtYXRpY2FsIiwidm9jYWIiLCJ3aWR0aHMiLCJ3b3Jkc3BhY2luZyIsIndyaXRpbmdtb2RlIiwieDEiLCJ4MiIsInhjaGFubmVsc2VsZWN0b3IiLCJ4aGVpZ2h0IiwieGxpbmthY3R1YXRlIiwieGxpbmthcmNyb2xlIiwieGxpbmtocmVmIiwieGxpbmtyb2xlIiwieGxpbmtzaG93IiwieGxpbmt0aXRsZSIsInhsaW5rdHlwZSIsInhtbGJhc2UiLCJ4bWxsYW5nIiwieG1sbnMiLCJ4bWxuc3hsaW5rIiwieG1sc3BhY2UiLCJ5MSIsInkyIiwieWNoYW5uZWxzZWxlY3RvciIsInpvb21hbmRwYW4iLCJnZXRTdGFja0FkZGVuZHVtJDIiLCJ3YXJuZWRQcm9wZXJ0aWVzJDEiLCJoYXNPd25Qcm9wZXJ0eSQxIiwiRVZFTlRfTkFNRV9SRUdFWCIsIklOVkFMSURfRVZFTlRfTkFNRV9SRUdFWCIsInJBUklBJDEiLCJyQVJJQUNhbWVsJDEiLCJ2YWxpZGF0ZVByb3BlcnR5JDEiLCJjYW5Vc2VFdmVudFN5c3RlbSIsImlzUmVzZXJ2ZWQiLCJ3YXJuVW5rbm93blByb3BlcnRpZXMiLCJ1bmtub3duUHJvcHMiLCJ2YWxpZGF0ZVByb3BlcnRpZXMkMiIsImdldEN1cnJlbnRGaWJlck93bmVyTmFtZSQxIiwiZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQyIiwiZGlkV2FybkludmFsaWRIeWRyYXRpb24iLCJkaWRXYXJuU2hhZHlET00iLCJEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCIsIlNVUFBSRVNTX0NPTlRFTlRfRURJVEFCTEVfV0FSTklORyIsIlNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDEiLCJBVVRPRk9DVVMiLCJDSElMRFJFTiIsIlNUWUxFIiwiSFRNTCIsIkhUTUxfTkFNRVNQQUNFIiwid2FybmVkVW5rbm93blRhZ3MiLCJkaWFsb2ciLCJ2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50IiwiTk9STUFMSVpFX05FV0xJTkVTX1JFR0VYIiwiTk9STUFMSVpFX05VTExfQU5EX1JFUExBQ0VNRU5UX1JFR0VYIiwibm9ybWFsaXplTWFya3VwRm9yVGV4dE9yQXR0cmlidXRlIiwibWFya3VwIiwibWFya3VwU3RyaW5nIiwid2FybkZvclRleHREaWZmZXJlbmNlIiwic2VydmVyVGV4dCIsImNsaWVudFRleHQiLCJub3JtYWxpemVkQ2xpZW50VGV4dCIsIm5vcm1hbGl6ZWRTZXJ2ZXJUZXh0Iiwid2FybkZvclByb3BEaWZmZXJlbmNlIiwic2VydmVyVmFsdWUiLCJjbGllbnRWYWx1ZSIsIm5vcm1hbGl6ZWRDbGllbnRWYWx1ZSIsIm5vcm1hbGl6ZWRTZXJ2ZXJWYWx1ZSIsIndhcm5Gb3JFeHRyYUF0dHJpYnV0ZXMiLCJhdHRyaWJ1dGVOYW1lcyIsIm5hbWVzIiwid2FybkZvckludmFsaWRFdmVudExpc3RlbmVyIiwibm9ybWFsaXplSFRNTCIsInRlc3RFbGVtZW50IiwiZW5zdXJlTGlzdGVuaW5nVG8iLCJyb290Q29udGFpbmVyRWxlbWVudCIsImlzRG9jdW1lbnRPckZyYWdtZW50IiwiZ2V0T3duZXJEb2N1bWVudEZyb21Sb290Q29udGFpbmVyIiwibWVkaWFFdmVudHMiLCJ0cmFwQ2xpY2tPbk5vbkludGVyYWN0aXZlRWxlbWVudCIsInNldEluaXRpYWxET01Qcm9wZXJ0aWVzIiwiZG9tRWxlbWVudCIsImlzQ3VzdG9tQ29tcG9uZW50VGFnIiwicHJvcEtleSIsIm5leHRQcm9wIiwibmV4dEh0bWwiLCJjYW5TZXRUZXh0Q29udGVudCIsInVwZGF0ZURPTVByb3BlcnRpZXMiLCJ3YXNDdXN0b21Db21wb25lbnRUYWciLCJjcmVhdGVFbGVtZW50JDEiLCJkaXYiLCJjcmVhdGVUZXh0Tm9kZSQxIiwic2V0SW5pdGlhbFByb3BlcnRpZXMkMSIsInJhd1Byb3BzIiwic2hhZHlSb290IiwiZGlmZlByb3BlcnRpZXMkMSIsImxhc3RSYXdQcm9wcyIsIm5leHRSYXdQcm9wcyIsImxhc3RQcm9wcyIsInN0eWxlVXBkYXRlcyIsImxhc3RTdHlsZSIsImxhc3RQcm9wIiwibGFzdEh0bWwiLCJ1cGRhdGVQcm9wZXJ0aWVzJDEiLCJkaWZmSHlkcmF0ZWRQcm9wZXJ0aWVzJDEiLCJleHRyYUF0dHJpYnV0ZU5hbWVzIiwiYXR0cmlidXRlcyIsInJhd0h0bWwiLCJzZXJ2ZXJIVE1MIiwiZXhwZWN0ZWRIVE1MIiwiZXhwZWN0ZWRTdHlsZSIsIm93bk5hbWVzcGFjZSIsImRpZmZIeWRyYXRlZFRleHQkMSIsInRleHROb2RlIiwiaXNEaWZmZXJlbnQiLCJ3YXJuRm9yVW5tYXRjaGVkVGV4dCQxIiwid2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudCQxIiwid2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dCQxIiwid2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50JDEiLCJ3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZFRleHQkMSIsIlJlYWN0RE9NRmliZXJDb21wb25lbnQiLCJnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDYiLCJ2YWxpZGF0ZURPTU5lc3RpbmciLCJzcGVjaWFsVGFncyIsImluU2NvcGVUYWdzIiwiYnV0dG9uU2NvcGVUYWdzIiwiaW1wbGllZEVuZFRhZ3MiLCJlbXB0eUFuY2VzdG9ySW5mbyIsImZvcm1UYWciLCJhVGFnSW5TY29wZSIsImJ1dHRvblRhZ0luU2NvcGUiLCJub2JyVGFnSW5TY29wZSIsInBUYWdJbkJ1dHRvblNjb3BlIiwibGlzdEl0ZW1UYWdBdXRvY2xvc2luZyIsImRsSXRlbVRhZ0F1dG9jbG9zaW5nIiwidXBkYXRlZEFuY2VzdG9ySW5mbyQxIiwib2xkSW5mbyIsImFuY2VzdG9ySW5mbyIsImlzVGFnVmFsaWRXaXRoUGFyZW50IiwicGFyZW50VGFnIiwiZmluZEludmFsaWRBbmNlc3RvckZvclRhZyIsImRpZFdhcm4iLCJjaGlsZFRhZyIsImNoaWxkVGV4dCIsInBhcmVudEluZm8iLCJpbnZhbGlkUGFyZW50IiwiaW52YWxpZEFuY2VzdG9yIiwiaW52YWxpZFBhcmVudE9yQW5jZXN0b3IiLCJhbmNlc3RvclRhZyIsIndhcm5LZXkiLCJ0YWdEaXNwbGF5TmFtZSIsIndoaXRlc3BhY2VJbmZvIiwidXBkYXRlZEFuY2VzdG9ySW5mbyIsImlzVGFnVmFsaWRJbkNvbnRleHQiLCJ2YWxpZGF0ZURPTU5lc3RpbmckMSIsIlNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HIiwiZXZlbnRzRW5hYmxlZCIsInNlbGVjdGlvbkluZm9ybWF0aW9uIiwiaXNWYWxpZENvbnRhaW5lciIsImdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lciIsInNob3VsZEh5ZHJhdGVEdWVUb0xlZ2FjeUhldXJpc3RpYyIsInJvb3RFbGVtZW50Iiwic2hvdWxkQXV0b0ZvY3VzSG9zdENvbXBvbmVudCIsIkRPTVJlbmRlcmVyIiwidmFsaWRhdGVkVGFnIiwiX2FuY2VzdG9ySW5mbyIsInBhcmVudEhvc3RDb250ZXh0IiwicGFyZW50SG9zdENvbnRleHREZXYiLCJfbmFtZXNwYWNlIiwiX2FuY2VzdG9ySW5mbzIiLCJpbnRlcm5hbEluc3RhbmNlSGFuZGxlIiwiaG9zdENvbnRleHREZXYiLCJvd25BbmNlc3RvckluZm8iLCJiZWZvcmVDaGlsZCIsIndhcm5lZEFib3V0SHlkcmF0ZUFQSSIsInJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyIiwiZm9yY2VIeWRyYXRlIiwiaG9zdEluc3RhbmNlIiwiaXNSb290UmVuZGVyZWRCeVNvbWVSZWFjdCIsInJvb3RFbCIsImhhc05vblJvb3RSZWFjdENoaWxkIiwic2hvdWxkSHlkcmF0ZSIsIndhcm5lZCIsInJvb3RTaWJsaW5nIiwibmV3Um9vdCIsIlJlYWN0Um9vdCIsIlJlYWN0RE9NIiwiY29tcG9uZW50T3JFbGVtZW50Iiwid2FybmVkQWJvdXRSZWZzSW5SZW5kZXIiLCJjb250YWluZXJOb2RlIiwicmVuZGVyZWRCeURpZmZlcmVudFJlYWN0IiwiX3Jvb3RFbCIsImlzQ29udGFpbmVyUmVhY3RSb290IiwiY3JlYXRlUm9vdCIsImZvdW5kRGV2VG9vbHMiLCJSZWFjdERPTSQyIiwiUmVhY3RET00kMyIsInJlYWN0RG9tIiwiaHlwaGVuYXRlIiwibXNQYXR0ZXJuIiwiX3VwcGVyY2FzZVBhdHRlcm4iLCJjYW1lbGl6ZSIsIl9oeXBoZW5QYXR0ZXJuIiwiXyIsImNoYXJhY3RlciIsImNzcyIsImJhc2VVcmwiLCJjdXJyZW50RGlyIiwicGF0aG5hbWUiLCJmaXhlZENzcyIsImZ1bGxNYXRjaCIsIm9yaWdVcmwiLCJ1bnF1b3RlZE9yaWdVcmwiLCJvIiwibmV3VXJsIiwibG9va3VwIiwiY2FjaGUiLCJtYW5hZ2VycyIsInBhcnNlZCIsInNhbWVOYW1lc3BhY2UiLCJuZXdDb25uZWN0aW9uIiwiZm9yY2VOZXciLCJtdWx0aXBsZXgiLCJsb2MiLCJjcmVhdGVEZWJ1ZyIsImNvZXJjZSIsImRpc2FibGUiLCJza2lwcyIsInByZXZUaW1lIiwic2VsZWN0Q29sb3IiLCJoYXNoIiwiYWJzIiwiY3VyciIsImZvcm1hdHRlciIsImxvZ0ZuIiwiaW5pdCIsImxvbmciLCJmbXRMb25nIiwiZm10U2hvcnQiLCJyb3VuZCIsInBsdXJhbCIsImNlaWwiLCJwYWNrZXREYXRhIiwiX2RlY29uc3RydWN0UGFja2V0IiwiX3BsYWNlaG9sZGVyIiwibmV3RGF0YSIsIl9yZWNvbnN0cnVjdFBhY2tldCIsIl9yZW1vdmVCbG9icyIsImN1cktleSIsImNvbnRhaW5pbmdPYmplY3QiLCJwZW5kaW5nQmxvYnMiLCJmaWxlUmVhZGVyIiwidHJhbnNwb3J0cyIsInRyYW5zcG9ydE9wdGlvbnMiLCJ3cml0ZUJ1ZmZlciIsInByZXZCdWZmZXJMZW4iLCJwb2xpY3lQb3J0IiwicmVtZW1iZXJVcGdyYWRlIiwib25seUJpbmFyeVVwZ3JhZGVzIiwicGVyTWVzc2FnZURlZmxhdGUiLCJ0aHJlc2hvbGQiLCJmcmVlR2xvYmFsIiwidXBncmFkZXMiLCJwaW5nSW50ZXJ2YWwiLCJwaW5nVGltZW91dCIsInBpbmdJbnRlcnZhbFRpbWVyIiwicGluZ1RpbWVvdXRUaW1lciIsInByaW9yV2Vic29ja2V0U3VjY2VzcyIsImNyZWF0ZVRyYW5zcG9ydCIsIkVJTyIsInRyYW5zcG9ydCIsInJlcXVlc3RUaW1lb3V0IiwicHJvdG9jb2xzIiwic2V0VHJhbnNwb3J0Iiwib25EcmFpbiIsInByb2JlIiwiZmFpbGVkIiwib25UcmFuc3BvcnRPcGVuIiwidXBncmFkZUxvc2VzQmluYXJ5IiwidXBncmFkaW5nIiwiZmx1c2giLCJmcmVlemVUcmFuc3BvcnQiLCJvblRyYW5zcG9ydENsb3NlIiwib251cGdyYWRlIiwib25IYW5kc2hha2UiLCJzZXRQaW5nIiwiY29kZSIsImZpbHRlclVwZ3JhZGVzIiwib25IZWFydGJlYXQiLCJzZW5kUGFja2V0Iiwid2FpdEZvclVwZ3JhZGUiLCJjbGVhbnVwQW5kQ2xvc2UiLCJmaWx0ZXJlZFVwZ3JhZGVzIiwiUmVxdWVzdCIsImVtcHR5IiwicmVxdWVzdCIsInJlcSIsInNlbmRYaHIiLCJwb2xsWGhyIiwic2V0RGlzYWJsZUhlYWRlckNoZWNrIiwic2V0UmVxdWVzdEhlYWRlciIsIndpdGhDcmVkZW50aWFscyIsImhhc1hEUiIsIm9uTG9hZCIsInJlc3BvbnNlVGV4dCIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsImNvbnRlbnRUeXBlIiwiZ2V0UmVzcG9uc2VIZWFkZXIiLCJzdGF0dXMiLCJyZXF1ZXN0c0NvdW50IiwicmVxdWVzdHMiLCJvblN1Y2Nlc3MiLCJmcm9tRXJyb3IiLCJhYm9ydCIsInJlc3BvbnNlIiwidW5sb2FkSGFuZGxlciIsImFycmF5YnVmZmVyIiwiYnl0ZXMiLCJhYnYiLCJlcnJfY2IiLCJiYWlsIiwicHJveHkiLCJmcmVlRXhwb3J0cyIsImZyZWVNb2R1bGUiLCJzdHJpbmdGcm9tQ2hhckNvZGUiLCJ1Y3MyZGVjb2RlIiwib3V0cHV0IiwiY291bnRlciIsImV4dHJhIiwidWNzMmVuY29kZSIsImNoZWNrU2NhbGFyVmFsdWUiLCJjb2RlUG9pbnQiLCJjcmVhdGVCeXRlIiwiZW5jb2RlQ29kZVBvaW50Iiwic3ltYm9sIiwiY29kZVBvaW50cyIsImJ5dGVTdHJpbmciLCJyZWFkQ29udGludWF0aW9uQnl0ZSIsImJ5dGVJbmRleCIsImJ5dGVDb3VudCIsImNvbnRpbnVhdGlvbkJ5dGUiLCJieXRlQXJyYXkiLCJkZWNvZGVTeW1ib2wiLCJieXRlMSIsImJ5dGUyIiwiYnl0ZTMiLCJieXRlNCIsInRtcCIsImRlZmluZSIsIndlYnBhY2tQb2x5ZmlsbCIsImRlcHJlY2F0ZSIsInBhdGhzIiwiYnVmZmVyTGVuZ3RoIiwiZW5jb2RlZDEiLCJlbmNvZGVkMiIsImVuY29kZWQzIiwiZW5jb2RlZDQiLCJCbG9iQnVpbGRlciIsIldlYktpdEJsb2JCdWlsZGVyIiwiTVNCbG9iQnVpbGRlciIsIk1vekJsb2JCdWlsZGVyIiwiYmxvYlN1cHBvcnRlZCIsImJsb2JTdXBwb3J0c0FycmF5QnVmZmVyVmlldyIsImJsb2JCdWlsZGVyU3VwcG9ydGVkIiwiYXBwZW5kIiwiZ2V0QmxvYiIsIm1hcEFycmF5QnVmZmVyVmlld3MiLCJjaHVuayIsImNvcHkiLCJieXRlT2Zmc2V0IiwiQmxvYkJ1aWxkZXJDb25zdHJ1Y3RvciIsIkJsb2JDb25zdHJ1Y3RvciIsIkpTT05QUG9sbGluZyIsInJOZXdsaW5lIiwickVzY2FwZWROZXdsaW5lIiwiX19fZWlvIiwic2NyaXB0IiwiaWZyYW1lIiwiaW5zZXJ0QXQiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsImhlYWQiLCJpc1VBZ2Vja28iLCJpZnJhbWVJZCIsInBvc2l0aW9uIiwiY29tcGxldGUiLCJpbml0SWZyYW1lIiwiQnJvd3NlcldlYlNvY2tldCIsIldlYlNvY2tldCIsIk1veldlYlNvY2tldCIsIk5vZGVXZWJTb2NrZXQiLCJXUyIsInVzaW5nQnJvd3NlcldlYlNvY2tldCIsImNoZWNrIiwid3MiLCJzdXBwb3J0cyIsImFkZEV2ZW50TGlzdGVuZXJzIiwib25tZXNzYWdlIiwiZmFjdG9yIiwicG93IiwicmFuZCIsImRldmlhdGlvbiIsIk1lc3NhZ2VIb2xkZXIiXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQTJCLDBCQUEwQixFQUFFO0FBQ3ZELHlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUFzRCwrREFBK0Q7O0FBRXJIO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7O0FDN0RBLElBQUlBLENBQUo7O0FBRUE7QUFDQUEsSUFBSyxZQUFXO0FBQ2YsUUFBTyxJQUFQO0FBQ0EsQ0FGRyxFQUFKOztBQUlBLElBQUk7QUFDSDtBQUNBQSxLQUFJQSxLQUFLQyxTQUFTLGFBQVQsR0FBTCxJQUFrQyxDQUFDLEdBQUVDLElBQUgsRUFBUyxNQUFULENBQXRDO0FBQ0EsQ0FIRCxDQUdFLE9BQU1DLENBQU4sRUFBUztBQUNWO0FBQ0EsS0FBRyxRQUFPQyxNQUFQLHlDQUFPQSxNQUFQLE9BQWtCLFFBQXJCLEVBQ0NKLElBQUlJLE1BQUo7QUFDRDs7QUFFRDtBQUNBO0FBQ0E7O0FBRUFDLE9BQU9DLE9BQVAsR0FBaUJOLENBQWpCLEM7Ozs7Ozs7OztBQ3BCQTtBQUNBLElBQUlPLFVBQVVGLE9BQU9DLE9BQVAsR0FBaUIsRUFBL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSUUsZ0JBQUo7QUFDQSxJQUFJQyxrQkFBSjs7QUFFQSxTQUFTQyxnQkFBVCxHQUE0QjtBQUN4QixVQUFNLElBQUlDLEtBQUosQ0FBVSxpQ0FB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bDhHLElBQWQsQ0FBbUJ6RixJQUFuQixDQUF3QjtBQUN0QnNCLGNBQU1BLElBRGdCO0FBRXRCb1osbUJBQVdBLFNBRlc7QUFHdEI3QixjQUFNQTtBQUhnQixPQUF4QjtBQUtEOzs7a0NBRXFCO0FBQ3BCLGFBQU84b0csY0FBY2w4RyxJQUFyQjtBQUNEOzs7Ozs7a0JBWGtCazhHLGE7OztBQWNyQkEsY0FBY2w4RyxJQUFkLEdBQXFCLEVBQXJCLEMiLCJmaWxlIjoiYnVuZGxlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdFx0fSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gNDUpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIDUxN2QzMTFmMjgyZjE2NjFiMDc2IiwidmFyIGc7XG5cbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXG5nID0gKGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcztcbn0pKCk7XG5cbnRyeSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxuXHRnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDEsZXZhbCkoXCJ0aGlzXCIpO1xufSBjYXRjaChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpXG5cdFx0ZyA9IHdpbmRvdztcbn1cblxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3Ncbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cblxubW9kdWxlLmV4cG9ydHMgPSBnO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vICh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwiLyoqXG4gKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGVidWcnKTtcbmV4cG9ydHMubG9nID0gbG9nO1xuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5leHBvcnRzLnN0b3JhZ2UgPSAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lXG4gICAgICAgICAgICAgICAmJiAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lLnN0b3JhZ2VcbiAgICAgICAgICAgICAgICAgID8gY2hyb21lLnN0b3JhZ2UubG9jYWxcbiAgICAgICAgICAgICAgICAgIDogbG9jYWxzdG9yYWdlKCk7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gW1xuICAnbGlnaHRzZWFncmVlbicsXG4gICdmb3Jlc3RncmVlbicsXG4gICdnb2xkZW5yb2QnLFxuICAnZG9kZ2VyYmx1ZScsXG4gICdkYXJrb3JjaGlkJyxcbiAgJ2NyaW1zb24nXG5dO1xuXG4vKipcbiAqIEN1cnJlbnRseSBvbmx5IFdlYktpdC1iYXNlZCBXZWIgSW5zcGVjdG9ycywgRmlyZWZveCA+PSB2MzEsXG4gKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cbiAqIHRvIHN1cHBvcnQgXCIlY1wiIENTUyBjdXN0b21pemF0aW9ucy5cbiAqXG4gKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuICovXG5cbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcbiAgLy8gTkI6IEluIGFuIEVsZWN0cm9uIHByZWxvYWQgc2NyaXB0LCBkb2N1bWVudCB3aWxsIGJlIGRlZmluZWQgYnV0IG5vdCBmdWxseVxuICAvLyBpbml0aWFsaXplZC4gU2luY2Ugd2Uga25vdyB3ZSdyZSBpbiBDaHJvbWUsIHdlJ2xsIGp1c3QgZGV0ZWN0IHRoaXMgY2FzZVxuICAvLyBleHBsaWNpdGx5XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucHJvY2VzcyAmJiB3aW5kb3cucHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBpcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuICAvLyBkb2N1bWVudCBpcyB1bmRlZmluZWQgaW4gcmVhY3QtbmF0aXZlOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QtbmF0aXZlL3B1bGwvMTYzMlxuICByZXR1cm4gKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuV2Via2l0QXBwZWFyYW5jZSkgfHxcbiAgICAvLyBpcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXG4gICAgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS5maXJlYnVnIHx8ICh3aW5kb3cuY29uc29sZS5leGNlcHRpb24gJiYgd2luZG93LmNvbnNvbGUudGFibGUpKSkgfHxcbiAgICAvLyBpcyBmaXJlZm94ID49IHYzMT9cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcbiAgICAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSAmJiBwYXJzZUludChSZWdFeHAuJDEsIDEwKSA+PSAzMSkgfHxcbiAgICAvLyBkb3VibGUgY2hlY2sgd2Via2l0IGluIHVzZXJBZ2VudCBqdXN0IGluIGNhc2Ugd2UgYXJlIGluIGEgd29ya2VyXG4gICAgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9hcHBsZXdlYmtpdFxcLyhcXGQrKS8pKTtcbn1cblxuLyoqXG4gKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbih2KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gJ1tVbmV4cGVjdGVkSlNPTlBhcnNlRXJyb3JdOiAnICsgZXJyLm1lc3NhZ2U7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcbiAgdmFyIHVzZUNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuXG4gIGFyZ3NbMF0gPSAodXNlQ29sb3JzID8gJyVjJyA6ICcnKVxuICAgICsgdGhpcy5uYW1lc3BhY2VcbiAgICArICh1c2VDb2xvcnMgPyAnICVjJyA6ICcgJylcbiAgICArIGFyZ3NbMF1cbiAgICArICh1c2VDb2xvcnMgPyAnJWMgJyA6ICcgJylcbiAgICArICcrJyArIGV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcblxuICBpZiAoIXVzZUNvbG9ycykgcmV0dXJuO1xuXG4gIHZhciBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcbiAgYXJncy5zcGxpY2UoMSwgMCwgYywgJ2NvbG9yOiBpbmhlcml0JylcblxuICAvLyB0aGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuICAvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG4gIC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGFzdEMgPSAwO1xuICBhcmdzWzBdLnJlcGxhY2UoLyVbYS16QS1aJV0vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICBpZiAoJyUlJyA9PT0gbWF0Y2gpIHJldHVybjtcbiAgICBpbmRleCsrO1xuICAgIGlmICgnJWMnID09PSBtYXRjaCkge1xuICAgICAgLy8gd2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXG4gICAgICAvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuICAgICAgbGFzdEMgPSBpbmRleDtcbiAgICB9XG4gIH0pO1xuXG4gIGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbn1cblxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmxvZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUubG9nYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBsb2coKSB7XG4gIC8vIHRoaXMgaGFja2VyeSBpcyByZXF1aXJlZCBmb3IgSUU4LzksIHdoZXJlXG4gIC8vIHRoZSBgY29uc29sZS5sb2dgIGZ1bmN0aW9uIGRvZXNuJ3QgaGF2ZSAnYXBwbHknXG4gIHJldHVybiAnb2JqZWN0JyA9PT0gdHlwZW9mIGNvbnNvbGVcbiAgICAmJiBjb25zb2xlLmxvZ1xuICAgICYmIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGUubG9nLCBjb25zb2xlLCBhcmd1bWVudHMpO1xufVxuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcbiAgdHJ5IHtcbiAgICBpZiAobnVsbCA9PSBuYW1lc3BhY2VzKSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLmRlYnVnID0gbmFtZXNwYWNlcztcbiAgICB9XG4gIH0gY2F0Y2goZSkge31cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2FkKCkge1xuICB2YXIgcjtcbiAgdHJ5IHtcbiAgICByID0gZXhwb3J0cy5zdG9yYWdlLmRlYnVnO1xuICB9IGNhdGNoKGUpIHt9XG5cbiAgLy8gSWYgZGVidWcgaXNuJ3Qgc2V0IGluIExTLCBhbmQgd2UncmUgaW4gRWxlY3Ryb24sIHRyeSB0byBsb2FkICRERUJVR1xuICBpZiAoIXIgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICdlbnYnIGluIHByb2Nlc3MpIHtcbiAgICByID0gcHJvY2Vzcy5lbnYuREVCVUc7XG4gIH1cblxuICByZXR1cm4gcjtcbn1cblxuLyoqXG4gKiBFbmFibGUgbmFtZXNwYWNlcyBsaXN0ZWQgaW4gYGxvY2FsU3RvcmFnZS5kZWJ1Z2AgaW5pdGlhbGx5LlxuICovXG5cbmV4cG9ydHMuZW5hYmxlKGxvYWQoKSk7XG5cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCkge1xuICB0cnkge1xuICAgIHJldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlO1xuICB9IGNhdGNoIChlKSB7fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9icm93c2VyLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LmRldmVsb3BtZW50LmpzJyk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QvaW5kZXguanMiLCJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqL1xuXG5mdW5jdGlvbiBtYWtlRW1wdHlGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYXJnO1xuICB9O1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gYWNjZXB0cyBhbmQgZGlzY2FyZHMgaW5wdXRzOyBpdCBoYXMgbm8gc2lkZSBlZmZlY3RzLiBUaGlzIGlzXG4gKiBwcmltYXJpbHkgdXNlZnVsIGlkaW9tYXRpY2FsbHkgZm9yIG92ZXJyaWRhYmxlIGZ1bmN0aW9uIGVuZHBvaW50cyB3aGljaFxuICogYWx3YXlzIG5lZWQgdG8gYmUgY2FsbGFibGUsIHNpbmNlIEpTIGxhY2tzIGEgbnVsbC1jYWxsIGlkaW9tIGFsYSBDb2NvYS5cbiAqL1xudmFyIGVtcHR5RnVuY3Rpb24gPSBmdW5jdGlvbiBlbXB0eUZ1bmN0aW9uKCkge307XG5cbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnMgPSBtYWtlRW1wdHlGdW5jdGlvbjtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZSA9IG1ha2VFbXB0eUZ1bmN0aW9uKGZhbHNlKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlID0gbWFrZUVtcHR5RnVuY3Rpb24odHJ1ZSk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCA9IG1ha2VFbXB0eUZ1bmN0aW9uKG51bGwpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RoaXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzO1xufTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNBcmd1bWVudCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgcmV0dXJuIGFyZztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZW1wdHlGdW5jdGlvbjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZW1wdHlGdW5jdGlvbi5qcyIsIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG4vLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih1c2VTb3VyY2VNYXApIHtcblx0dmFyIGxpc3QgPSBbXTtcblxuXHQvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXG5cdGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRcdHZhciBjb250ZW50ID0gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApO1xuXHRcdFx0aWYoaXRlbVsyXSkge1xuXHRcdFx0XHRyZXR1cm4gXCJAbWVkaWEgXCIgKyBpdGVtWzJdICsgXCJ7XCIgKyBjb250ZW50ICsgXCJ9XCI7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gY29udGVudDtcblx0XHRcdH1cblx0XHR9KS5qb2luKFwiXCIpO1xuXHR9O1xuXG5cdC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XG5cdGxpc3QuaSA9IGZ1bmN0aW9uKG1vZHVsZXMsIG1lZGlhUXVlcnkpIHtcblx0XHRpZih0eXBlb2YgbW9kdWxlcyA9PT0gXCJzdHJpbmdcIilcblx0XHRcdG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsIFwiXCJdXTtcblx0XHR2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaWQgPSB0aGlzW2ldWzBdO1xuXHRcdFx0aWYodHlwZW9mIGlkID09PSBcIm51bWJlclwiKVxuXHRcdFx0XHRhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG5cdFx0fVxuXHRcdGZvcihpID0gMDsgaSA8IG1vZHVsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gbW9kdWxlc1tpXTtcblx0XHRcdC8vIHNraXAgYWxyZWFkeSBpbXBvcnRlZCBtb2R1bGVcblx0XHRcdC8vIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgbm90IDEwMCUgcGVyZmVjdCBmb3Igd2VpcmQgbWVkaWEgcXVlcnkgY29tYmluYXRpb25zXG5cdFx0XHQvLyAgd2hlbiBhIG1vZHVsZSBpcyBpbXBvcnRlZCBtdWx0aXBsZSB0aW1lcyB3aXRoIGRpZmZlcmVudCBtZWRpYSBxdWVyaWVzLlxuXHRcdFx0Ly8gIEkgaG9wZSB0aGlzIHdpbGwgbmV2ZXIgb2NjdXIgKEhleSB0aGlzIHdheSB3ZSBoYXZlIHNtYWxsZXIgYnVuZGxlcylcblx0XHRcdGlmKHR5cGVvZiBpdGVtWzBdICE9PSBcIm51bWJlclwiIHx8ICFhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XG5cdFx0XHRcdGlmKG1lZGlhUXVlcnkgJiYgIWl0ZW1bMl0pIHtcblx0XHRcdFx0XHRpdGVtWzJdID0gbWVkaWFRdWVyeTtcblx0XHRcdFx0fSBlbHNlIGlmKG1lZGlhUXVlcnkpIHtcblx0XHRcdFx0XHRpdGVtWzJdID0gXCIoXCIgKyBpdGVtWzJdICsgXCIpIGFuZCAoXCIgKyBtZWRpYVF1ZXJ5ICsgXCIpXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0bGlzdC5wdXNoKGl0ZW0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0cmV0dXJuIGxpc3Q7XG59O1xuXG5mdW5jdGlvbiBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCkge1xuXHR2YXIgY29udGVudCA9IGl0ZW1bMV0gfHwgJyc7XG5cdHZhciBjc3NNYXBwaW5nID0gaXRlbVszXTtcblx0aWYgKCFjc3NNYXBwaW5nKSB7XG5cdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdH1cblxuXHRpZiAodXNlU291cmNlTWFwICYmIHR5cGVvZiBidG9hID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0dmFyIHNvdXJjZU1hcHBpbmcgPSB0b0NvbW1lbnQoY3NzTWFwcGluZyk7XG5cdFx0dmFyIHNvdXJjZVVSTHMgPSBjc3NNYXBwaW5nLnNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcblx0XHRcdHJldHVybiAnLyojIHNvdXJjZVVSTD0nICsgY3NzTWFwcGluZy5zb3VyY2VSb290ICsgc291cmNlICsgJyAqLydcblx0XHR9KTtcblxuXHRcdHJldHVybiBbY29udGVudF0uY29uY2F0KHNvdXJjZVVSTHMpLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oJ1xcbicpO1xuXHR9XG5cblx0cmV0dXJuIFtjb250ZW50XS5qb2luKCdcXG4nKTtcbn1cblxuLy8gQWRhcHRlZCBmcm9tIGNvbnZlcnQtc291cmNlLW1hcCAoTUlUKVxuZnVuY3Rpb24gdG9Db21tZW50KHNvdXJjZU1hcCkge1xuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcblx0dmFyIGJhc2U2NCA9IGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSk7XG5cdHZhciBkYXRhID0gJ3NvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LCcgKyBiYXNlNjQ7XG5cblx0cmV0dXJuICcvKiMgJyArIGRhdGEgKyAnICovJztcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qcyIsIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG5cbnZhciBzdHlsZXNJbkRvbSA9IHt9O1xuXG52YXJcdG1lbW9pemUgPSBmdW5jdGlvbiAoZm4pIHtcblx0dmFyIG1lbW87XG5cblx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodHlwZW9mIG1lbW8gPT09IFwidW5kZWZpbmVkXCIpIG1lbW8gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdHJldHVybiBtZW1vO1xuXHR9O1xufTtcblxudmFyIGlzT2xkSUUgPSBtZW1vaXplKGZ1bmN0aW9uICgpIHtcblx0Ly8gVGVzdCBmb3IgSUUgPD0gOSBhcyBwcm9wb3NlZCBieSBCcm93c2VyaGFja3Ncblx0Ly8gQHNlZSBodHRwOi8vYnJvd3NlcmhhY2tzLmNvbS8jaGFjay1lNzFkODY5MmY2NTMzNDE3M2ZlZTcxNWMyMjJjYjgwNVxuXHQvLyBUZXN0cyBmb3IgZXhpc3RlbmNlIG9mIHN0YW5kYXJkIGdsb2JhbHMgaXMgdG8gYWxsb3cgc3R5bGUtbG9hZGVyXG5cdC8vIHRvIG9wZXJhdGUgY29ycmVjdGx5IGludG8gbm9uLXN0YW5kYXJkIGVudmlyb25tZW50c1xuXHQvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyL2lzc3Vlcy8xNzdcblx0cmV0dXJuIHdpbmRvdyAmJiBkb2N1bWVudCAmJiBkb2N1bWVudC5hbGwgJiYgIXdpbmRvdy5hdG9iO1xufSk7XG5cbnZhciBnZXRFbGVtZW50ID0gKGZ1bmN0aW9uIChmbikge1xuXHR2YXIgbWVtbyA9IHt9O1xuXG5cdHJldHVybiBmdW5jdGlvbihzZWxlY3Rvcikge1xuXHRcdGlmICh0eXBlb2YgbWVtb1tzZWxlY3Rvcl0gPT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRcdHZhciBzdHlsZVRhcmdldCA9IGZuLmNhbGwodGhpcywgc2VsZWN0b3IpO1xuXHRcdFx0Ly8gU3BlY2lhbCBjYXNlIHRvIHJldHVybiBoZWFkIG9mIGlmcmFtZSBpbnN0ZWFkIG9mIGlmcmFtZSBpdHNlbGZcblx0XHRcdGlmIChzdHlsZVRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdC8vIFRoaXMgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYWNjZXNzIHRvIGlmcmFtZSBpcyBibG9ja2VkXG5cdFx0XHRcdFx0Ly8gZHVlIHRvIGNyb3NzLW9yaWdpbiByZXN0cmljdGlvbnNcblx0XHRcdFx0XHRzdHlsZVRhcmdldCA9IHN0eWxlVGFyZ2V0LmNvbnRlbnREb2N1bWVudC5oZWFkO1xuXHRcdFx0XHR9IGNhdGNoKGUpIHtcblx0XHRcdFx0XHRzdHlsZVRhcmdldCA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdG1lbW9bc2VsZWN0b3JdID0gc3R5bGVUYXJnZXQ7XG5cdFx0fVxuXHRcdHJldHVybiBtZW1vW3NlbGVjdG9yXVxuXHR9O1xufSkoZnVuY3Rpb24gKHRhcmdldCkge1xuXHRyZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpXG59KTtcblxudmFyIHNpbmdsZXRvbiA9IG51bGw7XG52YXJcdHNpbmdsZXRvbkNvdW50ZXIgPSAwO1xudmFyXHRzdHlsZXNJbnNlcnRlZEF0VG9wID0gW107XG5cbnZhclx0Zml4VXJscyA9IHJlcXVpcmUoXCIuL3VybHNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGlzdCwgb3B0aW9ucykge1xuXHRpZiAodHlwZW9mIERFQlVHICE9PSBcInVuZGVmaW5lZFwiICYmIERFQlVHKSB7XG5cdFx0aWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJvYmplY3RcIikgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50XCIpO1xuXHR9XG5cblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0b3B0aW9ucy5hdHRycyA9IHR5cGVvZiBvcHRpb25zLmF0dHJzID09PSBcIm9iamVjdFwiID8gb3B0aW9ucy5hdHRycyA6IHt9O1xuXG5cdC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxuXHQvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG5cdGlmICghb3B0aW9ucy5zaW5nbGV0b24gJiYgdHlwZW9mIG9wdGlvbnMuc2luZ2xldG9uICE9PSBcImJvb2xlYW5cIikgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XG5cblx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgPGhlYWQ+IGVsZW1lbnRcblx0aWYgKCFvcHRpb25zLmluc2VydEludG8pIG9wdGlvbnMuaW5zZXJ0SW50byA9IFwiaGVhZFwiO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIGJvdHRvbSBvZiB0aGUgdGFyZ2V0XG5cdGlmICghb3B0aW9ucy5pbnNlcnRBdCkgb3B0aW9ucy5pbnNlcnRBdCA9IFwiYm90dG9tXCI7XG5cblx0dmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhsaXN0LCBvcHRpb25zKTtcblxuXHRhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGUgKG5ld0xpc3QpIHtcblx0XHR2YXIgbWF5UmVtb3ZlID0gW107XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblxuXHRcdFx0ZG9tU3R5bGUucmVmcy0tO1xuXHRcdFx0bWF5UmVtb3ZlLnB1c2goZG9tU3R5bGUpO1xuXHRcdH1cblxuXHRcdGlmKG5ld0xpc3QpIHtcblx0XHRcdHZhciBuZXdTdHlsZXMgPSBsaXN0VG9TdHlsZXMobmV3TGlzdCwgb3B0aW9ucyk7XG5cdFx0XHRhZGRTdHlsZXNUb0RvbShuZXdTdHlsZXMsIG9wdGlvbnMpO1xuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBtYXlSZW1vdmVbaV07XG5cblx0XHRcdGlmKGRvbVN0eWxlLnJlZnMgPT09IDApIHtcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykgZG9tU3R5bGUucGFydHNbal0oKTtcblxuXHRcdFx0XHRkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn07XG5cbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tIChzdHlsZXMsIG9wdGlvbnMpIHtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcblx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblxuXHRcdGlmKGRvbVN0eWxlKSB7XG5cdFx0XHRkb21TdHlsZS5yZWZzKys7XG5cblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yKDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBwYXJ0cyA9IFtdO1xuXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRwYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdH1cblxuXHRcdFx0c3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7aWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0c307XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGxpc3RUb1N0eWxlcyAobGlzdCwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGVzID0gW107XG5cdHZhciBuZXdTdHlsZXMgPSB7fTtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IGxpc3RbaV07XG5cdFx0dmFyIGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG5cdFx0dmFyIGNzcyA9IGl0ZW1bMV07XG5cdFx0dmFyIG1lZGlhID0gaXRlbVsyXTtcblx0XHR2YXIgc291cmNlTWFwID0gaXRlbVszXTtcblx0XHR2YXIgcGFydCA9IHtjc3M6IGNzcywgbWVkaWE6IG1lZGlhLCBzb3VyY2VNYXA6IHNvdXJjZU1hcH07XG5cblx0XHRpZighbmV3U3R5bGVzW2lkXSkgc3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHtpZDogaWQsIHBhcnRzOiBbcGFydF19KTtcblx0XHRlbHNlIG5ld1N0eWxlc1tpZF0ucGFydHMucHVzaChwYXJ0KTtcblx0fVxuXG5cdHJldHVybiBzdHlsZXM7XG59XG5cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudCAob3B0aW9ucywgc3R5bGUpIHtcblx0dmFyIHRhcmdldCA9IGdldEVsZW1lbnQob3B0aW9ucy5pbnNlcnRJbnRvKVxuXG5cdGlmICghdGFyZ2V0KSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnRJbnRvJyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG5cdH1cblxuXHR2YXIgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AgPSBzdHlsZXNJbnNlcnRlZEF0VG9wW3N0eWxlc0luc2VydGVkQXRUb3AubGVuZ3RoIC0gMV07XG5cblx0aWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidG9wXCIpIHtcblx0XHRpZiAoIWxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wKSB7XG5cdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCB0YXJnZXQuZmlyc3RDaGlsZCk7XG5cdFx0fSBlbHNlIGlmIChsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZykge1xuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHRcdH1cblx0XHRzdHlsZXNJbnNlcnRlZEF0VG9wLnB1c2goc3R5bGUpO1xuXHR9IGVsc2UgaWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwiYm90dG9tXCIpIHtcblx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLmluc2VydEF0ID09PSBcIm9iamVjdFwiICYmIG9wdGlvbnMuaW5zZXJ0QXQuYmVmb3JlKSB7XG5cdFx0dmFyIG5leHRTaWJsaW5nID0gZ2V0RWxlbWVudChvcHRpb25zLmluc2VydEludG8gKyBcIiBcIiArIG9wdGlvbnMuaW5zZXJ0QXQuYmVmb3JlKTtcblx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCBuZXh0U2libGluZyk7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiW1N0eWxlIExvYWRlcl1cXG5cXG4gSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyICdpbnNlcnRBdCcgKCdvcHRpb25zLmluc2VydEF0JykgZm91bmQuXFxuIE11c3QgYmUgJ3RvcCcsICdib3R0b20nLCBvciBPYmplY3QuXFxuIChodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlciNpbnNlcnRhdClcXG5cIik7XG5cdH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50IChzdHlsZSkge1xuXHRpZiAoc3R5bGUucGFyZW50Tm9kZSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXHRzdHlsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlKTtcblxuXHR2YXIgaWR4ID0gc3R5bGVzSW5zZXJ0ZWRBdFRvcC5pbmRleE9mKHN0eWxlKTtcblx0aWYoaWR4ID49IDApIHtcblx0XHRzdHlsZXNJbnNlcnRlZEF0VG9wLnNwbGljZShpZHgsIDEpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudCAob3B0aW9ucykge1xuXHR2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG5cblx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXG5cdGFkZEF0dHJzKHN0eWxlLCBvcHRpb25zLmF0dHJzKTtcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIHN0eWxlKTtcblxuXHRyZXR1cm4gc3R5bGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxpbmtFbGVtZW50IChvcHRpb25zKSB7XG5cdHZhciBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XG5cblx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXHRvcHRpb25zLmF0dHJzLnJlbCA9IFwic3R5bGVzaGVldFwiO1xuXG5cdGFkZEF0dHJzKGxpbmssIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgbGluayk7XG5cblx0cmV0dXJuIGxpbms7XG59XG5cbmZ1bmN0aW9uIGFkZEF0dHJzIChlbCwgYXR0cnMpIHtcblx0T2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHRcdGVsLnNldEF0dHJpYnV0ZShrZXksIGF0dHJzW2tleV0pO1xuXHR9KTtcbn1cblxuZnVuY3Rpb24gYWRkU3R5bGUgKG9iaiwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGUsIHVwZGF0ZSwgcmVtb3ZlLCByZXN1bHQ7XG5cblx0Ly8gSWYgYSB0cmFuc2Zvcm0gZnVuY3Rpb24gd2FzIGRlZmluZWQsIHJ1biBpdCBvbiB0aGUgY3NzXG5cdGlmIChvcHRpb25zLnRyYW5zZm9ybSAmJiBvYmouY3NzKSB7XG5cdCAgICByZXN1bHQgPSBvcHRpb25zLnRyYW5zZm9ybShvYmouY3NzKTtcblxuXHQgICAgaWYgKHJlc3VsdCkge1xuXHQgICAgXHQvLyBJZiB0cmFuc2Zvcm0gcmV0dXJucyBhIHZhbHVlLCB1c2UgdGhhdCBpbnN0ZWFkIG9mIHRoZSBvcmlnaW5hbCBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIHJ1bm5pbmcgcnVudGltZSB0cmFuc2Zvcm1hdGlvbnMgb24gdGhlIGNzcy5cblx0ICAgIFx0b2JqLmNzcyA9IHJlc3VsdDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICBcdC8vIElmIHRoZSB0cmFuc2Zvcm0gZnVuY3Rpb24gcmV0dXJucyBhIGZhbHN5IHZhbHVlLCBkb24ndCBhZGQgdGhpcyBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIGNvbmRpdGlvbmFsIGxvYWRpbmcgb2YgY3NzXG5cdCAgICBcdHJldHVybiBmdW5jdGlvbigpIHtcblx0ICAgIFx0XHQvLyBub29wXG5cdCAgICBcdH07XG5cdCAgICB9XG5cdH1cblxuXHRpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcblx0XHR2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcblxuXHRcdHN0eWxlID0gc2luZ2xldG9uIHx8IChzaW5nbGV0b24gPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykpO1xuXG5cdFx0dXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCBmYWxzZSk7XG5cdFx0cmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCB0cnVlKTtcblxuXHR9IGVsc2UgaWYgKFxuXHRcdG9iai5zb3VyY2VNYXAgJiZcblx0XHR0eXBlb2YgVVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLmNyZWF0ZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIFVSTC5yZXZva2VPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBCbG9iID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiXG5cdCkge1xuXHRcdHN0eWxlID0gY3JlYXRlTGlua0VsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gdXBkYXRlTGluay5iaW5kKG51bGwsIHN0eWxlLCBvcHRpb25zKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXG5cdFx0XHRpZihzdHlsZS5ocmVmKSBVUkwucmV2b2tlT2JqZWN0VVJMKHN0eWxlLmhyZWYpO1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0c3R5bGUgPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXHRcdH07XG5cdH1cblxuXHR1cGRhdGUob2JqKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG5ld09iaikge1xuXHRcdGlmIChuZXdPYmopIHtcblx0XHRcdGlmIChcblx0XHRcdFx0bmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJlxuXHRcdFx0XHRuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJlxuXHRcdFx0XHRuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwXG5cdFx0XHQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR1cGRhdGUob2JqID0gbmV3T2JqKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVtb3ZlKCk7XG5cdFx0fVxuXHR9O1xufVxuXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xuXHR2YXIgdGV4dFN0b3JlID0gW107XG5cblx0cmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcblx0XHR0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG5cblx0XHRyZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKTtcblx0fTtcbn0pKCk7XG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcgKHN0eWxlLCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcblx0dmFyIGNzcyA9IHJlbW92ZSA/IFwiXCIgOiBvYmouY3NzO1xuXG5cdGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xuXHRcdHZhciBjaGlsZE5vZGVzID0gc3R5bGUuY2hpbGROb2RlcztcblxuXHRcdGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuXG5cdFx0aWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XG5cdFx0XHRzdHlsZS5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdHlsZS5hcHBlbmRDaGlsZChjc3NOb2RlKTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyAoc3R5bGUsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIG1lZGlhID0gb2JqLm1lZGlhO1xuXG5cdGlmKG1lZGlhKSB7XG5cdFx0c3R5bGUuc2V0QXR0cmlidXRlKFwibWVkaWFcIiwgbWVkaWEpXG5cdH1cblxuXHRpZihzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuXHR9IGVsc2Uge1xuXHRcdHdoaWxlKHN0eWxlLmZpcnN0Q2hpbGQpIHtcblx0XHRcdHN0eWxlLnJlbW92ZUNoaWxkKHN0eWxlLmZpcnN0Q2hpbGQpO1xuXHRcdH1cblxuXHRcdHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpbmsgKGxpbmssIG9wdGlvbnMsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cblx0Lypcblx0XHRJZiBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgaXNuJ3QgZGVmaW5lZCwgYnV0IHNvdXJjZW1hcHMgYXJlIGVuYWJsZWRcblx0XHRhbmQgdGhlcmUgaXMgbm8gcHVibGljUGF0aCBkZWZpbmVkIHRoZW4gbGV0cyB0dXJuIGNvbnZlcnRUb0Fic29sdXRlVXJsc1xuXHRcdG9uIGJ5IGRlZmF1bHQuICBPdGhlcndpc2UgZGVmYXVsdCB0byB0aGUgY29udmVydFRvQWJzb2x1dGVVcmxzIG9wdGlvblxuXHRcdGRpcmVjdGx5XG5cdCovXG5cdHZhciBhdXRvRml4VXJscyA9IG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzID09PSB1bmRlZmluZWQgJiYgc291cmNlTWFwO1xuXG5cdGlmIChvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyB8fCBhdXRvRml4VXJscykge1xuXHRcdGNzcyA9IGZpeFVybHMoY3NzKTtcblx0fVxuXG5cdGlmIChzb3VyY2VNYXApIHtcblx0XHQvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjYwMzg3NVxuXHRcdGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcblx0fVxuXG5cdHZhciBibG9iID0gbmV3IEJsb2IoW2Nzc10sIHsgdHlwZTogXCJ0ZXh0L2Nzc1wiIH0pO1xuXG5cdHZhciBvbGRTcmMgPSBsaW5rLmhyZWY7XG5cblx0bGluay5ocmVmID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcblxuXHRpZihvbGRTcmMpIFVSTC5yZXZva2VPYmplY3RVUkwob2xkU3JjKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXG4vLyBtb2R1bGUgaWQgPSA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG4vKipcclxuICogRXhwb3NlIGBFbWl0dGVyYC5cclxuICovXHJcblxyXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICBtb2R1bGUuZXhwb3J0cyA9IEVtaXR0ZXI7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBJbml0aWFsaXplIGEgbmV3IGBFbWl0dGVyYC5cclxuICpcclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5mdW5jdGlvbiBFbWl0dGVyKG9iaikge1xyXG4gIGlmIChvYmopIHJldHVybiBtaXhpbihvYmopO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIE1peGluIHRoZSBlbWl0dGVyIHByb3BlcnRpZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcclxuICogQHJldHVybiB7T2JqZWN0fVxyXG4gKiBAYXBpIHByaXZhdGVcclxuICovXHJcblxyXG5mdW5jdGlvbiBtaXhpbihvYmopIHtcclxuICBmb3IgKHZhciBrZXkgaW4gRW1pdHRlci5wcm90b3R5cGUpIHtcclxuICAgIG9ialtrZXldID0gRW1pdHRlci5wcm90b3R5cGVba2V5XTtcclxuICB9XHJcbiAgcmV0dXJuIG9iajtcclxufVxyXG5cclxuLyoqXHJcbiAqIExpc3RlbiBvbiB0aGUgZ2l2ZW4gYGV2ZW50YCB3aXRoIGBmbmAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLm9uID1cclxuRW1pdHRlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG4gICh0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXSlcclxuICAgIC5wdXNoKGZuKTtcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBZGRzIGFuIGBldmVudGAgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGludm9rZWQgYSBzaW5nbGVcclxuICogdGltZSB0aGVuIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XHJcbiAgZnVuY3Rpb24gb24oKSB7XHJcbiAgICB0aGlzLm9mZihldmVudCwgb24pO1xyXG4gICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICB9XHJcblxyXG4gIG9uLmZuID0gZm47XHJcbiAgdGhpcy5vbihldmVudCwgb24pO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZSB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGBldmVudGAgb3IgYWxsXHJcbiAqIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5vZmYgPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuXHJcbiAgLy8gYWxsXHJcbiAgaWYgKDAgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgdGhpcy5fY2FsbGJhY2tzID0ge307XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8vIHNwZWNpZmljIGV2ZW50XHJcbiAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcbiAgaWYgKCFjYWxsYmFja3MpIHJldHVybiB0aGlzO1xyXG5cclxuICAvLyByZW1vdmUgYWxsIGhhbmRsZXJzXHJcbiAgaWYgKDEgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8vIHJlbW92ZSBzcGVjaWZpYyBoYW5kbGVyXHJcbiAgdmFyIGNiO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBjYiA9IGNhbGxiYWNrc1tpXTtcclxuICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XHJcbiAgICAgIGNhbGxiYWNrcy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBFbWl0IGBldmVudGAgd2l0aCB0aGUgZ2l2ZW4gYXJncy5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7TWl4ZWR9IC4uLlxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbihldmVudCl7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG4gIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpXHJcbiAgICAsIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcblxyXG4gIGlmIChjYWxsYmFja3MpIHtcclxuICAgIGNhbGxiYWNrcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcclxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcclxuICAgICAgY2FsbGJhY2tzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJuIGFycmF5IG9mIGNhbGxiYWNrcyBmb3IgYGV2ZW50YC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEByZXR1cm4ge0FycmF5fVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcbiAgcmV0dXJuIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gfHwgW107XHJcbn07XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgdGhpcyBlbWl0dGVyIGhhcyBgZXZlbnRgIGhhbmRsZXJzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHJldHVybiB7Qm9vbGVhbn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5oYXNMaXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XHJcbiAgcmV0dXJuICEhIHRoaXMubGlzdGVuZXJzKGV2ZW50KS5sZW5ndGg7XHJcbn07XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb21wb25lbnQtZW1pdHRlci9pbmRleC5qcyIsIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xudmFyIGhhc0JpbmFyeSA9IHJlcXVpcmUoJ2hhcy1iaW5hcnkyJyk7XG52YXIgc2xpY2VCdWZmZXIgPSByZXF1aXJlKCdhcnJheWJ1ZmZlci5zbGljZScpO1xudmFyIGFmdGVyID0gcmVxdWlyZSgnYWZ0ZXInKTtcbnZhciB1dGY4ID0gcmVxdWlyZSgnLi91dGY4Jyk7XG5cbnZhciBiYXNlNjRlbmNvZGVyO1xuaWYgKGdsb2JhbCAmJiBnbG9iYWwuQXJyYXlCdWZmZXIpIHtcbiAgYmFzZTY0ZW5jb2RlciA9IHJlcXVpcmUoJ2Jhc2U2NC1hcnJheWJ1ZmZlcicpO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHdlIGFyZSBydW5uaW5nIGFuIGFuZHJvaWQgYnJvd3Nlci4gVGhhdCByZXF1aXJlcyB1cyB0byB1c2VcbiAqIEFycmF5QnVmZmVyIHdpdGggcG9sbGluZyB0cmFuc3BvcnRzLi4uXG4gKlxuICogaHR0cDovL2doaW5kYS5uZXQvanBlZy1ibG9iLWFqYXgtYW5kcm9pZC9cbiAqL1xuXG52YXIgaXNBbmRyb2lkID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL0FuZHJvaWQvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG4vKipcbiAqIENoZWNrIGlmIHdlIGFyZSBydW5uaW5nIGluIFBoYW50b21KUy5cbiAqIFVwbG9hZGluZyBhIEJsb2Igd2l0aCBQaGFudG9tSlMgZG9lcyBub3Qgd29yayBjb3JyZWN0bHksIGFzIHJlcG9ydGVkIGhlcmU6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vYXJpeWEvcGhhbnRvbWpzL2lzc3Vlcy8xMTM5NVxuICogQHR5cGUgYm9vbGVhblxuICovXG52YXIgaXNQaGFudG9tSlMgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvUGhhbnRvbUpTL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuLyoqXG4gKiBXaGVuIHRydWUsIGF2b2lkcyB1c2luZyBCbG9icyB0byBlbmNvZGUgcGF5bG9hZHMuXG4gKiBAdHlwZSBib29sZWFuXG4gKi9cbnZhciBkb250U2VuZEJsb2JzID0gaXNBbmRyb2lkIHx8IGlzUGhhbnRvbUpTO1xuXG4vKipcbiAqIEN1cnJlbnQgcHJvdG9jb2wgdmVyc2lvbi5cbiAqL1xuXG5leHBvcnRzLnByb3RvY29sID0gMztcblxuLyoqXG4gKiBQYWNrZXQgdHlwZXMuXG4gKi9cblxudmFyIHBhY2tldHMgPSBleHBvcnRzLnBhY2tldHMgPSB7XG4gICAgb3BlbjogICAgIDAgICAgLy8gbm9uLXdzXG4gICwgY2xvc2U6ICAgIDEgICAgLy8gbm9uLXdzXG4gICwgcGluZzogICAgIDJcbiAgLCBwb25nOiAgICAgM1xuICAsIG1lc3NhZ2U6ICA0XG4gICwgdXBncmFkZTogIDVcbiAgLCBub29wOiAgICAgNlxufTtcblxudmFyIHBhY2tldHNsaXN0ID0ga2V5cyhwYWNrZXRzKTtcblxuLyoqXG4gKiBQcmVtYWRlIGVycm9yIHBhY2tldC5cbiAqL1xuXG52YXIgZXJyID0geyB0eXBlOiAnZXJyb3InLCBkYXRhOiAncGFyc2VyIGVycm9yJyB9O1xuXG4vKipcbiAqIENyZWF0ZSBhIGJsb2IgYXBpIGV2ZW4gZm9yIGJsb2IgYnVpbGRlciB3aGVuIHZlbmRvciBwcmVmaXhlcyBleGlzdFxuICovXG5cbnZhciBCbG9iID0gcmVxdWlyZSgnYmxvYicpO1xuXG4vKipcbiAqIEVuY29kZXMgYSBwYWNrZXQuXG4gKlxuICogICAgIDxwYWNrZXQgdHlwZSBpZD4gWyA8ZGF0YT4gXVxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgIDVoZWxsbyB3b3JsZFxuICogICAgIDNcbiAqICAgICA0XG4gKlxuICogQmluYXJ5IGlzIGVuY29kZWQgaW4gYW4gaWRlbnRpY2FsIHByaW5jaXBsZVxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZW5jb2RlUGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIHV0ZjhlbmNvZGUsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygc3VwcG9ydHNCaW5hcnkgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IHN1cHBvcnRzQmluYXJ5O1xuICAgIHN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG4gIH1cblxuICBpZiAodHlwZW9mIHV0ZjhlbmNvZGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IHV0ZjhlbmNvZGU7XG4gICAgdXRmOGVuY29kZSA9IG51bGw7XG4gIH1cblxuICB2YXIgZGF0YSA9IChwYWNrZXQuZGF0YSA9PT0gdW5kZWZpbmVkKVxuICAgID8gdW5kZWZpbmVkXG4gICAgOiBwYWNrZXQuZGF0YS5idWZmZXIgfHwgcGFja2V0LmRhdGE7XG5cbiAgaWYgKGdsb2JhbC5BcnJheUJ1ZmZlciAmJiBkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZW5jb2RlQXJyYXlCdWZmZXIocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spO1xuICB9IGVsc2UgaWYgKEJsb2IgJiYgZGF0YSBpbnN0YW5jZW9mIGdsb2JhbC5CbG9iKSB7XG4gICAgcmV0dXJuIGVuY29kZUJsb2IocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spO1xuICB9XG5cbiAgLy8gbWlnaHQgYmUgYW4gb2JqZWN0IHdpdGggeyBiYXNlNjQ6IHRydWUsIGRhdGE6IGRhdGFBc0Jhc2U2NFN0cmluZyB9XG4gIGlmIChkYXRhICYmIGRhdGEuYmFzZTY0KSB7XG4gICAgcmV0dXJuIGVuY29kZUJhc2U2NE9iamVjdChwYWNrZXQsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8vIFNlbmRpbmcgZGF0YSBhcyBhIHV0Zi04IHN0cmluZ1xuICB2YXIgZW5jb2RlZCA9IHBhY2tldHNbcGFja2V0LnR5cGVdO1xuXG4gIC8vIGRhdGEgZnJhZ21lbnQgaXMgb3B0aW9uYWxcbiAgaWYgKHVuZGVmaW5lZCAhPT0gcGFja2V0LmRhdGEpIHtcbiAgICBlbmNvZGVkICs9IHV0ZjhlbmNvZGUgPyB1dGY4LmVuY29kZShTdHJpbmcocGFja2V0LmRhdGEpLCB7IHN0cmljdDogZmFsc2UgfSkgOiBTdHJpbmcocGFja2V0LmRhdGEpO1xuICB9XG5cbiAgcmV0dXJuIGNhbGxiYWNrKCcnICsgZW5jb2RlZCk7XG5cbn07XG5cbmZ1bmN0aW9uIGVuY29kZUJhc2U2NE9iamVjdChwYWNrZXQsIGNhbGxiYWNrKSB7XG4gIC8vIHBhY2tldCBkYXRhIGlzIGFuIG9iamVjdCB7IGJhc2U2NDogdHJ1ZSwgZGF0YTogZGF0YUFzQmFzZTY0U3RyaW5nIH1cbiAgdmFyIG1lc3NhZ2UgPSAnYicgKyBleHBvcnRzLnBhY2tldHNbcGFja2V0LnR5cGVdICsgcGFja2V0LmRhdGEuZGF0YTtcbiAgcmV0dXJuIGNhbGxiYWNrKG1lc3NhZ2UpO1xufVxuXG4vKipcbiAqIEVuY29kZSBwYWNrZXQgaGVscGVycyBmb3IgYmluYXJ5IHR5cGVzXG4gKi9cblxuZnVuY3Rpb24gZW5jb2RlQXJyYXlCdWZmZXIocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spIHtcbiAgaWYgKCFzdXBwb3J0c0JpbmFyeSkge1xuICAgIHJldHVybiBleHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldChwYWNrZXQsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIHZhciBkYXRhID0gcGFja2V0LmRhdGE7XG4gIHZhciBjb250ZW50QXJyYXkgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgdmFyIHJlc3VsdEJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KDEgKyBkYXRhLmJ5dGVMZW5ndGgpO1xuXG4gIHJlc3VsdEJ1ZmZlclswXSA9IHBhY2tldHNbcGFja2V0LnR5cGVdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnRlbnRBcnJheS5sZW5ndGg7IGkrKykge1xuICAgIHJlc3VsdEJ1ZmZlcltpKzFdID0gY29udGVudEFycmF5W2ldO1xuICB9XG5cbiAgcmV0dXJuIGNhbGxiYWNrKHJlc3VsdEJ1ZmZlci5idWZmZXIpO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVCbG9iQXNBcnJheUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuICBpZiAoIXN1cHBvcnRzQmluYXJ5KSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZW5jb2RlQmFzZTY0UGFja2V0KHBhY2tldCwgY2FsbGJhY2spO1xuICB9XG5cbiAgdmFyIGZyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgZnIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgcGFja2V0LmRhdGEgPSBmci5yZXN1bHQ7XG4gICAgZXhwb3J0cy5lbmNvZGVQYWNrZXQocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgdHJ1ZSwgY2FsbGJhY2spO1xuICB9O1xuICByZXR1cm4gZnIucmVhZEFzQXJyYXlCdWZmZXIocGFja2V0LmRhdGEpO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVCbG9iKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKSB7XG4gIGlmICghc3VwcG9ydHNCaW5hcnkpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVCYXNlNjRQYWNrZXQocGFja2V0LCBjYWxsYmFjayk7XG4gIH1cblxuICBpZiAoZG9udFNlbmRCbG9icykge1xuICAgIHJldHVybiBlbmNvZGVCbG9iQXNBcnJheUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjayk7XG4gIH1cblxuICB2YXIgbGVuZ3RoID0gbmV3IFVpbnQ4QXJyYXkoMSk7XG4gIGxlbmd0aFswXSA9IHBhY2tldHNbcGFja2V0LnR5cGVdO1xuICB2YXIgYmxvYiA9IG5ldyBCbG9iKFtsZW5ndGguYnVmZmVyLCBwYWNrZXQuZGF0YV0pO1xuXG4gIHJldHVybiBjYWxsYmFjayhibG9iKTtcbn1cblxuLyoqXG4gKiBFbmNvZGVzIGEgcGFja2V0IHdpdGggYmluYXJ5IGRhdGEgaW4gYSBiYXNlNjQgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldCwgaGFzIGB0eXBlYCBhbmQgYGRhdGFgXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGJhc2U2NCBlbmNvZGVkIG1lc3NhZ2VcbiAqL1xuXG5leHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldCA9IGZ1bmN0aW9uKHBhY2tldCwgY2FsbGJhY2spIHtcbiAgdmFyIG1lc3NhZ2UgPSAnYicgKyBleHBvcnRzLnBhY2tldHNbcGFja2V0LnR5cGVdO1xuICBpZiAoQmxvYiAmJiBwYWNrZXQuZGF0YSBpbnN0YW5jZW9mIGdsb2JhbC5CbG9iKSB7XG4gICAgdmFyIGZyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICBmci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBiNjQgPSBmci5yZXN1bHQuc3BsaXQoJywnKVsxXTtcbiAgICAgIGNhbGxiYWNrKG1lc3NhZ2UgKyBiNjQpO1xuICAgIH07XG4gICAgcmV0dXJuIGZyLnJlYWRBc0RhdGFVUkwocGFja2V0LmRhdGEpO1xuICB9XG5cbiAgdmFyIGI2NGRhdGE7XG4gIHRyeSB7XG4gICAgYjY0ZGF0YSA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQ4QXJyYXkocGFja2V0LmRhdGEpKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIGlQaG9uZSBTYWZhcmkgZG9lc24ndCBsZXQgeW91IGFwcGx5IHdpdGggdHlwZWQgYXJyYXlzXG4gICAgdmFyIHR5cGVkID0gbmV3IFVpbnQ4QXJyYXkocGFja2V0LmRhdGEpO1xuICAgIHZhciBiYXNpYyA9IG5ldyBBcnJheSh0eXBlZC5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGJhc2ljW2ldID0gdHlwZWRbaV07XG4gICAgfVxuICAgIGI2NGRhdGEgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGJhc2ljKTtcbiAgfVxuICBtZXNzYWdlICs9IGdsb2JhbC5idG9hKGI2NGRhdGEpO1xuICByZXR1cm4gY2FsbGJhY2sobWVzc2FnZSk7XG59O1xuXG4vKipcbiAqIERlY29kZXMgYSBwYWNrZXQuIENoYW5nZXMgZm9ybWF0IHRvIEJsb2IgaWYgcmVxdWVzdGVkLlxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gd2l0aCBgdHlwZWAgYW5kIGBkYXRhYCAoaWYgYW55KVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5kZWNvZGVQYWNrZXQgPSBmdW5jdGlvbiAoZGF0YSwgYmluYXJ5VHlwZSwgdXRmOGRlY29kZSkge1xuICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGVycjtcbiAgfVxuICAvLyBTdHJpbmcgZGF0YVxuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKGRhdGEuY2hhckF0KDApID09PSAnYicpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmRlY29kZUJhc2U2NFBhY2tldChkYXRhLnN1YnN0cigxKSwgYmluYXJ5VHlwZSk7XG4gICAgfVxuXG4gICAgaWYgKHV0ZjhkZWNvZGUpIHtcbiAgICAgIGRhdGEgPSB0cnlEZWNvZGUoZGF0YSk7XG4gICAgICBpZiAoZGF0YSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHR5cGUgPSBkYXRhLmNoYXJBdCgwKTtcblxuICAgIGlmIChOdW1iZXIodHlwZSkgIT0gdHlwZSB8fCAhcGFja2V0c2xpc3RbdHlwZV0pIHtcbiAgICAgIHJldHVybiBlcnI7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEubGVuZ3RoID4gMSkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogcGFja2V0c2xpc3RbdHlwZV0sIGRhdGE6IGRhdGEuc3Vic3RyaW5nKDEpIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IHBhY2tldHNsaXN0W3R5cGVdIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIGFzQXJyYXkgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgdmFyIHR5cGUgPSBhc0FycmF5WzBdO1xuICB2YXIgcmVzdCA9IHNsaWNlQnVmZmVyKGRhdGEsIDEpO1xuICBpZiAoQmxvYiAmJiBiaW5hcnlUeXBlID09PSAnYmxvYicpIHtcbiAgICByZXN0ID0gbmV3IEJsb2IoW3Jlc3RdKTtcbiAgfVxuICByZXR1cm4geyB0eXBlOiBwYWNrZXRzbGlzdFt0eXBlXSwgZGF0YTogcmVzdCB9O1xufTtcblxuZnVuY3Rpb24gdHJ5RGVjb2RlKGRhdGEpIHtcbiAgdHJ5IHtcbiAgICBkYXRhID0gdXRmOC5kZWNvZGUoZGF0YSwgeyBzdHJpY3Q6IGZhbHNlIH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIERlY29kZXMgYSBwYWNrZXQgZW5jb2RlZCBpbiBhIGJhc2U2NCBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYmFzZTY0IGVuY29kZWQgbWVzc2FnZVxuICogQHJldHVybiB7T2JqZWN0fSB3aXRoIGB0eXBlYCBhbmQgYGRhdGFgIChpZiBhbnkpXG4gKi9cblxuZXhwb3J0cy5kZWNvZGVCYXNlNjRQYWNrZXQgPSBmdW5jdGlvbihtc2csIGJpbmFyeVR5cGUpIHtcbiAgdmFyIHR5cGUgPSBwYWNrZXRzbGlzdFttc2cuY2hhckF0KDApXTtcbiAgaWYgKCFiYXNlNjRlbmNvZGVyKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogdHlwZSwgZGF0YTogeyBiYXNlNjQ6IHRydWUsIGRhdGE6IG1zZy5zdWJzdHIoMSkgfSB9O1xuICB9XG5cbiAgdmFyIGRhdGEgPSBiYXNlNjRlbmNvZGVyLmRlY29kZShtc2cuc3Vic3RyKDEpKTtcblxuICBpZiAoYmluYXJ5VHlwZSA9PT0gJ2Jsb2InICYmIEJsb2IpIHtcbiAgICBkYXRhID0gbmV3IEJsb2IoW2RhdGFdKTtcbiAgfVxuXG4gIHJldHVybiB7IHR5cGU6IHR5cGUsIGRhdGE6IGRhdGEgfTtcbn07XG5cbi8qKlxuICogRW5jb2RlcyBtdWx0aXBsZSBtZXNzYWdlcyAocGF5bG9hZCkuXG4gKlxuICogICAgIDxsZW5ndGg+OmRhdGFcbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICAxMTpoZWxsbyB3b3JsZDI6aGlcbiAqXG4gKiBJZiBhbnkgY29udGVudHMgYXJlIGJpbmFyeSwgdGhleSB3aWxsIGJlIGVuY29kZWQgYXMgYmFzZTY0IHN0cmluZ3MuIEJhc2U2NFxuICogZW5jb2RlZCBzdHJpbmdzIGFyZSBtYXJrZWQgd2l0aCBhIGIgYmVmb3JlIHRoZSBsZW5ndGggc3BlY2lmaWVyXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcGFja2V0c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5lbmNvZGVQYXlsb2FkID0gZnVuY3Rpb24gKHBhY2tldHMsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIHN1cHBvcnRzQmluYXJ5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBzdXBwb3J0c0JpbmFyeTtcbiAgICBzdXBwb3J0c0JpbmFyeSA9IG51bGw7XG4gIH1cblxuICB2YXIgaXNCaW5hcnkgPSBoYXNCaW5hcnkocGFja2V0cyk7XG5cbiAgaWYgKHN1cHBvcnRzQmluYXJ5ICYmIGlzQmluYXJ5KSB7XG4gICAgaWYgKEJsb2IgJiYgIWRvbnRTZW5kQmxvYnMpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmVuY29kZVBheWxvYWRBc0Jsb2IocGFja2V0cywgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIHJldHVybiBleHBvcnRzLmVuY29kZVBheWxvYWRBc0FycmF5QnVmZmVyKHBhY2tldHMsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGlmICghcGFja2V0cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gY2FsbGJhY2soJzA6Jyk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRMZW5ndGhIZWFkZXIobWVzc2FnZSkge1xuICAgIHJldHVybiBtZXNzYWdlLmxlbmd0aCArICc6JyArIG1lc3NhZ2U7XG4gIH1cblxuICBmdW5jdGlvbiBlbmNvZGVPbmUocGFja2V0LCBkb25lQ2FsbGJhY2spIHtcbiAgICBleHBvcnRzLmVuY29kZVBhY2tldChwYWNrZXQsICFpc0JpbmFyeSA/IGZhbHNlIDogc3VwcG9ydHNCaW5hcnksIGZhbHNlLCBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICBkb25lQ2FsbGJhY2sobnVsbCwgc2V0TGVuZ3RoSGVhZGVyKG1lc3NhZ2UpKTtcbiAgICB9KTtcbiAgfVxuXG4gIG1hcChwYWNrZXRzLCBlbmNvZGVPbmUsIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICAgIHJldHVybiBjYWxsYmFjayhyZXN1bHRzLmpvaW4oJycpKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEFzeW5jIGFycmF5IG1hcCB1c2luZyBhZnRlclxuICovXG5cbmZ1bmN0aW9uIG1hcChhcnksIGVhY2gsIGRvbmUpIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShhcnkubGVuZ3RoKTtcbiAgdmFyIG5leHQgPSBhZnRlcihhcnkubGVuZ3RoLCBkb25lKTtcblxuICB2YXIgZWFjaFdpdGhJbmRleCA9IGZ1bmN0aW9uKGksIGVsLCBjYikge1xuICAgIGVhY2goZWwsIGZ1bmN0aW9uKGVycm9yLCBtc2cpIHtcbiAgICAgIHJlc3VsdFtpXSA9IG1zZztcbiAgICAgIGNiKGVycm9yLCByZXN1bHQpO1xuICAgIH0pO1xuICB9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgZWFjaFdpdGhJbmRleChpLCBhcnlbaV0sIG5leHQpO1xuICB9XG59XG5cbi8qXG4gKiBEZWNvZGVzIGRhdGEgd2hlbiBhIHBheWxvYWQgaXMgbWF5YmUgZXhwZWN0ZWQuIFBvc3NpYmxlIGJpbmFyeSBjb250ZW50cyBhcmVcbiAqIGRlY29kZWQgZnJvbSB0aGVpciBiYXNlNjQgcmVwcmVzZW50YXRpb25cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YSwgY2FsbGJhY2sgbWV0aG9kXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuZGVjb2RlUGF5bG9hZCA9IGZ1bmN0aW9uIChkYXRhLCBiaW5hcnlUeXBlLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZGVjb2RlUGF5bG9hZEFzQmluYXJ5KGRhdGEsIGJpbmFyeVR5cGUsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgYmluYXJ5VHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gYmluYXJ5VHlwZTtcbiAgICBiaW5hcnlUeXBlID0gbnVsbDtcbiAgfVxuXG4gIHZhciBwYWNrZXQ7XG4gIGlmIChkYXRhID09PSAnJykge1xuICAgIC8vIHBhcnNlciBlcnJvciAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgfVxuXG4gIHZhciBsZW5ndGggPSAnJywgbiwgbXNnO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gZGF0YS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgY2hyID0gZGF0YS5jaGFyQXQoaSk7XG5cbiAgICBpZiAoY2hyICE9PSAnOicpIHtcbiAgICAgIGxlbmd0aCArPSBjaHI7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAobGVuZ3RoID09PSAnJyB8fCAobGVuZ3RoICE9IChuID0gTnVtYmVyKGxlbmd0aCkpKSkge1xuICAgICAgLy8gcGFyc2VyIGVycm9yIC0gaWdub3JpbmcgcGF5bG9hZFxuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gICAgfVxuXG4gICAgbXNnID0gZGF0YS5zdWJzdHIoaSArIDEsIG4pO1xuXG4gICAgaWYgKGxlbmd0aCAhPSBtc2cubGVuZ3RoKSB7XG4gICAgICAvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgICB9XG5cbiAgICBpZiAobXNnLmxlbmd0aCkge1xuICAgICAgcGFja2V0ID0gZXhwb3J0cy5kZWNvZGVQYWNrZXQobXNnLCBiaW5hcnlUeXBlLCBmYWxzZSk7XG5cbiAgICAgIGlmIChlcnIudHlwZSA9PT0gcGFja2V0LnR5cGUgJiYgZXJyLmRhdGEgPT09IHBhY2tldC5kYXRhKSB7XG4gICAgICAgIC8vIHBhcnNlciBlcnJvciBpbiBpbmRpdmlkdWFsIHBhY2tldCAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXQgPSBjYWxsYmFjayhwYWNrZXQsIGkgKyBuLCBsKTtcbiAgICAgIGlmIChmYWxzZSA9PT0gcmV0KSByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYWR2YW5jZSBjdXJzb3JcbiAgICBpICs9IG47XG4gICAgbGVuZ3RoID0gJyc7XG4gIH1cblxuICBpZiAobGVuZ3RoICE9PSAnJykge1xuICAgIC8vIHBhcnNlciBlcnJvciAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgfVxuXG59O1xuXG4vKipcbiAqIEVuY29kZXMgbXVsdGlwbGUgbWVzc2FnZXMgKHBheWxvYWQpIGFzIGJpbmFyeS5cbiAqXG4gKiA8MSA9IGJpbmFyeSwgMCA9IHN0cmluZz48bnVtYmVyIGZyb20gMC05PjxudW1iZXIgZnJvbSAwLTk+Wy4uLl08bnVtYmVyXG4gKiAyNTU+PGRhdGE+XG4gKlxuICogRXhhbXBsZTpcbiAqIDEgMyAyNTUgMSAyIDMsIGlmIHRoZSBiaW5hcnkgY29udGVudHMgYXJlIGludGVycHJldGVkIGFzIDggYml0IGludGVnZXJzXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcGFja2V0c1xuICogQHJldHVybiB7QXJyYXlCdWZmZXJ9IGVuY29kZWQgcGF5bG9hZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5lbmNvZGVQYXlsb2FkQXNBcnJheUJ1ZmZlciA9IGZ1bmN0aW9uKHBhY2tldHMsIGNhbGxiYWNrKSB7XG4gIGlmICghcGFja2V0cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gY2FsbGJhY2sobmV3IEFycmF5QnVmZmVyKDApKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuY29kZU9uZShwYWNrZXQsIGRvbmVDYWxsYmFjaykge1xuICAgIGV4cG9ydHMuZW5jb2RlUGFja2V0KHBhY2tldCwgdHJ1ZSwgdHJ1ZSwgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgcmV0dXJuIGRvbmVDYWxsYmFjayhudWxsLCBkYXRhKTtcbiAgICB9KTtcbiAgfVxuXG4gIG1hcChwYWNrZXRzLCBlbmNvZGVPbmUsIGZ1bmN0aW9uKGVyciwgZW5jb2RlZFBhY2tldHMpIHtcbiAgICB2YXIgdG90YWxMZW5ndGggPSBlbmNvZGVkUGFja2V0cy5yZWR1Y2UoZnVuY3Rpb24oYWNjLCBwKSB7XG4gICAgICB2YXIgbGVuO1xuICAgICAgaWYgKHR5cGVvZiBwID09PSAnc3RyaW5nJyl7XG4gICAgICAgIGxlbiA9IHAubGVuZ3RoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVuID0gcC5ieXRlTGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjYyArIGxlbi50b1N0cmluZygpLmxlbmd0aCArIGxlbiArIDI7IC8vIHN0cmluZy9iaW5hcnkgaWRlbnRpZmllciArIHNlcGFyYXRvciA9IDJcbiAgICB9LCAwKTtcblxuICAgIHZhciByZXN1bHRBcnJheSA9IG5ldyBVaW50OEFycmF5KHRvdGFsTGVuZ3RoKTtcblxuICAgIHZhciBidWZmZXJJbmRleCA9IDA7XG4gICAgZW5jb2RlZFBhY2tldHMuZm9yRWFjaChmdW5jdGlvbihwKSB7XG4gICAgICB2YXIgaXNTdHJpbmcgPSB0eXBlb2YgcCA9PT0gJ3N0cmluZyc7XG4gICAgICB2YXIgYWIgPSBwO1xuICAgICAgaWYgKGlzU3RyaW5nKSB7XG4gICAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkocC5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2aWV3W2ldID0gcC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB9XG4gICAgICAgIGFiID0gdmlldy5idWZmZXI7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc1N0cmluZykgeyAvLyBub3QgdHJ1ZSBiaW5hcnlcbiAgICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSAwO1xuICAgICAgfSBlbHNlIHsgLy8gdHJ1ZSBiaW5hcnlcbiAgICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSAxO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGVuU3RyID0gYWIuYnl0ZUxlbmd0aC50b1N0cmluZygpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5TdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSBwYXJzZUludChsZW5TdHJbaV0pO1xuICAgICAgfVxuICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSAyNTU7XG5cbiAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYWIpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gdmlld1tpXTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBjYWxsYmFjayhyZXN1bHRBcnJheS5idWZmZXIpO1xuICB9KTtcbn07XG5cbi8qKlxuICogRW5jb2RlIGFzIEJsb2JcbiAqL1xuXG5leHBvcnRzLmVuY29kZVBheWxvYWRBc0Jsb2IgPSBmdW5jdGlvbihwYWNrZXRzLCBjYWxsYmFjaykge1xuICBmdW5jdGlvbiBlbmNvZGVPbmUocGFja2V0LCBkb25lQ2FsbGJhY2spIHtcbiAgICBleHBvcnRzLmVuY29kZVBhY2tldChwYWNrZXQsIHRydWUsIHRydWUsIGZ1bmN0aW9uKGVuY29kZWQpIHtcbiAgICAgIHZhciBiaW5hcnlJZGVudGlmaWVyID0gbmV3IFVpbnQ4QXJyYXkoMSk7XG4gICAgICBiaW5hcnlJZGVudGlmaWVyWzBdID0gMTtcbiAgICAgIGlmICh0eXBlb2YgZW5jb2RlZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShlbmNvZGVkLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5jb2RlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZpZXdbaV0gPSBlbmNvZGVkLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZW5jb2RlZCA9IHZpZXcuYnVmZmVyO1xuICAgICAgICBiaW5hcnlJZGVudGlmaWVyWzBdID0gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIGxlbiA9IChlbmNvZGVkIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpXG4gICAgICAgID8gZW5jb2RlZC5ieXRlTGVuZ3RoXG4gICAgICAgIDogZW5jb2RlZC5zaXplO1xuXG4gICAgICB2YXIgbGVuU3RyID0gbGVuLnRvU3RyaW5nKCk7XG4gICAgICB2YXIgbGVuZ3RoQXJ5ID0gbmV3IFVpbnQ4QXJyYXkobGVuU3RyLmxlbmd0aCArIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5TdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGVuZ3RoQXJ5W2ldID0gcGFyc2VJbnQobGVuU3RyW2ldKTtcbiAgICAgIH1cbiAgICAgIGxlbmd0aEFyeVtsZW5TdHIubGVuZ3RoXSA9IDI1NTtcblxuICAgICAgaWYgKEJsb2IpIHtcbiAgICAgICAgdmFyIGJsb2IgPSBuZXcgQmxvYihbYmluYXJ5SWRlbnRpZmllci5idWZmZXIsIGxlbmd0aEFyeS5idWZmZXIsIGVuY29kZWRdKTtcbiAgICAgICAgZG9uZUNhbGxiYWNrKG51bGwsIGJsb2IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgbWFwKHBhY2tldHMsIGVuY29kZU9uZSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBCbG9iKHJlc3VsdHMpKTtcbiAgfSk7XG59O1xuXG4vKlxuICogRGVjb2RlcyBkYXRhIHdoZW4gYSBwYXlsb2FkIGlzIG1heWJlIGV4cGVjdGVkLiBTdHJpbmdzIGFyZSBkZWNvZGVkIGJ5XG4gKiBpbnRlcnByZXRpbmcgZWFjaCBieXRlIGFzIGEga2V5IGNvZGUgZm9yIGVudHJpZXMgbWFya2VkIHRvIHN0YXJ0IHdpdGggMC4gU2VlXG4gKiBkZXNjcmlwdGlvbiBvZiBlbmNvZGVQYXlsb2FkQXNCaW5hcnlcbiAqXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBkYXRhLCBjYWxsYmFjayBtZXRob2RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5kZWNvZGVQYXlsb2FkQXNCaW5hcnkgPSBmdW5jdGlvbiAoZGF0YSwgYmluYXJ5VHlwZSwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBiaW5hcnlUeXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBiaW5hcnlUeXBlO1xuICAgIGJpbmFyeVR5cGUgPSBudWxsO1xuICB9XG5cbiAgdmFyIGJ1ZmZlclRhaWwgPSBkYXRhO1xuICB2YXIgYnVmZmVycyA9IFtdO1xuXG4gIHdoaWxlIChidWZmZXJUYWlsLmJ5dGVMZW5ndGggPiAwKSB7XG4gICAgdmFyIHRhaWxBcnJheSA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlclRhaWwpO1xuICAgIHZhciBpc1N0cmluZyA9IHRhaWxBcnJheVswXSA9PT0gMDtcbiAgICB2YXIgbXNnTGVuZ3RoID0gJyc7XG5cbiAgICBmb3IgKHZhciBpID0gMTsgOyBpKyspIHtcbiAgICAgIGlmICh0YWlsQXJyYXlbaV0gPT09IDI1NSkgYnJlYWs7XG5cbiAgICAgIC8vIDMxMCA9IGNoYXIgbGVuZ3RoIG9mIE51bWJlci5NQVhfVkFMVUVcbiAgICAgIGlmIChtc2dMZW5ndGgubGVuZ3RoID4gMzEwKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICAgICAgfVxuXG4gICAgICBtc2dMZW5ndGggKz0gdGFpbEFycmF5W2ldO1xuICAgIH1cblxuICAgIGJ1ZmZlclRhaWwgPSBzbGljZUJ1ZmZlcihidWZmZXJUYWlsLCAyICsgbXNnTGVuZ3RoLmxlbmd0aCk7XG4gICAgbXNnTGVuZ3RoID0gcGFyc2VJbnQobXNnTGVuZ3RoKTtcblxuICAgIHZhciBtc2cgPSBzbGljZUJ1ZmZlcihidWZmZXJUYWlsLCAwLCBtc2dMZW5ndGgpO1xuICAgIGlmIChpc1N0cmluZykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbXNnID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheShtc2cpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gaVBob25lIFNhZmFyaSBkb2Vzbid0IGxldCB5b3UgYXBwbHkgdG8gdHlwZWQgYXJyYXlzXG4gICAgICAgIHZhciB0eXBlZCA9IG5ldyBVaW50OEFycmF5KG1zZyk7XG4gICAgICAgIG1zZyA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbXNnICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodHlwZWRbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgYnVmZmVycy5wdXNoKG1zZyk7XG4gICAgYnVmZmVyVGFpbCA9IHNsaWNlQnVmZmVyKGJ1ZmZlclRhaWwsIG1zZ0xlbmd0aCk7XG4gIH1cblxuICB2YXIgdG90YWwgPSBidWZmZXJzLmxlbmd0aDtcbiAgYnVmZmVycy5mb3JFYWNoKGZ1bmN0aW9uKGJ1ZmZlciwgaSkge1xuICAgIGNhbGxiYWNrKGV4cG9ydHMuZGVjb2RlUGFja2V0KGJ1ZmZlciwgYmluYXJ5VHlwZSwgdHJ1ZSksIGksIHRvdGFsKTtcbiAgfSk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1wYXJzZXIvbGliL2Jyb3dzZXIuanMiLCIvKlxub2JqZWN0LWFzc2lnblxuKGMpIFNpbmRyZSBTb3JodXNcbkBsaWNlbnNlIE1JVFxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwcm9wSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuZnVuY3Rpb24gdG9PYmplY3QodmFsKSB7XG5cdGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QuYXNzaWduIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBudWxsIG9yIHVuZGVmaW5lZCcpO1xuXHR9XG5cblx0cmV0dXJuIE9iamVjdCh2YWwpO1xufVxuXG5mdW5jdGlvbiBzaG91bGRVc2VOYXRpdmUoKSB7XG5cdHRyeSB7XG5cdFx0aWYgKCFPYmplY3QuYXNzaWduKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZWN0IGJ1Z2d5IHByb3BlcnR5IGVudW1lcmF0aW9uIG9yZGVyIGluIG9sZGVyIFY4IHZlcnNpb25zLlxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9NDExOFxuXHRcdHZhciB0ZXN0MSA9IG5ldyBTdHJpbmcoJ2FiYycpOyAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXctd3JhcHBlcnNcblx0XHR0ZXN0MVs1XSA9ICdkZSc7XG5cdFx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QxKVswXSA9PT0gJzUnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MiA9IHt9O1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuXHRcdFx0dGVzdDJbJ18nICsgU3RyaW5nLmZyb21DaGFyQ29kZShpKV0gPSBpO1xuXHRcdH1cblx0XHR2YXIgb3JkZXIyID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDIpLm1hcChmdW5jdGlvbiAobikge1xuXHRcdFx0cmV0dXJuIHRlc3QyW25dO1xuXHRcdH0pO1xuXHRcdGlmIChvcmRlcjIuam9pbignJykgIT09ICcwMTIzNDU2Nzg5Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDMgPSB7fTtcblx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChsZXR0ZXIpIHtcblx0XHRcdHRlc3QzW2xldHRlcl0gPSBsZXR0ZXI7XG5cdFx0fSk7XG5cdFx0aWYgKE9iamVjdC5rZXlzKE9iamVjdC5hc3NpZ24oe30sIHRlc3QzKSkuam9pbignJykgIT09XG5cdFx0XHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0Ly8gV2UgZG9uJ3QgZXhwZWN0IGFueSBvZiB0aGUgYWJvdmUgdG8gdGhyb3csIGJ1dCBiZXR0ZXIgdG8gYmUgc2FmZS5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG91bGRVc2VOYXRpdmUoKSA/IE9iamVjdC5hc3NpZ24gOiBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcblx0dmFyIGZyb207XG5cdHZhciB0byA9IHRvT2JqZWN0KHRhcmdldCk7XG5cdHZhciBzeW1ib2xzO1xuXG5cdGZvciAodmFyIHMgPSAxOyBzIDwgYXJndW1lbnRzLmxlbmd0aDsgcysrKSB7XG5cdFx0ZnJvbSA9IE9iamVjdChhcmd1bWVudHNbc10pO1xuXG5cdFx0Zm9yICh2YXIga2V5IGluIGZyb20pIHtcblx0XHRcdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGZyb20sIGtleSkpIHtcblx0XHRcdFx0dG9ba2V5XSA9IGZyb21ba2V5XTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG5cdFx0XHRzeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGZyb20pO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChwcm9wSXNFbnVtZXJhYmxlLmNhbGwoZnJvbSwgc3ltYm9sc1tpXSkpIHtcblx0XHRcdFx0XHR0b1tzeW1ib2xzW2ldXSA9IGZyb21bc3ltYm9sc1tpXV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdG87XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL29iamVjdC1hc3NpZ24vaW5kZXguanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbXB0eU9iamVjdCA9IHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBPYmplY3QuZnJlZXplKGVtcHR5T2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlbXB0eU9iamVjdDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZW1wdHlPYmplY3QuanMiLCIvKipcclxuICogQ29tcGlsZXMgYSBxdWVyeXN0cmluZ1xyXG4gKiBSZXR1cm5zIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgb2JqZWN0XHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fVxyXG4gKiBAYXBpIHByaXZhdGVcclxuICovXHJcblxyXG5leHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIChvYmopIHtcclxuICB2YXIgc3RyID0gJyc7XHJcblxyXG4gIGZvciAodmFyIGkgaW4gb2JqKSB7XHJcbiAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGkpKSB7XHJcbiAgICAgIGlmIChzdHIubGVuZ3RoKSBzdHIgKz0gJyYnO1xyXG4gICAgICBzdHIgKz0gZW5jb2RlVVJJQ29tcG9uZW50KGkpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KG9ialtpXSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gc3RyO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFBhcnNlcyBhIHNpbXBsZSBxdWVyeXN0cmluZyBpbnRvIGFuIG9iamVjdFxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gcXNcclxuICogQGFwaSBwcml2YXRlXHJcbiAqL1xyXG5cclxuZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbihxcyl7XHJcbiAgdmFyIHFyeSA9IHt9O1xyXG4gIHZhciBwYWlycyA9IHFzLnNwbGl0KCcmJyk7XHJcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYWlycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgIHZhciBwYWlyID0gcGFpcnNbaV0uc3BsaXQoJz0nKTtcclxuICAgIHFyeVtkZWNvZGVVUklDb21wb25lbnQocGFpclswXSldID0gZGVjb2RlVVJJQ29tcG9uZW50KHBhaXJbMV0pO1xyXG4gIH1cclxuICByZXR1cm4gcXJ5O1xyXG59O1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcGFyc2Vxcy9pbmRleC5qcyIsIlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhLCBiKXtcbiAgdmFyIGZuID0gZnVuY3Rpb24oKXt9O1xuICBmbi5wcm90b3R5cGUgPSBiLnByb3RvdHlwZTtcbiAgYS5wcm90b3R5cGUgPSBuZXcgZm47XG4gIGEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gYTtcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvbXBvbmVudC1pbmhlcml0L2luZGV4LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFVzZSBpbnZhcmlhbnQoKSB0byBhc3NlcnQgc3RhdGUgd2hpY2ggeW91ciBwcm9ncmFtIGFzc3VtZXMgdG8gYmUgdHJ1ZS5cbiAqXG4gKiBQcm92aWRlIHNwcmludGYtc3R5bGUgZm9ybWF0IChvbmx5ICVzIGlzIHN1cHBvcnRlZCkgYW5kIGFyZ3VtZW50c1xuICogdG8gcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGJyb2tlIGFuZCB3aGF0IHlvdSB3ZXJlXG4gKiBleHBlY3RpbmcuXG4gKlxuICogVGhlIGludmFyaWFudCBtZXNzYWdlIHdpbGwgYmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBpbnZhcmlhbnRcbiAqIHdpbGwgcmVtYWluIHRvIGVuc3VyZSBsb2dpYyBkb2VzIG5vdCBkaWZmZXIgaW4gcHJvZHVjdGlvbi5cbiAqL1xuXG52YXIgdmFsaWRhdGVGb3JtYXQgPSBmdW5jdGlvbiB2YWxpZGF0ZUZvcm1hdChmb3JtYXQpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YWxpZGF0ZUZvcm1hdCA9IGZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhcmlhbnQgcmVxdWlyZXMgYW4gZXJyb3IgbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW52YXJpYW50KGNvbmRpdGlvbiwgZm9ybWF0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCk7XG5cbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB2YXIgZXJyb3I7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcignTWluaWZpZWQgZXhjZXB0aW9uIG9jY3VycmVkOyB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgJyArICdmb3IgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZSBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXJncyA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICAgIH0pKTtcbiAgICAgIGVycm9yLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgfVxuXG4gICAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGludmFyaWFudCdzIG93biBmcmFtZVxuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW52YXJpYW50O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9pbnZhcmlhbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9lbXB0eUZ1bmN0aW9uJyk7XG5cbi8qKlxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciB3YXJuaW5nID0gZW1wdHlGdW5jdGlvbjtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uIHByaW50V2FybmluZyhmb3JtYXQpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xuXG4gIHdhcm5pbmcgPSBmdW5jdGlvbiB3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0KSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2B3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0LCAuLi5hcmdzKWAgcmVxdWlyZXMgYSB3YXJuaW5nICcgKyAnbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cblxuICAgIGlmIChmb3JtYXQuaW5kZXhPZignRmFpbGVkIENvbXBvc2l0ZSBwcm9wVHlwZTogJykgPT09IDApIHtcbiAgICAgIHJldHVybjsgLy8gSWdub3JlIENvbXBvc2l0ZUNvbXBvbmVudCBwcm9wdHlwZSBjaGVjay5cbiAgICB9XG5cbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIgPiAyID8gX2xlbjIgLSAyIDogMCksIF9rZXkyID0gMjsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMl0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcuYXBwbHkodW5kZWZpbmVkLCBbZm9ybWF0XS5jb25jYXQoYXJncykpO1xuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3YXJuaW5nO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi93YXJuaW5nLmpzIiwiaW1wb3J0IGNsaWVudCBmcm9tICdzb2NrZXQuaW8tY2xpZW50J1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb25uZWN0aW9uTWFuYWdlciB7XG4gIHN0YXRpYyBvcGVuICgpIHtcbiAgICBDb25uZWN0aW9uTWFuYWdlci5zb2NrZXQgPSBjbGllbnQuY29ubmVjdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwJylcbiAgfVxuXG4gIHN0YXRpYyBnZXRDb25uZWN0aW9uICgpIHtcbiAgICByZXR1cm4gQ29ubmVjdGlvbk1hbmFnZXIuc29ja2V0XG4gIH1cblxuICBzdGF0aWMgY2xvc2UgKCkge1xuICAgIC8vIFRPRE8gY29ubmVjdGlvbuOCkmNsb3Nl44GZ44KLQVBJ44KS5Y+p44GPXG4gICAgQ29ubmVjdGlvbk1hbmFnZXIuc29ja2V0LmRpc2Nvbm5lY3QoKVxuICB9XG59XG5cbkNvbm5lY3Rpb25NYW5hZ2VyLnNvY2tldCA9IG51bGxcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy93cy9jbGllbnQvQ29ubmVjdGlvbk1hbmFnZXIuanMiLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NrZXQuaW8tcGFyc2VyJyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgaGFzQmluID0gcmVxdWlyZSgnaGFzLWJpbmFyeTInKTtcbnZhciBiaW5hcnkgPSByZXF1aXJlKCcuL2JpbmFyeScpO1xudmFyIGlzQnVmID0gcmVxdWlyZSgnLi9pcy1idWZmZXInKTtcblxuLyoqXG4gKiBQcm90b2NvbCB2ZXJzaW9uLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5wcm90b2NvbCA9IDQ7XG5cbi8qKlxuICogUGFja2V0IHR5cGVzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy50eXBlcyA9IFtcbiAgJ0NPTk5FQ1QnLFxuICAnRElTQ09OTkVDVCcsXG4gICdFVkVOVCcsXG4gICdBQ0snLFxuICAnRVJST1InLFxuICAnQklOQVJZX0VWRU5UJyxcbiAgJ0JJTkFSWV9BQ0snXG5dO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBjb25uZWN0YC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuQ09OTkVDVCA9IDA7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGRpc2Nvbm5lY3RgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5ESVNDT05ORUNUID0gMTtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSBgZXZlbnRgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5FVkVOVCA9IDI7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGFja2AuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkFDSyA9IDM7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGVycm9yYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuRVJST1IgPSA0O1xuXG4vKipcbiAqIFBhY2tldCB0eXBlICdiaW5hcnkgZXZlbnQnXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkJJTkFSWV9FVkVOVCA9IDU7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGJpbmFyeSBhY2tgLiBGb3IgYWNrcyB3aXRoIGJpbmFyeSBhcmd1bWVudHMuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkJJTkFSWV9BQ0sgPSA2O1xuXG4vKipcbiAqIEVuY29kZXIgY29uc3RydWN0b3IuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkVuY29kZXIgPSBFbmNvZGVyO1xuXG4vKipcbiAqIERlY29kZXIgY29uc3RydWN0b3IuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkRlY29kZXIgPSBEZWNvZGVyO1xuXG4vKipcbiAqIEEgc29ja2V0LmlvIEVuY29kZXIgaW5zdGFuY2VcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIEVuY29kZXIoKSB7fVxuXG4vKipcbiAqIEVuY29kZSBhIHBhY2tldCBhcyBhIHNpbmdsZSBzdHJpbmcgaWYgbm9uLWJpbmFyeSwgb3IgYXMgYVxuICogYnVmZmVyIHNlcXVlbmNlLCBkZXBlbmRpbmcgb24gcGFja2V0IHR5cGUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIHBhY2tldCBvYmplY3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gZnVuY3Rpb24gdG8gaGFuZGxlIGVuY29kaW5ncyAobGlrZWx5IGVuZ2luZS53cml0ZSlcbiAqIEByZXR1cm4gQ2FsbHMgY2FsbGJhY2sgd2l0aCBBcnJheSBvZiBlbmNvZGluZ3NcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW5jb2Rlci5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24ob2JqLCBjYWxsYmFjayl7XG4gIGlmICgob2JqLnR5cGUgPT09IGV4cG9ydHMuRVZFTlQgfHwgb2JqLnR5cGUgPT09IGV4cG9ydHMuQUNLKSAmJiBoYXNCaW4ob2JqLmRhdGEpKSB7XG4gICAgb2JqLnR5cGUgPSBvYmoudHlwZSA9PT0gZXhwb3J0cy5FVkVOVCA/IGV4cG9ydHMuQklOQVJZX0VWRU5UIDogZXhwb3J0cy5CSU5BUllfQUNLO1xuICB9XG5cbiAgZGVidWcoJ2VuY29kaW5nIHBhY2tldCAlaicsIG9iaik7XG5cbiAgaWYgKGV4cG9ydHMuQklOQVJZX0VWRU5UID09PSBvYmoudHlwZSB8fCBleHBvcnRzLkJJTkFSWV9BQ0sgPT09IG9iai50eXBlKSB7XG4gICAgZW5jb2RlQXNCaW5hcnkob2JqLCBjYWxsYmFjayk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdmFyIGVuY29kaW5nID0gZW5jb2RlQXNTdHJpbmcob2JqKTtcbiAgICBjYWxsYmFjayhbZW5jb2RpbmddKTtcbiAgfVxufTtcblxuLyoqXG4gKiBFbmNvZGUgcGFja2V0IGFzIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAcmV0dXJuIHtTdHJpbmd9IGVuY29kZWRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGVuY29kZUFzU3RyaW5nKG9iaikge1xuXG4gIC8vIGZpcnN0IGlzIHR5cGVcbiAgdmFyIHN0ciA9ICcnICsgb2JqLnR5cGU7XG5cbiAgLy8gYXR0YWNobWVudHMgaWYgd2UgaGF2ZSB0aGVtXG4gIGlmIChleHBvcnRzLkJJTkFSWV9FVkVOVCA9PT0gb2JqLnR5cGUgfHwgZXhwb3J0cy5CSU5BUllfQUNLID09PSBvYmoudHlwZSkge1xuICAgIHN0ciArPSBvYmouYXR0YWNobWVudHMgKyAnLSc7XG4gIH1cblxuICAvLyBpZiB3ZSBoYXZlIGEgbmFtZXNwYWNlIG90aGVyIHRoYW4gYC9gXG4gIC8vIHdlIGFwcGVuZCBpdCBmb2xsb3dlZCBieSBhIGNvbW1hIGAsYFxuICBpZiAob2JqLm5zcCAmJiAnLycgIT09IG9iai5uc3ApIHtcbiAgICBzdHIgKz0gb2JqLm5zcCArICcsJztcbiAgfVxuXG4gIC8vIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IHRoZSBpZFxuICBpZiAobnVsbCAhPSBvYmouaWQpIHtcbiAgICBzdHIgKz0gb2JqLmlkO1xuICB9XG5cbiAgLy8ganNvbiBkYXRhXG4gIGlmIChudWxsICE9IG9iai5kYXRhKSB7XG4gICAgc3RyICs9IEpTT04uc3RyaW5naWZ5KG9iai5kYXRhKTtcbiAgfVxuXG4gIGRlYnVnKCdlbmNvZGVkICVqIGFzICVzJywgb2JqLCBzdHIpO1xuICByZXR1cm4gc3RyO1xufVxuXG4vKipcbiAqIEVuY29kZSBwYWNrZXQgYXMgJ2J1ZmZlciBzZXF1ZW5jZScgYnkgcmVtb3ZpbmcgYmxvYnMsIGFuZFxuICogZGVjb25zdHJ1Y3RpbmcgcGFja2V0IGludG8gb2JqZWN0IHdpdGggcGxhY2Vob2xkZXJzIGFuZFxuICogYSBsaXN0IG9mIGJ1ZmZlcnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQHJldHVybiB7QnVmZmVyfSBlbmNvZGVkXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBlbmNvZGVBc0JpbmFyeShvYmosIGNhbGxiYWNrKSB7XG5cbiAgZnVuY3Rpb24gd3JpdGVFbmNvZGluZyhibG9ibGVzc0RhdGEpIHtcbiAgICB2YXIgZGVjb25zdHJ1Y3Rpb24gPSBiaW5hcnkuZGVjb25zdHJ1Y3RQYWNrZXQoYmxvYmxlc3NEYXRhKTtcbiAgICB2YXIgcGFjayA9IGVuY29kZUFzU3RyaW5nKGRlY29uc3RydWN0aW9uLnBhY2tldCk7XG4gICAgdmFyIGJ1ZmZlcnMgPSBkZWNvbnN0cnVjdGlvbi5idWZmZXJzO1xuXG4gICAgYnVmZmVycy51bnNoaWZ0KHBhY2spOyAvLyBhZGQgcGFja2V0IGluZm8gdG8gYmVnaW5uaW5nIG9mIGRhdGEgbGlzdFxuICAgIGNhbGxiYWNrKGJ1ZmZlcnMpOyAvLyB3cml0ZSBhbGwgdGhlIGJ1ZmZlcnNcbiAgfVxuXG4gIGJpbmFyeS5yZW1vdmVCbG9icyhvYmosIHdyaXRlRW5jb2RpbmcpO1xufVxuXG4vKipcbiAqIEEgc29ja2V0LmlvIERlY29kZXIgaW5zdGFuY2VcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IGRlY29kZXJcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gRGVjb2RlcigpIHtcbiAgdGhpcy5yZWNvbnN0cnVjdG9yID0gbnVsbDtcbn1cblxuLyoqXG4gKiBNaXggaW4gYEVtaXR0ZXJgIHdpdGggRGVjb2Rlci5cbiAqL1xuXG5FbWl0dGVyKERlY29kZXIucHJvdG90eXBlKTtcblxuLyoqXG4gKiBEZWNvZGVzIGFuIGVjb2RlZCBwYWNrZXQgc3RyaW5nIGludG8gcGFja2V0IEpTT04uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG9iaiAtIGVuY29kZWQgcGFja2V0XG4gKiBAcmV0dXJuIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5EZWNvZGVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihvYmopIHtcbiAgdmFyIHBhY2tldDtcbiAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB7XG4gICAgcGFja2V0ID0gZGVjb2RlU3RyaW5nKG9iaik7XG4gICAgaWYgKGV4cG9ydHMuQklOQVJZX0VWRU5UID09PSBwYWNrZXQudHlwZSB8fCBleHBvcnRzLkJJTkFSWV9BQ0sgPT09IHBhY2tldC50eXBlKSB7IC8vIGJpbmFyeSBwYWNrZXQncyBqc29uXG4gICAgICB0aGlzLnJlY29uc3RydWN0b3IgPSBuZXcgQmluYXJ5UmVjb25zdHJ1Y3RvcihwYWNrZXQpO1xuXG4gICAgICAvLyBubyBhdHRhY2htZW50cywgbGFiZWxlZCBiaW5hcnkgYnV0IG5vIGJpbmFyeSBkYXRhIHRvIGZvbGxvd1xuICAgICAgaWYgKHRoaXMucmVjb25zdHJ1Y3Rvci5yZWNvblBhY2suYXR0YWNobWVudHMgPT09IDApIHtcbiAgICAgICAgdGhpcy5lbWl0KCdkZWNvZGVkJywgcGFja2V0KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgeyAvLyBub24tYmluYXJ5IGZ1bGwgcGFja2V0XG4gICAgICB0aGlzLmVtaXQoJ2RlY29kZWQnLCBwYWNrZXQpO1xuICAgIH1cbiAgfVxuICBlbHNlIGlmIChpc0J1ZihvYmopIHx8IG9iai5iYXNlNjQpIHsgLy8gcmF3IGJpbmFyeSBkYXRhXG4gICAgaWYgKCF0aGlzLnJlY29uc3RydWN0b3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZ290IGJpbmFyeSBkYXRhIHdoZW4gbm90IHJlY29uc3RydWN0aW5nIGEgcGFja2V0Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhY2tldCA9IHRoaXMucmVjb25zdHJ1Y3Rvci50YWtlQmluYXJ5RGF0YShvYmopO1xuICAgICAgaWYgKHBhY2tldCkgeyAvLyByZWNlaXZlZCBmaW5hbCBidWZmZXJcbiAgICAgICAgdGhpcy5yZWNvbnN0cnVjdG9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5lbWl0KCdkZWNvZGVkJywgcGFja2V0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHR5cGU6ICcgKyBvYmopO1xuICB9XG59O1xuXG4vKipcbiAqIERlY29kZSBhIHBhY2tldCBTdHJpbmcgKEpTT04gZGF0YSlcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZGVjb2RlU3RyaW5nKHN0cikge1xuICB2YXIgaSA9IDA7XG4gIC8vIGxvb2sgdXAgdHlwZVxuICB2YXIgcCA9IHtcbiAgICB0eXBlOiBOdW1iZXIoc3RyLmNoYXJBdCgwKSlcbiAgfTtcblxuICBpZiAobnVsbCA9PSBleHBvcnRzLnR5cGVzW3AudHlwZV0pIHJldHVybiBlcnJvcigpO1xuXG4gIC8vIGxvb2sgdXAgYXR0YWNobWVudHMgaWYgdHlwZSBiaW5hcnlcbiAgaWYgKGV4cG9ydHMuQklOQVJZX0VWRU5UID09PSBwLnR5cGUgfHwgZXhwb3J0cy5CSU5BUllfQUNLID09PSBwLnR5cGUpIHtcbiAgICB2YXIgYnVmID0gJyc7XG4gICAgd2hpbGUgKHN0ci5jaGFyQXQoKytpKSAhPT0gJy0nKSB7XG4gICAgICBidWYgKz0gc3RyLmNoYXJBdChpKTtcbiAgICAgIGlmIChpID09IHN0ci5sZW5ndGgpIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoYnVmICE9IE51bWJlcihidWYpIHx8IHN0ci5jaGFyQXQoaSkgIT09ICctJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGF0dGFjaG1lbnRzJyk7XG4gICAgfVxuICAgIHAuYXR0YWNobWVudHMgPSBOdW1iZXIoYnVmKTtcbiAgfVxuXG4gIC8vIGxvb2sgdXAgbmFtZXNwYWNlIChpZiBhbnkpXG4gIGlmICgnLycgPT09IHN0ci5jaGFyQXQoaSArIDEpKSB7XG4gICAgcC5uc3AgPSAnJztcbiAgICB3aGlsZSAoKytpKSB7XG4gICAgICB2YXIgYyA9IHN0ci5jaGFyQXQoaSk7XG4gICAgICBpZiAoJywnID09PSBjKSBicmVhaztcbiAgICAgIHAubnNwICs9IGM7XG4gICAgICBpZiAoaSA9PT0gc3RyLmxlbmd0aCkgYnJlYWs7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHAubnNwID0gJy8nO1xuICB9XG5cbiAgLy8gbG9vayB1cCBpZFxuICB2YXIgbmV4dCA9IHN0ci5jaGFyQXQoaSArIDEpO1xuICBpZiAoJycgIT09IG5leHQgJiYgTnVtYmVyKG5leHQpID09IG5leHQpIHtcbiAgICBwLmlkID0gJyc7XG4gICAgd2hpbGUgKCsraSkge1xuICAgICAgdmFyIGMgPSBzdHIuY2hhckF0KGkpO1xuICAgICAgaWYgKG51bGwgPT0gYyB8fCBOdW1iZXIoYykgIT0gYykge1xuICAgICAgICAtLWk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcC5pZCArPSBzdHIuY2hhckF0KGkpO1xuICAgICAgaWYgKGkgPT09IHN0ci5sZW5ndGgpIGJyZWFrO1xuICAgIH1cbiAgICBwLmlkID0gTnVtYmVyKHAuaWQpO1xuICB9XG5cbiAgLy8gbG9vayB1cCBqc29uIGRhdGFcbiAgaWYgKHN0ci5jaGFyQXQoKytpKSkge1xuICAgIHAgPSB0cnlQYXJzZShwLCBzdHIuc3Vic3RyKGkpKTtcbiAgfVxuXG4gIGRlYnVnKCdkZWNvZGVkICVzIGFzICVqJywgc3RyLCBwKTtcbiAgcmV0dXJuIHA7XG59XG5cbmZ1bmN0aW9uIHRyeVBhcnNlKHAsIHN0cikge1xuICB0cnkge1xuICAgIHAuZGF0YSA9IEpTT04ucGFyc2Uoc3RyKTtcbiAgfSBjYXRjaChlKXtcbiAgICByZXR1cm4gZXJyb3IoKTtcbiAgfVxuICByZXR1cm4gcDsgXG59XG5cbi8qKlxuICogRGVhbGxvY2F0ZXMgYSBwYXJzZXIncyByZXNvdXJjZXNcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkRlY29kZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMucmVjb25zdHJ1Y3Rvcikge1xuICAgIHRoaXMucmVjb25zdHJ1Y3Rvci5maW5pc2hlZFJlY29uc3RydWN0aW9uKCk7XG4gIH1cbn07XG5cbi8qKlxuICogQSBtYW5hZ2VyIG9mIGEgYmluYXJ5IGV2ZW50J3MgJ2J1ZmZlciBzZXF1ZW5jZScuIFNob3VsZFxuICogYmUgY29uc3RydWN0ZWQgd2hlbmV2ZXIgYSBwYWNrZXQgb2YgdHlwZSBCSU5BUllfRVZFTlQgaXNcbiAqIGRlY29kZWQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQHJldHVybiB7QmluYXJ5UmVjb25zdHJ1Y3Rvcn0gaW5pdGlhbGl6ZWQgcmVjb25zdHJ1Y3RvclxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gQmluYXJ5UmVjb25zdHJ1Y3RvcihwYWNrZXQpIHtcbiAgdGhpcy5yZWNvblBhY2sgPSBwYWNrZXQ7XG4gIHRoaXMuYnVmZmVycyA9IFtdO1xufVxuXG4vKipcbiAqIE1ldGhvZCB0byBiZSBjYWxsZWQgd2hlbiBiaW5hcnkgZGF0YSByZWNlaXZlZCBmcm9tIGNvbm5lY3Rpb25cbiAqIGFmdGVyIGEgQklOQVJZX0VWRU5UIHBhY2tldC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlciB8IEFycmF5QnVmZmVyfSBiaW5EYXRhIC0gdGhlIHJhdyBiaW5hcnkgZGF0YSByZWNlaXZlZFxuICogQHJldHVybiB7bnVsbCB8IE9iamVjdH0gcmV0dXJucyBudWxsIGlmIG1vcmUgYmluYXJ5IGRhdGEgaXMgZXhwZWN0ZWQgb3JcbiAqICAgYSByZWNvbnN0cnVjdGVkIHBhY2tldCBvYmplY3QgaWYgYWxsIGJ1ZmZlcnMgaGF2ZSBiZWVuIHJlY2VpdmVkLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuQmluYXJ5UmVjb25zdHJ1Y3Rvci5wcm90b3R5cGUudGFrZUJpbmFyeURhdGEgPSBmdW5jdGlvbihiaW5EYXRhKSB7XG4gIHRoaXMuYnVmZmVycy5wdXNoKGJpbkRhdGEpO1xuICBpZiAodGhpcy5idWZmZXJzLmxlbmd0aCA9PT0gdGhpcy5yZWNvblBhY2suYXR0YWNobWVudHMpIHsgLy8gZG9uZSB3aXRoIGJ1ZmZlciBsaXN0XG4gICAgdmFyIHBhY2tldCA9IGJpbmFyeS5yZWNvbnN0cnVjdFBhY2tldCh0aGlzLnJlY29uUGFjaywgdGhpcy5idWZmZXJzKTtcbiAgICB0aGlzLmZpbmlzaGVkUmVjb25zdHJ1Y3Rpb24oKTtcbiAgICByZXR1cm4gcGFja2V0O1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBDbGVhbnMgdXAgYmluYXJ5IHBhY2tldCByZWNvbnN0cnVjdGlvbiB2YXJpYWJsZXMuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuQmluYXJ5UmVjb25zdHJ1Y3Rvci5wcm90b3R5cGUuZmluaXNoZWRSZWNvbnN0cnVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnJlY29uUGFjayA9IG51bGw7XG4gIHRoaXMuYnVmZmVycyA9IFtdO1xufTtcblxuZnVuY3Rpb24gZXJyb3IoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogZXhwb3J0cy5FUlJPUixcbiAgICBkYXRhOiAncGFyc2VyIGVycm9yJ1xuICB9O1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1wYXJzZXIvaW5kZXguanMiLCIvLyBicm93c2VyIHNoaW0gZm9yIHhtbGh0dHByZXF1ZXN0IG1vZHVsZVxuXG52YXIgaGFzQ09SUyA9IHJlcXVpcmUoJ2hhcy1jb3JzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgdmFyIHhkb21haW4gPSBvcHRzLnhkb21haW47XG5cbiAgLy8gc2NoZW1lIG11c3QgYmUgc2FtZSB3aGVuIHVzaWduIFhEb21haW5SZXF1ZXN0XG4gIC8vIGh0dHA6Ly9ibG9ncy5tc2RuLmNvbS9iL2llaW50ZXJuYWxzL2FyY2hpdmUvMjAxMC8wNS8xMy94ZG9tYWlucmVxdWVzdC1yZXN0cmljdGlvbnMtbGltaXRhdGlvbnMtYW5kLXdvcmthcm91bmRzLmFzcHhcbiAgdmFyIHhzY2hlbWUgPSBvcHRzLnhzY2hlbWU7XG5cbiAgLy8gWERvbWFpblJlcXVlc3QgaGFzIGEgZmxvdyBvZiBub3Qgc2VuZGluZyBjb29raWUsIHRoZXJlZm9yZSBpdCBzaG91bGQgYmUgZGlzYWJsZWQgYXMgYSBkZWZhdWx0LlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vQXV0b21hdHRpYy9lbmdpbmUuaW8tY2xpZW50L3B1bGwvMjE3XG4gIHZhciBlbmFibGVzWERSID0gb3B0cy5lbmFibGVzWERSO1xuXG4gIC8vIFhNTEh0dHBSZXF1ZXN0IGNhbiBiZSBkaXNhYmxlZCBvbiBJRVxuICB0cnkge1xuICAgIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICYmICgheGRvbWFpbiB8fCBoYXNDT1JTKSkge1xuICAgICAgcmV0dXJuIG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkgeyB9XG5cbiAgLy8gVXNlIFhEb21haW5SZXF1ZXN0IGZvciBJRTggaWYgZW5hYmxlc1hEUiBpcyB0cnVlXG4gIC8vIGJlY2F1c2UgbG9hZGluZyBiYXIga2VlcHMgZmxhc2hpbmcgd2hlbiB1c2luZyBqc29ucC1wb2xsaW5nXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS95dWppb3Nha2Evc29ja2UuaW8taWU4LWxvYWRpbmctZXhhbXBsZVxuICB0cnkge1xuICAgIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIFhEb21haW5SZXF1ZXN0ICYmICF4c2NoZW1lICYmIGVuYWJsZXNYRFIpIHtcbiAgICAgIHJldHVybiBuZXcgWERvbWFpblJlcXVlc3QoKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHsgfVxuXG4gIGlmICgheGRvbWFpbikge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbmV3IGdsb2JhbFtbJ0FjdGl2ZSddLmNvbmNhdCgnT2JqZWN0Jykuam9pbignWCcpXSgnTWljcm9zb2Z0LlhNTEhUVFAnKTtcbiAgICB9IGNhdGNoIChlKSB7IH1cbiAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi94bWxodHRwcmVxdWVzdC5qcyIsIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgcGFyc2VyID0gcmVxdWlyZSgnZW5naW5lLmlvLXBhcnNlcicpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNwb3J0O1xuXG4vKipcbiAqIFRyYW5zcG9ydCBhYnN0cmFjdCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIFRyYW5zcG9ydCAob3B0cykge1xuICB0aGlzLnBhdGggPSBvcHRzLnBhdGg7XG4gIHRoaXMuaG9zdG5hbWUgPSBvcHRzLmhvc3RuYW1lO1xuICB0aGlzLnBvcnQgPSBvcHRzLnBvcnQ7XG4gIHRoaXMuc2VjdXJlID0gb3B0cy5zZWN1cmU7XG4gIHRoaXMucXVlcnkgPSBvcHRzLnF1ZXJ5O1xuICB0aGlzLnRpbWVzdGFtcFBhcmFtID0gb3B0cy50aW1lc3RhbXBQYXJhbTtcbiAgdGhpcy50aW1lc3RhbXBSZXF1ZXN0cyA9IG9wdHMudGltZXN0YW1wUmVxdWVzdHM7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICcnO1xuICB0aGlzLmFnZW50ID0gb3B0cy5hZ2VudCB8fCBmYWxzZTtcbiAgdGhpcy5zb2NrZXQgPSBvcHRzLnNvY2tldDtcbiAgdGhpcy5lbmFibGVzWERSID0gb3B0cy5lbmFibGVzWERSO1xuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB0aGlzLnBmeCA9IG9wdHMucGZ4O1xuICB0aGlzLmtleSA9IG9wdHMua2V5O1xuICB0aGlzLnBhc3NwaHJhc2UgPSBvcHRzLnBhc3NwaHJhc2U7XG4gIHRoaXMuY2VydCA9IG9wdHMuY2VydDtcbiAgdGhpcy5jYSA9IG9wdHMuY2E7XG4gIHRoaXMuY2lwaGVycyA9IG9wdHMuY2lwaGVycztcbiAgdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQgPSBvcHRzLnJlamVjdFVuYXV0aG9yaXplZDtcbiAgdGhpcy5mb3JjZU5vZGUgPSBvcHRzLmZvcmNlTm9kZTtcblxuICAvLyBvdGhlciBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB0aGlzLmV4dHJhSGVhZGVycyA9IG9wdHMuZXh0cmFIZWFkZXJzO1xuICB0aGlzLmxvY2FsQWRkcmVzcyA9IG9wdHMubG9jYWxBZGRyZXNzO1xufVxuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAuXG4gKi9cblxuRW1pdHRlcihUcmFuc3BvcnQucHJvdG90eXBlKTtcblxuLyoqXG4gKiBFbWl0cyBhbiBlcnJvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtUcmFuc3BvcnR9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbiAobXNnLCBkZXNjKSB7XG4gIHZhciBlcnIgPSBuZXcgRXJyb3IobXNnKTtcbiAgZXJyLnR5cGUgPSAnVHJhbnNwb3J0RXJyb3InO1xuICBlcnIuZGVzY3JpcHRpb24gPSBkZXNjO1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE9wZW5zIHRoZSB0cmFuc3BvcnQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIGlmICgnY2xvc2VkJyA9PT0gdGhpcy5yZWFkeVN0YXRlIHx8ICcnID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSAnb3BlbmluZyc7XG4gICAgdGhpcy5kb09wZW4oKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDbG9zZXMgdGhlIHRyYW5zcG9ydC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICBpZiAoJ29wZW5pbmcnID09PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ29wZW4nID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICB0aGlzLmRvQ2xvc2UoKTtcbiAgICB0aGlzLm9uQ2xvc2UoKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZW5kcyBtdWx0aXBsZSBwYWNrZXRzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHBhY2tldHNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChwYWNrZXRzKSB7XG4gIGlmICgnb3BlbicgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHRoaXMud3JpdGUocGFja2V0cyk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgbm90IG9wZW4nKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBvcGVuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5vbk9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuJztcbiAgdGhpcy53cml0YWJsZSA9IHRydWU7XG4gIHRoaXMuZW1pdCgnb3BlbicpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2l0aCBkYXRhLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHZhciBwYWNrZXQgPSBwYXJzZXIuZGVjb2RlUGFja2V0KGRhdGEsIHRoaXMuc29ja2V0LmJpbmFyeVR5cGUpO1xuICB0aGlzLm9uUGFja2V0KHBhY2tldCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aXRoIGEgZGVjb2RlZCBwYWNrZXQuXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5vblBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgdGhpcy5lbWl0KCdwYWNrZXQnLCBwYWNrZXQpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBjbG9zZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9uQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuICB0aGlzLmVtaXQoJ2Nsb3NlJyk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG4gIHZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuICB2YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xuICB2YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG59XG5cbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIHZhbHVlcyBtYXRjaCB3aXRoIHRoZSB0eXBlIHNwZWNzLlxuICogRXJyb3IgbWVzc2FnZXMgYXJlIG1lbW9yaXplZCBhbmQgd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHR5cGVTcGVjcyBNYXAgb2YgbmFtZSB0byBhIFJlYWN0UHJvcFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZXMgUnVudGltZSB2YWx1ZXMgdGhhdCBuZWVkIHRvIGJlIHR5cGUtY2hlY2tlZFxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uIGUuZy4gXCJwcm9wXCIsIFwiY29udGV4dFwiLCBcImNoaWxkIGNvbnRleHRcIlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbXBvbmVudE5hbWUgTmFtZSBvZiB0aGUgY29tcG9uZW50IGZvciBlcnJvciBtZXNzYWdlcy5cbiAqIEBwYXJhbSB7P0Z1bmN0aW9ufSBnZXRTdGFjayBSZXR1cm5zIHRoZSBjb21wb25lbnQgc3RhY2suXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGdldFN0YWNrKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKHR5cGVTcGVjcy5oYXNPd25Qcm9wZXJ0eSh0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvcjtcbiAgICAgICAgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGludmFyaWFudCh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gPT09ICdmdW5jdGlvbicsICclczogJXMgdHlwZSBgJXNgIGlzIGludmFsaWQ7IGl0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tICcgKyAndGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCVzYC4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSk7XG4gICAgICAgICAgZXJyb3IgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciA9IGV4O1xuICAgICAgICB9XG4gICAgICAgIHdhcm5pbmcoIWVycm9yIHx8IGVycm9yIGluc3RhbmNlb2YgRXJyb3IsICclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvcik7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IubWVzc2FnZV0gPSB0cnVlO1xuXG4gICAgICAgICAgdmFyIHN0YWNrID0gZ2V0U3RhY2sgPyBnZXRTdGFjaygpIDogJyc7XG5cbiAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAnRmFpbGVkICVzIHR5cGU6ICVzJXMnLCBsb2NhdGlvbiwgZXJyb3IubWVzc2FnZSwgc3RhY2sgIT0gbnVsbCA/IHN0YWNrIDogJycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2hlY2tQcm9wVHlwZXM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcy5qcyIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gY2hlY2tEQ0UoKSB7XG4gIC8qIGdsb2JhbCBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gKi9cbiAgaWYgKFxuICAgIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gPT09ICd1bmRlZmluZWQnIHx8XG4gICAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5jaGVja0RDRSAhPT0gJ2Z1bmN0aW9uJ1xuICApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyBUaGlzIGJyYW5jaCBpcyB1bnJlYWNoYWJsZSBiZWNhdXNlIHRoaXMgZnVuY3Rpb24gaXMgb25seSBjYWxsZWRcbiAgICAvLyBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGNvbmRpdGlvbiBpcyB0cnVlIG9ubHkgaW4gZGV2ZWxvcG1lbnQuXG4gICAgLy8gVGhlcmVmb3JlIGlmIHRoZSBicmFuY2ggaXMgc3RpbGwgaGVyZSwgZGVhZCBjb2RlIGVsaW1pbmF0aW9uIHdhc24ndFxuICAgIC8vIHByb3Blcmx5IGFwcGxpZWQuXG4gICAgLy8gRG9uJ3QgY2hhbmdlIHRoZSBtZXNzYWdlLiBSZWFjdCBEZXZUb29scyByZWxpZXMgb24gaXQuIEFsc28gbWFrZSBzdXJlXG4gICAgLy8gdGhpcyBtZXNzYWdlIGRvZXNuJ3Qgb2NjdXIgZWxzZXdoZXJlIGluIHRoaXMgZnVuY3Rpb24sIG9yIGl0IHdpbGwgY2F1c2VcbiAgICAvLyBhIGZhbHNlIHBvc2l0aXZlLlxuICAgIHRocm93IG5ldyBFcnJvcignXl9eJyk7XG4gIH1cbiAgdHJ5IHtcbiAgICAvLyBWZXJpZnkgdGhhdCB0aGUgY29kZSBhYm92ZSBoYXMgYmVlbiBkZWFkIGNvZGUgZWxpbWluYXRlZCAoRENFJ2QpLlxuICAgIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5jaGVja0RDRShjaGVja0RDRSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIERldlRvb2xzIHNob3VsZG4ndCBjcmFzaCBSZWFjdCwgbm8gbWF0dGVyIHdoYXQuXG4gICAgLy8gV2Ugc2hvdWxkIHN0aWxsIHJlcG9ydCBpbiBjYXNlIHdlIGJyZWFrIHRoaXMgY29kZS5cbiAgICBjb25zb2xlLmVycm9yKGVycik7XG4gIH1cbn1cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgLy8gRENFIGNoZWNrIHNob3VsZCBoYXBwZW4gYmVmb3JlIFJlYWN0RE9NIGJ1bmRsZSBleGVjdXRlcyBzbyB0aGF0XG4gIC8vIERldlRvb2xzIGNhbiByZXBvcnQgYmFkIG1pbmlmaWNhdGlvbiBkdXJpbmcgaW5qZWN0aW9uLlxuICBjaGVja0RDRSgpO1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWRvbS5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1kb20uZGV2ZWxvcG1lbnQuanMnKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vaW5kZXguanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjYW5Vc2VET00gPSAhISh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuZG9jdW1lbnQgJiYgd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xuXG4vKipcbiAqIFNpbXBsZSwgbGlnaHR3ZWlnaHQgbW9kdWxlIGFzc2lzdGluZyB3aXRoIHRoZSBkZXRlY3Rpb24gYW5kIGNvbnRleHQgb2ZcbiAqIFdvcmtlci4gSGVscHMgYXZvaWQgY2lyY3VsYXIgZGVwZW5kZW5jaWVzIGFuZCBhbGxvd3MgY29kZSB0byByZWFzb24gYWJvdXRcbiAqIHdoZXRoZXIgb3Igbm90IHRoZXkgYXJlIGluIGEgV29ya2VyLCBldmVuIGlmIHRoZXkgbmV2ZXIgaW5jbHVkZSB0aGUgbWFpblxuICogYFJlYWN0V29ya2VyYCBkZXBlbmRlbmN5LlxuICovXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSB7XG5cbiAgY2FuVXNlRE9NOiBjYW5Vc2VET00sXG5cbiAgY2FuVXNlV29ya2VyczogdHlwZW9mIFdvcmtlciAhPT0gJ3VuZGVmaW5lZCcsXG5cbiAgY2FuVXNlRXZlbnRMaXN0ZW5lcnM6IGNhblVzZURPTSAmJiAhISh3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciB8fCB3aW5kb3cuYXR0YWNoRXZlbnQpLFxuXG4gIGNhblVzZVZpZXdwb3J0OiBjYW5Vc2VET00gJiYgISF3aW5kb3cuc2NyZWVuLFxuXG4gIGlzSW5Xb3JrZXI6ICFjYW5Vc2VET00gLy8gRm9yIG5vdywgdGhpcyBpcyB0cnVlIC0gbWlnaHQgY2hhbmdlIGluIHRoZSBmdXR1cmUuXG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXhlY3V0aW9uRW52aXJvbm1lbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCcuL2VtcHR5RnVuY3Rpb24nKTtcblxuLyoqXG4gKiBVcHN0cmVhbSB2ZXJzaW9uIG9mIGV2ZW50IGxpc3RlbmVyLiBEb2VzIG5vdCB0YWtlIGludG8gYWNjb3VudCBzcGVjaWZpY1xuICogbmF0dXJlIG9mIHBsYXRmb3JtLlxuICovXG52YXIgRXZlbnRMaXN0ZW5lciA9IHtcbiAgLyoqXG4gICAqIExpc3RlbiB0byBET00gZXZlbnRzIGR1cmluZyB0aGUgYnViYmxlIHBoYXNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSB0YXJnZXQgRE9NIGVsZW1lbnQgdG8gcmVnaXN0ZXIgbGlzdGVuZXIgb24uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGUgRXZlbnQgdHlwZSwgZS5nLiAnY2xpY2snIG9yICdtb3VzZW92ZXInLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvbi5cbiAgICogQHJldHVybiB7b2JqZWN0fSBPYmplY3Qgd2l0aCBhIGByZW1vdmVgIG1ldGhvZC5cbiAgICovXG4gIGxpc3RlbjogZnVuY3Rpb24gbGlzdGVuKHRhcmdldCwgZXZlbnRUeXBlLCBjYWxsYmFjaykge1xuICAgIGlmICh0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBjYWxsYmFjaywgZmFsc2UpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBjYWxsYmFjaywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAodGFyZ2V0LmF0dGFjaEV2ZW50KSB7XG4gICAgICB0YXJnZXQuYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50VHlwZSwgY2FsbGJhY2spO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICAgICAgdGFyZ2V0LmRldGFjaEV2ZW50KCdvbicgKyBldmVudFR5cGUsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIExpc3RlbiB0byBET00gZXZlbnRzIGR1cmluZyB0aGUgY2FwdHVyZSBwaGFzZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gdGFyZ2V0IERPTSBlbGVtZW50IHRvIHJlZ2lzdGVyIGxpc3RlbmVyIG9uLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlIEV2ZW50IHR5cGUsIGUuZy4gJ2NsaWNrJyBvciAnbW91c2VvdmVyJy5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IHdpdGggYSBgcmVtb3ZlYCBtZXRob2QuXG4gICAqL1xuICBjYXB0dXJlOiBmdW5jdGlvbiBjYXB0dXJlKHRhcmdldCwgZXZlbnRUeXBlLCBjYWxsYmFjaykge1xuICAgIGlmICh0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBjYWxsYmFjaywgdHJ1ZSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGNhbGxiYWNrLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignQXR0ZW1wdGVkIHRvIGxpc3RlbiB0byBldmVudHMgZHVyaW5nIHRoZSBjYXB0dXJlIHBoYXNlIG9uIGEgJyArICdicm93c2VyIHRoYXQgZG9lcyBub3Qgc3VwcG9ydCB0aGUgY2FwdHVyZSBwaGFzZS4gWW91ciBhcHBsaWNhdGlvbiAnICsgJ3dpbGwgbm90IHJlY2VpdmUgc29tZSBldmVudHMuJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZW1vdmU6IGVtcHR5RnVuY3Rpb25cbiAgICAgIH07XG4gICAgfVxuICB9LFxuXG4gIHJlZ2lzdGVyRGVmYXVsdDogZnVuY3Rpb24gcmVnaXN0ZXJEZWZhdWx0KCkge31cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRMaXN0ZW5lcjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvRXZlbnRMaXN0ZW5lci5qcyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbi8qIGVzbGludC1kaXNhYmxlIGZiLXd3dy90eXBlb2YtdW5kZWZpbmVkICovXG5cbi8qKlxuICogU2FtZSBhcyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGJ1dCB3cmFwcyBpbiBhIHRyeS1jYXRjaCBibG9jay4gSW4gSUUgaXQgaXNcbiAqIG5vdCBzYWZlIHRvIGNhbGwgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBpZiB0aGVyZSBpcyBub3RoaW5nIGZvY3VzZWQuXG4gKlxuICogVGhlIGFjdGl2ZUVsZW1lbnQgd2lsbCBiZSBudWxsIG9ubHkgaWYgdGhlIGRvY3VtZW50IG9yIGRvY3VtZW50IGJvZHkgaXMgbm90XG4gKiB5ZXQgZGVmaW5lZC5cbiAqXG4gKiBAcGFyYW0gez9ET01Eb2N1bWVudH0gZG9jIERlZmF1bHRzIHRvIGN1cnJlbnQgZG9jdW1lbnQuXG4gKiBAcmV0dXJuIHs/RE9NRWxlbWVudH1cbiAqL1xuZnVuY3Rpb24gZ2V0QWN0aXZlRWxlbWVudChkb2MpIC8qP0RPTUVsZW1lbnQqL3tcbiAgZG9jID0gZG9jIHx8ICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gZG9jdW1lbnQgOiB1bmRlZmluZWQpO1xuICBpZiAodHlwZW9mIGRvYyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB0cnkge1xuICAgIHJldHVybiBkb2MuYWN0aXZlRWxlbWVudCB8fCBkb2MuYm9keTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBkb2MuYm9keTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEFjdGl2ZUVsZW1lbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2dldEFjdGl2ZUVsZW1lbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKiBcbiAqL1xuXG4vKmVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gKi9cbmZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgLy8gU2FtZVZhbHVlIGFsZ29yaXRobVxuICBpZiAoeCA9PT0geSkge1xuICAgIC8vIFN0ZXBzIDEtNSwgNy0xMFxuICAgIC8vIFN0ZXBzIDYuYi02LmU6ICswICE9IC0wXG4gICAgLy8gQWRkZWQgdGhlIG5vbnplcm8geSBjaGVjayB0byBtYWtlIEZsb3cgaGFwcHksIGJ1dCBpdCBpcyByZWR1bmRhbnRcbiAgICByZXR1cm4geCAhPT0gMCB8fCB5ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgfSBlbHNlIHtcbiAgICAvLyBTdGVwIDYuYTogTmFOID09IE5hTlxuICAgIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHk7XG4gIH1cbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBlcXVhbGl0eSBieSBpdGVyYXRpbmcgdGhyb3VnaCBrZXlzIG9uIGFuIG9iamVjdCBhbmQgcmV0dXJuaW5nIGZhbHNlXG4gKiB3aGVuIGFueSBrZXkgaGFzIHZhbHVlcyB3aGljaCBhcmUgbm90IHN0cmljdGx5IGVxdWFsIGJldHdlZW4gdGhlIGFyZ3VtZW50cy5cbiAqIFJldHVybnMgdHJ1ZSB3aGVuIHRoZSB2YWx1ZXMgb2YgYWxsIGtleXMgYXJlIHN0cmljdGx5IGVxdWFsLlxuICovXG5mdW5jdGlvbiBzaGFsbG93RXF1YWwob2JqQSwgb2JqQikge1xuICBpZiAoaXMob2JqQSwgb2JqQikpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqQSAhPT0gJ29iamVjdCcgfHwgb2JqQSA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqQiAhPT0gJ29iamVjdCcgfHwgb2JqQiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKG9iakEpO1xuICB2YXIga2V5c0IgPSBPYmplY3Qua2V5cyhvYmpCKTtcblxuICBpZiAoa2V5c0EubGVuZ3RoICE9PSBrZXlzQi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBUZXN0IGZvciBBJ3Mga2V5cyBkaWZmZXJlbnQgZnJvbSBCLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXNBLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iakIsIGtleXNBW2ldKSB8fCAhaXMob2JqQVtrZXlzQVtpXV0sIG9iakJba2V5c0FbaV1dKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNoYWxsb3dFcXVhbDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvc2hhbGxvd0VxdWFsLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICovXG5cbnZhciBpc1RleHROb2RlID0gcmVxdWlyZSgnLi9pc1RleHROb2RlJyk7XG5cbi8qZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSAqL1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGdpdmVuIERPTSBub2RlIGNvbnRhaW5zIG9yIGlzIGFub3RoZXIgRE9NIG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGNvbnRhaW5zTm9kZShvdXRlck5vZGUsIGlubmVyTm9kZSkge1xuICBpZiAoIW91dGVyTm9kZSB8fCAhaW5uZXJOb2RlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2UgaWYgKG91dGVyTm9kZSA9PT0gaW5uZXJOb2RlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoaXNUZXh0Tm9kZShvdXRlck5vZGUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2UgaWYgKGlzVGV4dE5vZGUoaW5uZXJOb2RlKSkge1xuICAgIHJldHVybiBjb250YWluc05vZGUob3V0ZXJOb2RlLCBpbm5lck5vZGUucGFyZW50Tm9kZSk7XG4gIH0gZWxzZSBpZiAoJ2NvbnRhaW5zJyBpbiBvdXRlck5vZGUpIHtcbiAgICByZXR1cm4gb3V0ZXJOb2RlLmNvbnRhaW5zKGlubmVyTm9kZSk7XG4gIH0gZWxzZSBpZiAob3V0ZXJOb2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKSB7XG4gICAgcmV0dXJuICEhKG91dGVyTm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihpbm5lck5vZGUpICYgMTYpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnRhaW5zTm9kZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvY29udGFpbnNOb2RlLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZSBpbnB1dC90ZXh0YXJlYSB0byBmb2N1c1xuICovXG5cbmZ1bmN0aW9uIGZvY3VzTm9kZShub2RlKSB7XG4gIC8vIElFOCBjYW4gdGhyb3cgXCJDYW4ndCBtb3ZlIGZvY3VzIHRvIHRoZSBjb250cm9sIGJlY2F1c2UgaXQgaXMgaW52aXNpYmxlLFxuICAvLyBub3QgZW5hYmxlZCwgb3Igb2YgYSB0eXBlIHRoYXQgZG9lcyBub3QgYWNjZXB0IHRoZSBmb2N1cy5cIiBmb3IgYWxsIGtpbmRzIG9mXG4gIC8vIHJlYXNvbnMgdGhhdCBhcmUgdG9vIGV4cGVuc2l2ZSBhbmQgZnJhZ2lsZSB0byB0ZXN0LlxuICB0cnkge1xuICAgIG5vZGUuZm9jdXMoKTtcbiAgfSBjYXRjaCAoZSkge31cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmb2N1c05vZGU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2ZvY3VzTm9kZS5qcyIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCdcbmltcG9ydCAnLi9DaGF0QXBwLmNzcydcbmltcG9ydCBIZWFkZXIgZnJvbSAnLi4vaGVhZGVyL0hlYWRlcidcbmltcG9ydCBDaGF0QXJlYSBmcm9tICcuL0NoYXRBcmVhJ1xuaW1wb3J0IENvbm5lY3Rpb25NYW5hZ2VyIGZyb20gJy4uLy4uL3dzL2NsaWVudC9Db25uZWN0aW9uTWFuYWdlcidcbmltcG9ydCBNZXNzYWdlSG9sZGVyIGZyb20gJy4uLy4uL2RhdGEvTWVzc2FnZUhvbGRlcidcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2hhdEFwcCBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yIChwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKVxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBpc0pvaW46IGZhbHNlLFxuICAgICAgbWVzc2FnZXM6IE1lc3NhZ2VIb2xkZXIuZ2V0TWVzc2FnZXMoKSxcbiAgICAgIHVzZXJzOiBbXVxuICAgIH1cbiAgICBDb25uZWN0aW9uTWFuYWdlci5vcGVuKClcbiAgICB0aGlzLnNvY2tldCA9IG51bGxcbiAgfVxuXG4gIG9uSm9pbiAoKSB7XG4gICAgdGhpcy5zb2NrZXQgPSBDb25uZWN0aW9uTWFuYWdlci5nZXRDb25uZWN0aW9uKClcbiAgICB0aGlzLmVzdGFibGlzaFdTKClcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGlzSm9pbjogdHJ1ZVxuICAgIH0pXG4gIH1cblxuICBlc3RhYmxpc2hXUyAoKSB7XG4gICAgaWYgKHRoaXMuc29ja2V0KSB7XG4gICAgICB0aGlzLnNvY2tldC5vbignbWVzc2FnZScsIChtZXNzYWdlKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdkZWJ1ZyBtc2cgJyArIG1lc3NhZ2UuYm9keSlcbiAgICAgICAgTWVzc2FnZUhvbGRlci5hZGRNZXNzYWdlKG1lc3NhZ2UubmFtZSwgbWVzc2FnZS5jb2xvckNvZGUsIG1lc3NhZ2UuYm9keSlcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgbWVzc2FnZXM6IE1lc3NhZ2VIb2xkZXIuZ2V0TWVzc2FnZXMoKVxuICAgICAgICB9KVxuICAgICAgfSlcblxuICAgICAgdGhpcy5zb2NrZXQub24oJ3VzZXJzJywgKGRhdGEpID0+IHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgdXNlcnM6IGRhdGEudXNlcnNcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgb25MZWF2ZSAoKSB7XG4gICAgdGhpcy5zb2NrZXQgPSBudWxsXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBpc0pvaW46IGZhbHNlLFxuICAgICAgbWVzc2FnZXM6IFtdLFxuICAgICAgdXNlcnM6IFtdXG4gICAgfSlcbiAgfVxuXG4gIHJlbmRlciAoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXY+XG4gICAgICAgIDxIZWFkZXIgb25Kb2luPXtlID0+IHRoaXMub25Kb2luKGUpfSBvbkxlYXZlPXtlID0+IHRoaXMub25MZWF2ZShlKX0vPlxuICAgICAgICA8Q2hhdEFyZWEgaXNKb2luPXt0aGlzLnN0YXRlLmlzSm9pbn0gbWVzc2FnZXM9e3RoaXMuc3RhdGUubWVzc2FnZXN9IHVzZXJzPXt0aGlzLnN0YXRlLnVzZXJzfS8+XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb21wb25lbnRzL2NoYXQvQ2hhdEFwcC5qcyIsImltcG9ydCBSZWFjdCwge0NvbXBvbmVudH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgJy4vSGVhZGVyLmNzcydcbmltcG9ydCBDb25uZWN0aW9uTWFuYWdlciBmcm9tICcuLi8uLi93cy9jbGllbnQvQ29ubmVjdGlvbk1hbmFnZXInXG5pbXBvcnQgVXNlciBmcm9tICcuLi8uLi9kYXRhL1VzZXInXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEhlYWRlciBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yIChwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKVxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBsYWJlbDogJ0pvaW4nLFxuICAgICAgbG9naW46IGZhbHNlLFxuICAgICAgdXNlcm5hbWU6ICcnXG4gICAgfVxuICAgIHRoaXMuc29ja2V0ID0gQ29ubmVjdGlvbk1hbmFnZXIuZ2V0Q29ubmVjdGlvbigpXG4gIH1cblxuICB1cGRhdGUgKGUpIHtcbiAgICB0aGlzLnNldFN0YXRlKHt1c2VybmFtZTogZS50YXJnZXQudmFsdWV9KVxuICB9XG5cbiAgb25TdGF0ZUNsaWNrIChlKSB7XG4gICAgY29uc3QgbmFtZSA9IHRoaXMuc3RhdGUudXNlcm5hbWVcbiAgICBpZiAodGhpcy5zdGF0ZS5sb2dpbikge1xuICAgICAgdGhpcy5zb2NrZXQuZW1pdCgnbGVhdmUnLCB7XG4gICAgICAgIGlkOiB0aGlzLnNvY2tldC5pZCxcbiAgICAgICAgbmFtZTogbmFtZVxuICAgICAgfSlcblxuICAgICAgdGhpcy5wcm9wcy5vbkxlYXZlKClcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBsYWJlbDogJ0pvaW4nLFxuICAgICAgICBsb2dpbjogZmFsc2UsXG4gICAgICAgIHVzZXJuYW1lOiAnJ1xuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zb2NrZXQuZW1pdCgnam9pbicsIHtcbiAgICAgICAgaWQ6IHRoaXMuc29ja2V0LmlkLFxuICAgICAgICBuYW1lOiBuYW1lXG4gICAgICB9KVxuICAgICAgVXNlci5zZXROYW1lKG5hbWUpXG4gICAgICB0aGlzLnByb3BzLm9uSm9pbigpXG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgbGFiZWw6ICdMZWF2ZScsXG4gICAgICAgIGxvZ2luOiB0cnVlXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHJlbmRlciAoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxuYXYgY2xhc3NOYW1lPVwibmF2YmFyIG5hdmJhci1pbnZlcnNlXCIgcm9sZT1cIm5hdmlnYXRpb25cIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb250YWluZXJcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm5hdmJhci1oZWFkZXJcIj5cbiAgICAgICAgICAgIDxpbWcgY2xhc3NOYW1lPVwibmF2YmFyLWJyYW5kIGFwcC1sb2dvXCIgc3JjPVwiLi9mYXZpY29uLmljb1wiIC8+XG4gICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJuYXZiYXItYnJhbmRcIj5SZWFjdCBDaGF0PC9zcGFuPlxuICAgICAgICAgICAgPGltZyBjbGFzc05hbWU9XCJuYXZiYXItYnJhbmQgYXBwLWxvZ29cIiBzcmM9XCIuL2Zhdmljb24uaWNvXCIgLz5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8dWwgY2xhc3NOYW1lPVwibmF2IG5hdmJhci1uYXYgbmF2YmFyLXJpZ2h0XCI+XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc3RhdGUubG9naW4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgICA8bGk+XG4gICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgY2xhc3NOYW1lPVwiZm9ybS1jb250cm9sIHVzZXJuYW1lXCIgdHlwZT1cInRleHRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cInVzZXJuYW1lXCIgb25DaGFuZ2U9e2UgPT4gdGhpcy51cGRhdGUoZSl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXt0aGlzLnN0YXRlLnVzZXJuYW1lfSAvPlxuICAgICAgICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgICAgPGxpPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwibmF2YmFyLWJyYW5kXCI+e3RoaXMuc3RhdGUudXNlcm5hbWV9PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICkoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgPGxpPlxuICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzTmFtZT1cImJ0biBidG4tc3VjY2VzcyBuYXZiYXItYnRuXCIgb25DbGljaz17ZSA9PiB0aGlzLm9uU3RhdGVDbGljayhlKX0+XG4gICAgICAgICAgICAgICAge3RoaXMuc3RhdGUubGFiZWx9XG4gICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICA8L3VsPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvbmF2PlxuICAgIClcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbXBvbmVudHMvaGVhZGVyL0hlYWRlci5qcyIsIi8qKlxyXG4gKiBQYXJzZXMgYW4gVVJJXHJcbiAqXHJcbiAqIEBhdXRob3IgU3RldmVuIExldml0aGFuIDxzdGV2ZW5sZXZpdGhhbi5jb20+IChNSVQgbGljZW5zZSlcclxuICogQGFwaSBwcml2YXRlXHJcbiAqL1xyXG5cclxudmFyIHJlID0gL14oPzooPyFbXjpAXSs6W146QFxcL10qQCkoaHR0cHxodHRwc3x3c3x3c3MpOlxcL1xcLyk/KCg/OigoW146QF0qKSg/OjooW146QF0qKSk/KT9AKT8oKD86W2EtZjAtOV17MCw0fTopezIsN31bYS1mMC05XXswLDR9fFteOlxcLz8jXSopKD86OihcXGQqKSk/KSgoKFxcLyg/OltePyNdKD8hW14/I1xcL10qXFwuW14/I1xcLy5dKyg/Ols/I118JCkpKSpcXC8/KT8oW14/I1xcL10qKSkoPzpcXD8oW14jXSopKT8oPzojKC4qKSk/KS87XHJcblxyXG52YXIgcGFydHMgPSBbXHJcbiAgICAnc291cmNlJywgJ3Byb3RvY29sJywgJ2F1dGhvcml0eScsICd1c2VySW5mbycsICd1c2VyJywgJ3Bhc3N3b3JkJywgJ2hvc3QnLCAncG9ydCcsICdyZWxhdGl2ZScsICdwYXRoJywgJ2RpcmVjdG9yeScsICdmaWxlJywgJ3F1ZXJ5JywgJ2FuY2hvcidcclxuXTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2V1cmkoc3RyKSB7XHJcbiAgICB2YXIgc3JjID0gc3RyLFxyXG4gICAgICAgIGIgPSBzdHIuaW5kZXhPZignWycpLFxyXG4gICAgICAgIGUgPSBzdHIuaW5kZXhPZignXScpO1xyXG5cclxuICAgIGlmIChiICE9IC0xICYmIGUgIT0gLTEpIHtcclxuICAgICAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDAsIGIpICsgc3RyLnN1YnN0cmluZyhiLCBlKS5yZXBsYWNlKC86L2csICc7JykgKyBzdHIuc3Vic3RyaW5nKGUsIHN0ci5sZW5ndGgpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBtID0gcmUuZXhlYyhzdHIgfHwgJycpLFxyXG4gICAgICAgIHVyaSA9IHt9LFxyXG4gICAgICAgIGkgPSAxNDtcclxuXHJcbiAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgdXJpW3BhcnRzW2ldXSA9IG1baV0gfHwgJyc7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGIgIT0gLTEgJiYgZSAhPSAtMSkge1xyXG4gICAgICAgIHVyaS5zb3VyY2UgPSBzcmM7XHJcbiAgICAgICAgdXJpLmhvc3QgPSB1cmkuaG9zdC5zdWJzdHJpbmcoMSwgdXJpLmhvc3QubGVuZ3RoIC0gMSkucmVwbGFjZSgvOy9nLCAnOicpO1xyXG4gICAgICAgIHVyaS5hdXRob3JpdHkgPSB1cmkuYXV0aG9yaXR5LnJlcGxhY2UoJ1snLCAnJykucmVwbGFjZSgnXScsICcnKS5yZXBsYWNlKC87L2csICc6Jyk7XHJcbiAgICAgICAgdXJpLmlwdjZ1cmkgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB1cmk7XHJcbn07XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9wYXJzZXVyaS9pbmRleC5qcyIsIi8qIGdsb2JhbCBCbG9iIEZpbGUgKi9cblxuLypcbiAqIE1vZHVsZSByZXF1aXJlbWVudHMuXG4gKi9cblxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgd2l0aE5hdGl2ZUJsb2IgPSB0eXBlb2YgZ2xvYmFsLkJsb2IgPT09ICdmdW5jdGlvbicgfHwgdG9TdHJpbmcuY2FsbChnbG9iYWwuQmxvYikgPT09ICdbb2JqZWN0IEJsb2JDb25zdHJ1Y3Rvcl0nO1xudmFyIHdpdGhOYXRpdmVGaWxlID0gdHlwZW9mIGdsb2JhbC5GaWxlID09PSAnZnVuY3Rpb24nIHx8IHRvU3RyaW5nLmNhbGwoZ2xvYmFsLkZpbGUpID09PSAnW29iamVjdCBGaWxlQ29uc3RydWN0b3JdJztcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc0JpbmFyeTtcblxuLyoqXG4gKiBDaGVja3MgZm9yIGJpbmFyeSBkYXRhLlxuICpcbiAqIFN1cHBvcnRzIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEJsb2IgYW5kIEZpbGUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGFueXRoaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGhhc0JpbmFyeSAob2JqKSB7XG4gIGlmICghb2JqIHx8IHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gb2JqLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKGhhc0JpbmFyeShvYmpbaV0pKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoKHR5cGVvZiBnbG9iYWwuQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIGdsb2JhbC5CdWZmZXIuaXNCdWZmZXIgJiYgZ2xvYmFsLkJ1ZmZlci5pc0J1ZmZlcihvYmopKSB8fFxuICAgICAodHlwZW9mIGdsb2JhbC5BcnJheUJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBvYmogaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHxcbiAgICAgKHdpdGhOYXRpdmVCbG9iICYmIG9iaiBpbnN0YW5jZW9mIEJsb2IpIHx8XG4gICAgICh3aXRoTmF0aXZlRmlsZSAmJiBvYmogaW5zdGFuY2VvZiBGaWxlKVxuICAgICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vQXV0b21hdHRpYy9oYXMtYmluYXJ5L3B1bGwvNFxuICBpZiAob2JqLnRvSlNPTiAmJiB0eXBlb2Ygb2JqLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJyAmJiBhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGhhc0JpbmFyeShvYmoudG9KU09OKCksIHRydWUpO1xuICB9XG5cbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpICYmIGhhc0JpbmFyeShvYmpba2V5XSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9oYXMtYmluYXJ5Mi9pbmRleC5qcyIsIlxubW9kdWxlLmV4cG9ydHMgPSBpc0J1ZjtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgb2JqIGlzIGEgYnVmZmVyIG9yIGFuIGFycmF5YnVmZmVyLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGlzQnVmKG9iaikge1xuICByZXR1cm4gKGdsb2JhbC5CdWZmZXIgJiYgZ2xvYmFsLkJ1ZmZlci5pc0J1ZmZlcihvYmopKSB8fFxuICAgICAgICAgKGdsb2JhbC5BcnJheUJ1ZmZlciAmJiBvYmogaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcik7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9pcy1idWZmZXIuanMiLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgZWlvID0gcmVxdWlyZSgnZW5naW5lLmlvLWNsaWVudCcpO1xudmFyIFNvY2tldCA9IHJlcXVpcmUoJy4vc29ja2V0Jyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgcGFyc2VyID0gcmVxdWlyZSgnc29ja2V0LmlvLXBhcnNlcicpO1xudmFyIG9uID0gcmVxdWlyZSgnLi9vbicpO1xudmFyIGJpbmQgPSByZXF1aXJlKCdjb21wb25lbnQtYmluZCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2V0LmlvLWNsaWVudDptYW5hZ2VyJyk7XG52YXIgaW5kZXhPZiA9IHJlcXVpcmUoJ2luZGV4b2YnKTtcbnZhciBCYWNrb2ZmID0gcmVxdWlyZSgnYmFja28yJyk7XG5cbi8qKlxuICogSUU2KyBoYXNPd25Qcm9wZXJ0eVxuICovXG5cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBNYW5hZ2VyO1xuXG4vKipcbiAqIGBNYW5hZ2VyYCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZW5naW5lIGluc3RhbmNlIG9yIGVuZ2luZSB1cmkvb3B0c1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gTWFuYWdlciAodXJpLCBvcHRzKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBNYW5hZ2VyKSkgcmV0dXJuIG5ldyBNYW5hZ2VyKHVyaSwgb3B0cyk7XG4gIGlmICh1cmkgJiYgKCdvYmplY3QnID09PSB0eXBlb2YgdXJpKSkge1xuICAgIG9wdHMgPSB1cmk7XG4gICAgdXJpID0gdW5kZWZpbmVkO1xuICB9XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIG9wdHMucGF0aCA9IG9wdHMucGF0aCB8fCAnL3NvY2tldC5pbyc7XG4gIHRoaXMubnNwcyA9IHt9O1xuICB0aGlzLnN1YnMgPSBbXTtcbiAgdGhpcy5vcHRzID0gb3B0cztcbiAgdGhpcy5yZWNvbm5lY3Rpb24ob3B0cy5yZWNvbm5lY3Rpb24gIT09IGZhbHNlKTtcbiAgdGhpcy5yZWNvbm5lY3Rpb25BdHRlbXB0cyhvcHRzLnJlY29ubmVjdGlvbkF0dGVtcHRzIHx8IEluZmluaXR5KTtcbiAgdGhpcy5yZWNvbm5lY3Rpb25EZWxheShvcHRzLnJlY29ubmVjdGlvbkRlbGF5IHx8IDEwMDApO1xuICB0aGlzLnJlY29ubmVjdGlvbkRlbGF5TWF4KG9wdHMucmVjb25uZWN0aW9uRGVsYXlNYXggfHwgNTAwMCk7XG4gIHRoaXMucmFuZG9taXphdGlvbkZhY3RvcihvcHRzLnJhbmRvbWl6YXRpb25GYWN0b3IgfHwgMC41KTtcbiAgdGhpcy5iYWNrb2ZmID0gbmV3IEJhY2tvZmYoe1xuICAgIG1pbjogdGhpcy5yZWNvbm5lY3Rpb25EZWxheSgpLFxuICAgIG1heDogdGhpcy5yZWNvbm5lY3Rpb25EZWxheU1heCgpLFxuICAgIGppdHRlcjogdGhpcy5yYW5kb21pemF0aW9uRmFjdG9yKClcbiAgfSk7XG4gIHRoaXMudGltZW91dChudWxsID09IG9wdHMudGltZW91dCA/IDIwMDAwIDogb3B0cy50aW1lb3V0KTtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG4gIHRoaXMudXJpID0gdXJpO1xuICB0aGlzLmNvbm5lY3RpbmcgPSBbXTtcbiAgdGhpcy5sYXN0UGluZyA9IG51bGw7XG4gIHRoaXMuZW5jb2RpbmcgPSBmYWxzZTtcbiAgdGhpcy5wYWNrZXRCdWZmZXIgPSBbXTtcbiAgdmFyIF9wYXJzZXIgPSBvcHRzLnBhcnNlciB8fCBwYXJzZXI7XG4gIHRoaXMuZW5jb2RlciA9IG5ldyBfcGFyc2VyLkVuY29kZXIoKTtcbiAgdGhpcy5kZWNvZGVyID0gbmV3IF9wYXJzZXIuRGVjb2RlcigpO1xuICB0aGlzLmF1dG9Db25uZWN0ID0gb3B0cy5hdXRvQ29ubmVjdCAhPT0gZmFsc2U7XG4gIGlmICh0aGlzLmF1dG9Db25uZWN0KSB0aGlzLm9wZW4oKTtcbn1cblxuLyoqXG4gKiBQcm9wYWdhdGUgZ2l2ZW4gZXZlbnQgdG8gc29ja2V0cyBhbmQgZW1pdCBvbiBgdGhpc2BcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5lbWl0QWxsID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmVtaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgZm9yICh2YXIgbnNwIGluIHRoaXMubnNwcykge1xuICAgIGlmIChoYXMuY2FsbCh0aGlzLm5zcHMsIG5zcCkpIHtcbiAgICAgIHRoaXMubnNwc1tuc3BdLmVtaXQuYXBwbHkodGhpcy5uc3BzW25zcF0sIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFVwZGF0ZSBgc29ja2V0LmlkYCBvZiBhbGwgc29ja2V0c1xuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnVwZGF0ZVNvY2tldElkcyA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgbnNwIGluIHRoaXMubnNwcykge1xuICAgIGlmIChoYXMuY2FsbCh0aGlzLm5zcHMsIG5zcCkpIHtcbiAgICAgIHRoaXMubnNwc1tuc3BdLmlkID0gdGhpcy5nZW5lcmF0ZUlkKG5zcCk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIGdlbmVyYXRlIGBzb2NrZXQuaWRgIGZvciB0aGUgZ2l2ZW4gYG5zcGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbnNwXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5nZW5lcmF0ZUlkID0gZnVuY3Rpb24gKG5zcCkge1xuICByZXR1cm4gKG5zcCA9PT0gJy8nID8gJycgOiAobnNwICsgJyMnKSkgKyB0aGlzLmVuZ2luZS5pZDtcbn07XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKE1hbmFnZXIucHJvdG90eXBlKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBgcmVjb25uZWN0aW9uYCBjb25maWcuXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSB0cnVlL2ZhbHNlIGlmIGl0IHNob3VsZCBhdXRvbWF0aWNhbGx5IHJlY29ubmVjdFxuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3Rpb24gPSBmdW5jdGlvbiAodikge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yZWNvbm5lY3Rpb247XG4gIHRoaXMuX3JlY29ubmVjdGlvbiA9ICEhdjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIHJlY29ubmVjdGlvbiBhdHRlbXB0cyBjb25maWcuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1heCByZWNvbm5lY3Rpb24gYXR0ZW1wdHMgYmVmb3JlIGdpdmluZyB1cFxuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3Rpb25BdHRlbXB0cyA9IGZ1bmN0aW9uICh2KSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbkF0dGVtcHRzO1xuICB0aGlzLl9yZWNvbm5lY3Rpb25BdHRlbXB0cyA9IHY7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBkZWxheSBiZXR3ZWVuIHJlY29ubmVjdGlvbnMuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGRlbGF5XG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdGlvbkRlbGF5ID0gZnVuY3Rpb24gKHYpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmVjb25uZWN0aW9uRGVsYXk7XG4gIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5ID0gdjtcbiAgdGhpcy5iYWNrb2ZmICYmIHRoaXMuYmFja29mZi5zZXRNaW4odik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuTWFuYWdlci5wcm90b3R5cGUucmFuZG9taXphdGlvbkZhY3RvciA9IGZ1bmN0aW9uICh2KSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JhbmRvbWl6YXRpb25GYWN0b3I7XG4gIHRoaXMuX3JhbmRvbWl6YXRpb25GYWN0b3IgPSB2O1xuICB0aGlzLmJhY2tvZmYgJiYgdGhpcy5iYWNrb2ZmLnNldEppdHRlcih2KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIG1heGltdW0gZGVsYXkgYmV0d2VlbiByZWNvbm5lY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheVxuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3Rpb25EZWxheU1heCA9IGZ1bmN0aW9uICh2KSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5TWF4O1xuICB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheU1heCA9IHY7XG4gIHRoaXMuYmFja29mZiAmJiB0aGlzLmJhY2tvZmYuc2V0TWF4KHYpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgY29ubmVjdGlvbiB0aW1lb3V0LiBgZmFsc2VgIHRvIGRpc2FibGVcbiAqXG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnRpbWVvdXQgPSBmdW5jdGlvbiAodikge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl90aW1lb3V0O1xuICB0aGlzLl90aW1lb3V0ID0gdjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFN0YXJ0cyB0cnlpbmcgdG8gcmVjb25uZWN0IGlmIHJlY29ubmVjdGlvbiBpcyBlbmFibGVkIGFuZCB3ZSBoYXZlIG5vdFxuICogc3RhcnRlZCByZWNvbm5lY3RpbmcgeWV0XG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUubWF5YmVSZWNvbm5lY3RPbk9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIC8vIE9ubHkgdHJ5IHRvIHJlY29ubmVjdCBpZiBpdCdzIHRoZSBmaXJzdCB0aW1lIHdlJ3JlIGNvbm5lY3RpbmdcbiAgaWYgKCF0aGlzLnJlY29ubmVjdGluZyAmJiB0aGlzLl9yZWNvbm5lY3Rpb24gJiYgdGhpcy5iYWNrb2ZmLmF0dGVtcHRzID09PSAwKSB7XG4gICAgLy8ga2VlcHMgcmVjb25uZWN0aW9uIGZyb20gZmlyaW5nIHR3aWNlIGZvciB0aGUgc2FtZSByZWNvbm5lY3Rpb24gbG9vcFxuICAgIHRoaXMucmVjb25uZWN0KCk7XG4gIH1cbn07XG5cbi8qKlxuICogU2V0cyB0aGUgY3VycmVudCB0cmFuc3BvcnQgYHNvY2tldGAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9uYWwsIGNhbGxiYWNrXG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9wZW4gPVxuTWFuYWdlci5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uIChmbiwgb3B0cykge1xuICBkZWJ1ZygncmVhZHlTdGF0ZSAlcycsIHRoaXMucmVhZHlTdGF0ZSk7XG4gIGlmICh+dGhpcy5yZWFkeVN0YXRlLmluZGV4T2YoJ29wZW4nKSkgcmV0dXJuIHRoaXM7XG5cbiAgZGVidWcoJ29wZW5pbmcgJXMnLCB0aGlzLnVyaSk7XG4gIHRoaXMuZW5naW5lID0gZWlvKHRoaXMudXJpLCB0aGlzLm9wdHMpO1xuICB2YXIgc29ja2V0ID0gdGhpcy5lbmdpbmU7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW5pbmcnO1xuICB0aGlzLnNraXBSZWNvbm5lY3QgPSBmYWxzZTtcblxuICAvLyBlbWl0IGBvcGVuYFxuICB2YXIgb3BlblN1YiA9IG9uKHNvY2tldCwgJ29wZW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5vbm9wZW4oKTtcbiAgICBmbiAmJiBmbigpO1xuICB9KTtcblxuICAvLyBlbWl0IGBjb25uZWN0X2Vycm9yYFxuICB2YXIgZXJyb3JTdWIgPSBvbihzb2NrZXQsICdlcnJvcicsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGVidWcoJ2Nvbm5lY3RfZXJyb3InKTtcbiAgICBzZWxmLmNsZWFudXAoKTtcbiAgICBzZWxmLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcbiAgICBzZWxmLmVtaXRBbGwoJ2Nvbm5lY3RfZXJyb3InLCBkYXRhKTtcbiAgICBpZiAoZm4pIHtcbiAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ0Nvbm5lY3Rpb24gZXJyb3InKTtcbiAgICAgIGVyci5kYXRhID0gZGF0YTtcbiAgICAgIGZuKGVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE9ubHkgZG8gdGhpcyBpZiB0aGVyZSBpcyBubyBmbiB0byBoYW5kbGUgdGhlIGVycm9yXG4gICAgICBzZWxmLm1heWJlUmVjb25uZWN0T25PcGVuKCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBlbWl0IGBjb25uZWN0X3RpbWVvdXRgXG4gIGlmIChmYWxzZSAhPT0gdGhpcy5fdGltZW91dCkge1xuICAgIHZhciB0aW1lb3V0ID0gdGhpcy5fdGltZW91dDtcbiAgICBkZWJ1ZygnY29ubmVjdCBhdHRlbXB0IHdpbGwgdGltZW91dCBhZnRlciAlZCcsIHRpbWVvdXQpO1xuXG4gICAgLy8gc2V0IHRpbWVyXG4gICAgdmFyIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBkZWJ1ZygnY29ubmVjdCBhdHRlbXB0IHRpbWVkIG91dCBhZnRlciAlZCcsIHRpbWVvdXQpO1xuICAgICAgb3BlblN1Yi5kZXN0cm95KCk7XG4gICAgICBzb2NrZXQuY2xvc2UoKTtcbiAgICAgIHNvY2tldC5lbWl0KCdlcnJvcicsICd0aW1lb3V0Jyk7XG4gICAgICBzZWxmLmVtaXRBbGwoJ2Nvbm5lY3RfdGltZW91dCcsIHRpbWVvdXQpO1xuICAgIH0sIHRpbWVvdXQpO1xuXG4gICAgdGhpcy5zdWJzLnB1c2goe1xuICAgICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgdGhpcy5zdWJzLnB1c2gob3BlblN1Yik7XG4gIHRoaXMuc3Vicy5wdXNoKGVycm9yU3ViKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IG9wZW4uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25vcGVuID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1Zygnb3BlbicpO1xuXG4gIC8vIGNsZWFyIG9sZCBzdWJzXG4gIHRoaXMuY2xlYW51cCgpO1xuXG4gIC8vIG1hcmsgYXMgb3BlblxuICB0aGlzLnJlYWR5U3RhdGUgPSAnb3Blbic7XG4gIHRoaXMuZW1pdCgnb3BlbicpO1xuXG4gIC8vIGFkZCBuZXcgc3Vic1xuICB2YXIgc29ja2V0ID0gdGhpcy5lbmdpbmU7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ2RhdGEnLCBiaW5kKHRoaXMsICdvbmRhdGEnKSkpO1xuICB0aGlzLnN1YnMucHVzaChvbihzb2NrZXQsICdwaW5nJywgYmluZCh0aGlzLCAnb25waW5nJykpKTtcbiAgdGhpcy5zdWJzLnB1c2gob24oc29ja2V0LCAncG9uZycsIGJpbmQodGhpcywgJ29ucG9uZycpKSk7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ2Vycm9yJywgYmluZCh0aGlzLCAnb25lcnJvcicpKSk7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ2Nsb3NlJywgYmluZCh0aGlzLCAnb25jbG9zZScpKSk7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHRoaXMuZGVjb2RlciwgJ2RlY29kZWQnLCBiaW5kKHRoaXMsICdvbmRlY29kZWQnKSkpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBhIHBpbmcuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25waW5nID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmxhc3RQaW5nID0gbmV3IERhdGUoKTtcbiAgdGhpcy5lbWl0QWxsKCdwaW5nJyk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGEgcGFja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9ucG9uZyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5lbWl0QWxsKCdwb25nJywgbmV3IERhdGUoKSAtIHRoaXMubGFzdFBpbmcpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2l0aCBkYXRhLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9uZGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuZGVjb2Rlci5hZGQoZGF0YSk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aGVuIHBhcnNlciBmdWxseSBkZWNvZGVzIGEgcGFja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9uZGVjb2RlZCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgdGhpcy5lbWl0KCdwYWNrZXQnLCBwYWNrZXQpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBzb2NrZXQgZXJyb3IuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgZGVidWcoJ2Vycm9yJywgZXJyKTtcbiAgdGhpcy5lbWl0QWxsKCdlcnJvcicsIGVycik7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgc29ja2V0IGZvciB0aGUgZ2l2ZW4gYG5zcGAuXG4gKlxuICogQHJldHVybiB7U29ja2V0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5zb2NrZXQgPSBmdW5jdGlvbiAobnNwLCBvcHRzKSB7XG4gIHZhciBzb2NrZXQgPSB0aGlzLm5zcHNbbnNwXTtcbiAgaWYgKCFzb2NrZXQpIHtcbiAgICBzb2NrZXQgPSBuZXcgU29ja2V0KHRoaXMsIG5zcCwgb3B0cyk7XG4gICAgdGhpcy5uc3BzW25zcF0gPSBzb2NrZXQ7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNvY2tldC5vbignY29ubmVjdGluZycsIG9uQ29ubmVjdGluZyk7XG4gICAgc29ja2V0Lm9uKCdjb25uZWN0JywgZnVuY3Rpb24gKCkge1xuICAgICAgc29ja2V0LmlkID0gc2VsZi5nZW5lcmF0ZUlkKG5zcCk7XG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5hdXRvQ29ubmVjdCkge1xuICAgICAgLy8gbWFudWFsbHkgY2FsbCBoZXJlIHNpbmNlIGNvbm5lY3RpbmcgZXZlbnQgaXMgZmlyZWQgYmVmb3JlIGxpc3RlbmluZ1xuICAgICAgb25Db25uZWN0aW5nKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25Db25uZWN0aW5nICgpIHtcbiAgICBpZiAoIX5pbmRleE9mKHNlbGYuY29ubmVjdGluZywgc29ja2V0KSkge1xuICAgICAgc2VsZi5jb25uZWN0aW5nLnB1c2goc29ja2V0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc29ja2V0O1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBhIHNvY2tldCBjbG9zZS5cbiAqXG4gKiBAcGFyYW0ge1NvY2tldH0gc29ja2V0XG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChzb2NrZXQpIHtcbiAgdmFyIGluZGV4ID0gaW5kZXhPZih0aGlzLmNvbm5lY3RpbmcsIHNvY2tldCk7XG4gIGlmICh+aW5kZXgpIHRoaXMuY29ubmVjdGluZy5zcGxpY2UoaW5kZXgsIDEpO1xuICBpZiAodGhpcy5jb25uZWN0aW5nLmxlbmd0aCkgcmV0dXJuO1xuXG4gIHRoaXMuY2xvc2UoKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgcGFja2V0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgZGVidWcoJ3dyaXRpbmcgcGFja2V0ICVqJywgcGFja2V0KTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAocGFja2V0LnF1ZXJ5ICYmIHBhY2tldC50eXBlID09PSAwKSBwYWNrZXQubnNwICs9ICc/JyArIHBhY2tldC5xdWVyeTtcblxuICBpZiAoIXNlbGYuZW5jb2RpbmcpIHtcbiAgICAvLyBlbmNvZGUsIHRoZW4gd3JpdGUgdG8gZW5naW5lIHdpdGggcmVzdWx0XG4gICAgc2VsZi5lbmNvZGluZyA9IHRydWU7XG4gICAgdGhpcy5lbmNvZGVyLmVuY29kZShwYWNrZXQsIGZ1bmN0aW9uIChlbmNvZGVkUGFja2V0cykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbmNvZGVkUGFja2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzZWxmLmVuZ2luZS53cml0ZShlbmNvZGVkUGFja2V0c1tpXSwgcGFja2V0Lm9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgc2VsZi5lbmNvZGluZyA9IGZhbHNlO1xuICAgICAgc2VsZi5wcm9jZXNzUGFja2V0UXVldWUoKTtcbiAgICB9KTtcbiAgfSBlbHNlIHsgLy8gYWRkIHBhY2tldCB0byB0aGUgcXVldWVcbiAgICBzZWxmLnBhY2tldEJ1ZmZlci5wdXNoKHBhY2tldCk7XG4gIH1cbn07XG5cbi8qKlxuICogSWYgcGFja2V0IGJ1ZmZlciBpcyBub24tZW1wdHksIGJlZ2lucyBlbmNvZGluZyB0aGVcbiAqIG5leHQgcGFja2V0IGluIGxpbmUuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucHJvY2Vzc1BhY2tldFF1ZXVlID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5wYWNrZXRCdWZmZXIubGVuZ3RoID4gMCAmJiAhdGhpcy5lbmNvZGluZykge1xuICAgIHZhciBwYWNrID0gdGhpcy5wYWNrZXRCdWZmZXIuc2hpZnQoKTtcbiAgICB0aGlzLnBhY2tldChwYWNrKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDbGVhbiB1cCB0cmFuc3BvcnQgc3Vic2NyaXB0aW9ucyBhbmQgcGFja2V0IGJ1ZmZlci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5jbGVhbnVwID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygnY2xlYW51cCcpO1xuXG4gIHZhciBzdWJzTGVuZ3RoID0gdGhpcy5zdWJzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJzTGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc3ViID0gdGhpcy5zdWJzLnNoaWZ0KCk7XG4gICAgc3ViLmRlc3Ryb3koKTtcbiAgfVxuXG4gIHRoaXMucGFja2V0QnVmZmVyID0gW107XG4gIHRoaXMuZW5jb2RpbmcgPSBmYWxzZTtcbiAgdGhpcy5sYXN0UGluZyA9IG51bGw7XG5cbiAgdGhpcy5kZWNvZGVyLmRlc3Ryb3koKTtcbn07XG5cbi8qKlxuICogQ2xvc2UgdGhlIGN1cnJlbnQgc29ja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLmNsb3NlID1cbk1hbmFnZXIucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdkaXNjb25uZWN0Jyk7XG4gIHRoaXMuc2tpcFJlY29ubmVjdCA9IHRydWU7XG4gIHRoaXMucmVjb25uZWN0aW5nID0gZmFsc2U7XG4gIGlmICgnb3BlbmluZycgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIC8vIGBvbmNsb3NlYCB3aWxsIG5vdCBmaXJlIGJlY2F1c2VcbiAgICAvLyBhbiBvcGVuIGV2ZW50IG5ldmVyIGhhcHBlbmVkXG4gICAgdGhpcy5jbGVhbnVwKCk7XG4gIH1cbiAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuICBpZiAodGhpcy5lbmdpbmUpIHRoaXMuZW5naW5lLmNsb3NlKCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGVuZ2luZSBjbG9zZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbmNsb3NlID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICBkZWJ1Zygnb25jbG9zZScpO1xuXG4gIHRoaXMuY2xlYW51cCgpO1xuICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG4gIHRoaXMuZW1pdCgnY2xvc2UnLCByZWFzb24pO1xuXG4gIGlmICh0aGlzLl9yZWNvbm5lY3Rpb24gJiYgIXRoaXMuc2tpcFJlY29ubmVjdCkge1xuICAgIHRoaXMucmVjb25uZWN0KCk7XG4gIH1cbn07XG5cbi8qKlxuICogQXR0ZW1wdCBhIHJlY29ubmVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnJlY29ubmVjdGluZyB8fCB0aGlzLnNraXBSZWNvbm5lY3QpIHJldHVybiB0aGlzO1xuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAodGhpcy5iYWNrb2ZmLmF0dGVtcHRzID49IHRoaXMuX3JlY29ubmVjdGlvbkF0dGVtcHRzKSB7XG4gICAgZGVidWcoJ3JlY29ubmVjdCBmYWlsZWQnKTtcbiAgICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcbiAgICB0aGlzLmVtaXRBbGwoJ3JlY29ubmVjdF9mYWlsZWQnKTtcbiAgICB0aGlzLnJlY29ubmVjdGluZyA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHZhciBkZWxheSA9IHRoaXMuYmFja29mZi5kdXJhdGlvbigpO1xuICAgIGRlYnVnKCd3aWxsIHdhaXQgJWRtcyBiZWZvcmUgcmVjb25uZWN0IGF0dGVtcHQnLCBkZWxheSk7XG5cbiAgICB0aGlzLnJlY29ubmVjdGluZyA9IHRydWU7XG4gICAgdmFyIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc2VsZi5za2lwUmVjb25uZWN0KSByZXR1cm47XG5cbiAgICAgIGRlYnVnKCdhdHRlbXB0aW5nIHJlY29ubmVjdCcpO1xuICAgICAgc2VsZi5lbWl0QWxsKCdyZWNvbm5lY3RfYXR0ZW1wdCcsIHNlbGYuYmFja29mZi5hdHRlbXB0cyk7XG4gICAgICBzZWxmLmVtaXRBbGwoJ3JlY29ubmVjdGluZycsIHNlbGYuYmFja29mZi5hdHRlbXB0cyk7XG5cbiAgICAgIC8vIGNoZWNrIGFnYWluIGZvciB0aGUgY2FzZSBzb2NrZXQgY2xvc2VkIGluIGFib3ZlIGV2ZW50c1xuICAgICAgaWYgKHNlbGYuc2tpcFJlY29ubmVjdCkgcmV0dXJuO1xuXG4gICAgICBzZWxmLm9wZW4oZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgZGVidWcoJ3JlY29ubmVjdCBhdHRlbXB0IGVycm9yJyk7XG4gICAgICAgICAgc2VsZi5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICBzZWxmLnJlY29ubmVjdCgpO1xuICAgICAgICAgIHNlbGYuZW1pdEFsbCgncmVjb25uZWN0X2Vycm9yJywgZXJyLmRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlYnVnKCdyZWNvbm5lY3Qgc3VjY2VzcycpO1xuICAgICAgICAgIHNlbGYub25yZWNvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSwgZGVsYXkpO1xuXG4gICAgdGhpcy5zdWJzLnB1c2goe1xuICAgICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHN1Y2Nlc3NmdWwgcmVjb25uZWN0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9ucmVjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYXR0ZW1wdCA9IHRoaXMuYmFja29mZi5hdHRlbXB0cztcbiAgdGhpcy5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gIHRoaXMudXBkYXRlU29ja2V0SWRzKCk7XG4gIHRoaXMuZW1pdEFsbCgncmVjb25uZWN0JywgYXR0ZW1wdCk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbGliL21hbmFnZXIuanMiLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXNcbiAqL1xuXG52YXIgWE1MSHR0cFJlcXVlc3QgPSByZXF1aXJlKCd4bWxodHRwcmVxdWVzdC1zc2wnKTtcbnZhciBYSFIgPSByZXF1aXJlKCcuL3BvbGxpbmcteGhyJyk7XG52YXIgSlNPTlAgPSByZXF1aXJlKCcuL3BvbGxpbmctanNvbnAnKTtcbnZhciB3ZWJzb2NrZXQgPSByZXF1aXJlKCcuL3dlYnNvY2tldCcpO1xuXG4vKipcbiAqIEV4cG9ydCB0cmFuc3BvcnRzLlxuICovXG5cbmV4cG9ydHMucG9sbGluZyA9IHBvbGxpbmc7XG5leHBvcnRzLndlYnNvY2tldCA9IHdlYnNvY2tldDtcblxuLyoqXG4gKiBQb2xsaW5nIHRyYW5zcG9ydCBwb2x5bW9ycGhpYyBjb25zdHJ1Y3Rvci5cbiAqIERlY2lkZXMgb24geGhyIHZzIGpzb25wIGJhc2VkIG9uIGZlYXR1cmUgZGV0ZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBvbGxpbmcgKG9wdHMpIHtcbiAgdmFyIHhocjtcbiAgdmFyIHhkID0gZmFsc2U7XG4gIHZhciB4cyA9IGZhbHNlO1xuICB2YXIganNvbnAgPSBmYWxzZSAhPT0gb3B0cy5qc29ucDtcblxuICBpZiAoZ2xvYmFsLmxvY2F0aW9uKSB7XG4gICAgdmFyIGlzU1NMID0gJ2h0dHBzOicgPT09IGxvY2F0aW9uLnByb3RvY29sO1xuICAgIHZhciBwb3J0ID0gbG9jYXRpb24ucG9ydDtcblxuICAgIC8vIHNvbWUgdXNlciBhZ2VudHMgaGF2ZSBlbXB0eSBgbG9jYXRpb24ucG9ydGBcbiAgICBpZiAoIXBvcnQpIHtcbiAgICAgIHBvcnQgPSBpc1NTTCA/IDQ0MyA6IDgwO1xuICAgIH1cblxuICAgIHhkID0gb3B0cy5ob3N0bmFtZSAhPT0gbG9jYXRpb24uaG9zdG5hbWUgfHwgcG9ydCAhPT0gb3B0cy5wb3J0O1xuICAgIHhzID0gb3B0cy5zZWN1cmUgIT09IGlzU1NMO1xuICB9XG5cbiAgb3B0cy54ZG9tYWluID0geGQ7XG4gIG9wdHMueHNjaGVtZSA9IHhzO1xuICB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3Qob3B0cyk7XG5cbiAgaWYgKCdvcGVuJyBpbiB4aHIgJiYgIW9wdHMuZm9yY2VKU09OUCkge1xuICAgIHJldHVybiBuZXcgWEhSKG9wdHMpO1xuICB9IGVsc2Uge1xuICAgIGlmICghanNvbnApIHRocm93IG5ldyBFcnJvcignSlNPTlAgZGlzYWJsZWQnKTtcbiAgICByZXR1cm4gbmV3IEpTT05QKG9wdHMpO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy9pbmRleC5qcyIsIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi4vdHJhbnNwb3J0Jyk7XG52YXIgcGFyc2VxcyA9IHJlcXVpcmUoJ3BhcnNlcXMnKTtcbnZhciBwYXJzZXIgPSByZXF1aXJlKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG52YXIgaW5oZXJpdCA9IHJlcXVpcmUoJ2NvbXBvbmVudC1pbmhlcml0Jyk7XG52YXIgeWVhc3QgPSByZXF1aXJlKCd5ZWFzdCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnZW5naW5lLmlvLWNsaWVudDpwb2xsaW5nJyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBQb2xsaW5nO1xuXG4vKipcbiAqIElzIFhIUjIgc3VwcG9ydGVkP1xuICovXG5cbnZhciBoYXNYSFIyID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIFhNTEh0dHBSZXF1ZXN0ID0gcmVxdWlyZSgneG1saHR0cHJlcXVlc3Qtc3NsJyk7XG4gIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoeyB4ZG9tYWluOiBmYWxzZSB9KTtcbiAgcmV0dXJuIG51bGwgIT0geGhyLnJlc3BvbnNlVHlwZTtcbn0pKCk7XG5cbi8qKlxuICogUG9sbGluZyBpbnRlcmZhY2UuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIFBvbGxpbmcgKG9wdHMpIHtcbiAgdmFyIGZvcmNlQmFzZTY0ID0gKG9wdHMgJiYgb3B0cy5mb3JjZUJhc2U2NCk7XG4gIGlmICghaGFzWEhSMiB8fCBmb3JjZUJhc2U2NCkge1xuICAgIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSBmYWxzZTtcbiAgfVxuICBUcmFuc3BvcnQuY2FsbCh0aGlzLCBvcHRzKTtcbn1cblxuLyoqXG4gKiBJbmhlcml0cyBmcm9tIFRyYW5zcG9ydC5cbiAqL1xuXG5pbmhlcml0KFBvbGxpbmcsIFRyYW5zcG9ydCk7XG5cbi8qKlxuICogVHJhbnNwb3J0IG5hbWUuXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUubmFtZSA9ICdwb2xsaW5nJztcblxuLyoqXG4gKiBPcGVucyB0aGUgc29ja2V0ICh0cmlnZ2VycyBwb2xsaW5nKS4gV2Ugd3JpdGUgYSBQSU5HIG1lc3NhZ2UgdG8gZGV0ZXJtaW5lXG4gKiB3aGVuIHRoZSB0cmFuc3BvcnQgaXMgb3Blbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5kb09wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucG9sbCgpO1xufTtcblxuLyoqXG4gKiBQYXVzZXMgcG9sbGluZy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayB1cG9uIGJ1ZmZlcnMgYXJlIGZsdXNoZWQgYW5kIHRyYW5zcG9ydCBpcyBwYXVzZWRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKG9uUGF1c2UpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdwYXVzaW5nJztcblxuICBmdW5jdGlvbiBwYXVzZSAoKSB7XG4gICAgZGVidWcoJ3BhdXNlZCcpO1xuICAgIHNlbGYucmVhZHlTdGF0ZSA9ICdwYXVzZWQnO1xuICAgIG9uUGF1c2UoKTtcbiAgfVxuXG4gIGlmICh0aGlzLnBvbGxpbmcgfHwgIXRoaXMud3JpdGFibGUpIHtcbiAgICB2YXIgdG90YWwgPSAwO1xuXG4gICAgaWYgKHRoaXMucG9sbGluZykge1xuICAgICAgZGVidWcoJ3dlIGFyZSBjdXJyZW50bHkgcG9sbGluZyAtIHdhaXRpbmcgdG8gcGF1c2UnKTtcbiAgICAgIHRvdGFsKys7XG4gICAgICB0aGlzLm9uY2UoJ3BvbGxDb21wbGV0ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZGVidWcoJ3ByZS1wYXVzZSBwb2xsaW5nIGNvbXBsZXRlJyk7XG4gICAgICAgIC0tdG90YWwgfHwgcGF1c2UoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICghdGhpcy53cml0YWJsZSkge1xuICAgICAgZGVidWcoJ3dlIGFyZSBjdXJyZW50bHkgd3JpdGluZyAtIHdhaXRpbmcgdG8gcGF1c2UnKTtcbiAgICAgIHRvdGFsKys7XG4gICAgICB0aGlzLm9uY2UoJ2RyYWluJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBkZWJ1ZygncHJlLXBhdXNlIHdyaXRpbmcgY29tcGxldGUnKTtcbiAgICAgICAgLS10b3RhbCB8fCBwYXVzZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHBhdXNlKCk7XG4gIH1cbn07XG5cbi8qKlxuICogU3RhcnRzIHBvbGxpbmcgY3ljbGUuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5wb2xsID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygncG9sbGluZycpO1xuICB0aGlzLnBvbGxpbmcgPSB0cnVlO1xuICB0aGlzLmRvUG9sbCgpO1xuICB0aGlzLmVtaXQoJ3BvbGwnKTtcbn07XG5cbi8qKlxuICogT3ZlcmxvYWRzIG9uRGF0YSB0byBkZXRlY3QgcGF5bG9hZHMuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBkZWJ1ZygncG9sbGluZyBnb3QgZGF0YSAlcycsIGRhdGEpO1xuICB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbiAocGFja2V0LCBpbmRleCwgdG90YWwpIHtcbiAgICAvLyBpZiBpdHMgdGhlIGZpcnN0IG1lc3NhZ2Ugd2UgY29uc2lkZXIgdGhlIHRyYW5zcG9ydCBvcGVuXG4gICAgaWYgKCdvcGVuaW5nJyA9PT0gc2VsZi5yZWFkeVN0YXRlKSB7XG4gICAgICBzZWxmLm9uT3BlbigpO1xuICAgIH1cblxuICAgIC8vIGlmIGl0cyBhIGNsb3NlIHBhY2tldCwgd2UgY2xvc2UgdGhlIG9uZ29pbmcgcmVxdWVzdHNcbiAgICBpZiAoJ2Nsb3NlJyA9PT0gcGFja2V0LnR5cGUpIHtcbiAgICAgIHNlbGYub25DbG9zZSgpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIG90aGVyd2lzZSBieXBhc3Mgb25EYXRhIGFuZCBoYW5kbGUgdGhlIG1lc3NhZ2VcbiAgICBzZWxmLm9uUGFja2V0KHBhY2tldCk7XG4gIH07XG5cbiAgLy8gZGVjb2RlIHBheWxvYWRcbiAgcGFyc2VyLmRlY29kZVBheWxvYWQoZGF0YSwgdGhpcy5zb2NrZXQuYmluYXJ5VHlwZSwgY2FsbGJhY2spO1xuXG4gIC8vIGlmIGFuIGV2ZW50IGRpZCBub3QgdHJpZ2dlciBjbG9zaW5nXG4gIGlmICgnY2xvc2VkJyAhPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgLy8gaWYgd2UgZ290IGRhdGEgd2UncmUgbm90IHBvbGxpbmdcbiAgICB0aGlzLnBvbGxpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ3BvbGxDb21wbGV0ZScpO1xuXG4gICAgaWYgKCdvcGVuJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgICB0aGlzLnBvbGwoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWcoJ2lnbm9yaW5nIHBvbGwgLSB0cmFuc3BvcnQgc3RhdGUgXCIlc1wiJywgdGhpcy5yZWFkeVN0YXRlKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogRm9yIHBvbGxpbmcsIHNlbmQgYSBjbG9zZSBwYWNrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUuZG9DbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGZ1bmN0aW9uIGNsb3NlICgpIHtcbiAgICBkZWJ1Zygnd3JpdGluZyBjbG9zZSBwYWNrZXQnKTtcbiAgICBzZWxmLndyaXRlKFt7IHR5cGU6ICdjbG9zZScgfV0pO1xuICB9XG5cbiAgaWYgKCdvcGVuJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgZGVidWcoJ3RyYW5zcG9ydCBvcGVuIC0gY2xvc2luZycpO1xuICAgIGNsb3NlKCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gaW4gY2FzZSB3ZSdyZSB0cnlpbmcgdG8gY2xvc2Ugd2hpbGVcbiAgICAvLyBoYW5kc2hha2luZyBpcyBpbiBwcm9ncmVzcyAoR0gtMTY0KVxuICAgIGRlYnVnKCd0cmFuc3BvcnQgbm90IG9wZW4gLSBkZWZlcnJpbmcgY2xvc2UnKTtcbiAgICB0aGlzLm9uY2UoJ29wZW4nLCBjbG9zZSk7XG4gIH1cbn07XG5cbi8qKlxuICogV3JpdGVzIGEgcGFja2V0cyBwYXlsb2FkLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGRhdGEgcGFja2V0c1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZHJhaW4gY2FsbGJhY2tcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHBhY2tldHMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG4gIHZhciBjYWxsYmFja2ZuID0gZnVuY3Rpb24gKCkge1xuICAgIHNlbGYud3JpdGFibGUgPSB0cnVlO1xuICAgIHNlbGYuZW1pdCgnZHJhaW4nKTtcbiAgfTtcblxuICBwYXJzZXIuZW5jb2RlUGF5bG9hZChwYWNrZXRzLCB0aGlzLnN1cHBvcnRzQmluYXJ5LCBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHNlbGYuZG9Xcml0ZShkYXRhLCBjYWxsYmFja2ZuKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyB1cmkgZm9yIGNvbm5lY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUudXJpID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcXVlcnkgPSB0aGlzLnF1ZXJ5IHx8IHt9O1xuICB2YXIgc2NoZW1hID0gdGhpcy5zZWN1cmUgPyAnaHR0cHMnIDogJ2h0dHAnO1xuICB2YXIgcG9ydCA9ICcnO1xuXG4gIC8vIGNhY2hlIGJ1c3RpbmcgaXMgZm9yY2VkXG4gIGlmIChmYWxzZSAhPT0gdGhpcy50aW1lc3RhbXBSZXF1ZXN0cykge1xuICAgIHF1ZXJ5W3RoaXMudGltZXN0YW1wUGFyYW1dID0geWVhc3QoKTtcbiAgfVxuXG4gIGlmICghdGhpcy5zdXBwb3J0c0JpbmFyeSAmJiAhcXVlcnkuc2lkKSB7XG4gICAgcXVlcnkuYjY0ID0gMTtcbiAgfVxuXG4gIHF1ZXJ5ID0gcGFyc2Vxcy5lbmNvZGUocXVlcnkpO1xuXG4gIC8vIGF2b2lkIHBvcnQgaWYgZGVmYXVsdCBmb3Igc2NoZW1hXG4gIGlmICh0aGlzLnBvcnQgJiYgKCgnaHR0cHMnID09PSBzY2hlbWEgJiYgTnVtYmVyKHRoaXMucG9ydCkgIT09IDQ0MykgfHxcbiAgICAgKCdodHRwJyA9PT0gc2NoZW1hICYmIE51bWJlcih0aGlzLnBvcnQpICE9PSA4MCkpKSB7XG4gICAgcG9ydCA9ICc6JyArIHRoaXMucG9ydDtcbiAgfVxuXG4gIC8vIHByZXBlbmQgPyB0byBxdWVyeVxuICBpZiAocXVlcnkubGVuZ3RoKSB7XG4gICAgcXVlcnkgPSAnPycgKyBxdWVyeTtcbiAgfVxuXG4gIHZhciBpcHY2ID0gdGhpcy5ob3N0bmFtZS5pbmRleE9mKCc6JykgIT09IC0xO1xuICByZXR1cm4gc2NoZW1hICsgJzovLycgKyAoaXB2NiA/ICdbJyArIHRoaXMuaG9zdG5hbWUgKyAnXScgOiB0aGlzLmhvc3RuYW1lKSArIHBvcnQgKyB0aGlzLnBhdGggKyBxdWVyeTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy9wb2xsaW5nLmpzIiwiLyogZ2xvYmFscyBfX3dlYnBhY2tfYW1kX29wdGlvbnNfXyAqL1xubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfYW1kX29wdGlvbnNfXztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9idWlsZGluL2FtZC1vcHRpb25zLmpzXG4vLyBtb2R1bGUgaWQgPSAzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBhbHBoYWJldCA9ICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ei1fJy5zcGxpdCgnJylcbiAgLCBsZW5ndGggPSA2NFxuICAsIG1hcCA9IHt9XG4gICwgc2VlZCA9IDBcbiAgLCBpID0gMFxuICAsIHByZXY7XG5cbi8qKlxuICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgc3BlY2lmaWVkIG51bWJlci5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbnVtIFRoZSBudW1iZXIgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG51bWJlci5cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIGVuY29kZShudW0pIHtcbiAgdmFyIGVuY29kZWQgPSAnJztcblxuICBkbyB7XG4gICAgZW5jb2RlZCA9IGFscGhhYmV0W251bSAlIGxlbmd0aF0gKyBlbmNvZGVkO1xuICAgIG51bSA9IE1hdGguZmxvb3IobnVtIC8gbGVuZ3RoKTtcbiAgfSB3aGlsZSAobnVtID4gMCk7XG5cbiAgcmV0dXJuIGVuY29kZWQ7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBpbnRlZ2VyIHZhbHVlIHNwZWNpZmllZCBieSB0aGUgZ2l2ZW4gc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge051bWJlcn0gVGhlIGludGVnZXIgdmFsdWUgcmVwcmVzZW50ZWQgYnkgdGhlIHN0cmluZy5cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIGRlY29kZShzdHIpIHtcbiAgdmFyIGRlY29kZWQgPSAwO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBkZWNvZGVkID0gZGVjb2RlZCAqIGxlbmd0aCArIG1hcFtzdHIuY2hhckF0KGkpXTtcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVkO1xufVxuXG4vKipcbiAqIFllYXN0OiBBIHRpbnkgZ3Jvd2luZyBpZCBnZW5lcmF0b3IuXG4gKlxuICogQHJldHVybnMge1N0cmluZ30gQSB1bmlxdWUgaWQuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiB5ZWFzdCgpIHtcbiAgdmFyIG5vdyA9IGVuY29kZSgrbmV3IERhdGUoKSk7XG5cbiAgaWYgKG5vdyAhPT0gcHJldikgcmV0dXJuIHNlZWQgPSAwLCBwcmV2ID0gbm93O1xuICByZXR1cm4gbm93ICsnLicrIGVuY29kZShzZWVkKyspO1xufVxuXG4vL1xuLy8gTWFwIGVhY2ggY2hhcmFjdGVyIHRvIGl0cyBpbmRleC5cbi8vXG5mb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSBtYXBbYWxwaGFiZXRbaV1dID0gaTtcblxuLy9cbi8vIEV4cG9zZSB0aGUgYHllYXN0YCwgYGVuY29kZWAgYW5kIGBkZWNvZGVgIGZ1bmN0aW9ucy5cbi8vXG55ZWFzdC5lbmNvZGUgPSBlbmNvZGU7XG55ZWFzdC5kZWNvZGUgPSBkZWNvZGU7XG5tb2R1bGUuZXhwb3J0cyA9IHllYXN0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3llYXN0L2luZGV4LmpzIiwiXG52YXIgaW5kZXhPZiA9IFtdLmluZGV4T2Y7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXJyLCBvYmope1xuICBpZiAoaW5kZXhPZikgcmV0dXJuIGFyci5pbmRleE9mKG9iaik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGFycltpXSA9PT0gb2JqKSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9pbmRleG9mL2luZGV4LmpzIiwiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHBhcnNlciA9IHJlcXVpcmUoJ3NvY2tldC5pby1wYXJzZXInKTtcbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcbnZhciB0b0FycmF5ID0gcmVxdWlyZSgndG8tYXJyYXknKTtcbnZhciBvbiA9IHJlcXVpcmUoJy4vb24nKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnY29tcG9uZW50LWJpbmQnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tldC5pby1jbGllbnQ6c29ja2V0Jyk7XG52YXIgcGFyc2VxcyA9IHJlcXVpcmUoJ3BhcnNlcXMnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBTb2NrZXQ7XG5cbi8qKlxuICogSW50ZXJuYWwgZXZlbnRzIChibGFja2xpc3RlZCkuXG4gKiBUaGVzZSBldmVudHMgY2FuJ3QgYmUgZW1pdHRlZCBieSB0aGUgdXNlci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG52YXIgZXZlbnRzID0ge1xuICBjb25uZWN0OiAxLFxuICBjb25uZWN0X2Vycm9yOiAxLFxuICBjb25uZWN0X3RpbWVvdXQ6IDEsXG4gIGNvbm5lY3Rpbmc6IDEsXG4gIGRpc2Nvbm5lY3Q6IDEsXG4gIGVycm9yOiAxLFxuICByZWNvbm5lY3Q6IDEsXG4gIHJlY29ubmVjdF9hdHRlbXB0OiAxLFxuICByZWNvbm5lY3RfZmFpbGVkOiAxLFxuICByZWNvbm5lY3RfZXJyb3I6IDEsXG4gIHJlY29ubmVjdGluZzogMSxcbiAgcGluZzogMSxcbiAgcG9uZzogMVxufTtcblxuLyoqXG4gKiBTaG9ydGN1dCB0byBgRW1pdHRlciNlbWl0YC5cbiAqL1xuXG52YXIgZW1pdCA9IEVtaXR0ZXIucHJvdG90eXBlLmVtaXQ7XG5cbi8qKlxuICogYFNvY2tldGAgY29uc3RydWN0b3IuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBTb2NrZXQgKGlvLCBuc3AsIG9wdHMpIHtcbiAgdGhpcy5pbyA9IGlvO1xuICB0aGlzLm5zcCA9IG5zcDtcbiAgdGhpcy5qc29uID0gdGhpczsgLy8gY29tcGF0XG4gIHRoaXMuaWRzID0gMDtcbiAgdGhpcy5hY2tzID0ge307XG4gIHRoaXMucmVjZWl2ZUJ1ZmZlciA9IFtdO1xuICB0aGlzLnNlbmRCdWZmZXIgPSBbXTtcbiAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgdGhpcy5kaXNjb25uZWN0ZWQgPSB0cnVlO1xuICBpZiAob3B0cyAmJiBvcHRzLnF1ZXJ5KSB7XG4gICAgdGhpcy5xdWVyeSA9IG9wdHMucXVlcnk7XG4gIH1cbiAgaWYgKHRoaXMuaW8uYXV0b0Nvbm5lY3QpIHRoaXMub3BlbigpO1xufVxuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAuXG4gKi9cblxuRW1pdHRlcihTb2NrZXQucHJvdG90eXBlKTtcblxuLyoqXG4gKiBTdWJzY3JpYmUgdG8gb3BlbiwgY2xvc2UgYW5kIHBhY2tldCBldmVudHNcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnN1YkV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuc3VicykgcmV0dXJuO1xuXG4gIHZhciBpbyA9IHRoaXMuaW87XG4gIHRoaXMuc3VicyA9IFtcbiAgICBvbihpbywgJ29wZW4nLCBiaW5kKHRoaXMsICdvbm9wZW4nKSksXG4gICAgb24oaW8sICdwYWNrZXQnLCBiaW5kKHRoaXMsICdvbnBhY2tldCcpKSxcbiAgICBvbihpbywgJ2Nsb3NlJywgYmluZCh0aGlzLCAnb25jbG9zZScpKVxuICBdO1xufTtcblxuLyoqXG4gKiBcIk9wZW5zXCIgdGhlIHNvY2tldC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUub3BlbiA9XG5Tb2NrZXQucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmNvbm5lY3RlZCkgcmV0dXJuIHRoaXM7XG5cbiAgdGhpcy5zdWJFdmVudHMoKTtcbiAgdGhpcy5pby5vcGVuKCk7IC8vIGVuc3VyZSBvcGVuXG4gIGlmICgnb3BlbicgPT09IHRoaXMuaW8ucmVhZHlTdGF0ZSkgdGhpcy5vbm9wZW4oKTtcbiAgdGhpcy5lbWl0KCdjb25uZWN0aW5nJyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZW5kcyBhIGBtZXNzYWdlYCBldmVudC5cbiAqXG4gKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzKTtcbiAgYXJncy51bnNoaWZ0KCdtZXNzYWdlJyk7XG4gIHRoaXMuZW1pdC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE92ZXJyaWRlIGBlbWl0YC5cbiAqIElmIHRoZSBldmVudCBpcyBpbiBgZXZlbnRzYCwgaXQncyBlbWl0dGVkIG5vcm1hbGx5LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBuYW1lXG4gKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gKGV2KSB7XG4gIGlmIChldmVudHMuaGFzT3duUHJvcGVydHkoZXYpKSB7XG4gICAgZW1pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cyk7XG4gIHZhciBwYWNrZXQgPSB7IHR5cGU6IHBhcnNlci5FVkVOVCwgZGF0YTogYXJncyB9O1xuXG4gIHBhY2tldC5vcHRpb25zID0ge307XG4gIHBhY2tldC5vcHRpb25zLmNvbXByZXNzID0gIXRoaXMuZmxhZ3MgfHwgZmFsc2UgIT09IHRoaXMuZmxhZ3MuY29tcHJlc3M7XG5cbiAgLy8gZXZlbnQgYWNrIGNhbGxiYWNrXG4gIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdKSB7XG4gICAgZGVidWcoJ2VtaXR0aW5nIHBhY2tldCB3aXRoIGFjayBpZCAlZCcsIHRoaXMuaWRzKTtcbiAgICB0aGlzLmFja3NbdGhpcy5pZHNdID0gYXJncy5wb3AoKTtcbiAgICBwYWNrZXQuaWQgPSB0aGlzLmlkcysrO1xuICB9XG5cbiAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgdGhpcy5wYWNrZXQocGFja2V0KTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnNlbmRCdWZmZXIucHVzaChwYWNrZXQpO1xuICB9XG5cbiAgZGVsZXRlIHRoaXMuZmxhZ3M7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNlbmRzIGEgcGFja2V0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUucGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICBwYWNrZXQubnNwID0gdGhpcy5uc3A7XG4gIHRoaXMuaW8ucGFja2V0KHBhY2tldCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGVuZ2luZSBgb3BlbmAuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCd0cmFuc3BvcnQgaXMgb3BlbiAtIGNvbm5lY3RpbmcnKTtcblxuICAvLyB3cml0ZSBjb25uZWN0IHBhY2tldCBpZiBuZWNlc3NhcnlcbiAgaWYgKCcvJyAhPT0gdGhpcy5uc3ApIHtcbiAgICBpZiAodGhpcy5xdWVyeSkge1xuICAgICAgdmFyIHF1ZXJ5ID0gdHlwZW9mIHRoaXMucXVlcnkgPT09ICdvYmplY3QnID8gcGFyc2Vxcy5lbmNvZGUodGhpcy5xdWVyeSkgOiB0aGlzLnF1ZXJ5O1xuICAgICAgZGVidWcoJ3NlbmRpbmcgY29ubmVjdCBwYWNrZXQgd2l0aCBxdWVyeSAlcycsIHF1ZXJ5KTtcbiAgICAgIHRoaXMucGFja2V0KHt0eXBlOiBwYXJzZXIuQ09OTkVDVCwgcXVlcnk6IHF1ZXJ5fSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGFja2V0KHt0eXBlOiBwYXJzZXIuQ09OTkVDVH0pO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBlbmdpbmUgYGNsb3NlYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVhc29uXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uY2xvc2UgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gIGRlYnVnKCdjbG9zZSAoJXMpJywgcmVhc29uKTtcbiAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgdGhpcy5kaXNjb25uZWN0ZWQgPSB0cnVlO1xuICBkZWxldGUgdGhpcy5pZDtcbiAgdGhpcy5lbWl0KCdkaXNjb25uZWN0JywgcmVhc29uKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdpdGggc29ja2V0IHBhY2tldC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9ucGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICBpZiAocGFja2V0Lm5zcCAhPT0gdGhpcy5uc3ApIHJldHVybjtcblxuICBzd2l0Y2ggKHBhY2tldC50eXBlKSB7XG4gICAgY2FzZSBwYXJzZXIuQ09OTkVDVDpcbiAgICAgIHRoaXMub25jb25uZWN0KCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcGFyc2VyLkVWRU5UOlxuICAgICAgdGhpcy5vbmV2ZW50KHBhY2tldCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcGFyc2VyLkJJTkFSWV9FVkVOVDpcbiAgICAgIHRoaXMub25ldmVudChwYWNrZXQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5BQ0s6XG4gICAgICB0aGlzLm9uYWNrKHBhY2tldCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcGFyc2VyLkJJTkFSWV9BQ0s6XG4gICAgICB0aGlzLm9uYWNrKHBhY2tldCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcGFyc2VyLkRJU0NPTk5FQ1Q6XG4gICAgICB0aGlzLm9uZGlzY29ubmVjdCgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5FUlJPUjpcbiAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBwYWNrZXQuZGF0YSk7XG4gICAgICBicmVhaztcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBhIHNlcnZlciBldmVudC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uZXZlbnQgPSBmdW5jdGlvbiAocGFja2V0KSB7XG4gIHZhciBhcmdzID0gcGFja2V0LmRhdGEgfHwgW107XG4gIGRlYnVnKCdlbWl0dGluZyBldmVudCAlaicsIGFyZ3MpO1xuXG4gIGlmIChudWxsICE9IHBhY2tldC5pZCkge1xuICAgIGRlYnVnKCdhdHRhY2hpbmcgYWNrIGNhbGxiYWNrIHRvIGV2ZW50Jyk7XG4gICAgYXJncy5wdXNoKHRoaXMuYWNrKHBhY2tldC5pZCkpO1xuICB9XG5cbiAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgZW1pdC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnJlY2VpdmVCdWZmZXIucHVzaChhcmdzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBQcm9kdWNlcyBhbiBhY2sgY2FsbGJhY2sgdG8gZW1pdCB3aXRoIGFuIGV2ZW50LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuYWNrID0gZnVuY3Rpb24gKGlkKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHNlbnQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAvLyBwcmV2ZW50IGRvdWJsZSBjYWxsYmFja3NcbiAgICBpZiAoc2VudCkgcmV0dXJuO1xuICAgIHNlbnQgPSB0cnVlO1xuICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMpO1xuICAgIGRlYnVnKCdzZW5kaW5nIGFjayAlaicsIGFyZ3MpO1xuXG4gICAgc2VsZi5wYWNrZXQoe1xuICAgICAgdHlwZTogcGFyc2VyLkFDSyxcbiAgICAgIGlkOiBpZCxcbiAgICAgIGRhdGE6IGFyZ3NcbiAgICB9KTtcbiAgfTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gYSBzZXJ2ZXIgYWNrbm93bGVnZW1lbnQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbmFjayA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgdmFyIGFjayA9IHRoaXMuYWNrc1twYWNrZXQuaWRdO1xuICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGFjaykge1xuICAgIGRlYnVnKCdjYWxsaW5nIGFjayAlcyB3aXRoICVqJywgcGFja2V0LmlkLCBwYWNrZXQuZGF0YSk7XG4gICAgYWNrLmFwcGx5KHRoaXMsIHBhY2tldC5kYXRhKTtcbiAgICBkZWxldGUgdGhpcy5hY2tzW3BhY2tldC5pZF07XG4gIH0gZWxzZSB7XG4gICAgZGVidWcoJ2JhZCBhY2sgJXMnLCBwYWNrZXQuaWQpO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHNlcnZlciBjb25uZWN0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25jb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmNvbm5lY3RlZCA9IHRydWU7XG4gIHRoaXMuZGlzY29ubmVjdGVkID0gZmFsc2U7XG4gIHRoaXMuZW1pdCgnY29ubmVjdCcpO1xuICB0aGlzLmVtaXRCdWZmZXJlZCgpO1xufTtcblxuLyoqXG4gKiBFbWl0IGJ1ZmZlcmVkIGV2ZW50cyAocmVjZWl2ZWQgYW5kIGVtaXR0ZWQpLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuZW1pdEJ1ZmZlcmVkID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaTtcbiAgZm9yIChpID0gMDsgaSA8IHRoaXMucmVjZWl2ZUJ1ZmZlci5sZW5ndGg7IGkrKykge1xuICAgIGVtaXQuYXBwbHkodGhpcywgdGhpcy5yZWNlaXZlQnVmZmVyW2ldKTtcbiAgfVxuICB0aGlzLnJlY2VpdmVCdWZmZXIgPSBbXTtcblxuICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5zZW5kQnVmZmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5wYWNrZXQodGhpcy5zZW5kQnVmZmVyW2ldKTtcbiAgfVxuICB0aGlzLnNlbmRCdWZmZXIgPSBbXTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gc2VydmVyIGRpc2Nvbm5lY3QuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdzZXJ2ZXIgZGlzY29ubmVjdCAoJXMpJywgdGhpcy5uc3ApO1xuICB0aGlzLmRlc3Ryb3koKTtcbiAgdGhpcy5vbmNsb3NlKCdpbyBzZXJ2ZXIgZGlzY29ubmVjdCcpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBmb3JjZWQgY2xpZW50L3NlcnZlciBzaWRlIGRpc2Nvbm5lY3Rpb25zLFxuICogdGhpcyBtZXRob2QgZW5zdXJlcyB0aGUgbWFuYWdlciBzdG9wcyB0cmFja2luZyB1cyBhbmRcbiAqIHRoYXQgcmVjb25uZWN0aW9ucyBkb24ndCBnZXQgdHJpZ2dlcmVkIGZvciB0aGlzLlxuICpcbiAqIEBhcGkgcHJpdmF0ZS5cbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnN1YnMpIHtcbiAgICAvLyBjbGVhbiBzdWJzY3JpcHRpb25zIHRvIGF2b2lkIHJlY29ubmVjdGlvbnNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc3Vicy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5zdWJzW2ldLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdGhpcy5zdWJzID0gbnVsbDtcbiAgfVxuXG4gIHRoaXMuaW8uZGVzdHJveSh0aGlzKTtcbn07XG5cbi8qKlxuICogRGlzY29ubmVjdHMgdGhlIHNvY2tldCBtYW51YWxseS5cbiAqXG4gKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5jbG9zZSA9XG5Tb2NrZXQucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgIGRlYnVnKCdwZXJmb3JtaW5nIGRpc2Nvbm5lY3QgKCVzKScsIHRoaXMubnNwKTtcbiAgICB0aGlzLnBhY2tldCh7IHR5cGU6IHBhcnNlci5ESVNDT05ORUNUIH0pO1xuICB9XG5cbiAgLy8gcmVtb3ZlIHNvY2tldCBmcm9tIHBvb2xcbiAgdGhpcy5kZXN0cm95KCk7XG5cbiAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgLy8gZmlyZSBldmVudHNcbiAgICB0aGlzLm9uY2xvc2UoJ2lvIGNsaWVudCBkaXNjb25uZWN0Jyk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGNvbXByZXNzIGZsYWcuXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBpZiBgdHJ1ZWAsIGNvbXByZXNzZXMgdGhlIHNlbmRpbmcgZGF0YVxuICogQHJldHVybiB7U29ja2V0fSBzZWxmXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUuY29tcHJlc3MgPSBmdW5jdGlvbiAoY29tcHJlc3MpIHtcbiAgdGhpcy5mbGFncyA9IHRoaXMuZmxhZ3MgfHwge307XG4gIHRoaXMuZmxhZ3MuY29tcHJlc3MgPSBjb21wcmVzcztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbGliL3NvY2tldC5qcyIsIlxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IG9uO1xuXG4vKipcbiAqIEhlbHBlciBmb3Igc3Vic2NyaXB0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxFdmVudEVtaXR0ZXJ9IG9iaiB3aXRoIGBFbWl0dGVyYCBtaXhpbiBvciBgRXZlbnRFbWl0dGVyYFxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIG9uIChvYmosIGV2LCBmbikge1xuICBvYmoub24oZXYsIGZuKTtcbiAgcmV0dXJuIHtcbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gICAgICBvYmoucmVtb3ZlTGlzdGVuZXIoZXYsIGZuKTtcbiAgICB9XG4gIH07XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9saWIvb24uanMiLCIvKipcbiAqIFNsaWNlIHJlZmVyZW5jZS5cbiAqL1xuXG52YXIgc2xpY2UgPSBbXS5zbGljZTtcblxuLyoqXG4gKiBCaW5kIGBvYmpgIHRvIGBmbmAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtGdW5jdGlvbnxTdHJpbmd9IGZuIG9yIHN0cmluZ1xuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqLCBmbil7XG4gIGlmICgnc3RyaW5nJyA9PSB0eXBlb2YgZm4pIGZuID0gb2JqW2ZuXTtcbiAgaWYgKCdmdW5jdGlvbicgIT0gdHlwZW9mIGZuKSB0aHJvdyBuZXcgRXJyb3IoJ2JpbmQoKSByZXF1aXJlcyBhIGZ1bmN0aW9uJyk7XG4gIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gZm4uYXBwbHkob2JqLCBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb21wb25lbnQtYmluZC9pbmRleC5qcyIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIFVzZXIge1xuICBzdGF0aWMgc2V0TmFtZSAobmFtZSkge1xuICAgIFVzZXIuaW5mby5uYW1lID0gbmFtZVxuICB9XG5cbiAgc3RhdGljIGdldE5hbWUgKCkge1xuICAgIHJldHVybiBVc2VyLmluZm8ubmFtZVxuICB9XG59XG5cblVzZXIuaW5mbyA9IHtcbiAgbmFtZTogJydcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9kYXRhL1VzZXIuanMiLCJpbXBvcnQgUmVhY3QsIHtDb21wb25lbnR9IGZyb20gJ3JlYWN0J1xuaW1wb3J0ICcuL0NoYXRBcmVhLmNzcydcbmltcG9ydCBDaGF0TG9nIGZyb20gJy4vQ2hhdExvZydcbmltcG9ydCBDaGF0VXNlcnMgZnJvbSAnLi9DaGF0VXNlcnMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENoYXRBcmVhIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgcmVuZGVyICgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb250YWluZXJcIj5cbiAgICAgICAgPENoYXRMb2cgaXNKb2luPXt0aGlzLnByb3BzLmlzSm9pbn0gbWVzc2FnZXM9e3RoaXMucHJvcHMubWVzc2FnZXN9Lz5cbiAgICAgICAgPENoYXRVc2VycyBpc0pvaW49e3RoaXMucHJvcHMuaXNKb2lufSB1c2Vycz17dGhpcy5wcm9wcy51c2Vyc30vPlxuICAgICAgPC9kaXY+XG4gICAgKVxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY29tcG9uZW50cy9jaGF0L0NoYXRBcmVhLmpzIiwiaW1wb3J0IFJlYWN0LCB7Q29tcG9uZW50fSBmcm9tICdyZWFjdCdcbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nXG5pbXBvcnQgJy4vQ2hhdExvZy5jc3MnXG5pbXBvcnQgQ29ubmVjdGlvbk1hbmFnZXIgZnJvbSAnLi4vLi4vd3MvY2xpZW50L0Nvbm5lY3Rpb25NYW5hZ2VyJ1xuaW1wb3J0IFVzZXIgZnJvbSAnLi4vLi4vZGF0YS9Vc2VyJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDaGF0TG9nIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGRpc2FibGVkOiAhdGhpcy5wcm9wcy5pc0pvaW4sXG4gICAgICBtZXNzYWdlczogdGhpcy5wcm9wcy5tZXNzYWdlcyxcbiAgICAgIHRtcG1lc3NhZ2U6ICcnXG4gICAgfVxuICAgIHRoaXMuc29ja2V0ID0gbnVsbFxuICB9XG5cbiAgY29tcG9uZW50RGlkVXBkYXRlICgpIHtcbiAgICBjb25zdCBub2RlID0gUmVhY3RET00uZmluZERPTU5vZGUodGhpcy5yZWZzLmxvZylcbiAgICBub2RlLnNjcm9sbFRvcCA9IG5vZGUuc2Nyb2xsSGVpZ2h0XG4gIH1cblxuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIChuZXh0UHJvcHMpIHtcbiAgICBpZiAobmV4dFByb3BzLmlzSm9pbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgZGlzYWJsZWQ6ICFuZXh0UHJvcHMuaXNKb2luXG4gICAgICB9KVxuICAgICAgaWYgKG5leHRQcm9wcy5pc0pvaW4pIHtcbiAgICAgICAgdGhpcy5zb2NrZXQgPSBDb25uZWN0aW9uTWFuYWdlci5nZXRDb25uZWN0aW9uKClcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5leHRQcm9wcy5tZXNzYWdlcykge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIG1lc3NhZ2VzOiBuZXh0UHJvcHMubWVzc2FnZXNcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgb25JbnB1dCAoZSkge1xuICAgIGNvbnN0IHZhbHVlID0gZS50YXJnZXQudmFsdWVcbiAgICB0aGlzLnNldFN0YXRlKHt0bXBtZXNzYWdlOiB2YWx1ZX0pXG4gICAgdGhpcy5zb2NrZXQuZW1pdCgndG1wbWVzc2FnZScsIHtcbiAgICAgIGlkOiB0aGlzLnNvY2tldC5pZCxcbiAgICAgIGJvZHk6IHZhbHVlXG4gICAgfSlcbiAgfVxuXG4gIG9uS2V5UHJlc3MgKGUpIHtcbiAgICBpZiAoZS53aGljaCA9PT0gMTMgJiYgdGhpcy5zdGF0ZS50bXBtZXNzYWdlLmxlbmd0aCAhPT0gMCkge1xuICAgICAgdGhpcy5zb2NrZXQuZW1pdCgnbWVzc2FnZScsIHtcbiAgICAgICAgaWQ6IHRoaXMuc29ja2V0LmlkLFxuICAgICAgICBuYW1lOiBVc2VyLmdldE5hbWUoKSxcbiAgICAgICAgYm9keTogdGhpcy5zdGF0ZS50bXBtZXNzYWdlXG4gICAgICB9KVxuICAgICAgdGhpcy5zZXRTdGF0ZSh7dG1wbWVzc2FnZTogJyd9KVxuICAgIH1cbiAgfVxuXG4gIHJlbmRlciAoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29sLW1kLThcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJwYW5lbCBwYW5lbC1pbmZvXCI+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJwYW5lbC1oZWFkaW5nXCI+XG4gICAgICAgICAgICBDSEFUIExPR1xuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicGFuZWwtYm9keVwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjaGF0bG9nXCIgcmVmPVwibG9nXCI+XG4gICAgICAgICAgICAgIHsoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3BzLmlzSm9pbiAmJiB0aGlzLnN0YXRlLm1lc3NhZ2VzLm1hcChlID0+IChcbiAgICAgICAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgICAgIDxmb250IGNvbG9yPXtlLmNvbG9yQ29kZX0+e2UubmFtZX08L2ZvbnQ+OntlLmJvZHl9XG4gICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICkoKX1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicGFuZWwtZm9vdGVyXCI+XG4gICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIlxuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJmb3JtLWNvbnRyb2xcIlxuICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cInlvdXIgbWVzc2FnZVwiXG4gICAgICAgICAgICAgIHZhbHVlPXt0aGlzLnN0YXRlLnRtcG1lc3NhZ2V9XG4gICAgICAgICAgICAgIGRpc2FibGVkPXt0aGlzLnN0YXRlLmRpc2FibGVkfVxuICAgICAgICAgICAgICBvbklucHV0PXtlID0+IHRoaXMub25JbnB1dChlKX1cbiAgICAgICAgICAgICAgb25LZXlQcmVzcz17ZSA9PiB0aGlzLm9uS2V5UHJlc3MoZSl9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIClcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbXBvbmVudHMvY2hhdC9DaGF0TG9nLmpzIiwiaW1wb3J0IFJlYWN0LCB7Q29tcG9uZW50fSBmcm9tICdyZWFjdCdcbmltcG9ydCAnLi9DaGF0VXNlcnMuY3NzJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDaGF0VXNlcnMgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcylcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgdXNlcnM6IHRoaXMucHJvcHMudXNlcnNcbiAgICB9XG4gIH1cblxuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIChuZXh0UHJvcHMpIHtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIHVzZXJzOiBuZXh0UHJvcHMudXNlcnNcbiAgICB9KVxuICB9XG5cbiAgcmVuZGVyICgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb2wtbWQtNFwiPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInBhbmVsIHBhbmVsLXByaW1hcnlcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInBhbmVsLWhlYWRpbmdcIj5cbiAgICAgICAgICAgIE9OTElORSBVU0VSU1xuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicGFuZWwtYm9keVwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjaGF0dXNlcnNcIj5cbiAgICAgICAgICAgICAgPHVsPlxuICAgICAgICAgICAgICAgIHsoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMuaXNKb2luICYmIHRoaXMuc3RhdGUudXNlcnMubWFwKGUgPT4gKFxuICAgICAgICAgICAgICAgICAgICA8bGkga2V5PXtlLmlkfT5cbiAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInVzZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxmb250IGNvbG9yPXtlLmNvbG9yQ29kZX0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHtlLm5hbWV9XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2ZvbnQ+XG4gICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS50bXBtZXNzYWdlLmxlbmd0aCAhPT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0bXBtZXNzYWdlXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHtlLnRtcG1lc3NhZ2V9XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApKCl9XG4gICAgICAgICAgICAgIDwvdWw+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb21wb25lbnRzL2NoYXQvQ2hhdFVzZXJzLmpzIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSdcbmltcG9ydCAnLi9pbmRleC5jc3MnXG5pbXBvcnQgQ2hhdEFwcCBmcm9tICcuL2NvbXBvbmVudHMvY2hhdC9DaGF0QXBwJ1xuXG5SZWFjdERPTS5yZW5kZXIoPENoYXRBcHAgLz4sIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyb290JykpXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvaW5kZXguanMiLCIvKiogQGxpY2Vuc2UgUmVhY3QgdjE2LjIuMFxuICogcmVhY3QucHJvZHVjdGlvbi5taW4uanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7dmFyIG09cmVxdWlyZShcIm9iamVjdC1hc3NpZ25cIiksbj1yZXF1aXJlKFwiZmJqcy9saWIvZW1wdHlPYmplY3RcIikscD1yZXF1aXJlKFwiZmJqcy9saWIvZW1wdHlGdW5jdGlvblwiKSxxPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBTeW1ib2wmJlN5bWJvbFtcImZvclwiXSxyPXE/U3ltYm9sW1wiZm9yXCJdKFwicmVhY3QuZWxlbWVudFwiKTo2MDEwMyx0PXE/U3ltYm9sW1wiZm9yXCJdKFwicmVhY3QuY2FsbFwiKTo2MDEwNCx1PXE/U3ltYm9sW1wiZm9yXCJdKFwicmVhY3QucmV0dXJuXCIpOjYwMTA1LHY9cT9TeW1ib2xbXCJmb3JcIl0oXCJyZWFjdC5wb3J0YWxcIik6NjAxMDYsdz1xP1N5bWJvbFtcImZvclwiXShcInJlYWN0LmZyYWdtZW50XCIpOjYwMTA3LHg9XCJmdW5jdGlvblwiPT09dHlwZW9mIFN5bWJvbCYmU3ltYm9sLml0ZXJhdG9yO1xuZnVuY3Rpb24geShhKXtmb3IodmFyIGI9YXJndW1lbnRzLmxlbmd0aC0xLGU9XCJNaW5pZmllZCBSZWFjdCBlcnJvciAjXCIrYStcIjsgdmlzaXQgaHR0cDovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL2Vycm9yLWRlY29kZXIuaHRtbD9pbnZhcmlhbnRcXHgzZFwiK2EsYz0wO2M8YjtjKyspZSs9XCJcXHgyNmFyZ3NbXVxceDNkXCIrZW5jb2RlVVJJQ29tcG9uZW50KGFyZ3VtZW50c1tjKzFdKTtiPUVycm9yKGUrXCIgZm9yIHRoZSBmdWxsIG1lc3NhZ2Ugb3IgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50IGZvciBmdWxsIGVycm9ycyBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLlwiKTtiLm5hbWU9XCJJbnZhcmlhbnQgVmlvbGF0aW9uXCI7Yi5mcmFtZXNUb1BvcD0xO3Rocm93IGI7fVxudmFyIHo9e2lzTW91bnRlZDpmdW5jdGlvbigpe3JldHVybiExfSxlbnF1ZXVlRm9yY2VVcGRhdGU6ZnVuY3Rpb24oKXt9LGVucXVldWVSZXBsYWNlU3RhdGU6ZnVuY3Rpb24oKXt9LGVucXVldWVTZXRTdGF0ZTpmdW5jdGlvbigpe319O2Z1bmN0aW9uIEEoYSxiLGUpe3RoaXMucHJvcHM9YTt0aGlzLmNvbnRleHQ9Yjt0aGlzLnJlZnM9bjt0aGlzLnVwZGF0ZXI9ZXx8en1BLnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50PXt9O0EucHJvdG90eXBlLnNldFN0YXRlPWZ1bmN0aW9uKGEsYil7XCJvYmplY3RcIiE9PXR5cGVvZiBhJiZcImZ1bmN0aW9uXCIhPT10eXBlb2YgYSYmbnVsbCE9YT95KFwiODVcIik6dm9pZCAwO3RoaXMudXBkYXRlci5lbnF1ZXVlU2V0U3RhdGUodGhpcyxhLGIsXCJzZXRTdGF0ZVwiKX07QS5wcm90b3R5cGUuZm9yY2VVcGRhdGU9ZnVuY3Rpb24oYSl7dGhpcy51cGRhdGVyLmVucXVldWVGb3JjZVVwZGF0ZSh0aGlzLGEsXCJmb3JjZVVwZGF0ZVwiKX07XG5mdW5jdGlvbiBCKGEsYixlKXt0aGlzLnByb3BzPWE7dGhpcy5jb250ZXh0PWI7dGhpcy5yZWZzPW47dGhpcy51cGRhdGVyPWV8fHp9ZnVuY3Rpb24gQygpe31DLnByb3RvdHlwZT1BLnByb3RvdHlwZTt2YXIgRD1CLnByb3RvdHlwZT1uZXcgQztELmNvbnN0cnVjdG9yPUI7bShELEEucHJvdG90eXBlKTtELmlzUHVyZVJlYWN0Q29tcG9uZW50PSEwO2Z1bmN0aW9uIEUoYSxiLGUpe3RoaXMucHJvcHM9YTt0aGlzLmNvbnRleHQ9Yjt0aGlzLnJlZnM9bjt0aGlzLnVwZGF0ZXI9ZXx8en12YXIgRj1FLnByb3RvdHlwZT1uZXcgQztGLmNvbnN0cnVjdG9yPUU7bShGLEEucHJvdG90eXBlKTtGLnVuc3RhYmxlX2lzQXN5bmNSZWFjdENvbXBvbmVudD0hMDtGLnJlbmRlcj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnByb3BzLmNoaWxkcmVufTt2YXIgRz17Y3VycmVudDpudWxsfSxIPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksST17a2V5OiEwLHJlZjohMCxfX3NlbGY6ITAsX19zb3VyY2U6ITB9O1xuZnVuY3Rpb24gSihhLGIsZSl7dmFyIGMsZD17fSxnPW51bGwsaz1udWxsO2lmKG51bGwhPWIpZm9yKGMgaW4gdm9pZCAwIT09Yi5yZWYmJihrPWIucmVmKSx2b2lkIDAhPT1iLmtleSYmKGc9XCJcIitiLmtleSksYilILmNhbGwoYixjKSYmIUkuaGFzT3duUHJvcGVydHkoYykmJihkW2NdPWJbY10pO3ZhciBmPWFyZ3VtZW50cy5sZW5ndGgtMjtpZigxPT09ZilkLmNoaWxkcmVuPWU7ZWxzZSBpZigxPGYpe2Zvcih2YXIgaD1BcnJheShmKSxsPTA7bDxmO2wrKyloW2xdPWFyZ3VtZW50c1tsKzJdO2QuY2hpbGRyZW49aH1pZihhJiZhLmRlZmF1bHRQcm9wcylmb3IoYyBpbiBmPWEuZGVmYXVsdFByb3BzLGYpdm9pZCAwPT09ZFtjXSYmKGRbY109ZltjXSk7cmV0dXJueyQkdHlwZW9mOnIsdHlwZTphLGtleTpnLHJlZjprLHByb3BzOmQsX293bmVyOkcuY3VycmVudH19ZnVuY3Rpb24gSyhhKXtyZXR1cm5cIm9iamVjdFwiPT09dHlwZW9mIGEmJm51bGwhPT1hJiZhLiQkdHlwZW9mPT09cn1cbmZ1bmN0aW9uIGVzY2FwZShhKXt2YXIgYj17XCJcXHgzZFwiOlwiXFx4M2QwXCIsXCI6XCI6XCJcXHgzZDJcIn07cmV0dXJuXCIkXCIrKFwiXCIrYSkucmVwbGFjZSgvWz06XS9nLGZ1bmN0aW9uKGEpe3JldHVybiBiW2FdfSl9dmFyIEw9L1xcLysvZyxNPVtdO2Z1bmN0aW9uIE4oYSxiLGUsYyl7aWYoTS5sZW5ndGgpe3ZhciBkPU0ucG9wKCk7ZC5yZXN1bHQ9YTtkLmtleVByZWZpeD1iO2QuZnVuYz1lO2QuY29udGV4dD1jO2QuY291bnQ9MDtyZXR1cm4gZH1yZXR1cm57cmVzdWx0OmEsa2V5UHJlZml4OmIsZnVuYzplLGNvbnRleHQ6Yyxjb3VudDowfX1mdW5jdGlvbiBPKGEpe2EucmVzdWx0PW51bGw7YS5rZXlQcmVmaXg9bnVsbDthLmZ1bmM9bnVsbDthLmNvbnRleHQ9bnVsbDthLmNvdW50PTA7MTA+TS5sZW5ndGgmJk0ucHVzaChhKX1cbmZ1bmN0aW9uIFAoYSxiLGUsYyl7dmFyIGQ9dHlwZW9mIGE7aWYoXCJ1bmRlZmluZWRcIj09PWR8fFwiYm9vbGVhblwiPT09ZClhPW51bGw7dmFyIGc9ITE7aWYobnVsbD09PWEpZz0hMDtlbHNlIHN3aXRjaChkKXtjYXNlIFwic3RyaW5nXCI6Y2FzZSBcIm51bWJlclwiOmc9ITA7YnJlYWs7Y2FzZSBcIm9iamVjdFwiOnN3aXRjaChhLiQkdHlwZW9mKXtjYXNlIHI6Y2FzZSB0OmNhc2UgdTpjYXNlIHY6Zz0hMH19aWYoZylyZXR1cm4gZShjLGEsXCJcIj09PWI/XCIuXCIrUShhLDApOmIpLDE7Zz0wO2I9XCJcIj09PWI/XCIuXCI6YitcIjpcIjtpZihBcnJheS5pc0FycmF5KGEpKWZvcih2YXIgaz0wO2s8YS5sZW5ndGg7aysrKXtkPWFba107dmFyIGY9YitRKGQsayk7Zys9UChkLGYsZSxjKX1lbHNlIGlmKG51bGw9PT1hfHxcInVuZGVmaW5lZFwiPT09dHlwZW9mIGE/Zj1udWxsOihmPXgmJmFbeF18fGFbXCJAQGl0ZXJhdG9yXCJdLGY9XCJmdW5jdGlvblwiPT09dHlwZW9mIGY/ZjpudWxsKSxcImZ1bmN0aW9uXCI9PT10eXBlb2YgZilmb3IoYT1cbmYuY2FsbChhKSxrPTA7IShkPWEubmV4dCgpKS5kb25lOylkPWQudmFsdWUsZj1iK1EoZCxrKyspLGcrPVAoZCxmLGUsYyk7ZWxzZVwib2JqZWN0XCI9PT1kJiYoZT1cIlwiK2EseShcIjMxXCIsXCJbb2JqZWN0IE9iamVjdF1cIj09PWU/XCJvYmplY3Qgd2l0aCBrZXlzIHtcIitPYmplY3Qua2V5cyhhKS5qb2luKFwiLCBcIikrXCJ9XCI6ZSxcIlwiKSk7cmV0dXJuIGd9ZnVuY3Rpb24gUShhLGIpe3JldHVyblwib2JqZWN0XCI9PT10eXBlb2YgYSYmbnVsbCE9PWEmJm51bGwhPWEua2V5P2VzY2FwZShhLmtleSk6Yi50b1N0cmluZygzNil9ZnVuY3Rpb24gUihhLGIpe2EuZnVuYy5jYWxsKGEuY29udGV4dCxiLGEuY291bnQrKyl9XG5mdW5jdGlvbiBTKGEsYixlKXt2YXIgYz1hLnJlc3VsdCxkPWEua2V5UHJlZml4O2E9YS5mdW5jLmNhbGwoYS5jb250ZXh0LGIsYS5jb3VudCsrKTtBcnJheS5pc0FycmF5KGEpP1QoYSxjLGUscC50aGF0UmV0dXJuc0FyZ3VtZW50KTpudWxsIT1hJiYoSyhhKSYmKGI9ZCsoIWEua2V5fHxiJiZiLmtleT09PWEua2V5P1wiXCI6KFwiXCIrYS5rZXkpLnJlcGxhY2UoTCxcIiRcXHgyNi9cIikrXCIvXCIpK2UsYT17JCR0eXBlb2Y6cix0eXBlOmEudHlwZSxrZXk6YixyZWY6YS5yZWYscHJvcHM6YS5wcm9wcyxfb3duZXI6YS5fb3duZXJ9KSxjLnB1c2goYSkpfWZ1bmN0aW9uIFQoYSxiLGUsYyxkKXt2YXIgZz1cIlwiO251bGwhPWUmJihnPShcIlwiK2UpLnJlcGxhY2UoTCxcIiRcXHgyNi9cIikrXCIvXCIpO2I9TihiLGcsYyxkKTtudWxsPT1hfHxQKGEsXCJcIixTLGIpO08oYil9XG52YXIgVT17Q2hpbGRyZW46e21hcDpmdW5jdGlvbihhLGIsZSl7aWYobnVsbD09YSlyZXR1cm4gYTt2YXIgYz1bXTtUKGEsYyxudWxsLGIsZSk7cmV0dXJuIGN9LGZvckVhY2g6ZnVuY3Rpb24oYSxiLGUpe2lmKG51bGw9PWEpcmV0dXJuIGE7Yj1OKG51bGwsbnVsbCxiLGUpO251bGw9PWF8fFAoYSxcIlwiLFIsYik7TyhiKX0sY291bnQ6ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGw9PWE/MDpQKGEsXCJcIixwLnRoYXRSZXR1cm5zTnVsbCxudWxsKX0sdG9BcnJheTpmdW5jdGlvbihhKXt2YXIgYj1bXTtUKGEsYixudWxsLHAudGhhdFJldHVybnNBcmd1bWVudCk7cmV0dXJuIGJ9LG9ubHk6ZnVuY3Rpb24oYSl7SyhhKT92b2lkIDA6eShcIjE0M1wiKTtyZXR1cm4gYX19LENvbXBvbmVudDpBLFB1cmVDb21wb25lbnQ6Qix1bnN0YWJsZV9Bc3luY0NvbXBvbmVudDpFLEZyYWdtZW50OncsY3JlYXRlRWxlbWVudDpKLGNsb25lRWxlbWVudDpmdW5jdGlvbihhLGIsZSl7dmFyIGM9bSh7fSxhLnByb3BzKSxcbmQ9YS5rZXksZz1hLnJlZixrPWEuX293bmVyO2lmKG51bGwhPWIpe3ZvaWQgMCE9PWIucmVmJiYoZz1iLnJlZixrPUcuY3VycmVudCk7dm9pZCAwIT09Yi5rZXkmJihkPVwiXCIrYi5rZXkpO2lmKGEudHlwZSYmYS50eXBlLmRlZmF1bHRQcm9wcyl2YXIgZj1hLnR5cGUuZGVmYXVsdFByb3BzO2ZvcihoIGluIGIpSC5jYWxsKGIsaCkmJiFJLmhhc093blByb3BlcnR5KGgpJiYoY1toXT12b2lkIDA9PT1iW2hdJiZ2b2lkIDAhPT1mP2ZbaF06YltoXSl9dmFyIGg9YXJndW1lbnRzLmxlbmd0aC0yO2lmKDE9PT1oKWMuY2hpbGRyZW49ZTtlbHNlIGlmKDE8aCl7Zj1BcnJheShoKTtmb3IodmFyIGw9MDtsPGg7bCsrKWZbbF09YXJndW1lbnRzW2wrMl07Yy5jaGlsZHJlbj1mfXJldHVybnskJHR5cGVvZjpyLHR5cGU6YS50eXBlLGtleTpkLHJlZjpnLHByb3BzOmMsX293bmVyOmt9fSxjcmVhdGVGYWN0b3J5OmZ1bmN0aW9uKGEpe3ZhciBiPUouYmluZChudWxsLGEpO2IudHlwZT1hO3JldHVybiBifSxcbmlzVmFsaWRFbGVtZW50OkssdmVyc2lvbjpcIjE2LjIuMFwiLF9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEOntSZWFjdEN1cnJlbnRPd25lcjpHLGFzc2lnbjptfX0sVj1PYmplY3QuZnJlZXplKHtkZWZhdWx0OlV9KSxXPVYmJlV8fFY7bW9kdWxlLmV4cG9ydHM9V1tcImRlZmF1bHRcIl0/V1tcImRlZmF1bHRcIl06VztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC9janMvcmVhY3QucHJvZHVjdGlvbi5taW4uanMiLCIvKiogQGxpY2Vuc2UgUmVhY3QgdjE2LjIuMFxuICogcmVhY3QuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cblxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG52YXIgZW1wdHlPYmplY3QgPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eU9iamVjdCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciBjaGVja1Byb3BUeXBlcyA9IHJlcXVpcmUoJ3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMnKTtcblxuLy8gVE9ETzogdGhpcyBpcyBzcGVjaWFsIGJlY2F1c2UgaXQgZ2V0cyBpbXBvcnRlZCBkdXJpbmcgYnVpbGQuXG5cbnZhciBSZWFjdFZlcnNpb24gPSAnMTYuMi4wJztcblxuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cbnZhciBoYXNTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbFsnZm9yJ107XG5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5lbGVtZW50JykgOiAweGVhYzc7XG52YXIgUkVBQ1RfQ0FMTF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sWydmb3InXSgncmVhY3QuY2FsbCcpIDogMHhlYWM4O1xudmFyIFJFQUNUX1JFVFVSTl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sWydmb3InXSgncmVhY3QucmV0dXJuJykgOiAweGVhYzk7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5wb3J0YWwnKSA6IDB4ZWFjYTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sWydmb3InXSgncmVhY3QuZnJhZ21lbnQnKSA6IDB4ZWFjYjtcblxudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuXG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgaWYgKG1heWJlSXRlcmFibGUgPT09IG51bGwgfHwgdHlwZW9mIG1heWJlSXRlcmFibGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBXQVJOSU5HOiBETyBOT1QgbWFudWFsbHkgcmVxdWlyZSB0aGlzIG1vZHVsZS5cbiAqIFRoaXMgaXMgYSByZXBsYWNlbWVudCBmb3IgYGludmFyaWFudCguLi4pYCB1c2VkIGJ5IHRoZSBlcnJvciBjb2RlIHN5c3RlbVxuICogYW5kIHdpbGwgX29ubHlfIGJlIHJlcXVpcmVkIGJ5IHRoZSBjb3JyZXNwb25kaW5nIGJhYmVsIHBhc3MuXG4gKiBJdCBhbHdheXMgdGhyb3dzLlxuICovXG5cbi8qKlxuICogRm9ya2VkIGZyb20gZmJqcy93YXJuaW5nOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2ZianMvYmxvYi9lNjZiYTIwYWQ1YmU0MzNlYjU0NDIzZjJiMDk3ZDgyOTMyNGQ5ZGU2L3BhY2thZ2VzL2ZianMvc3JjL19fZm9ya3NfXy93YXJuaW5nLmpzXG4gKlxuICogT25seSBjaGFuZ2UgaXMgd2UgdXNlIGNvbnNvbGUud2FybiBpbnN0ZWFkIG9mIGNvbnNvbGUuZXJyb3IsXG4gKiBhbmQgZG8gbm90aGluZyB3aGVuICdjb25zb2xlJyBpcyBub3Qgc3VwcG9ydGVkLlxuICogVGhpcyByZWFsbHkgc2ltcGxpZmllcyB0aGUgY29kZS5cbiAqIC0tLVxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciBsb3dQcmlvcml0eVdhcm5pbmcgPSBmdW5jdGlvbiAoKSB7fTtcblxue1xuICB2YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcblxuICBsb3dQcmlvcml0eVdhcm5pbmcgPSBmdW5jdGlvbiAoY29uZGl0aW9uLCBmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArICdtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiA+IDIgPyBfbGVuMiAtIDIgOiAwKSwgX2tleTIgPSAyOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZy5hcHBseSh1bmRlZmluZWQsIFtmb3JtYXRdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuICB9O1xufVxuXG52YXIgbG93UHJpb3JpdHlXYXJuaW5nJDEgPSBsb3dQcmlvcml0eVdhcm5pbmc7XG5cbnZhciBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnQgPSB7fTtcblxuZnVuY3Rpb24gd2Fybk5vb3AocHVibGljSW5zdGFuY2UsIGNhbGxlck5hbWUpIHtcbiAge1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IHB1YmxpY0luc3RhbmNlLmNvbnN0cnVjdG9yO1xuICAgIHZhciBjb21wb25lbnROYW1lID0gY29uc3RydWN0b3IgJiYgKGNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8IGNvbnN0cnVjdG9yLm5hbWUpIHx8ICdSZWFjdENsYXNzJztcbiAgICB2YXIgd2FybmluZ0tleSA9IGNvbXBvbmVudE5hbWUgKyAnLicgKyBjYWxsZXJOYW1lO1xuICAgIGlmIChkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnRbd2FybmluZ0tleV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgd2FybmluZyhmYWxzZSwgJyVzKC4uLik6IENhbiBvbmx5IHVwZGF0ZSBhIG1vdW50ZWQgb3IgbW91bnRpbmcgY29tcG9uZW50LiAnICsgJ1RoaXMgdXN1YWxseSBtZWFucyB5b3UgY2FsbGVkICVzKCkgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4gJyArICdUaGlzIGlzIGEgbm8tb3AuXFxuXFxuUGxlYXNlIGNoZWNrIHRoZSBjb2RlIGZvciB0aGUgJXMgY29tcG9uZW50LicsIGNhbGxlck5hbWUsIGNhbGxlck5hbWUsIGNvbXBvbmVudE5hbWUpO1xuICAgIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudFt3YXJuaW5nS2V5XSA9IHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBhYnN0cmFjdCBBUEkgZm9yIGFuIHVwZGF0ZSBxdWV1ZS5cbiAqL1xudmFyIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlID0ge1xuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB3ZSB3YW50IHRvIHRlc3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbW91bnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBmaW5hbFxuICAgKi9cbiAgaXNNb3VudGVkOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAgICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAgICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG4gICAqXG4gICAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAgICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gY2FsbGVyTmFtZSBuYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVGb3JjZVVwZGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnZm9yY2VVcGRhdGUnKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVwbGFjZXMgYWxsIG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIG9yIGBzZXRTdGF0ZWAgdG8gbXV0YXRlIHN0YXRlLlxuICAgKiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gICAqXG4gICAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gICAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29tcGxldGVTdGF0ZSBOZXh0IHN0YXRlLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IGNhbGxlck5hbWUgbmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlUmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNvbXBsZXRlU3RhdGUsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdyZXBsYWNlU3RhdGUnKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIFRoaXMgb25seSBleGlzdHMgYmVjYXVzZSBfcGVuZGluZ1N0YXRlIGlzXG4gICAqIGludGVybmFsLiBUaGlzIHByb3ZpZGVzIGEgbWVyZ2luZyBzdHJhdGVneSB0aGF0IGlzIG5vdCBhdmFpbGFibGUgdG8gZGVlcFxuICAgKiBwcm9wZXJ0aWVzIHdoaWNoIGlzIGNvbmZ1c2luZy4gVE9ETzogRXhwb3NlIHBlbmRpbmdTdGF0ZSBvciBkb24ndCB1c2UgaXRcbiAgICogZHVyaW5nIHRoZSBtZXJnZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIHN0YXRlLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IE5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ3NldFN0YXRlJyk7XG4gIH1cbn07XG5cbi8qKlxuICogQmFzZSBjbGFzcyBoZWxwZXJzIGZvciB0aGUgdXBkYXRpbmcgc3RhdGUgb2YgYSBjb21wb25lbnQuXG4gKi9cbmZ1bmN0aW9uIENvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICAvLyBXZSBpbml0aWFsaXplIHRoZSBkZWZhdWx0IHVwZGF0ZXIgYnV0IHRoZSByZWFsIG9uZSBnZXRzIGluamVjdGVkIGJ5IHRoZVxuICAvLyByZW5kZXJlci5cbiAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcbn1cblxuQ29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50ID0ge307XG5cbi8qKlxuICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyB0byBtdXRhdGVcbiAqIHN0YXRlLiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gKlxuICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gKlxuICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgY2FsbHMgdG8gYHNldFN0YXRlYCB3aWxsIHJ1biBzeW5jaHJvbm91c2x5LFxuICogYXMgdGhleSBtYXkgZXZlbnR1YWxseSBiZSBiYXRjaGVkIHRvZ2V0aGVyLiAgWW91IGNhbiBwcm92aWRlIGFuIG9wdGlvbmFsXG4gKiBjYWxsYmFjayB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiB0aGUgY2FsbCB0byBzZXRTdGF0ZSBpcyBhY3R1YWxseVxuICogY29tcGxldGVkLlxuICpcbiAqIFdoZW4gYSBmdW5jdGlvbiBpcyBwcm92aWRlZCB0byBzZXRTdGF0ZSwgaXQgd2lsbCBiZSBjYWxsZWQgYXQgc29tZSBwb2ludCBpblxuICogdGhlIGZ1dHVyZSAobm90IHN5bmNocm9ub3VzbHkpLiBJdCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSB1cCB0byBkYXRlXG4gKiBjb21wb25lbnQgYXJndW1lbnRzIChzdGF0ZSwgcHJvcHMsIGNvbnRleHQpLiBUaGVzZSB2YWx1ZXMgY2FuIGJlIGRpZmZlcmVudFxuICogZnJvbSB0aGlzLiogYmVjYXVzZSB5b3VyIGZ1bmN0aW9uIG1heSBiZSBjYWxsZWQgYWZ0ZXIgcmVjZWl2ZVByb3BzIGJ1dCBiZWZvcmVcbiAqIHNob3VsZENvbXBvbmVudFVwZGF0ZSwgYW5kIHRoaXMgbmV3IHN0YXRlLCBwcm9wcywgYW5kIGNvbnRleHQgd2lsbCBub3QgeWV0IGJlXG4gKiBhc3NpZ25lZCB0byB0aGlzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fGZ1bmN0aW9ufSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIG9yIGZ1bmN0aW9uIHRvXG4gKiAgICAgICAgcHJvZHVjZSBuZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggY3VycmVudCBzdGF0ZS5cbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgc3RhdGUgaXMgdXBkYXRlZC5cbiAqIEBmaW5hbFxuICogQHByb3RlY3RlZFxuICovXG5Db21wb25lbnQucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24gKHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2spIHtcbiAgISh0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnZnVuY3Rpb24nIHx8IHBhcnRpYWxTdGF0ZSA9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ3NldFN0YXRlKC4uLik6IHRha2VzIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMgdG8gdXBkYXRlIG9yIGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzLicpIDogdm9pZCAwO1xuICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZVNldFN0YXRlKHRoaXMsIHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2ssICdzZXRTdGF0ZScpO1xufTtcblxuLyoqXG4gKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAqXG4gKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAqXG4gKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICpcbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgdXBkYXRlIGlzIGNvbXBsZXRlLlxuICogQGZpbmFsXG4gKiBAcHJvdGVjdGVkXG4gKi9cbkNvbXBvbmVudC5wcm90b3R5cGUuZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgdGhpcy51cGRhdGVyLmVucXVldWVGb3JjZVVwZGF0ZSh0aGlzLCBjYWxsYmFjaywgJ2ZvcmNlVXBkYXRlJyk7XG59O1xuXG4vKipcbiAqIERlcHJlY2F0ZWQgQVBJcy4gVGhlc2UgQVBJcyB1c2VkIHRvIGV4aXN0IG9uIGNsYXNzaWMgUmVhY3QgY2xhc3NlcyBidXQgc2luY2VcbiAqIHdlIHdvdWxkIGxpa2UgdG8gZGVwcmVjYXRlIHRoZW0sIHdlJ3JlIG5vdCBnb2luZyB0byBtb3ZlIHRoZW0gb3ZlciB0byB0aGlzXG4gKiBtb2Rlcm4gYmFzZSBjbGFzcy4gSW5zdGVhZCwgd2UgZGVmaW5lIGEgZ2V0dGVyIHRoYXQgd2FybnMgaWYgaXQncyBhY2Nlc3NlZC5cbiAqL1xue1xuICB2YXIgZGVwcmVjYXRlZEFQSXMgPSB7XG4gICAgaXNNb3VudGVkOiBbJ2lzTW91bnRlZCcsICdJbnN0ZWFkLCBtYWtlIHN1cmUgdG8gY2xlYW4gdXAgc3Vic2NyaXB0aW9ucyBhbmQgcGVuZGluZyByZXF1ZXN0cyBpbiAnICsgJ2NvbXBvbmVudFdpbGxVbm1vdW50IHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzLiddLFxuICAgIHJlcGxhY2VTdGF0ZTogWydyZXBsYWNlU3RhdGUnLCAnUmVmYWN0b3IgeW91ciBjb2RlIHRvIHVzZSBzZXRTdGF0ZSBpbnN0ZWFkIChzZWUgJyArICdodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzMyMzYpLiddXG4gIH07XG4gIHZhciBkZWZpbmVEZXByZWNhdGlvbldhcm5pbmcgPSBmdW5jdGlvbiAobWV0aG9kTmFtZSwgaW5mbykge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnQucHJvdG90eXBlLCBtZXRob2ROYW1lLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG93UHJpb3JpdHlXYXJuaW5nJDEoZmFsc2UsICclcyguLi4pIGlzIGRlcHJlY2F0ZWQgaW4gcGxhaW4gSmF2YVNjcmlwdCBSZWFjdCBjbGFzc2VzLiAlcycsIGluZm9bMF0sIGluZm9bMV0pO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICBmb3IgKHZhciBmbk5hbWUgaW4gZGVwcmVjYXRlZEFQSXMpIHtcbiAgICBpZiAoZGVwcmVjYXRlZEFQSXMuaGFzT3duUHJvcGVydHkoZm5OYW1lKSkge1xuICAgICAgZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nKGZuTmFtZSwgZGVwcmVjYXRlZEFQSXNbZm5OYW1lXSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQmFzZSBjbGFzcyBoZWxwZXJzIGZvciB0aGUgdXBkYXRpbmcgc3RhdGUgb2YgYSBjb21wb25lbnQuXG4gKi9cbmZ1bmN0aW9uIFB1cmVDb21wb25lbnQocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgLy8gRHVwbGljYXRlZCBmcm9tIENvbXBvbmVudC5cbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgLy8gV2UgaW5pdGlhbGl6ZSB0aGUgZGVmYXVsdCB1cGRhdGVyIGJ1dCB0aGUgcmVhbCBvbmUgZ2V0cyBpbmplY3RlZCBieSB0aGVcbiAgLy8gcmVuZGVyZXIuXG4gIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG59XG5cbmZ1bmN0aW9uIENvbXBvbmVudER1bW15KCkge31cbkNvbXBvbmVudER1bW15LnByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG52YXIgcHVyZUNvbXBvbmVudFByb3RvdHlwZSA9IFB1cmVDb21wb25lbnQucHJvdG90eXBlID0gbmV3IENvbXBvbmVudER1bW15KCk7XG5wdXJlQ29tcG9uZW50UHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUHVyZUNvbXBvbmVudDtcbi8vIEF2b2lkIGFuIGV4dHJhIHByb3RvdHlwZSBqdW1wIGZvciB0aGVzZSBtZXRob2RzLlxuX2Fzc2lnbihwdXJlQ29tcG9uZW50UHJvdG90eXBlLCBDb21wb25lbnQucHJvdG90eXBlKTtcbnB1cmVDb21wb25lbnRQcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQgPSB0cnVlO1xuXG5mdW5jdGlvbiBBc3luY0NvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICAvLyBEdXBsaWNhdGVkIGZyb20gQ29tcG9uZW50LlxuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICAvLyBXZSBpbml0aWFsaXplIHRoZSBkZWZhdWx0IHVwZGF0ZXIgYnV0IHRoZSByZWFsIG9uZSBnZXRzIGluamVjdGVkIGJ5IHRoZVxuICAvLyByZW5kZXJlci5cbiAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcbn1cblxudmFyIGFzeW5jQ29tcG9uZW50UHJvdG90eXBlID0gQXN5bmNDb21wb25lbnQucHJvdG90eXBlID0gbmV3IENvbXBvbmVudER1bW15KCk7XG5hc3luY0NvbXBvbmVudFByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFzeW5jQ29tcG9uZW50O1xuLy8gQXZvaWQgYW4gZXh0cmEgcHJvdG90eXBlIGp1bXAgZm9yIHRoZXNlIG1ldGhvZHMuXG5fYXNzaWduKGFzeW5jQ29tcG9uZW50UHJvdG90eXBlLCBDb21wb25lbnQucHJvdG90eXBlKTtcbmFzeW5jQ29tcG9uZW50UHJvdG90eXBlLnVuc3RhYmxlX2lzQXN5bmNSZWFjdENvbXBvbmVudCA9IHRydWU7XG5hc3luY0NvbXBvbmVudFByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuO1xufTtcblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBvd25lci5cbiAqXG4gKiBUaGUgY3VycmVudCBvd25lciBpcyB0aGUgY29tcG9uZW50IHdobyBzaG91bGQgb3duIGFueSBjb21wb25lbnRzIHRoYXQgYXJlXG4gKiBjdXJyZW50bHkgYmVpbmcgY29uc3RydWN0ZWQuXG4gKi9cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAdHlwZSB7UmVhY3RDb21wb25lbnR9XG4gICAqL1xuICBjdXJyZW50OiBudWxsXG59O1xuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGtleTogdHJ1ZSxcbiAgcmVmOiB0cnVlLFxuICBfX3NlbGY6IHRydWUsXG4gIF9fc291cmNlOiB0cnVlXG59O1xuXG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvbmZpZy5yZWYgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRLZXkoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdrZXknKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAna2V5JykuZ2V0O1xuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duKSB7XG4gICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL2ZiLm1lL3JlYWN0LXNwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgIH1cbiAgfTtcbiAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAna2V5Jywge1xuICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bikge1xuICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuICAgICAgd2FybmluZyhmYWxzZSwgJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9mYi5tZS9yZWFjdC1zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICB9XG4gIH07XG4gIHdhcm5BYm91dEFjY2Vzc2luZ1JlZi5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ3JlZicsIHtcbiAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBubyBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIHdvcmsuIEluc3RlYWQgdGVzdCAkJHR5cGVvZiBmaWVsZCBhZ2FpbnN0IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSB0byBjaGVja1xuICogaWYgc29tZXRoaW5nIGlzIGEgUmVhY3QgRWxlbWVudC5cbiAqXG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7Kn0ga2V5XG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHJlZlxuICogQHBhcmFtIHsqfSBzZWxmIEEgKnRlbXBvcmFyeSogaGVscGVyIHRvIGRldGVjdCBwbGFjZXMgd2hlcmUgYHRoaXNgIGlzXG4gKiBkaWZmZXJlbnQgZnJvbSB0aGUgYG93bmVyYCB3aGVuIFJlYWN0LmNyZWF0ZUVsZW1lbnQgaXMgY2FsbGVkLCBzbyB0aGF0IHdlXG4gKiBjYW4gd2Fybi4gV2Ugd2FudCB0byBnZXQgcmlkIG9mIG93bmVyIGFuZCByZXBsYWNlIHN0cmluZyBgcmVmYHMgd2l0aCBhcnJvd1xuICogZnVuY3Rpb25zLCBhbmQgYXMgbG9uZyBhcyBgdGhpc2AgYW5kIG93bmVyIGFyZSB0aGUgc2FtZSwgdGhlcmUgd2lsbCBiZSBub1xuICogY2hhbmdlIGluIGJlaGF2aW9yLlxuICogQHBhcmFtIHsqfSBzb3VyY2UgQW4gYW5ub3RhdGlvbiBvYmplY3QgKGFkZGVkIGJ5IGEgdHJhbnNwaWxlciBvciBvdGhlcndpc2UpXG4gKiBpbmRpY2F0aW5nIGZpbGVuYW1lLCBsaW5lIG51bWJlciwgYW5kL29yIG90aGVyIGluZm9ybWF0aW9uLlxuICogQHBhcmFtIHsqfSBvd25lclxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdEVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKSB7XG4gIHZhciBlbGVtZW50ID0ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93IHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcblxuICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICB0eXBlOiB0eXBlLFxuICAgIGtleToga2V5LFxuICAgIHJlZjogcmVmLFxuICAgIHByb3BzOiBwcm9wcyxcblxuICAgIC8vIFJlY29yZCB0aGUgY29tcG9uZW50IHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGlzIGVsZW1lbnQuXG4gICAgX293bmVyOiBvd25lclxuICB9O1xuXG4gIHtcbiAgICAvLyBUaGUgdmFsaWRhdGlvbiBmbGFnIGlzIGN1cnJlbnRseSBtdXRhdGl2ZS4gV2UgcHV0IGl0IG9uXG4gICAgLy8gYW4gZXh0ZXJuYWwgYmFja2luZyBzdG9yZSBzbyB0aGF0IHdlIGNhbiBmcmVlemUgdGhlIHdob2xlIG9iamVjdC5cbiAgICAvLyBUaGlzIGNhbiBiZSByZXBsYWNlZCB3aXRoIGEgV2Vha01hcCBvbmNlIHRoZXkgYXJlIGltcGxlbWVudGVkIGluXG4gICAgLy8gY29tbW9ubHkgdXNlZCBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMuXG4gICAgZWxlbWVudC5fc3RvcmUgPSB7fTtcblxuICAgIC8vIFRvIG1ha2UgY29tcGFyaW5nIFJlYWN0RWxlbWVudHMgZWFzaWVyIGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB3ZSBtYWtlXG4gICAgLy8gdGhlIHZhbGlkYXRpb24gZmxhZyBub24tZW51bWVyYWJsZSAod2hlcmUgcG9zc2libGUsIHdoaWNoIHNob3VsZFxuICAgIC8vIGluY2x1ZGUgZXZlcnkgZW52aXJvbm1lbnQgd2UgcnVuIHRlc3RzIGluKSwgc28gdGhlIHRlc3QgZnJhbWV3b3JrXG4gICAgLy8gaWdub3JlcyBpdC5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pO1xuICAgIC8vIHNlbGYgYW5kIHNvdXJjZSBhcmUgREVWIG9ubHkgcHJvcGVydGllcy5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNlbGZcbiAgICB9KTtcbiAgICAvLyBUd28gZWxlbWVudHMgY3JlYXRlZCBpbiB0d28gZGlmZmVyZW50IHBsYWNlcyBzaG91bGQgYmUgY29uc2lkZXJlZFxuICAgIC8vIGVxdWFsIGZvciB0ZXN0aW5nIHB1cnBvc2VzIGFuZCB0aGVyZWZvcmUgd2UgaGlkZSBpdCBmcm9tIGVudW1lcmF0aW9uLlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICB9KTtcbiAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50LnByb3BzKTtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgbmV3IFJlYWN0RWxlbWVudCBvZiB0aGUgZ2l2ZW4gdHlwZS5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjY3JlYXRlZWxlbWVudFxuICovXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50KHR5cGUsIGNvbmZpZywgY2hpbGRyZW4pIHtcbiAgdmFyIHByb3BOYW1lO1xuXG4gIC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcbiAgdmFyIHByb3BzID0ge307XG5cbiAgdmFyIGtleSA9IG51bGw7XG4gIHZhciByZWYgPSBudWxsO1xuICB2YXIgc2VsZiA9IG51bGw7XG4gIHZhciBzb3VyY2UgPSBudWxsO1xuXG4gIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgIH1cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIHNlbGYgPSBjb25maWcuX19zZWxmID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLl9fc2VsZjtcbiAgICBzb3VyY2UgPSBjb25maWcuX19zb3VyY2UgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb25maWcuX19zb3VyY2U7XG4gICAgLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgYXJlIGFkZGVkIHRvIGEgbmV3IHByb3BzIG9iamVjdFxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ2hpbGRyZW4gY2FuIGJlIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQsIGFuZCB0aG9zZSBhcmUgdHJhbnNmZXJyZWQgb250b1xuICAvLyB0aGUgbmV3bHkgYWxsb2NhdGVkIHByb3BzIG9iamVjdC5cbiAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG4gIGlmIChjaGlsZHJlbkxlbmd0aCA9PT0gMSkge1xuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgdmFyIGNoaWxkQXJyYXkgPSBBcnJheShjaGlsZHJlbkxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICB9XG4gICAge1xuICAgICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZShjaGlsZEFycmF5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICB9XG5cbiAgLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG4gIGlmICh0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuICAgIGZvciAocHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAge1xuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICBpZiAodHlwZW9mIHByb3BzLiQkdHlwZW9mID09PSAndW5kZWZpbmVkJyB8fCBwcm9wcy4kJHR5cGVvZiAhPT0gUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XG4gICAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcbiAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlZikge1xuICAgICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LCBwcm9wcyk7XG59XG5cbi8qKlxuICogUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBwcm9kdWNlcyBSZWFjdEVsZW1lbnRzIG9mIGEgZ2l2ZW4gdHlwZS5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjY3JlYXRlZmFjdG9yeVxuICovXG5cblxuZnVuY3Rpb24gY2xvbmVBbmRSZXBsYWNlS2V5KG9sZEVsZW1lbnQsIG5ld0tleSkge1xuICB2YXIgbmV3RWxlbWVudCA9IFJlYWN0RWxlbWVudChvbGRFbGVtZW50LnR5cGUsIG5ld0tleSwgb2xkRWxlbWVudC5yZWYsIG9sZEVsZW1lbnQuX3NlbGYsIG9sZEVsZW1lbnQuX3NvdXJjZSwgb2xkRWxlbWVudC5fb3duZXIsIG9sZEVsZW1lbnQucHJvcHMpO1xuXG4gIHJldHVybiBuZXdFbGVtZW50O1xufVxuXG4vKipcbiAqIENsb25lIGFuZCByZXR1cm4gYSBuZXcgUmVhY3RFbGVtZW50IHVzaW5nIGVsZW1lbnQgYXMgdGhlIHN0YXJ0aW5nIHBvaW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNjbG9uZWVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gY2xvbmVFbGVtZW50KGVsZW1lbnQsIGNvbmZpZywgY2hpbGRyZW4pIHtcbiAgdmFyIHByb3BOYW1lO1xuXG4gIC8vIE9yaWdpbmFsIHByb3BzIGFyZSBjb3BpZWRcbiAgdmFyIHByb3BzID0gX2Fzc2lnbih7fSwgZWxlbWVudC5wcm9wcyk7XG5cbiAgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuICB2YXIga2V5ID0gZWxlbWVudC5rZXk7XG4gIHZhciByZWYgPSBlbGVtZW50LnJlZjtcbiAgLy8gU2VsZiBpcyBwcmVzZXJ2ZWQgc2luY2UgdGhlIG93bmVyIGlzIHByZXNlcnZlZC5cbiAgdmFyIHNlbGYgPSBlbGVtZW50Ll9zZWxmO1xuICAvLyBTb3VyY2UgaXMgcHJlc2VydmVkIHNpbmNlIGNsb25lRWxlbWVudCBpcyB1bmxpa2VseSB0byBiZSB0YXJnZXRlZCBieSBhXG4gIC8vIHRyYW5zcGlsZXIsIGFuZCB0aGUgb3JpZ2luYWwgc291cmNlIGlzIHByb2JhYmx5IGEgYmV0dGVyIGluZGljYXRvciBvZiB0aGVcbiAgLy8gdHJ1ZSBvd25lci5cbiAgdmFyIHNvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTtcblxuICAvLyBPd25lciB3aWxsIGJlIHByZXNlcnZlZCwgdW5sZXNzIHJlZiBpcyBvdmVycmlkZGVuXG4gIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuXG4gIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICAvLyBTaWxlbnRseSBzdGVhbCB0aGUgcmVmIGZyb20gdGhlIHBhcmVudC5cbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG4gICAgICBvd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgfVxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XG4gICAgfVxuXG4gICAgLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgb3ZlcnJpZGUgZXhpc3RpbmcgcHJvcHNcbiAgICB2YXIgZGVmYXVsdFByb3BzO1xuICAgIGlmIChlbGVtZW50LnR5cGUgJiYgZWxlbWVudC50eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgZGVmYXVsdFByb3BzID0gZWxlbWVudC50eXBlLmRlZmF1bHRQcm9wcztcbiAgICB9XG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgaWYgKGNvbmZpZ1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCAmJiBkZWZhdWx0UHJvcHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIENoaWxkcmVuIGNhbiBiZSBtb3JlIHRoYW4gb25lIGFyZ3VtZW50LCBhbmQgdGhvc2UgYXJlIHRyYW5zZmVycmVkIG9udG9cbiAgLy8gdGhlIG5ld2x5IGFsbG9jYXRlZCBwcm9wcyBvYmplY3QuXG4gIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB9IGVsc2UgaWYgKGNoaWxkcmVuTGVuZ3RoID4gMSkge1xuICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGRBcnJheVtpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgfVxuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcbiAgfVxuXG4gIHJldHVybiBSZWFjdEVsZW1lbnQoZWxlbWVudC50eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpO1xufVxuXG4vKipcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2lzdmFsaWRlbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIHZhbGlkIGNvbXBvbmVudC5cbiAqIEBmaW5hbFxuICovXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbn1cblxudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSB7fTtcblxue1xuICAvLyBDb21wb25lbnQgdGhhdCBpcyBiZWluZyB3b3JrZWQgb25cbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2sgPSBudWxsO1xuXG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaW1wbCA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrO1xuICAgIGlmIChpbXBsKSB7XG4gICAgICByZXR1cm4gaW1wbCgpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcbn1cblxudmFyIFNFUEFSQVRPUiA9ICcuJztcbnZhciBTVUJTRVBBUkFUT1IgPSAnOic7XG5cbi8qKlxuICogRXNjYXBlIGFuZCB3cmFwIGtleSBzbyBpdCBpcyBzYWZlIHRvIHVzZSBhcyBhIHJlYWN0aWRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHRvIGJlIGVzY2FwZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBlc2NhcGVkIGtleS5cbiAqL1xuZnVuY3Rpb24gZXNjYXBlKGtleSkge1xuICB2YXIgZXNjYXBlUmVnZXggPSAvWz06XS9nO1xuICB2YXIgZXNjYXBlckxvb2t1cCA9IHtcbiAgICAnPSc6ICc9MCcsXG4gICAgJzonOiAnPTInXG4gIH07XG4gIHZhciBlc2NhcGVkU3RyaW5nID0gKCcnICsga2V5KS5yZXBsYWNlKGVzY2FwZVJlZ2V4LCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICByZXR1cm4gZXNjYXBlckxvb2t1cFttYXRjaF07XG4gIH0pO1xuXG4gIHJldHVybiAnJCcgKyBlc2NhcGVkU3RyaW5nO1xufVxuXG4vKipcbiAqIFRPRE86IFRlc3QgdGhhdCBhIHNpbmdsZSBjaGlsZCBhbmQgYW4gYXJyYXkgd2l0aCBvbmUgaXRlbSBoYXZlIHRoZSBzYW1lIGtleVxuICogcGF0dGVybi5cbiAqL1xuXG52YXIgZGlkV2FybkFib3V0TWFwcyA9IGZhbHNlO1xuXG52YXIgdXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXggPSAvXFwvKy9nO1xuZnVuY3Rpb24gZXNjYXBlVXNlclByb3ZpZGVkS2V5KHRleHQpIHtcbiAgcmV0dXJuICgnJyArIHRleHQpLnJlcGxhY2UodXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXgsICckJi8nKTtcbn1cblxudmFyIFBPT0xfU0laRSA9IDEwO1xudmFyIHRyYXZlcnNlQ29udGV4dFBvb2wgPSBbXTtcbmZ1bmN0aW9uIGdldFBvb2xlZFRyYXZlcnNlQ29udGV4dChtYXBSZXN1bHQsIGtleVByZWZpeCwgbWFwRnVuY3Rpb24sIG1hcENvbnRleHQpIHtcbiAgaWYgKHRyYXZlcnNlQ29udGV4dFBvb2wubGVuZ3RoKSB7XG4gICAgdmFyIHRyYXZlcnNlQ29udGV4dCA9IHRyYXZlcnNlQ29udGV4dFBvb2wucG9wKCk7XG4gICAgdHJhdmVyc2VDb250ZXh0LnJlc3VsdCA9IG1hcFJlc3VsdDtcbiAgICB0cmF2ZXJzZUNvbnRleHQua2V5UHJlZml4ID0ga2V5UHJlZml4O1xuICAgIHRyYXZlcnNlQ29udGV4dC5mdW5jID0gbWFwRnVuY3Rpb247XG4gICAgdHJhdmVyc2VDb250ZXh0LmNvbnRleHQgPSBtYXBDb250ZXh0O1xuICAgIHRyYXZlcnNlQ29udGV4dC5jb3VudCA9IDA7XG4gICAgcmV0dXJuIHRyYXZlcnNlQ29udGV4dDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVzdWx0OiBtYXBSZXN1bHQsXG4gICAgICBrZXlQcmVmaXg6IGtleVByZWZpeCxcbiAgICAgIGZ1bmM6IG1hcEZ1bmN0aW9uLFxuICAgICAgY29udGV4dDogbWFwQ29udGV4dCxcbiAgICAgIGNvdW50OiAwXG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWxlYXNlVHJhdmVyc2VDb250ZXh0KHRyYXZlcnNlQ29udGV4dCkge1xuICB0cmF2ZXJzZUNvbnRleHQucmVzdWx0ID0gbnVsbDtcbiAgdHJhdmVyc2VDb250ZXh0LmtleVByZWZpeCA9IG51bGw7XG4gIHRyYXZlcnNlQ29udGV4dC5mdW5jID0gbnVsbDtcbiAgdHJhdmVyc2VDb250ZXh0LmNvbnRleHQgPSBudWxsO1xuICB0cmF2ZXJzZUNvbnRleHQuY291bnQgPSAwO1xuICBpZiAodHJhdmVyc2VDb250ZXh0UG9vbC5sZW5ndGggPCBQT09MX1NJWkUpIHtcbiAgICB0cmF2ZXJzZUNvbnRleHRQb29sLnB1c2godHJhdmVyc2VDb250ZXh0KTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHshc3RyaW5nfSBuYW1lU29GYXIgTmFtZSBvZiB0aGUga2V5IHBhdGggc28gZmFyLlxuICogQHBhcmFtIHshZnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGludm9rZSB3aXRoIGVhY2ggY2hpbGQgZm91bmQuXG4gKiBAcGFyYW0gez8qfSB0cmF2ZXJzZUNvbnRleHQgVXNlZCB0byBwYXNzIGluZm9ybWF0aW9uIHRocm91Z2hvdXQgdGhlIHRyYXZlcnNhbFxuICogcHJvY2Vzcy5cbiAqIEByZXR1cm4geyFudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4gaW4gdGhpcyBzdWJ0cmVlLlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZHJlbiwgbmFtZVNvRmFyLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIGNoaWxkcmVuO1xuXG4gIGlmICh0eXBlID09PSAndW5kZWZpbmVkJyB8fCB0eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAvLyBBbGwgb2YgdGhlIGFib3ZlIGFyZSBwZXJjZWl2ZWQgYXMgbnVsbC5cbiAgICBjaGlsZHJlbiA9IG51bGw7XG4gIH1cblxuICB2YXIgaW52b2tlQ2FsbGJhY2sgPSBmYWxzZTtcblxuICBpZiAoY2hpbGRyZW4gPT09IG51bGwpIHtcbiAgICBpbnZva2VDYWxsYmFjayA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgaW52b2tlQ2FsbGJhY2sgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHN3aXRjaCAoY2hpbGRyZW4uJCR0eXBlb2YpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX0NBTExfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1JFVFVSTl9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgICBpbnZva2VDYWxsYmFjayA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoaW52b2tlQ2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayh0cmF2ZXJzZUNvbnRleHQsIGNoaWxkcmVuLFxuICAgIC8vIElmIGl0J3MgdGhlIG9ubHkgY2hpbGQsIHRyZWF0IHRoZSBuYW1lIGFzIGlmIGl0IHdhcyB3cmFwcGVkIGluIGFuIGFycmF5XG4gICAgLy8gc28gdGhhdCBpdCdzIGNvbnNpc3RlbnQgaWYgdGhlIG51bWJlciBvZiBjaGlsZHJlbiBncm93cy5cbiAgICBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkcmVuLCAwKSA6IG5hbWVTb0Zhcik7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICB2YXIgY2hpbGQ7XG4gIHZhciBuZXh0TmFtZTtcbiAgdmFyIHN1YnRyZWVDb3VudCA9IDA7IC8vIENvdW50IG9mIGNoaWxkcmVuIGZvdW5kIGluIHRoZSBjdXJyZW50IHN1YnRyZWUuXG4gIHZhciBuZXh0TmFtZVByZWZpeCA9IG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgOiBuYW1lU29GYXIgKyBTVUJTRVBBUkFUT1I7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRDb21wb25lbnRLZXkoY2hpbGQsIGkpO1xuICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihjaGlsZHJlbik7XG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB7XG4gICAgICAgIC8vIFdhcm4gYWJvdXQgdXNpbmcgTWFwcyBhcyBjaGlsZHJlblxuICAgICAgICBpZiAoaXRlcmF0b3JGbiA9PT0gY2hpbGRyZW4uZW50cmllcykge1xuICAgICAgICAgIHdhcm5pbmcoZGlkV2FybkFib3V0TWFwcywgJ1VzaW5nIE1hcHMgYXMgY2hpbGRyZW4gaXMgdW5zdXBwb3J0ZWQgYW5kIHdpbGwgbGlrZWx5IHlpZWxkICcgKyAndW5leHBlY3RlZCByZXN1bHRzLiBDb252ZXJ0IGl0IHRvIGEgc2VxdWVuY2UvaXRlcmFibGUgb2Yga2V5ZWQgJyArICdSZWFjdEVsZW1lbnRzIGluc3RlYWQuJXMnLCBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKSk7XG4gICAgICAgICAgZGlkV2FybkFib3V0TWFwcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKGNoaWxkcmVuKTtcbiAgICAgIHZhciBzdGVwO1xuICAgICAgdmFyIGlpID0gMDtcbiAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgY2hpbGQgPSBzdGVwLnZhbHVlO1xuICAgICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkLCBpaSsrKTtcbiAgICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGFkZGVuZHVtID0gJyc7XG4gICAgICB7XG4gICAgICAgIGFkZGVuZHVtID0gJyBJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5ICcgKyAnaW5zdGVhZC4nICsgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG4gICAgICB9XG4gICAgICB2YXIgY2hpbGRyZW5TdHJpbmcgPSAnJyArIGNoaWxkcmVuO1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQgKGZvdW5kOiAlcykuJXMnLCBjaGlsZHJlblN0cmluZyA9PT0gJ1tvYmplY3QgT2JqZWN0XScgPyAnb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKGNoaWxkcmVuKS5qb2luKCcsICcpICsgJ30nIDogY2hpbGRyZW5TdHJpbmcsIGFkZGVuZHVtKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3VidHJlZUNvdW50O1xufVxuXG4vKipcbiAqIFRyYXZlcnNlcyBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAsIGJ1dFxuICogbWlnaHQgYWxzbyBiZSBzcGVjaWZpZWQgdGhyb3VnaCBhdHRyaWJ1dGVzOlxuICpcbiAqIC0gYHRyYXZlcnNlQWxsQ2hpbGRyZW4odGhpcy5wcm9wcy5jaGlsZHJlbiwgLi4uKWBcbiAqIC0gYHRyYXZlcnNlQWxsQ2hpbGRyZW4odGhpcy5wcm9wcy5sZWZ0UGFuZWxDaGlsZHJlbiwgLi4uKWBcbiAqXG4gKiBUaGUgYHRyYXZlcnNlQ29udGV4dGAgaXMgYW4gb3B0aW9uYWwgYXJndW1lbnQgdGhhdCBpcyBwYXNzZWQgdGhyb3VnaCB0aGVcbiAqIGVudGlyZSB0cmF2ZXJzYWwuIEl0IGNhbiBiZSB1c2VkIHRvIHN0b3JlIGFjY3VtdWxhdGlvbnMgb3IgYW55dGhpbmcgZWxzZSB0aGF0XG4gKiB0aGUgY2FsbGJhY2sgbWlnaHQgZmluZCByZWxldmFudC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIG9iamVjdC5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBjYWxsYmFjayBUbyBpbnZva2UgdXBvbiB0cmF2ZXJzaW5nIGVhY2ggY2hpbGQuXG4gKiBAcGFyYW0gez8qfSB0cmF2ZXJzZUNvbnRleHQgQ29udGV4dCBmb3IgdHJhdmVyc2FsLlxuICogQHJldHVybiB7IW51bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbiBpbiB0aGlzIHN1YnRyZWUuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHJldHVybiB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZHJlbiwgJycsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGEga2V5IHN0cmluZyB0aGF0IGlkZW50aWZpZXMgYSBjb21wb25lbnQgd2l0aGluIGEgc2V0LlxuICpcbiAqIEBwYXJhbSB7Kn0gY29tcG9uZW50IEEgY29tcG9uZW50IHRoYXQgY291bGQgY29udGFpbiBhIG1hbnVhbCBrZXkuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggdGhhdCBpcyB1c2VkIGlmIGEgbWFudWFsIGtleSBpcyBub3QgcHJvdmlkZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldENvbXBvbmVudEtleShjb21wb25lbnQsIGluZGV4KSB7XG4gIC8vIERvIHNvbWUgdHlwZWNoZWNraW5nIGhlcmUgc2luY2Ugd2UgY2FsbCB0aGlzIGJsaW5kbHkuIFdlIHdhbnQgdG8gZW5zdXJlXG4gIC8vIHRoYXQgd2UgZG9uJ3QgYmxvY2sgcG90ZW50aWFsIGZ1dHVyZSBFUyBBUElzLlxuICBpZiAodHlwZW9mIGNvbXBvbmVudCA9PT0gJ29iamVjdCcgJiYgY29tcG9uZW50ICE9PSBudWxsICYmIGNvbXBvbmVudC5rZXkgIT0gbnVsbCkge1xuICAgIC8vIEV4cGxpY2l0IGtleVxuICAgIHJldHVybiBlc2NhcGUoY29tcG9uZW50LmtleSk7XG4gIH1cbiAgLy8gSW1wbGljaXQga2V5IGRldGVybWluZWQgYnkgdGhlIGluZGV4IGluIHRoZSBzZXRcbiAgcmV0dXJuIGluZGV4LnRvU3RyaW5nKDM2KTtcbn1cblxuZnVuY3Rpb24gZm9yRWFjaFNpbmdsZUNoaWxkKGJvb2tLZWVwaW5nLCBjaGlsZCwgbmFtZSkge1xuICB2YXIgZnVuYyA9IGJvb2tLZWVwaW5nLmZ1bmMsXG4gICAgICBjb250ZXh0ID0gYm9va0tlZXBpbmcuY29udGV4dDtcblxuICBmdW5jLmNhbGwoY29udGV4dCwgY2hpbGQsIGJvb2tLZWVwaW5nLmNvdW50KyspO1xufVxuXG4vKipcbiAqIEl0ZXJhdGVzIHRocm91Z2ggY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4uZm9yZWFjaFxuICpcbiAqIFRoZSBwcm92aWRlZCBmb3JFYWNoRnVuYyhjaGlsZCwgaW5kZXgpIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoXG4gKiBsZWFmIGNoaWxkLlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBpbnQpfSBmb3JFYWNoRnVuY1xuICogQHBhcmFtIHsqfSBmb3JFYWNoQ29udGV4dCBDb250ZXh0IGZvciBmb3JFYWNoQ29udGV4dC5cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cbiAgdmFyIHRyYXZlcnNlQ29udGV4dCA9IGdldFBvb2xlZFRyYXZlcnNlQ29udGV4dChudWxsLCBudWxsLCBmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpO1xuICB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoU2luZ2xlQ2hpbGQsIHRyYXZlcnNlQ29udGV4dCk7XG4gIHJlbGVhc2VUcmF2ZXJzZUNvbnRleHQodHJhdmVyc2VDb250ZXh0KTtcbn1cblxuZnVuY3Rpb24gbWFwU2luZ2xlQ2hpbGRJbnRvQ29udGV4dChib29rS2VlcGluZywgY2hpbGQsIGNoaWxkS2V5KSB7XG4gIHZhciByZXN1bHQgPSBib29rS2VlcGluZy5yZXN1bHQsXG4gICAgICBrZXlQcmVmaXggPSBib29rS2VlcGluZy5rZXlQcmVmaXgsXG4gICAgICBmdW5jID0gYm9va0tlZXBpbmcuZnVuYyxcbiAgICAgIGNvbnRleHQgPSBib29rS2VlcGluZy5jb250ZXh0O1xuXG5cbiAgdmFyIG1hcHBlZENoaWxkID0gZnVuYy5jYWxsKGNvbnRleHQsIGNoaWxkLCBib29rS2VlcGluZy5jb3VudCsrKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkobWFwcGVkQ2hpbGQpKSB7XG4gICAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChtYXBwZWRDaGlsZCwgcmVzdWx0LCBjaGlsZEtleSwgZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50KTtcbiAgfSBlbHNlIGlmIChtYXBwZWRDaGlsZCAhPSBudWxsKSB7XG4gICAgaWYgKGlzVmFsaWRFbGVtZW50KG1hcHBlZENoaWxkKSkge1xuICAgICAgbWFwcGVkQ2hpbGQgPSBjbG9uZUFuZFJlcGxhY2VLZXkobWFwcGVkQ2hpbGQsXG4gICAgICAvLyBLZWVwIGJvdGggdGhlIChtYXBwZWQpIGFuZCBvbGQga2V5cyBpZiB0aGV5IGRpZmZlciwganVzdCBhc1xuICAgICAgLy8gdHJhdmVyc2VBbGxDaGlsZHJlbiB1c2VkIHRvIGRvIGZvciBvYmplY3RzIGFzIGNoaWxkcmVuXG4gICAgICBrZXlQcmVmaXggKyAobWFwcGVkQ2hpbGQua2V5ICYmICghY2hpbGQgfHwgY2hpbGQua2V5ICE9PSBtYXBwZWRDaGlsZC5rZXkpID8gZXNjYXBlVXNlclByb3ZpZGVkS2V5KG1hcHBlZENoaWxkLmtleSkgKyAnLycgOiAnJykgKyBjaGlsZEtleSk7XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKG1hcHBlZENoaWxkKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKGNoaWxkcmVuLCBhcnJheSwgcHJlZml4LCBmdW5jLCBjb250ZXh0KSB7XG4gIHZhciBlc2NhcGVkUHJlZml4ID0gJyc7XG4gIGlmIChwcmVmaXggIT0gbnVsbCkge1xuICAgIGVzY2FwZWRQcmVmaXggPSBlc2NhcGVVc2VyUHJvdmlkZWRLZXkocHJlZml4KSArICcvJztcbiAgfVxuICB2YXIgdHJhdmVyc2VDb250ZXh0ID0gZ2V0UG9vbGVkVHJhdmVyc2VDb250ZXh0KGFycmF5LCBlc2NhcGVkUHJlZml4LCBmdW5jLCBjb250ZXh0KTtcbiAgdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgbWFwU2luZ2xlQ2hpbGRJbnRvQ29udGV4dCwgdHJhdmVyc2VDb250ZXh0KTtcbiAgcmVsZWFzZVRyYXZlcnNlQ29udGV4dCh0cmF2ZXJzZUNvbnRleHQpO1xufVxuXG4vKipcbiAqIE1hcHMgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4ubWFwXG4gKlxuICogVGhlIHByb3ZpZGVkIG1hcEZ1bmN0aW9uKGNoaWxkLCBrZXksIGluZGV4KSB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaFxuICogbGVhZiBjaGlsZC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgaW50KX0gZnVuYyBUaGUgbWFwIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IENvbnRleHQgZm9yIG1hcEZ1bmN0aW9uLlxuICogQHJldHVybiB7b2JqZWN0fSBPYmplY3QgY29udGFpbmluZyB0aGUgb3JkZXJlZCBtYXAgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmMsIGNvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKGNoaWxkcmVuLCByZXN1bHQsIG51bGwsIGZ1bmMsIGNvbnRleHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENvdW50IHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhc1xuICogYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0LmNoaWxkcmVuLmNvdW50XG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4uXG4gKi9cbmZ1bmN0aW9uIGNvdW50Q2hpbGRyZW4oY2hpbGRyZW4sIGNvbnRleHQpIHtcbiAgcmV0dXJuIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsLCBudWxsKTtcbn1cblxuLyoqXG4gKiBGbGF0dGVuIGEgY2hpbGRyZW4gb2JqZWN0ICh0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmApIGFuZFxuICogcmV0dXJuIGFuIGFycmF5IHdpdGggYXBwcm9wcmlhdGVseSByZS1rZXllZCBjaGlsZHJlbi5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0LmNoaWxkcmVuLnRvYXJyYXlcbiAqL1xuZnVuY3Rpb24gdG9BcnJheShjaGlsZHJlbikge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwoY2hpbGRyZW4sIHJlc3VsdCwgbnVsbCwgZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBjaGlsZCBpbiBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4gYW5kIHZlcmlmaWVzIHRoYXQgdGhlcmVcbiAqIGlzIG9ubHkgb25lIGNoaWxkIGluIHRoZSBjb2xsZWN0aW9uLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4ub25seVxuICpcbiAqIFRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uIG9mIHRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGF0IGEgc2luZ2xlIGNoaWxkIGdldHNcbiAqIHBhc3NlZCB3aXRob3V0IGEgd3JhcHBlciwgYnV0IHRoZSBwdXJwb3NlIG9mIHRoaXMgaGVscGVyIGZ1bmN0aW9uIGlzIHRvXG4gKiBhYnN0cmFjdCBhd2F5IHRoZSBwYXJ0aWN1bGFyIHN0cnVjdHVyZSBvZiBjaGlsZHJlbi5cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IGNoaWxkcmVuIENoaWxkIGNvbGxlY3Rpb24gc3RydWN0dXJlLlxuICogQHJldHVybiB7UmVhY3RFbGVtZW50fSBUaGUgZmlyc3QgYW5kIG9ubHkgYFJlYWN0RWxlbWVudGAgY29udGFpbmVkIGluIHRoZVxuICogc3RydWN0dXJlLlxuICovXG5mdW5jdGlvbiBvbmx5Q2hpbGQoY2hpbGRyZW4pIHtcbiAgIWlzVmFsaWRFbGVtZW50KGNoaWxkcmVuKSA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0LkNoaWxkcmVuLm9ubHkgZXhwZWN0ZWQgdG8gcmVjZWl2ZSBhIHNpbmdsZSBSZWFjdCBlbGVtZW50IGNoaWxkLicpIDogdm9pZCAwO1xuICByZXR1cm4gY2hpbGRyZW47XG59XG5cbnZhciBkZXNjcmliZUNvbXBvbmVudEZyYW1lID0gZnVuY3Rpb24gKG5hbWUsIHNvdXJjZSwgb3duZXJOYW1lKSB7XG4gIHJldHVybiAnXFxuICAgIGluICcgKyAobmFtZSB8fCAnVW5rbm93bicpICsgKHNvdXJjZSA/ICcgKGF0ICcgKyBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpICsgJzonICsgc291cmNlLmxpbmVOdW1iZXIgKyAnKScgOiBvd25lck5hbWUgPyAnIChjcmVhdGVkIGJ5ICcgKyBvd25lck5hbWUgKyAnKScgOiAnJyk7XG59O1xuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lKGZpYmVyKSB7XG4gIHZhciB0eXBlID0gZmliZXIudHlwZTtcblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFJlYWN0RWxlbWVudFZhbGlkYXRvciBwcm92aWRlcyBhIHdyYXBwZXIgYXJvdW5kIGEgZWxlbWVudCBmYWN0b3J5XG4gKiB3aGljaCB2YWxpZGF0ZXMgdGhlIHByb3BzIHBhc3NlZCB0byB0aGUgZWxlbWVudC4gVGhpcyBpcyBpbnRlbmRlZCB0byBiZVxuICogdXNlZCBvbmx5IGluIERFViBhbmQgY291bGQgYmUgcmVwbGFjZWQgYnkgYSBzdGF0aWMgdHlwZSBjaGVja2VyIGZvciBsYW5ndWFnZXNcbiAqIHRoYXQgc3VwcG9ydCBpdC5cbiAqL1xuXG57XG4gIHZhciBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCA9IG51bGw7XG5cbiAgdmFyIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gZmFsc2U7XG5cbiAgdmFyIGdldERpc3BsYXlOYW1lID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gJyNlbXB0eSc7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGVsZW1lbnQgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gJyN0ZXh0JztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbGVtZW50LnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gZWxlbWVudC50eXBlO1xuICAgIH0gZWxzZSBpZiAoZWxlbWVudC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICByZXR1cm4gJ1JlYWN0LkZyYWdtZW50JztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGVsZW1lbnQudHlwZS5kaXNwbGF5TmFtZSB8fCBlbGVtZW50LnR5cGUubmFtZSB8fCAnVW5rbm93bic7XG4gICAgfVxuICB9O1xuXG4gIHZhciBnZXRTdGFja0FkZGVuZHVtID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdGFjayA9ICcnO1xuICAgIGlmIChjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXREaXNwbGF5TmFtZShjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCk7XG4gICAgICB2YXIgb3duZXIgPSBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudC5fb3duZXI7XG4gICAgICBzdGFjayArPSBkZXNjcmliZUNvbXBvbmVudEZyYW1lKG5hbWUsIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50Ll9zb3VyY2UsIG93bmVyICYmIGdldENvbXBvbmVudE5hbWUob3duZXIpKTtcbiAgICB9XG4gICAgc3RhY2sgKz0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCkgfHwgJyc7XG4gICAgcmV0dXJuIHN0YWNrO1xuICB9O1xuXG4gIHZhciBWQUxJRF9GUkFHTUVOVF9QUk9QUyA9IG5ldyBNYXAoW1snY2hpbGRyZW4nLCB0cnVlXSwgWydrZXknLCB0cnVlXV0pO1xufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIGlmIChSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpO1xuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgfVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oZWxlbWVudFByb3BzKSB7XG4gIGlmIChlbGVtZW50UHJvcHMgIT09IG51bGwgJiYgZWxlbWVudFByb3BzICE9PSB1bmRlZmluZWQgJiYgZWxlbWVudFByb3BzLl9fc291cmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgc291cmNlID0gZWxlbWVudFByb3BzLl9fc291cmNlO1xuICAgIHZhciBmaWxlTmFtZSA9IHNvdXJjZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJyk7XG4gICAgdmFyIGxpbmVOdW1iZXIgPSBzb3VyY2UubGluZU51bWJlcjtcbiAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cbnZhciBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcblxuZnVuY3Rpb24gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKSB7XG4gIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgaWYgKCFpbmZvKSB7XG4gICAgdmFyIHBhcmVudE5hbWUgPSB0eXBlb2YgcGFyZW50VHlwZSA9PT0gJ3N0cmluZycgPyBwYXJlbnRUeXBlIDogcGFyZW50VHlwZS5kaXNwbGF5TmFtZSB8fCBwYXJlbnRUeXBlLm5hbWU7XG4gICAgaWYgKHBhcmVudE5hbWUpIHtcbiAgICAgIGluZm8gPSAnXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8JyArIHBhcmVudE5hbWUgKyAnPi4nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaW5mbztcbn1cblxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gIGlmICghZWxlbWVudC5fc3RvcmUgfHwgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkIHx8IGVsZW1lbnQua2V5ICE9IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcblxuICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9IGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSk7XG4gIGlmIChvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgb3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dID0gdHJ1ZTtcblxuICAvLyBVc3VhbGx5IHRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBvZmZlbmRlciwgYnV0IGlmIGl0IGFjY2VwdHMgY2hpbGRyZW4gYXMgYVxuICAvLyBwcm9wZXJ0eSwgaXQgbWF5IGJlIHRoZSBjcmVhdG9yIG9mIHRoZSBjaGlsZCB0aGF0J3MgcmVzcG9uc2libGUgZm9yXG4gIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cbiAgdmFyIGNoaWxkT3duZXIgPSAnJztcbiAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5fb3duZXIgJiYgZWxlbWVudC5fb3duZXIgIT09IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICAvLyBHaXZlIHRoZSBjb21wb25lbnQgdGhhdCBvcmlnaW5hbGx5IGNyZWF0ZWQgdGhpcyBjaGlsZC5cbiAgICBjaGlsZE93bmVyID0gJyBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSAnICsgZ2V0Q29tcG9uZW50TmFtZShlbGVtZW50Ll9vd25lcikgKyAnLic7XG4gIH1cblxuICBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCA9IGVsZW1lbnQ7XG4gIHtcbiAgICB3YXJuaW5nKGZhbHNlLCAnRWFjaCBjaGlsZCBpbiBhbiBhcnJheSBvciBpdGVyYXRvciBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmcta2V5cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4lcycsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIsIGdldFN0YWNrQWRkZW5kdW0oKSk7XG4gIH1cbiAgY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQgPSBudWxsO1xufVxuXG4vKipcbiAqIEVuc3VyZSB0aGF0IGV2ZXJ5IGVsZW1lbnQgZWl0aGVyIGlzIHBhc3NlZCBpbiBhIHN0YXRpYyBsb2NhdGlvbiwgaW4gYW5cbiAqIGFycmF5IHdpdGggYW4gZXhwbGljaXQga2V5cyBwcm9wZXJ0eSBkZWZpbmVkLCBvciBpbiBhbiBvYmplY3QgbGl0ZXJhbFxuICogd2l0aCB2YWxpZCBrZXkgcHJvcGVydHkuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0Tm9kZX0gbm9kZSBTdGF0aWNhbGx5IHBhc3NlZCBjaGlsZCBvZiBhbnkgdHlwZS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBub2RlJ3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAvLyBUaGlzIGVsZW1lbnQgd2FzIHBhc3NlZCBpbiBhIHZhbGlkIGxvY2F0aW9uLlxuICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAobm9kZSkge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihub2RlKTtcbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEVudHJ5IGl0ZXJhdG9ycyB1c2VkIHRvIHByb3ZpZGUgaW1wbGljaXQga2V5cyxcbiAgICAgIC8vIGJ1dCBub3cgd2UgcHJpbnQgYSBzZXBhcmF0ZSB3YXJuaW5nIGZvciB0aGVtIGxhdGVyLlxuICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobm9kZSk7XG4gICAgICAgIHZhciBzdGVwO1xuICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEdpdmVuIGFuIGVsZW1lbnQsIHZhbGlkYXRlIHRoYXQgaXRzIHByb3BzIGZvbGxvdyB0aGUgcHJvcFR5cGVzIGRlZmluaXRpb24sXG4gKiBwcm92aWRlZCBieSB0aGUgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KSB7XG4gIHZhciBjb21wb25lbnRDbGFzcyA9IGVsZW1lbnQudHlwZTtcbiAgaWYgKHR5cGVvZiBjb21wb25lbnRDbGFzcyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbmFtZSA9IGNvbXBvbmVudENsYXNzLmRpc3BsYXlOYW1lIHx8IGNvbXBvbmVudENsYXNzLm5hbWU7XG4gIHZhciBwcm9wVHlwZXMgPSBjb21wb25lbnRDbGFzcy5wcm9wVHlwZXM7XG4gIGlmIChwcm9wVHlwZXMpIHtcbiAgICBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGdldFN0YWNrQWRkZW5kdW0pO1xuICAgIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50ID0gbnVsbDtcbiAgfSBlbHNlIGlmIChjb21wb25lbnRDbGFzcy5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ0NvbXBvbmVudCAlcyBkZWNsYXJlZCBgUHJvcFR5cGVzYCBpbnN0ZWFkIG9mIGBwcm9wVHlwZXNgLiBEaWQgeW91IG1pc3NwZWxsIHRoZSBwcm9wZXJ0eSBhc3NpZ25tZW50PycsIG5hbWUgfHwgJ1Vua25vd24nKTtcbiAgfVxuICBpZiAodHlwZW9mIGNvbXBvbmVudENsYXNzLmdldERlZmF1bHRQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHdhcm5pbmcoY29tcG9uZW50Q2xhc3MuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkLCAnZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzICcgKyAnZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLicpO1xuICB9XG59XG5cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVGcmFnbWVudFByb3BzKGZyYWdtZW50KSB7XG4gIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50ID0gZnJhZ21lbnQ7XG5cbiAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gIHRyeSB7XG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgdmFyIGtleSA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICBpZiAoIVZBTElEX0ZSQUdNRU5UX1BST1BTLmhhcyhrZXkpKSB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJXMnLCBrZXksIGdldFN0YWNrQWRkZW5kdW0oKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yWydyZXR1cm4nXSkge1xuICAgICAgICBfaXRlcmF0b3JbJ3JldHVybiddKCk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZnJhZ21lbnQucmVmICE9PSBudWxsKSB7XG4gICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJXMnLCBnZXRTdGFja0FkZGVuZHVtKCkpO1xuICB9XG5cbiAgY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gIHZhciB2YWxpZFR5cGUgPSB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIHR5cGUgPT09ICdzeW1ib2wnIHx8IHR5cGVvZiB0eXBlID09PSAnbnVtYmVyJztcbiAgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgLy8gc3VjY2VlZCBhbmQgdGhlcmUgd2lsbCBsaWtlbHkgYmUgZXJyb3JzIGluIHJlbmRlci5cbiAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICB2YXIgaW5mbyA9ICcnO1xuICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiO1xuICAgIH1cblxuICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0ocHJvcHMpO1xuICAgIGlmIChzb3VyY2VJbmZvKSB7XG4gICAgICBpbmZvICs9IHNvdXJjZUluZm87XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZm8gKz0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG4gICAgfVxuXG4gICAgaW5mbyArPSBnZXRTdGFja0FkZGVuZHVtKCkgfHwgJyc7XG5cbiAgICB3YXJuaW5nKGZhbHNlLCAnUmVhY3QuY3JlYXRlRWxlbWVudDogdHlwZSBpcyBpbnZhbGlkIC0tIGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgJyArICdidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlICcgKyAnY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXMnLCB0eXBlID09IG51bGwgPyB0eXBlIDogdHlwZW9mIHR5cGUsIGluZm8pO1xuICB9XG5cbiAgdmFyIGVsZW1lbnQgPSBjcmVhdGVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgLy8gVGhlIHJlc3VsdCBjYW4gYmUgbnVsbGlzaCBpZiBhIG1vY2sgb3IgYSBjdXN0b20gZnVuY3Rpb24gaXMgdXNlZC5cbiAgLy8gVE9ETzogRHJvcCB0aGlzIHdoZW4gdGhlc2UgYXJlIG5vIGxvbmdlciBhbGxvd2VkIGFzIHRoZSB0eXBlIGFyZ3VtZW50LlxuICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gIC8vIFdlIGRvbid0IHdhbnQgZXhjZXB0aW9uIGJlaGF2aW9yIHRvIGRpZmZlciBiZXR3ZWVuIGRldiBhbmQgcHJvZC5cbiAgLy8gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlIHR5cGUgaXNcbiAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuICBpZiAodmFsaWRUeXBlKSB7XG4gICAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGFyZ3VtZW50c1tpXSwgdHlwZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3ltYm9sJyAmJiB0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgdmFsaWRhdGVGcmFnbWVudFByb3BzKGVsZW1lbnQpO1xuICB9IGVsc2Uge1xuICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZhY3RvcnlXaXRoVmFsaWRhdGlvbih0eXBlKSB7XG4gIHZhciB2YWxpZGF0ZWRGYWN0b3J5ID0gY3JlYXRlRWxlbWVudFdpdGhWYWxpZGF0aW9uLmJpbmQobnVsbCwgdHlwZSk7XG4gIC8vIExlZ2FjeSBob29rIFRPRE86IFdhcm4gaWYgdGhpcyBpcyBhY2Nlc3NlZFxuICB2YWxpZGF0ZWRGYWN0b3J5LnR5cGUgPSB0eXBlO1xuXG4gIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsaWRhdGVkRmFjdG9yeSwgJ3R5cGUnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICBsb3dQcmlvcml0eVdhcm5pbmckMShmYWxzZSwgJ0ZhY3RvcnkudHlwZSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdGhlIGNsYXNzIGRpcmVjdGx5ICcgKyAnYmVmb3JlIHBhc3NpbmcgaXQgdG8gY3JlYXRlRmFjdG9yeS4nKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICd0eXBlJywge1xuICAgICAgICAgIHZhbHVlOiB0eXBlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB2YWxpZGF0ZWRGYWN0b3J5O1xufVxuXG5mdW5jdGlvbiBjbG9uZUVsZW1lbnRXaXRoVmFsaWRhdGlvbihlbGVtZW50LCBwcm9wcywgY2hpbGRyZW4pIHtcbiAgdmFyIG5ld0VsZW1lbnQgPSBjbG9uZUVsZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YWxpZGF0ZUNoaWxkS2V5cyhhcmd1bWVudHNbaV0sIG5ld0VsZW1lbnQudHlwZSk7XG4gIH1cbiAgdmFsaWRhdGVQcm9wVHlwZXMobmV3RWxlbWVudCk7XG4gIHJldHVybiBuZXdFbGVtZW50O1xufVxuXG52YXIgUmVhY3QgPSB7XG4gIENoaWxkcmVuOiB7XG4gICAgbWFwOiBtYXBDaGlsZHJlbixcbiAgICBmb3JFYWNoOiBmb3JFYWNoQ2hpbGRyZW4sXG4gICAgY291bnQ6IGNvdW50Q2hpbGRyZW4sXG4gICAgdG9BcnJheTogdG9BcnJheSxcbiAgICBvbmx5OiBvbmx5Q2hpbGRcbiAgfSxcblxuICBDb21wb25lbnQ6IENvbXBvbmVudCxcbiAgUHVyZUNvbXBvbmVudDogUHVyZUNvbXBvbmVudCxcbiAgdW5zdGFibGVfQXN5bmNDb21wb25lbnQ6IEFzeW5jQ29tcG9uZW50LFxuXG4gIEZyYWdtZW50OiBSRUFDVF9GUkFHTUVOVF9UWVBFLFxuXG4gIGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbixcbiAgY2xvbmVFbGVtZW50OiBjbG9uZUVsZW1lbnRXaXRoVmFsaWRhdGlvbixcbiAgY3JlYXRlRmFjdG9yeTogY3JlYXRlRmFjdG9yeVdpdGhWYWxpZGF0aW9uLFxuICBpc1ZhbGlkRWxlbWVudDogaXNWYWxpZEVsZW1lbnQsXG5cbiAgdmVyc2lvbjogUmVhY3RWZXJzaW9uLFxuXG4gIF9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEOiB7XG4gICAgUmVhY3RDdXJyZW50T3duZXI6IFJlYWN0Q3VycmVudE93bmVyLFxuICAgIC8vIFVzZWQgYnkgcmVuZGVyZXJzIHRvIGF2b2lkIGJ1bmRsaW5nIG9iamVjdC1hc3NpZ24gdHdpY2UgaW4gVU1EIGJ1bmRsZXM6XG4gICAgYXNzaWduOiBfYXNzaWduXG4gIH1cbn07XG5cbntcbiAgX2Fzc2lnbihSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCwge1xuICAgIC8vIFRoZXNlIHNob3VsZCBub3QgYmUgaW5jbHVkZWQgaW4gcHJvZHVjdGlvbi5cbiAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lOiBSZWFjdERlYnVnQ3VycmVudEZyYW1lLFxuICAgIC8vIFNoaW0gZm9yIFJlYWN0IERPTSAxNi4wLjAgd2hpY2ggc3RpbGwgZGVzdHJ1Y3R1cmVkIChidXQgbm90IHVzZWQpIHRoaXMuXG4gICAgLy8gVE9ETzogcmVtb3ZlIGluIFJlYWN0IDE3LjAuXG4gICAgUmVhY3RDb21wb25lbnRUcmVlSG9vazoge31cbiAgfSk7XG59XG5cblxuXG52YXIgUmVhY3QkMiA9IE9iamVjdC5mcmVlemUoe1xuXHRkZWZhdWx0OiBSZWFjdFxufSk7XG5cbnZhciBSZWFjdCQzID0gKCBSZWFjdCQyICYmIFJlYWN0ICkgfHwgUmVhY3QkMjtcblxuLy8gVE9ETzogZGVjaWRlIG9uIHRoZSB0b3AtbGV2ZWwgZXhwb3J0IGZvcm0uXG4vLyBUaGlzIGlzIGhhY2t5IGJ1dCBtYWtlcyBpdCB3b3JrIHdpdGggYm90aCBSb2xsdXAgYW5kIEplc3QuXG52YXIgcmVhY3QgPSBSZWFjdCQzWydkZWZhdWx0J10gPyBSZWFjdCQzWydkZWZhdWx0J10gOiBSZWFjdCQzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlYWN0O1xuICB9KSgpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0L2Nqcy9yZWFjdC5kZXZlbG9wbWVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVzU2VjcmV0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzIiwiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNi4yLjBcbiAqIHJlYWN0LWRvbS5wcm9kdWN0aW9uLm1pbi5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbi8qXG4gTW9kZXJuaXpyIDMuMC4wcHJlIChDdXN0b20gQnVpbGQpIHwgTUlUXG4qL1xuJ3VzZSBzdHJpY3QnO3ZhciBhYT1yZXF1aXJlKFwicmVhY3RcIiksbD1yZXF1aXJlKFwiZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnRcIiksQj1yZXF1aXJlKFwib2JqZWN0LWFzc2lnblwiKSxDPXJlcXVpcmUoXCJmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uXCIpLGJhPXJlcXVpcmUoXCJmYmpzL2xpYi9FdmVudExpc3RlbmVyXCIpLGRhPXJlcXVpcmUoXCJmYmpzL2xpYi9nZXRBY3RpdmVFbGVtZW50XCIpLGVhPXJlcXVpcmUoXCJmYmpzL2xpYi9zaGFsbG93RXF1YWxcIiksZmE9cmVxdWlyZShcImZianMvbGliL2NvbnRhaW5zTm9kZVwiKSxpYT1yZXF1aXJlKFwiZmJqcy9saWIvZm9jdXNOb2RlXCIpLEQ9cmVxdWlyZShcImZianMvbGliL2VtcHR5T2JqZWN0XCIpO1xuZnVuY3Rpb24gRShhKXtmb3IodmFyIGI9YXJndW1lbnRzLmxlbmd0aC0xLGM9XCJNaW5pZmllZCBSZWFjdCBlcnJvciAjXCIrYStcIjsgdmlzaXQgaHR0cDovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL2Vycm9yLWRlY29kZXIuaHRtbD9pbnZhcmlhbnRcXHgzZFwiK2EsZD0wO2Q8YjtkKyspYys9XCJcXHgyNmFyZ3NbXVxceDNkXCIrZW5jb2RlVVJJQ29tcG9uZW50KGFyZ3VtZW50c1tkKzFdKTtiPUVycm9yKGMrXCIgZm9yIHRoZSBmdWxsIG1lc3NhZ2Ugb3IgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50IGZvciBmdWxsIGVycm9ycyBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLlwiKTtiLm5hbWU9XCJJbnZhcmlhbnQgVmlvbGF0aW9uXCI7Yi5mcmFtZXNUb1BvcD0xO3Rocm93IGI7fWFhP3ZvaWQgMDpFKFwiMjI3XCIpO1xudmFyIG9hPXtjaGlsZHJlbjohMCxkYW5nZXJvdXNseVNldElubmVySFRNTDohMCxkZWZhdWx0VmFsdWU6ITAsZGVmYXVsdENoZWNrZWQ6ITAsaW5uZXJIVE1MOiEwLHN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZzohMCxzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmc6ITAsc3R5bGU6ITB9O2Z1bmN0aW9uIHBhKGEsYil7cmV0dXJuKGEmYik9PT1ifVxudmFyIHRhPXtNVVNUX1VTRV9QUk9QRVJUWToxLEhBU19CT09MRUFOX1ZBTFVFOjQsSEFTX05VTUVSSUNfVkFMVUU6OCxIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRToyNCxIQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFOjMyLEhBU19TVFJJTkdfQk9PTEVBTl9WQUxVRTo2NCxpbmplY3RET01Qcm9wZXJ0eUNvbmZpZzpmdW5jdGlvbihhKXt2YXIgYj10YSxjPWEuUHJvcGVydGllc3x8e30sZD1hLkRPTUF0dHJpYnV0ZU5hbWVzcGFjZXN8fHt9LGU9YS5ET01BdHRyaWJ1dGVOYW1lc3x8e307YT1hLkRPTU11dGF0aW9uTWV0aG9kc3x8e307Zm9yKHZhciBmIGluIGMpe3VhLmhhc093blByb3BlcnR5KGYpP0UoXCI0OFwiLGYpOnZvaWQgMDt2YXIgZz1mLnRvTG93ZXJDYXNlKCksaD1jW2ZdO2c9e2F0dHJpYnV0ZU5hbWU6ZyxhdHRyaWJ1dGVOYW1lc3BhY2U6bnVsbCxwcm9wZXJ0eU5hbWU6ZixtdXRhdGlvbk1ldGhvZDpudWxsLG11c3RVc2VQcm9wZXJ0eTpwYShoLGIuTVVTVF9VU0VfUFJPUEVSVFkpLFxuaGFzQm9vbGVhblZhbHVlOnBhKGgsYi5IQVNfQk9PTEVBTl9WQUxVRSksaGFzTnVtZXJpY1ZhbHVlOnBhKGgsYi5IQVNfTlVNRVJJQ19WQUxVRSksaGFzUG9zaXRpdmVOdW1lcmljVmFsdWU6cGEoaCxiLkhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFKSxoYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlOnBhKGgsYi5IQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFKSxoYXNTdHJpbmdCb29sZWFuVmFsdWU6cGEoaCxiLkhBU19TVFJJTkdfQk9PTEVBTl9WQUxVRSl9OzE+PWcuaGFzQm9vbGVhblZhbHVlK2cuaGFzTnVtZXJpY1ZhbHVlK2cuaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZT92b2lkIDA6RShcIjUwXCIsZik7ZS5oYXNPd25Qcm9wZXJ0eShmKSYmKGcuYXR0cmlidXRlTmFtZT1lW2ZdKTtkLmhhc093blByb3BlcnR5KGYpJiYoZy5hdHRyaWJ1dGVOYW1lc3BhY2U9ZFtmXSk7YS5oYXNPd25Qcm9wZXJ0eShmKSYmKGcubXV0YXRpb25NZXRob2Q9YVtmXSk7dWFbZl09Z319fSx1YT17fTtcbmZ1bmN0aW9uIHZhKGEsYil7aWYob2EuaGFzT3duUHJvcGVydHkoYSl8fDI8YS5sZW5ndGgmJihcIm9cIj09PWFbMF18fFwiT1wiPT09YVswXSkmJihcIm5cIj09PWFbMV18fFwiTlwiPT09YVsxXSkpcmV0dXJuITE7aWYobnVsbD09PWIpcmV0dXJuITA7c3dpdGNoKHR5cGVvZiBiKXtjYXNlIFwiYm9vbGVhblwiOnJldHVybiBvYS5oYXNPd25Qcm9wZXJ0eShhKT9hPSEwOihiPXdhKGEpKT9hPWIuaGFzQm9vbGVhblZhbHVlfHxiLmhhc1N0cmluZ0Jvb2xlYW5WYWx1ZXx8Yi5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlOihhPWEudG9Mb3dlckNhc2UoKS5zbGljZSgwLDUpLGE9XCJkYXRhLVwiPT09YXx8XCJhcmlhLVwiPT09YSksYTtjYXNlIFwidW5kZWZpbmVkXCI6Y2FzZSBcIm51bWJlclwiOmNhc2UgXCJzdHJpbmdcIjpjYXNlIFwib2JqZWN0XCI6cmV0dXJuITA7ZGVmYXVsdDpyZXR1cm4hMX19ZnVuY3Rpb24gd2EoYSl7cmV0dXJuIHVhLmhhc093blByb3BlcnR5KGEpP3VhW2FdOm51bGx9XG52YXIgeGE9dGEseWE9eGEuTVVTVF9VU0VfUFJPUEVSVFksSz14YS5IQVNfQk9PTEVBTl9WQUxVRSx6YT14YS5IQVNfTlVNRVJJQ19WQUxVRSxBYT14YS5IQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSxCYT14YS5IQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFLENhPXhhLkhBU19TVFJJTkdfQk9PTEVBTl9WQUxVRSxEYT17UHJvcGVydGllczp7YWxsb3dGdWxsU2NyZWVuOkssYXN5bmM6SyxhdXRvRm9jdXM6SyxhdXRvUGxheTpLLGNhcHR1cmU6QmEsY2hlY2tlZDp5YXxLLGNvbHM6QWEsY29udGVudEVkaXRhYmxlOkNhLGNvbnRyb2xzOkssXCJkZWZhdWx0XCI6SyxkZWZlcjpLLGRpc2FibGVkOkssZG93bmxvYWQ6QmEsZHJhZ2dhYmxlOkNhLGZvcm1Ob1ZhbGlkYXRlOkssaGlkZGVuOkssbG9vcDpLLG11bHRpcGxlOnlhfEssbXV0ZWQ6eWF8Syxub1ZhbGlkYXRlOkssb3BlbjpLLHBsYXlzSW5saW5lOksscmVhZE9ubHk6SyxyZXF1aXJlZDpLLHJldmVyc2VkOksscm93czpBYSxyb3dTcGFuOnphLFxuc2NvcGVkOkssc2VhbWxlc3M6SyxzZWxlY3RlZDp5YXxLLHNpemU6QWEsc3RhcnQ6emEsc3BhbjpBYSxzcGVsbENoZWNrOkNhLHN0eWxlOjAsdGFiSW5kZXg6MCxpdGVtU2NvcGU6SyxhY2NlcHRDaGFyc2V0OjAsY2xhc3NOYW1lOjAsaHRtbEZvcjowLGh0dHBFcXVpdjowLHZhbHVlOkNhfSxET01BdHRyaWJ1dGVOYW1lczp7YWNjZXB0Q2hhcnNldDpcImFjY2VwdC1jaGFyc2V0XCIsY2xhc3NOYW1lOlwiY2xhc3NcIixodG1sRm9yOlwiZm9yXCIsaHR0cEVxdWl2OlwiaHR0cC1lcXVpdlwifSxET01NdXRhdGlvbk1ldGhvZHM6e3ZhbHVlOmZ1bmN0aW9uKGEsYil7aWYobnVsbD09YilyZXR1cm4gYS5yZW1vdmVBdHRyaWJ1dGUoXCJ2YWx1ZVwiKTtcIm51bWJlclwiIT09YS50eXBlfHwhMT09PWEuaGFzQXR0cmlidXRlKFwidmFsdWVcIik/YS5zZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiLFwiXCIrYik6YS52YWxpZGl0eSYmIWEudmFsaWRpdHkuYmFkSW5wdXQmJmEub3duZXJEb2N1bWVudC5hY3RpdmVFbGVtZW50IT09YSYmXG5hLnNldEF0dHJpYnV0ZShcInZhbHVlXCIsXCJcIitiKX19fSxFYT14YS5IQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUUsTT17eGxpbms6XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIseG1sOlwiaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlXCJ9LEdhPXtQcm9wZXJ0aWVzOnthdXRvUmV2ZXJzZTpFYSxleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkOkVhLHByZXNlcnZlQWxwaGE6RWF9LERPTUF0dHJpYnV0ZU5hbWVzOnthdXRvUmV2ZXJzZTpcImF1dG9SZXZlcnNlXCIsZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZDpcImV4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWRcIixwcmVzZXJ2ZUFscGhhOlwicHJlc2VydmVBbHBoYVwifSxET01BdHRyaWJ1dGVOYW1lc3BhY2VzOnt4bGlua0FjdHVhdGU6TS54bGluayx4bGlua0FyY3JvbGU6TS54bGluayx4bGlua0hyZWY6TS54bGluayx4bGlua1JvbGU6TS54bGluayx4bGlua1Nob3c6TS54bGluayx4bGlua1RpdGxlOk0ueGxpbmsseGxpbmtUeXBlOk0ueGxpbmssXG54bWxCYXNlOk0ueG1sLHhtbExhbmc6TS54bWwseG1sU3BhY2U6TS54bWx9fSxIYT0vW1xcLVxcOl0oW2Etel0pL2c7ZnVuY3Rpb24gSWEoYSl7cmV0dXJuIGFbMV0udG9VcHBlckNhc2UoKX1cblwiYWNjZW50LWhlaWdodCBhbGlnbm1lbnQtYmFzZWxpbmUgYXJhYmljLWZvcm0gYmFzZWxpbmUtc2hpZnQgY2FwLWhlaWdodCBjbGlwLXBhdGggY2xpcC1ydWxlIGNvbG9yLWludGVycG9sYXRpb24gY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzIGNvbG9yLXByb2ZpbGUgY29sb3ItcmVuZGVyaW5nIGRvbWluYW50LWJhc2VsaW5lIGVuYWJsZS1iYWNrZ3JvdW5kIGZpbGwtb3BhY2l0eSBmaWxsLXJ1bGUgZmxvb2QtY29sb3IgZmxvb2Qtb3BhY2l0eSBmb250LWZhbWlseSBmb250LXNpemUgZm9udC1zaXplLWFkanVzdCBmb250LXN0cmV0Y2ggZm9udC1zdHlsZSBmb250LXZhcmlhbnQgZm9udC13ZWlnaHQgZ2x5cGgtbmFtZSBnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsIGdseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsIGhvcml6LWFkdi14IGhvcml6LW9yaWdpbi14IGltYWdlLXJlbmRlcmluZyBsZXR0ZXItc3BhY2luZyBsaWdodGluZy1jb2xvciBtYXJrZXItZW5kIG1hcmtlci1taWQgbWFya2VyLXN0YXJ0IG92ZXJsaW5lLXBvc2l0aW9uIG92ZXJsaW5lLXRoaWNrbmVzcyBwYWludC1vcmRlciBwYW5vc2UtMSBwb2ludGVyLWV2ZW50cyByZW5kZXJpbmctaW50ZW50IHNoYXBlLXJlbmRlcmluZyBzdG9wLWNvbG9yIHN0b3Atb3BhY2l0eSBzdHJpa2V0aHJvdWdoLXBvc2l0aW9uIHN0cmlrZXRocm91Z2gtdGhpY2tuZXNzIHN0cm9rZS1kYXNoYXJyYXkgc3Ryb2tlLWRhc2hvZmZzZXQgc3Ryb2tlLWxpbmVjYXAgc3Ryb2tlLWxpbmVqb2luIHN0cm9rZS1taXRlcmxpbWl0IHN0cm9rZS1vcGFjaXR5IHN0cm9rZS13aWR0aCB0ZXh0LWFuY2hvciB0ZXh0LWRlY29yYXRpb24gdGV4dC1yZW5kZXJpbmcgdW5kZXJsaW5lLXBvc2l0aW9uIHVuZGVybGluZS10aGlja25lc3MgdW5pY29kZS1iaWRpIHVuaWNvZGUtcmFuZ2UgdW5pdHMtcGVyLWVtIHYtYWxwaGFiZXRpYyB2LWhhbmdpbmcgdi1pZGVvZ3JhcGhpYyB2LW1hdGhlbWF0aWNhbCB2ZWN0b3ItZWZmZWN0IHZlcnQtYWR2LXkgdmVydC1vcmlnaW4teCB2ZXJ0LW9yaWdpbi15IHdvcmQtc3BhY2luZyB3cml0aW5nLW1vZGUgeC1oZWlnaHQgeGxpbms6YWN0dWF0ZSB4bGluazphcmNyb2xlIHhsaW5rOmhyZWYgeGxpbms6cm9sZSB4bGluazpzaG93IHhsaW5rOnRpdGxlIHhsaW5rOnR5cGUgeG1sOmJhc2UgeG1sbnM6eGxpbmsgeG1sOmxhbmcgeG1sOnNwYWNlXCIuc3BsaXQoXCIgXCIpLmZvckVhY2goZnVuY3Rpb24oYSl7dmFyIGI9YS5yZXBsYWNlKEhhLFxuSWEpO0dhLlByb3BlcnRpZXNbYl09MDtHYS5ET01BdHRyaWJ1dGVOYW1lc1tiXT1hfSk7eGEuaW5qZWN0RE9NUHJvcGVydHlDb25maWcoRGEpO3hhLmluamVjdERPTVByb3BlcnR5Q29uZmlnKEdhKTtcbnZhciBQPXtfY2F1Z2h0RXJyb3I6bnVsbCxfaGFzQ2F1Z2h0RXJyb3I6ITEsX3JldGhyb3dFcnJvcjpudWxsLF9oYXNSZXRocm93RXJyb3I6ITEsaW5qZWN0aW9uOntpbmplY3RFcnJvclV0aWxzOmZ1bmN0aW9uKGEpe1wiZnVuY3Rpb25cIiE9PXR5cGVvZiBhLmludm9rZUd1YXJkZWRDYWxsYmFjaz9FKFwiMTk3XCIpOnZvaWQgMDtKYT1hLmludm9rZUd1YXJkZWRDYWxsYmFja319LGludm9rZUd1YXJkZWRDYWxsYmFjazpmdW5jdGlvbihhLGIsYyxkLGUsZixnLGgsayl7SmEuYXBwbHkoUCxhcmd1bWVudHMpfSxpbnZva2VHdWFyZGVkQ2FsbGJhY2tBbmRDYXRjaEZpcnN0RXJyb3I6ZnVuY3Rpb24oYSxiLGMsZCxlLGYsZyxoLGspe1AuaW52b2tlR3VhcmRlZENhbGxiYWNrLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtpZihQLmhhc0NhdWdodEVycm9yKCkpe3ZhciBxPVAuY2xlYXJDYXVnaHRFcnJvcigpO1AuX2hhc1JldGhyb3dFcnJvcnx8KFAuX2hhc1JldGhyb3dFcnJvcj0hMCxQLl9yZXRocm93RXJyb3I9XG5xKX19LHJldGhyb3dDYXVnaHRFcnJvcjpmdW5jdGlvbigpe3JldHVybiBLYS5hcHBseShQLGFyZ3VtZW50cyl9LGhhc0NhdWdodEVycm9yOmZ1bmN0aW9uKCl7cmV0dXJuIFAuX2hhc0NhdWdodEVycm9yfSxjbGVhckNhdWdodEVycm9yOmZ1bmN0aW9uKCl7aWYoUC5faGFzQ2F1Z2h0RXJyb3Ipe3ZhciBhPVAuX2NhdWdodEVycm9yO1AuX2NhdWdodEVycm9yPW51bGw7UC5faGFzQ2F1Z2h0RXJyb3I9ITE7cmV0dXJuIGF9RShcIjE5OFwiKX19O2Z1bmN0aW9uIEphKGEsYixjLGQsZSxmLGcsaCxrKXtQLl9oYXNDYXVnaHRFcnJvcj0hMTtQLl9jYXVnaHRFcnJvcj1udWxsO3ZhciBxPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywzKTt0cnl7Yi5hcHBseShjLHEpfWNhdGNoKHYpe1AuX2NhdWdodEVycm9yPXYsUC5faGFzQ2F1Z2h0RXJyb3I9ITB9fVxuZnVuY3Rpb24gS2EoKXtpZihQLl9oYXNSZXRocm93RXJyb3Ipe3ZhciBhPVAuX3JldGhyb3dFcnJvcjtQLl9yZXRocm93RXJyb3I9bnVsbDtQLl9oYXNSZXRocm93RXJyb3I9ITE7dGhyb3cgYTt9fXZhciBMYT1udWxsLE1hPXt9O1xuZnVuY3Rpb24gTmEoKXtpZihMYSlmb3IodmFyIGEgaW4gTWEpe3ZhciBiPU1hW2FdLGM9TGEuaW5kZXhPZihhKTstMTxjP3ZvaWQgMDpFKFwiOTZcIixhKTtpZighT2FbY10pe2IuZXh0cmFjdEV2ZW50cz92b2lkIDA6RShcIjk3XCIsYSk7T2FbY109YjtjPWIuZXZlbnRUeXBlcztmb3IodmFyIGQgaW4gYyl7dmFyIGU9dm9pZCAwO3ZhciBmPWNbZF0sZz1iLGg9ZDtQYS5oYXNPd25Qcm9wZXJ0eShoKT9FKFwiOTlcIixoKTp2b2lkIDA7UGFbaF09Zjt2YXIgaz1mLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzO2lmKGspe2ZvcihlIGluIGspay5oYXNPd25Qcm9wZXJ0eShlKSYmUWEoa1tlXSxnLGgpO2U9ITB9ZWxzZSBmLnJlZ2lzdHJhdGlvbk5hbWU/KFFhKGYucmVnaXN0cmF0aW9uTmFtZSxnLGgpLGU9ITApOmU9ITE7ZT92b2lkIDA6RShcIjk4XCIsZCxhKX19fX1cbmZ1bmN0aW9uIFFhKGEsYixjKXtSYVthXT9FKFwiMTAwXCIsYSk6dm9pZCAwO1JhW2FdPWI7U2FbYV09Yi5ldmVudFR5cGVzW2NdLmRlcGVuZGVuY2llc312YXIgT2E9W10sUGE9e30sUmE9e30sU2E9e307ZnVuY3Rpb24gVGEoYSl7TGE/RShcIjEwMVwiKTp2b2lkIDA7TGE9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYSk7TmEoKX1mdW5jdGlvbiBVYShhKXt2YXIgYj0hMSxjO2ZvcihjIGluIGEpaWYoYS5oYXNPd25Qcm9wZXJ0eShjKSl7dmFyIGQ9YVtjXTtNYS5oYXNPd25Qcm9wZXJ0eShjKSYmTWFbY109PT1kfHwoTWFbY10/RShcIjEwMlwiLGMpOnZvaWQgMCxNYVtjXT1kLGI9ITApfWImJk5hKCl9XG52YXIgVmE9T2JqZWN0LmZyZWV6ZSh7cGx1Z2luczpPYSxldmVudE5hbWVEaXNwYXRjaENvbmZpZ3M6UGEscmVnaXN0cmF0aW9uTmFtZU1vZHVsZXM6UmEscmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llczpTYSxwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzOm51bGwsaW5qZWN0RXZlbnRQbHVnaW5PcmRlcjpUYSxpbmplY3RFdmVudFBsdWdpbnNCeU5hbWU6VWF9KSxXYT1udWxsLFhhPW51bGwsWWE9bnVsbDtmdW5jdGlvbiBaYShhLGIsYyxkKXtiPWEudHlwZXx8XCJ1bmtub3duLWV2ZW50XCI7YS5jdXJyZW50VGFyZ2V0PVlhKGQpO1AuaW52b2tlR3VhcmRlZENhbGxiYWNrQW5kQ2F0Y2hGaXJzdEVycm9yKGIsYyx2b2lkIDAsYSk7YS5jdXJyZW50VGFyZ2V0PW51bGx9XG5mdW5jdGlvbiAkYShhLGIpe251bGw9PWI/RShcIjMwXCIpOnZvaWQgMDtpZihudWxsPT1hKXJldHVybiBiO2lmKEFycmF5LmlzQXJyYXkoYSkpe2lmKEFycmF5LmlzQXJyYXkoYikpcmV0dXJuIGEucHVzaC5hcHBseShhLGIpLGE7YS5wdXNoKGIpO3JldHVybiBhfXJldHVybiBBcnJheS5pc0FycmF5KGIpP1thXS5jb25jYXQoYik6W2EsYl19ZnVuY3Rpb24gYWIoYSxiLGMpe0FycmF5LmlzQXJyYXkoYSk/YS5mb3JFYWNoKGIsYyk6YSYmYi5jYWxsKGMsYSl9dmFyIGJiPW51bGw7XG5mdW5jdGlvbiBjYihhLGIpe2lmKGEpe3ZhciBjPWEuX2Rpc3BhdGNoTGlzdGVuZXJzLGQ9YS5fZGlzcGF0Y2hJbnN0YW5jZXM7aWYoQXJyYXkuaXNBcnJheShjKSlmb3IodmFyIGU9MDtlPGMubGVuZ3RoJiYhYS5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpO2UrKylaYShhLGIsY1tlXSxkW2VdKTtlbHNlIGMmJlphKGEsYixjLGQpO2EuX2Rpc3BhdGNoTGlzdGVuZXJzPW51bGw7YS5fZGlzcGF0Y2hJbnN0YW5jZXM9bnVsbDthLmlzUGVyc2lzdGVudCgpfHxhLmNvbnN0cnVjdG9yLnJlbGVhc2UoYSl9fWZ1bmN0aW9uIGRiKGEpe3JldHVybiBjYihhLCEwKX1mdW5jdGlvbiBnYihhKXtyZXR1cm4gY2IoYSwhMSl9dmFyIGhiPXtpbmplY3RFdmVudFBsdWdpbk9yZGVyOlRhLGluamVjdEV2ZW50UGx1Z2luc0J5TmFtZTpVYX07XG5mdW5jdGlvbiBpYihhLGIpe3ZhciBjPWEuc3RhdGVOb2RlO2lmKCFjKXJldHVybiBudWxsO3ZhciBkPVdhKGMpO2lmKCFkKXJldHVybiBudWxsO2M9ZFtiXTthOnN3aXRjaChiKXtjYXNlIFwib25DbGlja1wiOmNhc2UgXCJvbkNsaWNrQ2FwdHVyZVwiOmNhc2UgXCJvbkRvdWJsZUNsaWNrXCI6Y2FzZSBcIm9uRG91YmxlQ2xpY2tDYXB0dXJlXCI6Y2FzZSBcIm9uTW91c2VEb3duXCI6Y2FzZSBcIm9uTW91c2VEb3duQ2FwdHVyZVwiOmNhc2UgXCJvbk1vdXNlTW92ZVwiOmNhc2UgXCJvbk1vdXNlTW92ZUNhcHR1cmVcIjpjYXNlIFwib25Nb3VzZVVwXCI6Y2FzZSBcIm9uTW91c2VVcENhcHR1cmVcIjooZD0hZC5kaXNhYmxlZCl8fChhPWEudHlwZSxkPSEoXCJidXR0b25cIj09PWF8fFwiaW5wdXRcIj09PWF8fFwic2VsZWN0XCI9PT1hfHxcInRleHRhcmVhXCI9PT1hKSk7YT0hZDticmVhayBhO2RlZmF1bHQ6YT0hMX1pZihhKXJldHVybiBudWxsO2MmJlwiZnVuY3Rpb25cIiE9PXR5cGVvZiBjP0UoXCIyMzFcIixiLHR5cGVvZiBjKTp2b2lkIDA7XG5yZXR1cm4gY31mdW5jdGlvbiBqYihhLGIsYyxkKXtmb3IodmFyIGUsZj0wO2Y8T2EubGVuZ3RoO2YrKyl7dmFyIGc9T2FbZl07ZyYmKGc9Zy5leHRyYWN0RXZlbnRzKGEsYixjLGQpKSYmKGU9JGEoZSxnKSl9cmV0dXJuIGV9ZnVuY3Rpb24ga2IoYSl7YSYmKGJiPSRhKGJiLGEpKX1mdW5jdGlvbiBsYihhKXt2YXIgYj1iYjtiYj1udWxsO2ImJihhP2FiKGIsZGIpOmFiKGIsZ2IpLGJiP0UoXCI5NVwiKTp2b2lkIDAsUC5yZXRocm93Q2F1Z2h0RXJyb3IoKSl9dmFyIG1iPU9iamVjdC5mcmVlemUoe2luamVjdGlvbjpoYixnZXRMaXN0ZW5lcjppYixleHRyYWN0RXZlbnRzOmpiLGVucXVldWVFdmVudHM6a2IscHJvY2Vzc0V2ZW50UXVldWU6bGJ9KSxuYj1NYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKSxRPVwiX19yZWFjdEludGVybmFsSW5zdGFuY2UkXCIrbmIsb2I9XCJfX3JlYWN0RXZlbnRIYW5kbGVycyRcIituYjtcbmZ1bmN0aW9uIHBiKGEpe2lmKGFbUV0pcmV0dXJuIGFbUV07Zm9yKHZhciBiPVtdOyFhW1FdOylpZihiLnB1c2goYSksYS5wYXJlbnROb2RlKWE9YS5wYXJlbnROb2RlO2Vsc2UgcmV0dXJuIG51bGw7dmFyIGM9dm9pZCAwLGQ9YVtRXTtpZig1PT09ZC50YWd8fDY9PT1kLnRhZylyZXR1cm4gZDtmb3IoO2EmJihkPWFbUV0pO2E9Yi5wb3AoKSljPWQ7cmV0dXJuIGN9ZnVuY3Rpb24gcWIoYSl7aWYoNT09PWEudGFnfHw2PT09YS50YWcpcmV0dXJuIGEuc3RhdGVOb2RlO0UoXCIzM1wiKX1mdW5jdGlvbiByYihhKXtyZXR1cm4gYVtvYl18fG51bGx9XG52YXIgc2I9T2JqZWN0LmZyZWV6ZSh7cHJlY2FjaGVGaWJlck5vZGU6ZnVuY3Rpb24oYSxiKXtiW1FdPWF9LGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlOnBiLGdldEluc3RhbmNlRnJvbU5vZGU6ZnVuY3Rpb24oYSl7YT1hW1FdO3JldHVybiFhfHw1IT09YS50YWcmJjYhPT1hLnRhZz9udWxsOmF9LGdldE5vZGVGcm9tSW5zdGFuY2U6cWIsZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZTpyYix1cGRhdGVGaWJlclByb3BzOmZ1bmN0aW9uKGEsYil7YVtvYl09Yn19KTtmdW5jdGlvbiB0YihhKXtkbyBhPWFbXCJyZXR1cm5cIl07d2hpbGUoYSYmNSE9PWEudGFnKTtyZXR1cm4gYT9hOm51bGx9ZnVuY3Rpb24gdWIoYSxiLGMpe2Zvcih2YXIgZD1bXTthOylkLnB1c2goYSksYT10YihhKTtmb3IoYT1kLmxlbmd0aDswPGEtLTspYihkW2FdLFwiY2FwdHVyZWRcIixjKTtmb3IoYT0wO2E8ZC5sZW5ndGg7YSsrKWIoZFthXSxcImJ1YmJsZWRcIixjKX1cbmZ1bmN0aW9uIHZiKGEsYixjKXtpZihiPWliKGEsYy5kaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lc1tiXSkpYy5fZGlzcGF0Y2hMaXN0ZW5lcnM9JGEoYy5fZGlzcGF0Y2hMaXN0ZW5lcnMsYiksYy5fZGlzcGF0Y2hJbnN0YW5jZXM9JGEoYy5fZGlzcGF0Y2hJbnN0YW5jZXMsYSl9ZnVuY3Rpb24gd2IoYSl7YSYmYS5kaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcyYmdWIoYS5fdGFyZ2V0SW5zdCx2YixhKX1mdW5jdGlvbiB4YihhKXtpZihhJiZhLmRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKXt2YXIgYj1hLl90YXJnZXRJbnN0O2I9Yj90YihiKTpudWxsO3ViKGIsdmIsYSl9fVxuZnVuY3Rpb24geWIoYSxiLGMpe2EmJmMmJmMuZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSYmKGI9aWIoYSxjLmRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUpKSYmKGMuX2Rpc3BhdGNoTGlzdGVuZXJzPSRhKGMuX2Rpc3BhdGNoTGlzdGVuZXJzLGIpLGMuX2Rpc3BhdGNoSW5zdGFuY2VzPSRhKGMuX2Rpc3BhdGNoSW5zdGFuY2VzLGEpKX1mdW5jdGlvbiB6YihhKXthJiZhLmRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUmJnliKGEuX3RhcmdldEluc3QsbnVsbCxhKX1mdW5jdGlvbiBBYihhKXthYihhLHdiKX1cbmZ1bmN0aW9uIEJiKGEsYixjLGQpe2lmKGMmJmQpYTp7dmFyIGU9Yztmb3IodmFyIGY9ZCxnPTAsaD1lO2g7aD10YihoKSlnKys7aD0wO2Zvcih2YXIgaz1mO2s7az10YihrKSloKys7Zm9yKDswPGctaDspZT10YihlKSxnLS07Zm9yKDswPGgtZzspZj10YihmKSxoLS07Zm9yKDtnLS07KXtpZihlPT09Znx8ZT09PWYuYWx0ZXJuYXRlKWJyZWFrIGE7ZT10YihlKTtmPXRiKGYpfWU9bnVsbH1lbHNlIGU9bnVsbDtmPWU7Zm9yKGU9W107YyYmYyE9PWY7KXtnPWMuYWx0ZXJuYXRlO2lmKG51bGwhPT1nJiZnPT09ZilicmVhaztlLnB1c2goYyk7Yz10YihjKX1mb3IoYz1bXTtkJiZkIT09Zjspe2c9ZC5hbHRlcm5hdGU7aWYobnVsbCE9PWcmJmc9PT1mKWJyZWFrO2MucHVzaChkKTtkPXRiKGQpfWZvcihkPTA7ZDxlLmxlbmd0aDtkKyspeWIoZVtkXSxcImJ1YmJsZWRcIixhKTtmb3IoYT1jLmxlbmd0aDswPGEtLTspeWIoY1thXSxcImNhcHR1cmVkXCIsYil9XG52YXIgQ2I9T2JqZWN0LmZyZWV6ZSh7YWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlczpBYixhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2tpcFRhcmdldDpmdW5jdGlvbihhKXthYihhLHhiKX0sYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzOkJiLGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzOmZ1bmN0aW9uKGEpe2FiKGEsemIpfX0pLERiPW51bGw7ZnVuY3Rpb24gRWIoKXshRGImJmwuY2FuVXNlRE9NJiYoRGI9XCJ0ZXh0Q29udGVudFwiaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50P1widGV4dENvbnRlbnRcIjpcImlubmVyVGV4dFwiKTtyZXR1cm4gRGJ9dmFyIFM9e19yb290Om51bGwsX3N0YXJ0VGV4dDpudWxsLF9mYWxsYmFja1RleHQ6bnVsbH07XG5mdW5jdGlvbiBGYigpe2lmKFMuX2ZhbGxiYWNrVGV4dClyZXR1cm4gUy5fZmFsbGJhY2tUZXh0O3ZhciBhLGI9Uy5fc3RhcnRUZXh0LGM9Yi5sZW5ndGgsZCxlPUdiKCksZj1lLmxlbmd0aDtmb3IoYT0wO2E8YyYmYlthXT09PWVbYV07YSsrKTt2YXIgZz1jLWE7Zm9yKGQ9MTtkPD1nJiZiW2MtZF09PT1lW2YtZF07ZCsrKTtTLl9mYWxsYmFja1RleHQ9ZS5zbGljZShhLDE8ZD8xLWQ6dm9pZCAwKTtyZXR1cm4gUy5fZmFsbGJhY2tUZXh0fWZ1bmN0aW9uIEdiKCl7cmV0dXJuXCJ2YWx1ZVwiaW4gUy5fcm9vdD9TLl9yb290LnZhbHVlOlMuX3Jvb3RbRWIoKV19XG52YXIgSGI9XCJkaXNwYXRjaENvbmZpZyBfdGFyZ2V0SW5zdCBuYXRpdmVFdmVudCBpc0RlZmF1bHRQcmV2ZW50ZWQgaXNQcm9wYWdhdGlvblN0b3BwZWQgX2Rpc3BhdGNoTGlzdGVuZXJzIF9kaXNwYXRjaEluc3RhbmNlc1wiLnNwbGl0KFwiIFwiKSxJYj17dHlwZTpudWxsLHRhcmdldDpudWxsLGN1cnJlbnRUYXJnZXQ6Qy50aGF0UmV0dXJuc051bGwsZXZlbnRQaGFzZTpudWxsLGJ1YmJsZXM6bnVsbCxjYW5jZWxhYmxlOm51bGwsdGltZVN0YW1wOmZ1bmN0aW9uKGEpe3JldHVybiBhLnRpbWVTdGFtcHx8RGF0ZS5ub3coKX0sZGVmYXVsdFByZXZlbnRlZDpudWxsLGlzVHJ1c3RlZDpudWxsfTtcbmZ1bmN0aW9uIFQoYSxiLGMsZCl7dGhpcy5kaXNwYXRjaENvbmZpZz1hO3RoaXMuX3RhcmdldEluc3Q9Yjt0aGlzLm5hdGl2ZUV2ZW50PWM7YT10aGlzLmNvbnN0cnVjdG9yLkludGVyZmFjZTtmb3IodmFyIGUgaW4gYSlhLmhhc093blByb3BlcnR5KGUpJiYoKGI9YVtlXSk/dGhpc1tlXT1iKGMpOlwidGFyZ2V0XCI9PT1lP3RoaXMudGFyZ2V0PWQ6dGhpc1tlXT1jW2VdKTt0aGlzLmlzRGVmYXVsdFByZXZlbnRlZD0obnVsbCE9Yy5kZWZhdWx0UHJldmVudGVkP2MuZGVmYXVsdFByZXZlbnRlZDohMT09PWMucmV0dXJuVmFsdWUpP0MudGhhdFJldHVybnNUcnVlOkMudGhhdFJldHVybnNGYWxzZTt0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkPUMudGhhdFJldHVybnNGYWxzZTtyZXR1cm4gdGhpc31cbkIoVC5wcm90b3R5cGUse3ByZXZlbnREZWZhdWx0OmZ1bmN0aW9uKCl7dGhpcy5kZWZhdWx0UHJldmVudGVkPSEwO3ZhciBhPXRoaXMubmF0aXZlRXZlbnQ7YSYmKGEucHJldmVudERlZmF1bHQ/YS5wcmV2ZW50RGVmYXVsdCgpOlwidW5rbm93blwiIT09dHlwZW9mIGEucmV0dXJuVmFsdWUmJihhLnJldHVyblZhbHVlPSExKSx0aGlzLmlzRGVmYXVsdFByZXZlbnRlZD1DLnRoYXRSZXR1cm5zVHJ1ZSl9LHN0b3BQcm9wYWdhdGlvbjpmdW5jdGlvbigpe3ZhciBhPXRoaXMubmF0aXZlRXZlbnQ7YSYmKGEuc3RvcFByb3BhZ2F0aW9uP2Euc3RvcFByb3BhZ2F0aW9uKCk6XCJ1bmtub3duXCIhPT10eXBlb2YgYS5jYW5jZWxCdWJibGUmJihhLmNhbmNlbEJ1YmJsZT0hMCksdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZD1DLnRoYXRSZXR1cm5zVHJ1ZSl9LHBlcnNpc3Q6ZnVuY3Rpb24oKXt0aGlzLmlzUGVyc2lzdGVudD1DLnRoYXRSZXR1cm5zVHJ1ZX0saXNQZXJzaXN0ZW50OkMudGhhdFJldHVybnNGYWxzZSxcbmRlc3RydWN0b3I6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmNvbnN0cnVjdG9yLkludGVyZmFjZSxiO2ZvcihiIGluIGEpdGhpc1tiXT1udWxsO2ZvcihhPTA7YTxIYi5sZW5ndGg7YSsrKXRoaXNbSGJbYV1dPW51bGx9fSk7VC5JbnRlcmZhY2U9SWI7VC5hdWdtZW50Q2xhc3M9ZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKCl7fWMucHJvdG90eXBlPXRoaXMucHJvdG90eXBlO3ZhciBkPW5ldyBjO0IoZCxhLnByb3RvdHlwZSk7YS5wcm90b3R5cGU9ZDthLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1hO2EuSW50ZXJmYWNlPUIoe30sdGhpcy5JbnRlcmZhY2UsYik7YS5hdWdtZW50Q2xhc3M9dGhpcy5hdWdtZW50Q2xhc3M7SmIoYSl9O0piKFQpO2Z1bmN0aW9uIEtiKGEsYixjLGQpe2lmKHRoaXMuZXZlbnRQb29sLmxlbmd0aCl7dmFyIGU9dGhpcy5ldmVudFBvb2wucG9wKCk7dGhpcy5jYWxsKGUsYSxiLGMsZCk7cmV0dXJuIGV9cmV0dXJuIG5ldyB0aGlzKGEsYixjLGQpfVxuZnVuY3Rpb24gTGIoYSl7YSBpbnN0YW5jZW9mIHRoaXM/dm9pZCAwOkUoXCIyMjNcIik7YS5kZXN0cnVjdG9yKCk7MTA+dGhpcy5ldmVudFBvb2wubGVuZ3RoJiZ0aGlzLmV2ZW50UG9vbC5wdXNoKGEpfWZ1bmN0aW9uIEpiKGEpe2EuZXZlbnRQb29sPVtdO2EuZ2V0UG9vbGVkPUtiO2EucmVsZWFzZT1MYn1mdW5jdGlvbiBNYihhLGIsYyxkKXtyZXR1cm4gVC5jYWxsKHRoaXMsYSxiLGMsZCl9VC5hdWdtZW50Q2xhc3MoTWIse2RhdGE6bnVsbH0pO2Z1bmN0aW9uIE5iKGEsYixjLGQpe3JldHVybiBULmNhbGwodGhpcyxhLGIsYyxkKX1ULmF1Z21lbnRDbGFzcyhOYix7ZGF0YTpudWxsfSk7dmFyIFBiPVs5LDEzLDI3LDMyXSxWYj1sLmNhblVzZURPTSYmXCJDb21wb3NpdGlvbkV2ZW50XCJpbiB3aW5kb3csV2I9bnVsbDtsLmNhblVzZURPTSYmXCJkb2N1bWVudE1vZGVcImluIGRvY3VtZW50JiYoV2I9ZG9jdW1lbnQuZG9jdW1lbnRNb2RlKTt2YXIgWGI7XG5pZihYYj1sLmNhblVzZURPTSYmXCJUZXh0RXZlbnRcImluIHdpbmRvdyYmIVdiKXt2YXIgWWI9d2luZG93Lm9wZXJhO1hiPSEoXCJvYmplY3RcIj09PXR5cGVvZiBZYiYmXCJmdW5jdGlvblwiPT09dHlwZW9mIFliLnZlcnNpb24mJjEyPj1wYXJzZUludChZYi52ZXJzaW9uKCksMTApKX1cbnZhciBaYj1YYiwkYj1sLmNhblVzZURPTSYmKCFWYnx8V2ImJjg8V2ImJjExPj1XYiksYWM9U3RyaW5nLmZyb21DaGFyQ29kZSgzMiksYmM9e2JlZm9yZUlucHV0OntwaGFzZWRSZWdpc3RyYXRpb25OYW1lczp7YnViYmxlZDpcIm9uQmVmb3JlSW5wdXRcIixjYXB0dXJlZDpcIm9uQmVmb3JlSW5wdXRDYXB0dXJlXCJ9LGRlcGVuZGVuY2llczpbXCJ0b3BDb21wb3NpdGlvbkVuZFwiLFwidG9wS2V5UHJlc3NcIixcInRvcFRleHRJbnB1dFwiLFwidG9wUGFzdGVcIl19LGNvbXBvc2l0aW9uRW5kOntwaGFzZWRSZWdpc3RyYXRpb25OYW1lczp7YnViYmxlZDpcIm9uQ29tcG9zaXRpb25FbmRcIixjYXB0dXJlZDpcIm9uQ29tcG9zaXRpb25FbmRDYXB0dXJlXCJ9LGRlcGVuZGVuY2llczpcInRvcEJsdXIgdG9wQ29tcG9zaXRpb25FbmQgdG9wS2V5RG93biB0b3BLZXlQcmVzcyB0b3BLZXlVcCB0b3BNb3VzZURvd25cIi5zcGxpdChcIiBcIil9LGNvbXBvc2l0aW9uU3RhcnQ6e3BoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOntidWJibGVkOlwib25Db21wb3NpdGlvblN0YXJ0XCIsXG5jYXB0dXJlZDpcIm9uQ29tcG9zaXRpb25TdGFydENhcHR1cmVcIn0sZGVwZW5kZW5jaWVzOlwidG9wQmx1ciB0b3BDb21wb3NpdGlvblN0YXJ0IHRvcEtleURvd24gdG9wS2V5UHJlc3MgdG9wS2V5VXAgdG9wTW91c2VEb3duXCIuc3BsaXQoXCIgXCIpfSxjb21wb3NpdGlvblVwZGF0ZTp7cGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6e2J1YmJsZWQ6XCJvbkNvbXBvc2l0aW9uVXBkYXRlXCIsY2FwdHVyZWQ6XCJvbkNvbXBvc2l0aW9uVXBkYXRlQ2FwdHVyZVwifSxkZXBlbmRlbmNpZXM6XCJ0b3BCbHVyIHRvcENvbXBvc2l0aW9uVXBkYXRlIHRvcEtleURvd24gdG9wS2V5UHJlc3MgdG9wS2V5VXAgdG9wTW91c2VEb3duXCIuc3BsaXQoXCIgXCIpfX0sY2M9ITE7XG5mdW5jdGlvbiBkYyhhLGIpe3N3aXRjaChhKXtjYXNlIFwidG9wS2V5VXBcIjpyZXR1cm4tMSE9PVBiLmluZGV4T2YoYi5rZXlDb2RlKTtjYXNlIFwidG9wS2V5RG93blwiOnJldHVybiAyMjkhPT1iLmtleUNvZGU7Y2FzZSBcInRvcEtleVByZXNzXCI6Y2FzZSBcInRvcE1vdXNlRG93blwiOmNhc2UgXCJ0b3BCbHVyXCI6cmV0dXJuITA7ZGVmYXVsdDpyZXR1cm4hMX19ZnVuY3Rpb24gZWMoYSl7YT1hLmRldGFpbDtyZXR1cm5cIm9iamVjdFwiPT09dHlwZW9mIGEmJlwiZGF0YVwiaW4gYT9hLmRhdGE6bnVsbH12YXIgZmM9ITE7ZnVuY3Rpb24gZ2MoYSxiKXtzd2l0Y2goYSl7Y2FzZSBcInRvcENvbXBvc2l0aW9uRW5kXCI6cmV0dXJuIGVjKGIpO2Nhc2UgXCJ0b3BLZXlQcmVzc1wiOmlmKDMyIT09Yi53aGljaClyZXR1cm4gbnVsbDtjYz0hMDtyZXR1cm4gYWM7Y2FzZSBcInRvcFRleHRJbnB1dFwiOnJldHVybiBhPWIuZGF0YSxhPT09YWMmJmNjP251bGw6YTtkZWZhdWx0OnJldHVybiBudWxsfX1cbmZ1bmN0aW9uIGhjKGEsYil7aWYoZmMpcmV0dXJuXCJ0b3BDb21wb3NpdGlvbkVuZFwiPT09YXx8IVZiJiZkYyhhLGIpPyhhPUZiKCksUy5fcm9vdD1udWxsLFMuX3N0YXJ0VGV4dD1udWxsLFMuX2ZhbGxiYWNrVGV4dD1udWxsLGZjPSExLGEpOm51bGw7c3dpdGNoKGEpe2Nhc2UgXCJ0b3BQYXN0ZVwiOnJldHVybiBudWxsO2Nhc2UgXCJ0b3BLZXlQcmVzc1wiOmlmKCEoYi5jdHJsS2V5fHxiLmFsdEtleXx8Yi5tZXRhS2V5KXx8Yi5jdHJsS2V5JiZiLmFsdEtleSl7aWYoYi5jaGFyJiYxPGIuY2hhci5sZW5ndGgpcmV0dXJuIGIuY2hhcjtpZihiLndoaWNoKXJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGIud2hpY2gpfXJldHVybiBudWxsO2Nhc2UgXCJ0b3BDb21wb3NpdGlvbkVuZFwiOnJldHVybiAkYj9udWxsOmIuZGF0YTtkZWZhdWx0OnJldHVybiBudWxsfX1cbnZhciBpYz17ZXZlbnRUeXBlczpiYyxleHRyYWN0RXZlbnRzOmZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlO2lmKFZiKWI6e3N3aXRjaChhKXtjYXNlIFwidG9wQ29tcG9zaXRpb25TdGFydFwiOnZhciBmPWJjLmNvbXBvc2l0aW9uU3RhcnQ7YnJlYWsgYjtjYXNlIFwidG9wQ29tcG9zaXRpb25FbmRcIjpmPWJjLmNvbXBvc2l0aW9uRW5kO2JyZWFrIGI7Y2FzZSBcInRvcENvbXBvc2l0aW9uVXBkYXRlXCI6Zj1iYy5jb21wb3NpdGlvblVwZGF0ZTticmVhayBifWY9dm9pZCAwfWVsc2UgZmM/ZGMoYSxjKSYmKGY9YmMuY29tcG9zaXRpb25FbmQpOlwidG9wS2V5RG93blwiPT09YSYmMjI5PT09Yy5rZXlDb2RlJiYoZj1iYy5jb21wb3NpdGlvblN0YXJ0KTtmPygkYiYmKGZjfHxmIT09YmMuY29tcG9zaXRpb25TdGFydD9mPT09YmMuY29tcG9zaXRpb25FbmQmJmZjJiYoZT1GYigpKTooUy5fcm9vdD1kLFMuX3N0YXJ0VGV4dD1HYigpLGZjPSEwKSksZj1NYi5nZXRQb29sZWQoZixiLGMsZCksZT9mLmRhdGE9XG5lOihlPWVjKGMpLG51bGwhPT1lJiYoZi5kYXRhPWUpKSxBYihmKSxlPWYpOmU9bnVsbDsoYT1aYj9nYyhhLGMpOmhjKGEsYykpPyhiPU5iLmdldFBvb2xlZChiYy5iZWZvcmVJbnB1dCxiLGMsZCksYi5kYXRhPWEsQWIoYikpOmI9bnVsbDtyZXR1cm5bZSxiXX19LGpjPW51bGwsa2M9bnVsbCxsYz1udWxsO2Z1bmN0aW9uIG1jKGEpe2lmKGE9WGEoYSkpe2pjJiZcImZ1bmN0aW9uXCI9PT10eXBlb2YgamMucmVzdG9yZUNvbnRyb2xsZWRTdGF0ZT92b2lkIDA6RShcIjE5NFwiKTt2YXIgYj1XYShhLnN0YXRlTm9kZSk7amMucmVzdG9yZUNvbnRyb2xsZWRTdGF0ZShhLnN0YXRlTm9kZSxhLnR5cGUsYil9fXZhciBuYz17aW5qZWN0RmliZXJDb250cm9sbGVkSG9zdENvbXBvbmVudDpmdW5jdGlvbihhKXtqYz1hfX07ZnVuY3Rpb24gb2MoYSl7a2M/bGM/bGMucHVzaChhKTpsYz1bYV06a2M9YX1cbmZ1bmN0aW9uIHBjKCl7aWYoa2Mpe3ZhciBhPWtjLGI9bGM7bGM9a2M9bnVsbDttYyhhKTtpZihiKWZvcihhPTA7YTxiLmxlbmd0aDthKyspbWMoYlthXSl9fXZhciBxYz1PYmplY3QuZnJlZXplKHtpbmplY3Rpb246bmMsZW5xdWV1ZVN0YXRlUmVzdG9yZTpvYyxyZXN0b3JlU3RhdGVJZk5lZWRlZDpwY30pO2Z1bmN0aW9uIHJjKGEsYil7cmV0dXJuIGEoYil9dmFyIHNjPSExO2Z1bmN0aW9uIHRjKGEsYil7aWYoc2MpcmV0dXJuIHJjKGEsYik7c2M9ITA7dHJ5e3JldHVybiByYyhhLGIpfWZpbmFsbHl7c2M9ITEscGMoKX19dmFyIHVjPXtjb2xvcjohMCxkYXRlOiEwLGRhdGV0aW1lOiEwLFwiZGF0ZXRpbWUtbG9jYWxcIjohMCxlbWFpbDohMCxtb250aDohMCxudW1iZXI6ITAscGFzc3dvcmQ6ITAscmFuZ2U6ITAsc2VhcmNoOiEwLHRlbDohMCx0ZXh0OiEwLHRpbWU6ITAsdXJsOiEwLHdlZWs6ITB9O1xuZnVuY3Rpb24gdmMoYSl7dmFyIGI9YSYmYS5ub2RlTmFtZSYmYS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO3JldHVyblwiaW5wdXRcIj09PWI/ISF1Y1thLnR5cGVdOlwidGV4dGFyZWFcIj09PWI/ITA6ITF9ZnVuY3Rpb24gd2MoYSl7YT1hLnRhcmdldHx8YS5zcmNFbGVtZW50fHx3aW5kb3c7YS5jb3JyZXNwb25kaW5nVXNlRWxlbWVudCYmKGE9YS5jb3JyZXNwb25kaW5nVXNlRWxlbWVudCk7cmV0dXJuIDM9PT1hLm5vZGVUeXBlP2EucGFyZW50Tm9kZTphfXZhciB4YztsLmNhblVzZURPTSYmKHhjPWRvY3VtZW50LmltcGxlbWVudGF0aW9uJiZkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlJiYhMCE9PWRvY3VtZW50LmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUoXCJcIixcIlwiKSk7XG5mdW5jdGlvbiB5YyhhLGIpe2lmKCFsLmNhblVzZURPTXx8YiYmIShcImFkZEV2ZW50TGlzdGVuZXJcImluIGRvY3VtZW50KSlyZXR1cm4hMTtiPVwib25cIithO3ZhciBjPWIgaW4gZG9jdW1lbnQ7Y3x8KGM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSxjLnNldEF0dHJpYnV0ZShiLFwicmV0dXJuO1wiKSxjPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBjW2JdKTshYyYmeGMmJlwid2hlZWxcIj09PWEmJihjPWRvY3VtZW50LmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUoXCJFdmVudHMud2hlZWxcIixcIjMuMFwiKSk7cmV0dXJuIGN9ZnVuY3Rpb24gemMoYSl7dmFyIGI9YS50eXBlO3JldHVybihhPWEubm9kZU5hbWUpJiZcImlucHV0XCI9PT1hLnRvTG93ZXJDYXNlKCkmJihcImNoZWNrYm94XCI9PT1ifHxcInJhZGlvXCI9PT1iKX1cbmZ1bmN0aW9uIEFjKGEpe3ZhciBiPXpjKGEpP1wiY2hlY2tlZFwiOlwidmFsdWVcIixjPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUsYiksZD1cIlwiK2FbYl07aWYoIWEuaGFzT3duUHJvcGVydHkoYikmJlwiZnVuY3Rpb25cIj09PXR5cGVvZiBjLmdldCYmXCJmdW5jdGlvblwiPT09dHlwZW9mIGMuc2V0KXJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoYSxiLHtlbnVtZXJhYmxlOmMuZW51bWVyYWJsZSxjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGMuZ2V0LmNhbGwodGhpcyl9LHNldDpmdW5jdGlvbihhKXtkPVwiXCIrYTtjLnNldC5jYWxsKHRoaXMsYSl9fSkse2dldFZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIGR9LHNldFZhbHVlOmZ1bmN0aW9uKGEpe2Q9XCJcIithfSxzdG9wVHJhY2tpbmc6ZnVuY3Rpb24oKXthLl92YWx1ZVRyYWNrZXI9bnVsbDtkZWxldGUgYVtiXX19fVxuZnVuY3Rpb24gQmMoYSl7YS5fdmFsdWVUcmFja2VyfHwoYS5fdmFsdWVUcmFja2VyPUFjKGEpKX1mdW5jdGlvbiBDYyhhKXtpZighYSlyZXR1cm4hMTt2YXIgYj1hLl92YWx1ZVRyYWNrZXI7aWYoIWIpcmV0dXJuITA7dmFyIGM9Yi5nZXRWYWx1ZSgpO3ZhciBkPVwiXCI7YSYmKGQ9emMoYSk/YS5jaGVja2VkP1widHJ1ZVwiOlwiZmFsc2VcIjphLnZhbHVlKTthPWQ7cmV0dXJuIGEhPT1jPyhiLnNldFZhbHVlKGEpLCEwKTohMX12YXIgRGM9e2NoYW5nZTp7cGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6e2J1YmJsZWQ6XCJvbkNoYW5nZVwiLGNhcHR1cmVkOlwib25DaGFuZ2VDYXB0dXJlXCJ9LGRlcGVuZGVuY2llczpcInRvcEJsdXIgdG9wQ2hhbmdlIHRvcENsaWNrIHRvcEZvY3VzIHRvcElucHV0IHRvcEtleURvd24gdG9wS2V5VXAgdG9wU2VsZWN0aW9uQ2hhbmdlXCIuc3BsaXQoXCIgXCIpfX07XG5mdW5jdGlvbiBFYyhhLGIsYyl7YT1ULmdldFBvb2xlZChEYy5jaGFuZ2UsYSxiLGMpO2EudHlwZT1cImNoYW5nZVwiO29jKGMpO0FiKGEpO3JldHVybiBhfXZhciBGYz1udWxsLEdjPW51bGw7ZnVuY3Rpb24gSGMoYSl7a2IoYSk7bGIoITEpfWZ1bmN0aW9uIEljKGEpe3ZhciBiPXFiKGEpO2lmKENjKGIpKXJldHVybiBhfWZ1bmN0aW9uIEpjKGEsYil7aWYoXCJ0b3BDaGFuZ2VcIj09PWEpcmV0dXJuIGJ9dmFyIEtjPSExO2wuY2FuVXNlRE9NJiYoS2M9eWMoXCJpbnB1dFwiKSYmKCFkb2N1bWVudC5kb2N1bWVudE1vZGV8fDk8ZG9jdW1lbnQuZG9jdW1lbnRNb2RlKSk7ZnVuY3Rpb24gTGMoKXtGYyYmKEZjLmRldGFjaEV2ZW50KFwib25wcm9wZXJ0eWNoYW5nZVwiLE1jKSxHYz1GYz1udWxsKX1mdW5jdGlvbiBNYyhhKXtcInZhbHVlXCI9PT1hLnByb3BlcnR5TmFtZSYmSWMoR2MpJiYoYT1FYyhHYyxhLHdjKGEpKSx0YyhIYyxhKSl9XG5mdW5jdGlvbiBOYyhhLGIsYyl7XCJ0b3BGb2N1c1wiPT09YT8oTGMoKSxGYz1iLEdjPWMsRmMuYXR0YWNoRXZlbnQoXCJvbnByb3BlcnR5Y2hhbmdlXCIsTWMpKTpcInRvcEJsdXJcIj09PWEmJkxjKCl9ZnVuY3Rpb24gT2MoYSl7aWYoXCJ0b3BTZWxlY3Rpb25DaGFuZ2VcIj09PWF8fFwidG9wS2V5VXBcIj09PWF8fFwidG9wS2V5RG93blwiPT09YSlyZXR1cm4gSWMoR2MpfWZ1bmN0aW9uIFBjKGEsYil7aWYoXCJ0b3BDbGlja1wiPT09YSlyZXR1cm4gSWMoYil9ZnVuY3Rpb24gJGMoYSxiKXtpZihcInRvcElucHV0XCI9PT1hfHxcInRvcENoYW5nZVwiPT09YSlyZXR1cm4gSWMoYil9XG52YXIgYWQ9e2V2ZW50VHlwZXM6RGMsX2lzSW5wdXRFdmVudFN1cHBvcnRlZDpLYyxleHRyYWN0RXZlbnRzOmZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPWI/cWIoYik6d2luZG93LGY9ZS5ub2RlTmFtZSYmZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO2lmKFwic2VsZWN0XCI9PT1mfHxcImlucHV0XCI9PT1mJiZcImZpbGVcIj09PWUudHlwZSl2YXIgZz1KYztlbHNlIGlmKHZjKGUpKWlmKEtjKWc9JGM7ZWxzZXtnPU9jO3ZhciBoPU5jfWVsc2UgZj1lLm5vZGVOYW1lLCFmfHxcImlucHV0XCIhPT1mLnRvTG93ZXJDYXNlKCl8fFwiY2hlY2tib3hcIiE9PWUudHlwZSYmXCJyYWRpb1wiIT09ZS50eXBlfHwoZz1QYyk7aWYoZyYmKGc9ZyhhLGIpKSlyZXR1cm4gRWMoZyxjLGQpO2gmJmgoYSxlLGIpO1widG9wQmx1clwiPT09YSYmbnVsbCE9YiYmKGE9Yi5fd3JhcHBlclN0YXRlfHxlLl93cmFwcGVyU3RhdGUpJiZhLmNvbnRyb2xsZWQmJlwibnVtYmVyXCI9PT1lLnR5cGUmJihhPVwiXCIrZS52YWx1ZSxlLmdldEF0dHJpYnV0ZShcInZhbHVlXCIpIT09XG5hJiZlLnNldEF0dHJpYnV0ZShcInZhbHVlXCIsYSkpfX07ZnVuY3Rpb24gYmQoYSxiLGMsZCl7cmV0dXJuIFQuY2FsbCh0aGlzLGEsYixjLGQpfVQuYXVnbWVudENsYXNzKGJkLHt2aWV3Om51bGwsZGV0YWlsOm51bGx9KTt2YXIgY2Q9e0FsdDpcImFsdEtleVwiLENvbnRyb2w6XCJjdHJsS2V5XCIsTWV0YTpcIm1ldGFLZXlcIixTaGlmdDpcInNoaWZ0S2V5XCJ9O2Z1bmN0aW9uIGRkKGEpe3ZhciBiPXRoaXMubmF0aXZlRXZlbnQ7cmV0dXJuIGIuZ2V0TW9kaWZpZXJTdGF0ZT9iLmdldE1vZGlmaWVyU3RhdGUoYSk6KGE9Y2RbYV0pPyEhYlthXTohMX1mdW5jdGlvbiBlZCgpe3JldHVybiBkZH1mdW5jdGlvbiBmZChhLGIsYyxkKXtyZXR1cm4gVC5jYWxsKHRoaXMsYSxiLGMsZCl9XG5iZC5hdWdtZW50Q2xhc3MoZmQse3NjcmVlblg6bnVsbCxzY3JlZW5ZOm51bGwsY2xpZW50WDpudWxsLGNsaWVudFk6bnVsbCxwYWdlWDpudWxsLHBhZ2VZOm51bGwsY3RybEtleTpudWxsLHNoaWZ0S2V5Om51bGwsYWx0S2V5Om51bGwsbWV0YUtleTpudWxsLGdldE1vZGlmaWVyU3RhdGU6ZWQsYnV0dG9uOm51bGwsYnV0dG9uczpudWxsLHJlbGF0ZWRUYXJnZXQ6ZnVuY3Rpb24oYSl7cmV0dXJuIGEucmVsYXRlZFRhcmdldHx8KGEuZnJvbUVsZW1lbnQ9PT1hLnNyY0VsZW1lbnQ/YS50b0VsZW1lbnQ6YS5mcm9tRWxlbWVudCl9fSk7XG52YXIgZ2Q9e21vdXNlRW50ZXI6e3JlZ2lzdHJhdGlvbk5hbWU6XCJvbk1vdXNlRW50ZXJcIixkZXBlbmRlbmNpZXM6W1widG9wTW91c2VPdXRcIixcInRvcE1vdXNlT3ZlclwiXX0sbW91c2VMZWF2ZTp7cmVnaXN0cmF0aW9uTmFtZTpcIm9uTW91c2VMZWF2ZVwiLGRlcGVuZGVuY2llczpbXCJ0b3BNb3VzZU91dFwiLFwidG9wTW91c2VPdmVyXCJdfX0saGQ9e2V2ZW50VHlwZXM6Z2QsZXh0cmFjdEV2ZW50czpmdW5jdGlvbihhLGIsYyxkKXtpZihcInRvcE1vdXNlT3ZlclwiPT09YSYmKGMucmVsYXRlZFRhcmdldHx8Yy5mcm9tRWxlbWVudCl8fFwidG9wTW91c2VPdXRcIiE9PWEmJlwidG9wTW91c2VPdmVyXCIhPT1hKXJldHVybiBudWxsO3ZhciBlPWQud2luZG93PT09ZD9kOihlPWQub3duZXJEb2N1bWVudCk/ZS5kZWZhdWx0Vmlld3x8ZS5wYXJlbnRXaW5kb3c6d2luZG93O1widG9wTW91c2VPdXRcIj09PWE/KGE9YixiPShiPWMucmVsYXRlZFRhcmdldHx8Yy50b0VsZW1lbnQpP3BiKGIpOm51bGwpOmE9bnVsbDtpZihhPT09XG5iKXJldHVybiBudWxsO3ZhciBmPW51bGw9PWE/ZTpxYihhKTtlPW51bGw9PWI/ZTpxYihiKTt2YXIgZz1mZC5nZXRQb29sZWQoZ2QubW91c2VMZWF2ZSxhLGMsZCk7Zy50eXBlPVwibW91c2VsZWF2ZVwiO2cudGFyZ2V0PWY7Zy5yZWxhdGVkVGFyZ2V0PWU7Yz1mZC5nZXRQb29sZWQoZ2QubW91c2VFbnRlcixiLGMsZCk7Yy50eXBlPVwibW91c2VlbnRlclwiO2MudGFyZ2V0PWU7Yy5yZWxhdGVkVGFyZ2V0PWY7QmIoZyxjLGEsYik7cmV0dXJuW2csY119fSxpZD1hYS5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRC5SZWFjdEN1cnJlbnRPd25lcjtmdW5jdGlvbiBqZChhKXthPWEudHlwZTtyZXR1cm5cInN0cmluZ1wiPT09dHlwZW9mIGE/YTpcImZ1bmN0aW9uXCI9PT10eXBlb2YgYT9hLmRpc3BsYXlOYW1lfHxhLm5hbWU6bnVsbH1cbmZ1bmN0aW9uIGtkKGEpe3ZhciBiPWE7aWYoYS5hbHRlcm5hdGUpZm9yKDtiW1wicmV0dXJuXCJdOyliPWJbXCJyZXR1cm5cIl07ZWxzZXtpZigwIT09KGIuZWZmZWN0VGFnJjIpKXJldHVybiAxO2Zvcig7YltcInJldHVyblwiXTspaWYoYj1iW1wicmV0dXJuXCJdLDAhPT0oYi5lZmZlY3RUYWcmMikpcmV0dXJuIDF9cmV0dXJuIDM9PT1iLnRhZz8yOjN9ZnVuY3Rpb24gbGQoYSl7cmV0dXJuKGE9YS5fcmVhY3RJbnRlcm5hbEZpYmVyKT8yPT09a2QoYSk6ITF9ZnVuY3Rpb24gbWQoYSl7MiE9PWtkKGEpP0UoXCIxODhcIik6dm9pZCAwfVxuZnVuY3Rpb24gbmQoYSl7dmFyIGI9YS5hbHRlcm5hdGU7aWYoIWIpcmV0dXJuIGI9a2QoYSksMz09PWI/RShcIjE4OFwiKTp2b2lkIDAsMT09PWI/bnVsbDphO2Zvcih2YXIgYz1hLGQ9Yjs7KXt2YXIgZT1jW1wicmV0dXJuXCJdLGY9ZT9lLmFsdGVybmF0ZTpudWxsO2lmKCFlfHwhZilicmVhaztpZihlLmNoaWxkPT09Zi5jaGlsZCl7Zm9yKHZhciBnPWUuY2hpbGQ7Zzspe2lmKGc9PT1jKXJldHVybiBtZChlKSxhO2lmKGc9PT1kKXJldHVybiBtZChlKSxiO2c9Zy5zaWJsaW5nfUUoXCIxODhcIil9aWYoY1tcInJldHVyblwiXSE9PWRbXCJyZXR1cm5cIl0pYz1lLGQ9ZjtlbHNle2c9ITE7Zm9yKHZhciBoPWUuY2hpbGQ7aDspe2lmKGg9PT1jKXtnPSEwO2M9ZTtkPWY7YnJlYWt9aWYoaD09PWQpe2c9ITA7ZD1lO2M9ZjticmVha31oPWguc2libGluZ31pZighZyl7Zm9yKGg9Zi5jaGlsZDtoOyl7aWYoaD09PWMpe2c9ITA7Yz1mO2Q9ZTticmVha31pZihoPT09ZCl7Zz0hMDtkPWY7Yz1lO2JyZWFrfWg9aC5zaWJsaW5nfWc/XG52b2lkIDA6RShcIjE4OVwiKX19Yy5hbHRlcm5hdGUhPT1kP0UoXCIxOTBcIik6dm9pZCAwfTMhPT1jLnRhZz9FKFwiMTg4XCIpOnZvaWQgMDtyZXR1cm4gYy5zdGF0ZU5vZGUuY3VycmVudD09PWM/YTpifWZ1bmN0aW9uIG9kKGEpe2E9bmQoYSk7aWYoIWEpcmV0dXJuIG51bGw7Zm9yKHZhciBiPWE7Oyl7aWYoNT09PWIudGFnfHw2PT09Yi50YWcpcmV0dXJuIGI7aWYoYi5jaGlsZCliLmNoaWxkW1wicmV0dXJuXCJdPWIsYj1iLmNoaWxkO2Vsc2V7aWYoYj09PWEpYnJlYWs7Zm9yKDshYi5zaWJsaW5nOyl7aWYoIWJbXCJyZXR1cm5cIl18fGJbXCJyZXR1cm5cIl09PT1hKXJldHVybiBudWxsO2I9YltcInJldHVyblwiXX1iLnNpYmxpbmdbXCJyZXR1cm5cIl09YltcInJldHVyblwiXTtiPWIuc2libGluZ319cmV0dXJuIG51bGx9XG5mdW5jdGlvbiBwZChhKXthPW5kKGEpO2lmKCFhKXJldHVybiBudWxsO2Zvcih2YXIgYj1hOzspe2lmKDU9PT1iLnRhZ3x8Nj09PWIudGFnKXJldHVybiBiO2lmKGIuY2hpbGQmJjQhPT1iLnRhZyliLmNoaWxkW1wicmV0dXJuXCJdPWIsYj1iLmNoaWxkO2Vsc2V7aWYoYj09PWEpYnJlYWs7Zm9yKDshYi5zaWJsaW5nOyl7aWYoIWJbXCJyZXR1cm5cIl18fGJbXCJyZXR1cm5cIl09PT1hKXJldHVybiBudWxsO2I9YltcInJldHVyblwiXX1iLnNpYmxpbmdbXCJyZXR1cm5cIl09YltcInJldHVyblwiXTtiPWIuc2libGluZ319cmV0dXJuIG51bGx9dmFyIHFkPVtdO1xuZnVuY3Rpb24gcmQoYSl7dmFyIGI9YS50YXJnZXRJbnN0O2Rve2lmKCFiKXthLmFuY2VzdG9ycy5wdXNoKGIpO2JyZWFrfXZhciBjO2ZvcihjPWI7Y1tcInJldHVyblwiXTspYz1jW1wicmV0dXJuXCJdO2M9MyE9PWMudGFnP251bGw6Yy5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztpZighYylicmVhazthLmFuY2VzdG9ycy5wdXNoKGIpO2I9cGIoYyl9d2hpbGUoYik7Zm9yKGM9MDtjPGEuYW5jZXN0b3JzLmxlbmd0aDtjKyspYj1hLmFuY2VzdG9yc1tjXSxzZChhLnRvcExldmVsVHlwZSxiLGEubmF0aXZlRXZlbnQsd2MoYS5uYXRpdmVFdmVudCkpfXZhciB0ZD0hMCxzZD12b2lkIDA7ZnVuY3Rpb24gdWQoYSl7dGQ9ISFhfWZ1bmN0aW9uIFUoYSxiLGMpe3JldHVybiBjP2JhLmxpc3RlbihjLGIsdmQuYmluZChudWxsLGEpKTpudWxsfWZ1bmN0aW9uIHdkKGEsYixjKXtyZXR1cm4gYz9iYS5jYXB0dXJlKGMsYix2ZC5iaW5kKG51bGwsYSkpOm51bGx9XG5mdW5jdGlvbiB2ZChhLGIpe2lmKHRkKXt2YXIgYz13YyhiKTtjPXBiKGMpO251bGw9PT1jfHxcIm51bWJlclwiIT09dHlwZW9mIGMudGFnfHwyPT09a2QoYyl8fChjPW51bGwpO2lmKHFkLmxlbmd0aCl7dmFyIGQ9cWQucG9wKCk7ZC50b3BMZXZlbFR5cGU9YTtkLm5hdGl2ZUV2ZW50PWI7ZC50YXJnZXRJbnN0PWM7YT1kfWVsc2UgYT17dG9wTGV2ZWxUeXBlOmEsbmF0aXZlRXZlbnQ6Yix0YXJnZXRJbnN0OmMsYW5jZXN0b3JzOltdfTt0cnl7dGMocmQsYSl9ZmluYWxseXthLnRvcExldmVsVHlwZT1udWxsLGEubmF0aXZlRXZlbnQ9bnVsbCxhLnRhcmdldEluc3Q9bnVsbCxhLmFuY2VzdG9ycy5sZW5ndGg9MCwxMD5xZC5sZW5ndGgmJnFkLnB1c2goYSl9fX1cbnZhciB4ZD1PYmplY3QuZnJlZXplKHtnZXQgX2VuYWJsZWQoKXtyZXR1cm4gdGR9LGdldCBfaGFuZGxlVG9wTGV2ZWwoKXtyZXR1cm4gc2R9LHNldEhhbmRsZVRvcExldmVsOmZ1bmN0aW9uKGEpe3NkPWF9LHNldEVuYWJsZWQ6dWQsaXNFbmFibGVkOmZ1bmN0aW9uKCl7cmV0dXJuIHRkfSx0cmFwQnViYmxlZEV2ZW50OlUsdHJhcENhcHR1cmVkRXZlbnQ6d2QsZGlzcGF0Y2hFdmVudDp2ZH0pO2Z1bmN0aW9uIHlkKGEsYil7dmFyIGM9e307Y1thLnRvTG93ZXJDYXNlKCldPWIudG9Mb3dlckNhc2UoKTtjW1wiV2Via2l0XCIrYV09XCJ3ZWJraXRcIitiO2NbXCJNb3pcIithXT1cIm1velwiK2I7Y1tcIm1zXCIrYV09XCJNU1wiK2I7Y1tcIk9cIithXT1cIm9cIitiLnRvTG93ZXJDYXNlKCk7cmV0dXJuIGN9XG52YXIgemQ9e2FuaW1hdGlvbmVuZDp5ZChcIkFuaW1hdGlvblwiLFwiQW5pbWF0aW9uRW5kXCIpLGFuaW1hdGlvbml0ZXJhdGlvbjp5ZChcIkFuaW1hdGlvblwiLFwiQW5pbWF0aW9uSXRlcmF0aW9uXCIpLGFuaW1hdGlvbnN0YXJ0OnlkKFwiQW5pbWF0aW9uXCIsXCJBbmltYXRpb25TdGFydFwiKSx0cmFuc2l0aW9uZW5kOnlkKFwiVHJhbnNpdGlvblwiLFwiVHJhbnNpdGlvbkVuZFwiKX0sQWQ9e30sQmQ9e307bC5jYW5Vc2VET00mJihCZD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLnN0eWxlLFwiQW5pbWF0aW9uRXZlbnRcImluIHdpbmRvd3x8KGRlbGV0ZSB6ZC5hbmltYXRpb25lbmQuYW5pbWF0aW9uLGRlbGV0ZSB6ZC5hbmltYXRpb25pdGVyYXRpb24uYW5pbWF0aW9uLGRlbGV0ZSB6ZC5hbmltYXRpb25zdGFydC5hbmltYXRpb24pLFwiVHJhbnNpdGlvbkV2ZW50XCJpbiB3aW5kb3d8fGRlbGV0ZSB6ZC50cmFuc2l0aW9uZW5kLnRyYW5zaXRpb24pO1xuZnVuY3Rpb24gQ2QoYSl7aWYoQWRbYV0pcmV0dXJuIEFkW2FdO2lmKCF6ZFthXSlyZXR1cm4gYTt2YXIgYj16ZFthXSxjO2ZvcihjIGluIGIpaWYoYi5oYXNPd25Qcm9wZXJ0eShjKSYmYyBpbiBCZClyZXR1cm4gQWRbYV09YltjXTtyZXR1cm5cIlwifVxudmFyIERkPXt0b3BBYm9ydDpcImFib3J0XCIsdG9wQW5pbWF0aW9uRW5kOkNkKFwiYW5pbWF0aW9uZW5kXCIpfHxcImFuaW1hdGlvbmVuZFwiLHRvcEFuaW1hdGlvbkl0ZXJhdGlvbjpDZChcImFuaW1hdGlvbml0ZXJhdGlvblwiKXx8XCJhbmltYXRpb25pdGVyYXRpb25cIix0b3BBbmltYXRpb25TdGFydDpDZChcImFuaW1hdGlvbnN0YXJ0XCIpfHxcImFuaW1hdGlvbnN0YXJ0XCIsdG9wQmx1cjpcImJsdXJcIix0b3BDYW5jZWw6XCJjYW5jZWxcIix0b3BDYW5QbGF5OlwiY2FucGxheVwiLHRvcENhblBsYXlUaHJvdWdoOlwiY2FucGxheXRocm91Z2hcIix0b3BDaGFuZ2U6XCJjaGFuZ2VcIix0b3BDbGljazpcImNsaWNrXCIsdG9wQ2xvc2U6XCJjbG9zZVwiLHRvcENvbXBvc2l0aW9uRW5kOlwiY29tcG9zaXRpb25lbmRcIix0b3BDb21wb3NpdGlvblN0YXJ0OlwiY29tcG9zaXRpb25zdGFydFwiLHRvcENvbXBvc2l0aW9uVXBkYXRlOlwiY29tcG9zaXRpb251cGRhdGVcIix0b3BDb250ZXh0TWVudTpcImNvbnRleHRtZW51XCIsdG9wQ29weTpcImNvcHlcIixcbnRvcEN1dDpcImN1dFwiLHRvcERvdWJsZUNsaWNrOlwiZGJsY2xpY2tcIix0b3BEcmFnOlwiZHJhZ1wiLHRvcERyYWdFbmQ6XCJkcmFnZW5kXCIsdG9wRHJhZ0VudGVyOlwiZHJhZ2VudGVyXCIsdG9wRHJhZ0V4aXQ6XCJkcmFnZXhpdFwiLHRvcERyYWdMZWF2ZTpcImRyYWdsZWF2ZVwiLHRvcERyYWdPdmVyOlwiZHJhZ292ZXJcIix0b3BEcmFnU3RhcnQ6XCJkcmFnc3RhcnRcIix0b3BEcm9wOlwiZHJvcFwiLHRvcER1cmF0aW9uQ2hhbmdlOlwiZHVyYXRpb25jaGFuZ2VcIix0b3BFbXB0aWVkOlwiZW1wdGllZFwiLHRvcEVuY3J5cHRlZDpcImVuY3J5cHRlZFwiLHRvcEVuZGVkOlwiZW5kZWRcIix0b3BFcnJvcjpcImVycm9yXCIsdG9wRm9jdXM6XCJmb2N1c1wiLHRvcElucHV0OlwiaW5wdXRcIix0b3BLZXlEb3duOlwia2V5ZG93blwiLHRvcEtleVByZXNzOlwia2V5cHJlc3NcIix0b3BLZXlVcDpcImtleXVwXCIsdG9wTG9hZGVkRGF0YTpcImxvYWRlZGRhdGFcIix0b3BMb2FkOlwibG9hZFwiLHRvcExvYWRlZE1ldGFkYXRhOlwibG9hZGVkbWV0YWRhdGFcIix0b3BMb2FkU3RhcnQ6XCJsb2Fkc3RhcnRcIixcbnRvcE1vdXNlRG93bjpcIm1vdXNlZG93blwiLHRvcE1vdXNlTW92ZTpcIm1vdXNlbW92ZVwiLHRvcE1vdXNlT3V0OlwibW91c2VvdXRcIix0b3BNb3VzZU92ZXI6XCJtb3VzZW92ZXJcIix0b3BNb3VzZVVwOlwibW91c2V1cFwiLHRvcFBhc3RlOlwicGFzdGVcIix0b3BQYXVzZTpcInBhdXNlXCIsdG9wUGxheTpcInBsYXlcIix0b3BQbGF5aW5nOlwicGxheWluZ1wiLHRvcFByb2dyZXNzOlwicHJvZ3Jlc3NcIix0b3BSYXRlQ2hhbmdlOlwicmF0ZWNoYW5nZVwiLHRvcFNjcm9sbDpcInNjcm9sbFwiLHRvcFNlZWtlZDpcInNlZWtlZFwiLHRvcFNlZWtpbmc6XCJzZWVraW5nXCIsdG9wU2VsZWN0aW9uQ2hhbmdlOlwic2VsZWN0aW9uY2hhbmdlXCIsdG9wU3RhbGxlZDpcInN0YWxsZWRcIix0b3BTdXNwZW5kOlwic3VzcGVuZFwiLHRvcFRleHRJbnB1dDpcInRleHRJbnB1dFwiLHRvcFRpbWVVcGRhdGU6XCJ0aW1ldXBkYXRlXCIsdG9wVG9nZ2xlOlwidG9nZ2xlXCIsdG9wVG91Y2hDYW5jZWw6XCJ0b3VjaGNhbmNlbFwiLHRvcFRvdWNoRW5kOlwidG91Y2hlbmRcIix0b3BUb3VjaE1vdmU6XCJ0b3VjaG1vdmVcIixcbnRvcFRvdWNoU3RhcnQ6XCJ0b3VjaHN0YXJ0XCIsdG9wVHJhbnNpdGlvbkVuZDpDZChcInRyYW5zaXRpb25lbmRcIil8fFwidHJhbnNpdGlvbmVuZFwiLHRvcFZvbHVtZUNoYW5nZTpcInZvbHVtZWNoYW5nZVwiLHRvcFdhaXRpbmc6XCJ3YWl0aW5nXCIsdG9wV2hlZWw6XCJ3aGVlbFwifSxFZD17fSxGZD0wLEdkPVwiX3JlYWN0TGlzdGVuZXJzSURcIisoXCJcIitNYXRoLnJhbmRvbSgpKS5zbGljZSgyKTtmdW5jdGlvbiBIZChhKXtPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYSxHZCl8fChhW0dkXT1GZCsrLEVkW2FbR2RdXT17fSk7cmV0dXJuIEVkW2FbR2RdXX1mdW5jdGlvbiBJZChhKXtmb3IoO2EmJmEuZmlyc3RDaGlsZDspYT1hLmZpcnN0Q2hpbGQ7cmV0dXJuIGF9XG5mdW5jdGlvbiBKZChhLGIpe3ZhciBjPUlkKGEpO2E9MDtmb3IodmFyIGQ7Yzspe2lmKDM9PT1jLm5vZGVUeXBlKXtkPWErYy50ZXh0Q29udGVudC5sZW5ndGg7aWYoYTw9YiYmZD49YilyZXR1cm57bm9kZTpjLG9mZnNldDpiLWF9O2E9ZH1hOntmb3IoO2M7KXtpZihjLm5leHRTaWJsaW5nKXtjPWMubmV4dFNpYmxpbmc7YnJlYWsgYX1jPWMucGFyZW50Tm9kZX1jPXZvaWQgMH1jPUlkKGMpfX1mdW5jdGlvbiBLZChhKXt2YXIgYj1hJiZhLm5vZGVOYW1lJiZhLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7cmV0dXJuIGImJihcImlucHV0XCI9PT1iJiZcInRleHRcIj09PWEudHlwZXx8XCJ0ZXh0YXJlYVwiPT09Ynx8XCJ0cnVlXCI9PT1hLmNvbnRlbnRFZGl0YWJsZSl9XG52YXIgTGQ9bC5jYW5Vc2VET00mJlwiZG9jdW1lbnRNb2RlXCJpbiBkb2N1bWVudCYmMTE+PWRvY3VtZW50LmRvY3VtZW50TW9kZSxNZD17c2VsZWN0OntwaGFzZWRSZWdpc3RyYXRpb25OYW1lczp7YnViYmxlZDpcIm9uU2VsZWN0XCIsY2FwdHVyZWQ6XCJvblNlbGVjdENhcHR1cmVcIn0sZGVwZW5kZW5jaWVzOlwidG9wQmx1ciB0b3BDb250ZXh0TWVudSB0b3BGb2N1cyB0b3BLZXlEb3duIHRvcEtleVVwIHRvcE1vdXNlRG93biB0b3BNb3VzZVVwIHRvcFNlbGVjdGlvbkNoYW5nZVwiLnNwbGl0KFwiIFwiKX19LE5kPW51bGwsT2Q9bnVsbCxQZD1udWxsLFFkPSExO1xuZnVuY3Rpb24gUmQoYSxiKXtpZihRZHx8bnVsbD09TmR8fE5kIT09ZGEoKSlyZXR1cm4gbnVsbDt2YXIgYz1OZDtcInNlbGVjdGlvblN0YXJ0XCJpbiBjJiZLZChjKT9jPXtzdGFydDpjLnNlbGVjdGlvblN0YXJ0LGVuZDpjLnNlbGVjdGlvbkVuZH06d2luZG93LmdldFNlbGVjdGlvbj8oYz13aW5kb3cuZ2V0U2VsZWN0aW9uKCksYz17YW5jaG9yTm9kZTpjLmFuY2hvck5vZGUsYW5jaG9yT2Zmc2V0OmMuYW5jaG9yT2Zmc2V0LGZvY3VzTm9kZTpjLmZvY3VzTm9kZSxmb2N1c09mZnNldDpjLmZvY3VzT2Zmc2V0fSk6Yz12b2lkIDA7cmV0dXJuIFBkJiZlYShQZCxjKT9udWxsOihQZD1jLGE9VC5nZXRQb29sZWQoTWQuc2VsZWN0LE9kLGEsYiksYS50eXBlPVwic2VsZWN0XCIsYS50YXJnZXQ9TmQsQWIoYSksYSl9XG52YXIgU2Q9e2V2ZW50VHlwZXM6TWQsZXh0cmFjdEV2ZW50czpmdW5jdGlvbihhLGIsYyxkKXt2YXIgZT1kLndpbmRvdz09PWQ/ZC5kb2N1bWVudDo5PT09ZC5ub2RlVHlwZT9kOmQub3duZXJEb2N1bWVudCxmO2lmKCEoZj0hZSkpe2E6e2U9SGQoZSk7Zj1TYS5vblNlbGVjdDtmb3IodmFyIGc9MDtnPGYubGVuZ3RoO2crKyl7dmFyIGg9ZltnXTtpZighZS5oYXNPd25Qcm9wZXJ0eShoKXx8IWVbaF0pe2U9ITE7YnJlYWsgYX19ZT0hMH1mPSFlfWlmKGYpcmV0dXJuIG51bGw7ZT1iP3FiKGIpOndpbmRvdztzd2l0Y2goYSl7Y2FzZSBcInRvcEZvY3VzXCI6aWYodmMoZSl8fFwidHJ1ZVwiPT09ZS5jb250ZW50RWRpdGFibGUpTmQ9ZSxPZD1iLFBkPW51bGw7YnJlYWs7Y2FzZSBcInRvcEJsdXJcIjpQZD1PZD1OZD1udWxsO2JyZWFrO2Nhc2UgXCJ0b3BNb3VzZURvd25cIjpRZD0hMDticmVhaztjYXNlIFwidG9wQ29udGV4dE1lbnVcIjpjYXNlIFwidG9wTW91c2VVcFwiOnJldHVybiBRZD0hMSxSZChjLGQpO2Nhc2UgXCJ0b3BTZWxlY3Rpb25DaGFuZ2VcIjppZihMZClicmVhaztcbmNhc2UgXCJ0b3BLZXlEb3duXCI6Y2FzZSBcInRvcEtleVVwXCI6cmV0dXJuIFJkKGMsZCl9cmV0dXJuIG51bGx9fTtmdW5jdGlvbiBUZChhLGIsYyxkKXtyZXR1cm4gVC5jYWxsKHRoaXMsYSxiLGMsZCl9VC5hdWdtZW50Q2xhc3MoVGQse2FuaW1hdGlvbk5hbWU6bnVsbCxlbGFwc2VkVGltZTpudWxsLHBzZXVkb0VsZW1lbnQ6bnVsbH0pO2Z1bmN0aW9uIFVkKGEsYixjLGQpe3JldHVybiBULmNhbGwodGhpcyxhLGIsYyxkKX1ULmF1Z21lbnRDbGFzcyhVZCx7Y2xpcGJvYXJkRGF0YTpmdW5jdGlvbihhKXtyZXR1cm5cImNsaXBib2FyZERhdGFcImluIGE/YS5jbGlwYm9hcmREYXRhOndpbmRvdy5jbGlwYm9hcmREYXRhfX0pO2Z1bmN0aW9uIFZkKGEsYixjLGQpe3JldHVybiBULmNhbGwodGhpcyxhLGIsYyxkKX1iZC5hdWdtZW50Q2xhc3MoVmQse3JlbGF0ZWRUYXJnZXQ6bnVsbH0pO1xuZnVuY3Rpb24gV2QoYSl7dmFyIGI9YS5rZXlDb2RlO1wiY2hhckNvZGVcImluIGE/KGE9YS5jaGFyQ29kZSwwPT09YSYmMTM9PT1iJiYoYT0xMykpOmE9YjtyZXR1cm4gMzI8PWF8fDEzPT09YT9hOjB9XG52YXIgWGQ9e0VzYzpcIkVzY2FwZVwiLFNwYWNlYmFyOlwiIFwiLExlZnQ6XCJBcnJvd0xlZnRcIixVcDpcIkFycm93VXBcIixSaWdodDpcIkFycm93UmlnaHRcIixEb3duOlwiQXJyb3dEb3duXCIsRGVsOlwiRGVsZXRlXCIsV2luOlwiT1NcIixNZW51OlwiQ29udGV4dE1lbnVcIixBcHBzOlwiQ29udGV4dE1lbnVcIixTY3JvbGw6XCJTY3JvbGxMb2NrXCIsTW96UHJpbnRhYmxlS2V5OlwiVW5pZGVudGlmaWVkXCJ9LFlkPXs4OlwiQmFja3NwYWNlXCIsOTpcIlRhYlwiLDEyOlwiQ2xlYXJcIiwxMzpcIkVudGVyXCIsMTY6XCJTaGlmdFwiLDE3OlwiQ29udHJvbFwiLDE4OlwiQWx0XCIsMTk6XCJQYXVzZVwiLDIwOlwiQ2Fwc0xvY2tcIiwyNzpcIkVzY2FwZVwiLDMyOlwiIFwiLDMzOlwiUGFnZVVwXCIsMzQ6XCJQYWdlRG93blwiLDM1OlwiRW5kXCIsMzY6XCJIb21lXCIsMzc6XCJBcnJvd0xlZnRcIiwzODpcIkFycm93VXBcIiwzOTpcIkFycm93UmlnaHRcIiw0MDpcIkFycm93RG93blwiLDQ1OlwiSW5zZXJ0XCIsNDY6XCJEZWxldGVcIiwxMTI6XCJGMVwiLDExMzpcIkYyXCIsMTE0OlwiRjNcIiwxMTU6XCJGNFwiLFxuMTE2OlwiRjVcIiwxMTc6XCJGNlwiLDExODpcIkY3XCIsMTE5OlwiRjhcIiwxMjA6XCJGOVwiLDEyMTpcIkYxMFwiLDEyMjpcIkYxMVwiLDEyMzpcIkYxMlwiLDE0NDpcIk51bUxvY2tcIiwxNDU6XCJTY3JvbGxMb2NrXCIsMjI0OlwiTWV0YVwifTtmdW5jdGlvbiBaZChhLGIsYyxkKXtyZXR1cm4gVC5jYWxsKHRoaXMsYSxiLGMsZCl9XG5iZC5hdWdtZW50Q2xhc3MoWmQse2tleTpmdW5jdGlvbihhKXtpZihhLmtleSl7dmFyIGI9WGRbYS5rZXldfHxhLmtleTtpZihcIlVuaWRlbnRpZmllZFwiIT09YilyZXR1cm4gYn1yZXR1cm5cImtleXByZXNzXCI9PT1hLnR5cGU/KGE9V2QoYSksMTM9PT1hP1wiRW50ZXJcIjpTdHJpbmcuZnJvbUNoYXJDb2RlKGEpKTpcImtleWRvd25cIj09PWEudHlwZXx8XCJrZXl1cFwiPT09YS50eXBlP1lkW2Eua2V5Q29kZV18fFwiVW5pZGVudGlmaWVkXCI6XCJcIn0sbG9jYXRpb246bnVsbCxjdHJsS2V5Om51bGwsc2hpZnRLZXk6bnVsbCxhbHRLZXk6bnVsbCxtZXRhS2V5Om51bGwscmVwZWF0Om51bGwsbG9jYWxlOm51bGwsZ2V0TW9kaWZpZXJTdGF0ZTplZCxjaGFyQ29kZTpmdW5jdGlvbihhKXtyZXR1cm5cImtleXByZXNzXCI9PT1hLnR5cGU/V2QoYSk6MH0sa2V5Q29kZTpmdW5jdGlvbihhKXtyZXR1cm5cImtleWRvd25cIj09PWEudHlwZXx8XCJrZXl1cFwiPT09YS50eXBlP2Eua2V5Q29kZTowfSx3aGljaDpmdW5jdGlvbihhKXtyZXR1cm5cImtleXByZXNzXCI9PT1cbmEudHlwZT9XZChhKTpcImtleWRvd25cIj09PWEudHlwZXx8XCJrZXl1cFwiPT09YS50eXBlP2Eua2V5Q29kZTowfX0pO2Z1bmN0aW9uICRkKGEsYixjLGQpe3JldHVybiBULmNhbGwodGhpcyxhLGIsYyxkKX1mZC5hdWdtZW50Q2xhc3MoJGQse2RhdGFUcmFuc2ZlcjpudWxsfSk7ZnVuY3Rpb24gYWUoYSxiLGMsZCl7cmV0dXJuIFQuY2FsbCh0aGlzLGEsYixjLGQpfWJkLmF1Z21lbnRDbGFzcyhhZSx7dG91Y2hlczpudWxsLHRhcmdldFRvdWNoZXM6bnVsbCxjaGFuZ2VkVG91Y2hlczpudWxsLGFsdEtleTpudWxsLG1ldGFLZXk6bnVsbCxjdHJsS2V5Om51bGwsc2hpZnRLZXk6bnVsbCxnZXRNb2RpZmllclN0YXRlOmVkfSk7ZnVuY3Rpb24gYmUoYSxiLGMsZCl7cmV0dXJuIFQuY2FsbCh0aGlzLGEsYixjLGQpfVQuYXVnbWVudENsYXNzKGJlLHtwcm9wZXJ0eU5hbWU6bnVsbCxlbGFwc2VkVGltZTpudWxsLHBzZXVkb0VsZW1lbnQ6bnVsbH0pO1xuZnVuY3Rpb24gY2UoYSxiLGMsZCl7cmV0dXJuIFQuY2FsbCh0aGlzLGEsYixjLGQpfWZkLmF1Z21lbnRDbGFzcyhjZSx7ZGVsdGFYOmZ1bmN0aW9uKGEpe3JldHVyblwiZGVsdGFYXCJpbiBhP2EuZGVsdGFYOlwid2hlZWxEZWx0YVhcImluIGE/LWEud2hlZWxEZWx0YVg6MH0sZGVsdGFZOmZ1bmN0aW9uKGEpe3JldHVyblwiZGVsdGFZXCJpbiBhP2EuZGVsdGFZOlwid2hlZWxEZWx0YVlcImluIGE/LWEud2hlZWxEZWx0YVk6XCJ3aGVlbERlbHRhXCJpbiBhPy1hLndoZWVsRGVsdGE6MH0sZGVsdGFaOm51bGwsZGVsdGFNb2RlOm51bGx9KTt2YXIgZGU9e30sZWU9e307XG5cImFib3J0IGFuaW1hdGlvbkVuZCBhbmltYXRpb25JdGVyYXRpb24gYW5pbWF0aW9uU3RhcnQgYmx1ciBjYW5jZWwgY2FuUGxheSBjYW5QbGF5VGhyb3VnaCBjbGljayBjbG9zZSBjb250ZXh0TWVudSBjb3B5IGN1dCBkb3VibGVDbGljayBkcmFnIGRyYWdFbmQgZHJhZ0VudGVyIGRyYWdFeGl0IGRyYWdMZWF2ZSBkcmFnT3ZlciBkcmFnU3RhcnQgZHJvcCBkdXJhdGlvbkNoYW5nZSBlbXB0aWVkIGVuY3J5cHRlZCBlbmRlZCBlcnJvciBmb2N1cyBpbnB1dCBpbnZhbGlkIGtleURvd24ga2V5UHJlc3Mga2V5VXAgbG9hZCBsb2FkZWREYXRhIGxvYWRlZE1ldGFkYXRhIGxvYWRTdGFydCBtb3VzZURvd24gbW91c2VNb3ZlIG1vdXNlT3V0IG1vdXNlT3ZlciBtb3VzZVVwIHBhc3RlIHBhdXNlIHBsYXkgcGxheWluZyBwcm9ncmVzcyByYXRlQ2hhbmdlIHJlc2V0IHNjcm9sbCBzZWVrZWQgc2Vla2luZyBzdGFsbGVkIHN1Ym1pdCBzdXNwZW5kIHRpbWVVcGRhdGUgdG9nZ2xlIHRvdWNoQ2FuY2VsIHRvdWNoRW5kIHRvdWNoTW92ZSB0b3VjaFN0YXJ0IHRyYW5zaXRpb25FbmQgdm9sdW1lQ2hhbmdlIHdhaXRpbmcgd2hlZWxcIi5zcGxpdChcIiBcIikuZm9yRWFjaChmdW5jdGlvbihhKXt2YXIgYj1hWzBdLnRvVXBwZXJDYXNlKCkrXG5hLnNsaWNlKDEpLGM9XCJvblwiK2I7Yj1cInRvcFwiK2I7Yz17cGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6e2J1YmJsZWQ6YyxjYXB0dXJlZDpjK1wiQ2FwdHVyZVwifSxkZXBlbmRlbmNpZXM6W2JdfTtkZVthXT1jO2VlW2JdPWN9KTtcbnZhciBmZT17ZXZlbnRUeXBlczpkZSxleHRyYWN0RXZlbnRzOmZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPWVlW2FdO2lmKCFlKXJldHVybiBudWxsO3N3aXRjaChhKXtjYXNlIFwidG9wS2V5UHJlc3NcIjppZigwPT09V2QoYykpcmV0dXJuIG51bGw7Y2FzZSBcInRvcEtleURvd25cIjpjYXNlIFwidG9wS2V5VXBcIjphPVpkO2JyZWFrO2Nhc2UgXCJ0b3BCbHVyXCI6Y2FzZSBcInRvcEZvY3VzXCI6YT1WZDticmVhaztjYXNlIFwidG9wQ2xpY2tcIjppZigyPT09Yy5idXR0b24pcmV0dXJuIG51bGw7Y2FzZSBcInRvcERvdWJsZUNsaWNrXCI6Y2FzZSBcInRvcE1vdXNlRG93blwiOmNhc2UgXCJ0b3BNb3VzZU1vdmVcIjpjYXNlIFwidG9wTW91c2VVcFwiOmNhc2UgXCJ0b3BNb3VzZU91dFwiOmNhc2UgXCJ0b3BNb3VzZU92ZXJcIjpjYXNlIFwidG9wQ29udGV4dE1lbnVcIjphPWZkO2JyZWFrO2Nhc2UgXCJ0b3BEcmFnXCI6Y2FzZSBcInRvcERyYWdFbmRcIjpjYXNlIFwidG9wRHJhZ0VudGVyXCI6Y2FzZSBcInRvcERyYWdFeGl0XCI6Y2FzZSBcInRvcERyYWdMZWF2ZVwiOmNhc2UgXCJ0b3BEcmFnT3ZlclwiOmNhc2UgXCJ0b3BEcmFnU3RhcnRcIjpjYXNlIFwidG9wRHJvcFwiOmE9XG4kZDticmVhaztjYXNlIFwidG9wVG91Y2hDYW5jZWxcIjpjYXNlIFwidG9wVG91Y2hFbmRcIjpjYXNlIFwidG9wVG91Y2hNb3ZlXCI6Y2FzZSBcInRvcFRvdWNoU3RhcnRcIjphPWFlO2JyZWFrO2Nhc2UgXCJ0b3BBbmltYXRpb25FbmRcIjpjYXNlIFwidG9wQW5pbWF0aW9uSXRlcmF0aW9uXCI6Y2FzZSBcInRvcEFuaW1hdGlvblN0YXJ0XCI6YT1UZDticmVhaztjYXNlIFwidG9wVHJhbnNpdGlvbkVuZFwiOmE9YmU7YnJlYWs7Y2FzZSBcInRvcFNjcm9sbFwiOmE9YmQ7YnJlYWs7Y2FzZSBcInRvcFdoZWVsXCI6YT1jZTticmVhaztjYXNlIFwidG9wQ29weVwiOmNhc2UgXCJ0b3BDdXRcIjpjYXNlIFwidG9wUGFzdGVcIjphPVVkO2JyZWFrO2RlZmF1bHQ6YT1UfWI9YS5nZXRQb29sZWQoZSxiLGMsZCk7QWIoYik7cmV0dXJuIGJ9fTtzZD1mdW5jdGlvbihhLGIsYyxkKXthPWpiKGEsYixjLGQpO2tiKGEpO2xiKCExKX07aGIuaW5qZWN0RXZlbnRQbHVnaW5PcmRlcihcIlJlc3BvbmRlckV2ZW50UGx1Z2luIFNpbXBsZUV2ZW50UGx1Z2luIFRhcEV2ZW50UGx1Z2luIEVudGVyTGVhdmVFdmVudFBsdWdpbiBDaGFuZ2VFdmVudFBsdWdpbiBTZWxlY3RFdmVudFBsdWdpbiBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luXCIuc3BsaXQoXCIgXCIpKTtcbldhPXNiLmdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGU7WGE9c2IuZ2V0SW5zdGFuY2VGcm9tTm9kZTtZYT1zYi5nZXROb2RlRnJvbUluc3RhbmNlO2hiLmluamVjdEV2ZW50UGx1Z2luc0J5TmFtZSh7U2ltcGxlRXZlbnRQbHVnaW46ZmUsRW50ZXJMZWF2ZUV2ZW50UGx1Z2luOmhkLENoYW5nZUV2ZW50UGx1Z2luOmFkLFNlbGVjdEV2ZW50UGx1Z2luOlNkLEJlZm9yZUlucHV0RXZlbnRQbHVnaW46aWN9KTt2YXIgZ2U9W10saGU9LTE7ZnVuY3Rpb24gVihhKXswPmhlfHwoYS5jdXJyZW50PWdlW2hlXSxnZVtoZV09bnVsbCxoZS0tKX1mdW5jdGlvbiBXKGEsYil7aGUrKztnZVtoZV09YS5jdXJyZW50O2EuY3VycmVudD1ifW5ldyBTZXQ7dmFyIGllPXtjdXJyZW50OkR9LFg9e2N1cnJlbnQ6ITF9LGplPUQ7ZnVuY3Rpb24ga2UoYSl7cmV0dXJuIGxlKGEpP2plOmllLmN1cnJlbnR9XG5mdW5jdGlvbiBtZShhLGIpe3ZhciBjPWEudHlwZS5jb250ZXh0VHlwZXM7aWYoIWMpcmV0dXJuIEQ7dmFyIGQ9YS5zdGF0ZU5vZGU7aWYoZCYmZC5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZFVubWFza2VkQ2hpbGRDb250ZXh0PT09YilyZXR1cm4gZC5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1hc2tlZENoaWxkQ29udGV4dDt2YXIgZT17fSxmO2ZvcihmIGluIGMpZVtmXT1iW2ZdO2QmJihhPWEuc3RhdGVOb2RlLGEuX19yZWFjdEludGVybmFsTWVtb2l6ZWRVbm1hc2tlZENoaWxkQ29udGV4dD1iLGEuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNYXNrZWRDaGlsZENvbnRleHQ9ZSk7cmV0dXJuIGV9ZnVuY3Rpb24gbGUoYSl7cmV0dXJuIDI9PT1hLnRhZyYmbnVsbCE9YS50eXBlLmNoaWxkQ29udGV4dFR5cGVzfWZ1bmN0aW9uIG5lKGEpe2xlKGEpJiYoVihYLGEpLFYoaWUsYSkpfVxuZnVuY3Rpb24gb2UoYSxiLGMpe251bGwhPWllLmN1cnNvcj9FKFwiMTY4XCIpOnZvaWQgMDtXKGllLGIsYSk7VyhYLGMsYSl9ZnVuY3Rpb24gcGUoYSxiKXt2YXIgYz1hLnN0YXRlTm9kZSxkPWEudHlwZS5jaGlsZENvbnRleHRUeXBlcztpZihcImZ1bmN0aW9uXCIhPT10eXBlb2YgYy5nZXRDaGlsZENvbnRleHQpcmV0dXJuIGI7Yz1jLmdldENoaWxkQ29udGV4dCgpO2Zvcih2YXIgZSBpbiBjKWUgaW4gZD92b2lkIDA6RShcIjEwOFwiLGpkKGEpfHxcIlVua25vd25cIixlKTtyZXR1cm4gQih7fSxiLGMpfWZ1bmN0aW9uIHFlKGEpe2lmKCFsZShhKSlyZXR1cm4hMTt2YXIgYj1hLnN0YXRlTm9kZTtiPWImJmIuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHR8fEQ7amU9aWUuY3VycmVudDtXKGllLGIsYSk7VyhYLFguY3VycmVudCxhKTtyZXR1cm4hMH1cbmZ1bmN0aW9uIHJlKGEsYil7dmFyIGM9YS5zdGF0ZU5vZGU7Yz92b2lkIDA6RShcIjE2OVwiKTtpZihiKXt2YXIgZD1wZShhLGplKTtjLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0PWQ7VihYLGEpO1YoaWUsYSk7VyhpZSxkLGEpfWVsc2UgVihYLGEpO1coWCxiLGEpfVxuZnVuY3Rpb24gWShhLGIsYyl7dGhpcy50YWc9YTt0aGlzLmtleT1iO3RoaXMuc3RhdGVOb2RlPXRoaXMudHlwZT1udWxsO3RoaXMuc2libGluZz10aGlzLmNoaWxkPXRoaXNbXCJyZXR1cm5cIl09bnVsbDt0aGlzLmluZGV4PTA7dGhpcy5tZW1vaXplZFN0YXRlPXRoaXMudXBkYXRlUXVldWU9dGhpcy5tZW1vaXplZFByb3BzPXRoaXMucGVuZGluZ1Byb3BzPXRoaXMucmVmPW51bGw7dGhpcy5pbnRlcm5hbENvbnRleHRUYWc9Yzt0aGlzLmVmZmVjdFRhZz0wO3RoaXMubGFzdEVmZmVjdD10aGlzLmZpcnN0RWZmZWN0PXRoaXMubmV4dEVmZmVjdD1udWxsO3RoaXMuZXhwaXJhdGlvblRpbWU9MDt0aGlzLmFsdGVybmF0ZT1udWxsfVxuZnVuY3Rpb24gc2UoYSxiLGMpe3ZhciBkPWEuYWx0ZXJuYXRlO251bGw9PT1kPyhkPW5ldyBZKGEudGFnLGEua2V5LGEuaW50ZXJuYWxDb250ZXh0VGFnKSxkLnR5cGU9YS50eXBlLGQuc3RhdGVOb2RlPWEuc3RhdGVOb2RlLGQuYWx0ZXJuYXRlPWEsYS5hbHRlcm5hdGU9ZCk6KGQuZWZmZWN0VGFnPTAsZC5uZXh0RWZmZWN0PW51bGwsZC5maXJzdEVmZmVjdD1udWxsLGQubGFzdEVmZmVjdD1udWxsKTtkLmV4cGlyYXRpb25UaW1lPWM7ZC5wZW5kaW5nUHJvcHM9YjtkLmNoaWxkPWEuY2hpbGQ7ZC5tZW1vaXplZFByb3BzPWEubWVtb2l6ZWRQcm9wcztkLm1lbW9pemVkU3RhdGU9YS5tZW1vaXplZFN0YXRlO2QudXBkYXRlUXVldWU9YS51cGRhdGVRdWV1ZTtkLnNpYmxpbmc9YS5zaWJsaW5nO2QuaW5kZXg9YS5pbmRleDtkLnJlZj1hLnJlZjtyZXR1cm4gZH1cbmZ1bmN0aW9uIHRlKGEsYixjKXt2YXIgZD12b2lkIDAsZT1hLnR5cGUsZj1hLmtleTtcImZ1bmN0aW9uXCI9PT10eXBlb2YgZT8oZD1lLnByb3RvdHlwZSYmZS5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudD9uZXcgWSgyLGYsYik6bmV3IFkoMCxmLGIpLGQudHlwZT1lLGQucGVuZGluZ1Byb3BzPWEucHJvcHMpOlwic3RyaW5nXCI9PT10eXBlb2YgZT8oZD1uZXcgWSg1LGYsYiksZC50eXBlPWUsZC5wZW5kaW5nUHJvcHM9YS5wcm9wcyk6XCJvYmplY3RcIj09PXR5cGVvZiBlJiZudWxsIT09ZSYmXCJudW1iZXJcIj09PXR5cGVvZiBlLnRhZz8oZD1lLGQucGVuZGluZ1Byb3BzPWEucHJvcHMpOkUoXCIxMzBcIixudWxsPT1lP2U6dHlwZW9mIGUsXCJcIik7ZC5leHBpcmF0aW9uVGltZT1jO3JldHVybiBkfWZ1bmN0aW9uIHVlKGEsYixjLGQpe2I9bmV3IFkoMTAsZCxiKTtiLnBlbmRpbmdQcm9wcz1hO2IuZXhwaXJhdGlvblRpbWU9YztyZXR1cm4gYn1cbmZ1bmN0aW9uIHZlKGEsYixjKXtiPW5ldyBZKDYsbnVsbCxiKTtiLnBlbmRpbmdQcm9wcz1hO2IuZXhwaXJhdGlvblRpbWU9YztyZXR1cm4gYn1mdW5jdGlvbiB3ZShhLGIsYyl7Yj1uZXcgWSg3LGEua2V5LGIpO2IudHlwZT1hLmhhbmRsZXI7Yi5wZW5kaW5nUHJvcHM9YTtiLmV4cGlyYXRpb25UaW1lPWM7cmV0dXJuIGJ9ZnVuY3Rpb24geGUoYSxiLGMpe2E9bmV3IFkoOSxudWxsLGIpO2EuZXhwaXJhdGlvblRpbWU9YztyZXR1cm4gYX1mdW5jdGlvbiB5ZShhLGIsYyl7Yj1uZXcgWSg0LGEua2V5LGIpO2IucGVuZGluZ1Byb3BzPWEuY2hpbGRyZW58fFtdO2IuZXhwaXJhdGlvblRpbWU9YztiLnN0YXRlTm9kZT17Y29udGFpbmVySW5mbzphLmNvbnRhaW5lckluZm8scGVuZGluZ0NoaWxkcmVuOm51bGwsaW1wbGVtZW50YXRpb246YS5pbXBsZW1lbnRhdGlvbn07cmV0dXJuIGJ9dmFyIHplPW51bGwsQWU9bnVsbDtcbmZ1bmN0aW9uIEJlKGEpe3JldHVybiBmdW5jdGlvbihiKXt0cnl7cmV0dXJuIGEoYil9Y2F0Y2goYyl7fX19ZnVuY3Rpb24gQ2UoYSl7aWYoXCJ1bmRlZmluZWRcIj09PXR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18pcmV0dXJuITE7dmFyIGI9X19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fO2lmKGIuaXNEaXNhYmxlZHx8IWIuc3VwcG9ydHNGaWJlcilyZXR1cm4hMDt0cnl7dmFyIGM9Yi5pbmplY3QoYSk7emU9QmUoZnVuY3Rpb24oYSl7cmV0dXJuIGIub25Db21taXRGaWJlclJvb3QoYyxhKX0pO0FlPUJlKGZ1bmN0aW9uKGEpe3JldHVybiBiLm9uQ29tbWl0RmliZXJVbm1vdW50KGMsYSl9KX1jYXRjaChkKXt9cmV0dXJuITB9ZnVuY3Rpb24gRGUoYSl7XCJmdW5jdGlvblwiPT09dHlwZW9mIHplJiZ6ZShhKX1mdW5jdGlvbiBFZShhKXtcImZ1bmN0aW9uXCI9PT10eXBlb2YgQWUmJkFlKGEpfVxuZnVuY3Rpb24gRmUoYSl7cmV0dXJue2Jhc2VTdGF0ZTphLGV4cGlyYXRpb25UaW1lOjAsZmlyc3Q6bnVsbCxsYXN0Om51bGwsY2FsbGJhY2tMaXN0Om51bGwsaGFzRm9yY2VVcGRhdGU6ITEsaXNJbml0aWFsaXplZDohMX19ZnVuY3Rpb24gR2UoYSxiKXtudWxsPT09YS5sYXN0P2EuZmlyc3Q9YS5sYXN0PWI6KGEubGFzdC5uZXh0PWIsYS5sYXN0PWIpO2lmKDA9PT1hLmV4cGlyYXRpb25UaW1lfHxhLmV4cGlyYXRpb25UaW1lPmIuZXhwaXJhdGlvblRpbWUpYS5leHBpcmF0aW9uVGltZT1iLmV4cGlyYXRpb25UaW1lfVxuZnVuY3Rpb24gSGUoYSxiKXt2YXIgYz1hLmFsdGVybmF0ZSxkPWEudXBkYXRlUXVldWU7bnVsbD09PWQmJihkPWEudXBkYXRlUXVldWU9RmUobnVsbCkpO251bGwhPT1jPyhhPWMudXBkYXRlUXVldWUsbnVsbD09PWEmJihhPWMudXBkYXRlUXVldWU9RmUobnVsbCkpKTphPW51bGw7YT1hIT09ZD9hOm51bGw7bnVsbD09PWE/R2UoZCxiKTpudWxsPT09ZC5sYXN0fHxudWxsPT09YS5sYXN0PyhHZShkLGIpLEdlKGEsYikpOihHZShkLGIpLGEubGFzdD1iKX1mdW5jdGlvbiBJZShhLGIsYyxkKXthPWEucGFydGlhbFN0YXRlO3JldHVyblwiZnVuY3Rpb25cIj09PXR5cGVvZiBhP2EuY2FsbChiLGMsZCk6YX1cbmZ1bmN0aW9uIEplKGEsYixjLGQsZSxmKXtudWxsIT09YSYmYS51cGRhdGVRdWV1ZT09PWMmJihjPWIudXBkYXRlUXVldWU9e2Jhc2VTdGF0ZTpjLmJhc2VTdGF0ZSxleHBpcmF0aW9uVGltZTpjLmV4cGlyYXRpb25UaW1lLGZpcnN0OmMuZmlyc3QsbGFzdDpjLmxhc3QsaXNJbml0aWFsaXplZDpjLmlzSW5pdGlhbGl6ZWQsY2FsbGJhY2tMaXN0Om51bGwsaGFzRm9yY2VVcGRhdGU6ITF9KTtjLmV4cGlyYXRpb25UaW1lPTA7Yy5pc0luaXRpYWxpemVkP2E9Yy5iYXNlU3RhdGU6KGE9Yy5iYXNlU3RhdGU9Yi5tZW1vaXplZFN0YXRlLGMuaXNJbml0aWFsaXplZD0hMCk7Zm9yKHZhciBnPSEwLGg9Yy5maXJzdCxrPSExO251bGwhPT1oOyl7dmFyIHE9aC5leHBpcmF0aW9uVGltZTtpZihxPmYpe3ZhciB2PWMuZXhwaXJhdGlvblRpbWU7aWYoMD09PXZ8fHY+cSljLmV4cGlyYXRpb25UaW1lPXE7a3x8KGs9ITAsYy5iYXNlU3RhdGU9YSl9ZWxzZXtrfHwoYy5maXJzdD1oLm5leHQsbnVsbD09PVxuYy5maXJzdCYmKGMubGFzdD1udWxsKSk7aWYoaC5pc1JlcGxhY2UpYT1JZShoLGQsYSxlKSxnPSEwO2Vsc2UgaWYocT1JZShoLGQsYSxlKSlhPWc/Qih7fSxhLHEpOkIoYSxxKSxnPSExO2guaXNGb3JjZWQmJihjLmhhc0ZvcmNlVXBkYXRlPSEwKTtudWxsIT09aC5jYWxsYmFjayYmKHE9Yy5jYWxsYmFja0xpc3QsbnVsbD09PXEmJihxPWMuY2FsbGJhY2tMaXN0PVtdKSxxLnB1c2goaCkpfWg9aC5uZXh0fW51bGwhPT1jLmNhbGxiYWNrTGlzdD9iLmVmZmVjdFRhZ3w9MzI6bnVsbCE9PWMuZmlyc3R8fGMuaGFzRm9yY2VVcGRhdGV8fChiLnVwZGF0ZVF1ZXVlPW51bGwpO2t8fChjLmJhc2VTdGF0ZT1hKTtyZXR1cm4gYX1cbmZ1bmN0aW9uIEtlKGEsYil7dmFyIGM9YS5jYWxsYmFja0xpc3Q7aWYobnVsbCE9PWMpZm9yKGEuY2FsbGJhY2tMaXN0PW51bGwsYT0wO2E8Yy5sZW5ndGg7YSsrKXt2YXIgZD1jW2FdLGU9ZC5jYWxsYmFjaztkLmNhbGxiYWNrPW51bGw7XCJmdW5jdGlvblwiIT09dHlwZW9mIGU/RShcIjE5MVwiLGUpOnZvaWQgMDtlLmNhbGwoYil9fVxuZnVuY3Rpb24gTGUoYSxiLGMsZCl7ZnVuY3Rpb24gZShhLGIpe2IudXBkYXRlcj1mO2Euc3RhdGVOb2RlPWI7Yi5fcmVhY3RJbnRlcm5hbEZpYmVyPWF9dmFyIGY9e2lzTW91bnRlZDpsZCxlbnF1ZXVlU2V0U3RhdGU6ZnVuY3Rpb24oYyxkLGUpe2M9Yy5fcmVhY3RJbnRlcm5hbEZpYmVyO2U9dm9pZCAwPT09ZT9udWxsOmU7dmFyIGc9YihjKTtIZShjLHtleHBpcmF0aW9uVGltZTpnLHBhcnRpYWxTdGF0ZTpkLGNhbGxiYWNrOmUsaXNSZXBsYWNlOiExLGlzRm9yY2VkOiExLG5leHRDYWxsYmFjazpudWxsLG5leHQ6bnVsbH0pO2EoYyxnKX0sZW5xdWV1ZVJlcGxhY2VTdGF0ZTpmdW5jdGlvbihjLGQsZSl7Yz1jLl9yZWFjdEludGVybmFsRmliZXI7ZT12b2lkIDA9PT1lP251bGw6ZTt2YXIgZz1iKGMpO0hlKGMse2V4cGlyYXRpb25UaW1lOmcscGFydGlhbFN0YXRlOmQsY2FsbGJhY2s6ZSxpc1JlcGxhY2U6ITAsaXNGb3JjZWQ6ITEsbmV4dENhbGxiYWNrOm51bGwsbmV4dDpudWxsfSk7XG5hKGMsZyl9LGVucXVldWVGb3JjZVVwZGF0ZTpmdW5jdGlvbihjLGQpe2M9Yy5fcmVhY3RJbnRlcm5hbEZpYmVyO2Q9dm9pZCAwPT09ZD9udWxsOmQ7dmFyIGU9YihjKTtIZShjLHtleHBpcmF0aW9uVGltZTplLHBhcnRpYWxTdGF0ZTpudWxsLGNhbGxiYWNrOmQsaXNSZXBsYWNlOiExLGlzRm9yY2VkOiEwLG5leHRDYWxsYmFjazpudWxsLG5leHQ6bnVsbH0pO2EoYyxlKX19O3JldHVybnthZG9wdENsYXNzSW5zdGFuY2U6ZSxjb25zdHJ1Y3RDbGFzc0luc3RhbmNlOmZ1bmN0aW9uKGEsYil7dmFyIGM9YS50eXBlLGQ9a2UoYSksZj0yPT09YS50YWcmJm51bGwhPWEudHlwZS5jb250ZXh0VHlwZXMsZz1mP21lKGEsZCk6RDtiPW5ldyBjKGIsZyk7ZShhLGIpO2YmJihhPWEuc3RhdGVOb2RlLGEuX19yZWFjdEludGVybmFsTWVtb2l6ZWRVbm1hc2tlZENoaWxkQ29udGV4dD1kLGEuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNYXNrZWRDaGlsZENvbnRleHQ9Zyk7cmV0dXJuIGJ9LG1vdW50Q2xhc3NJbnN0YW5jZTpmdW5jdGlvbihhLFxuYil7dmFyIGM9YS5hbHRlcm5hdGUsZD1hLnN0YXRlTm9kZSxlPWQuc3RhdGV8fG51bGwsZz1hLnBlbmRpbmdQcm9wcztnP3ZvaWQgMDpFKFwiMTU4XCIpO3ZhciBoPWtlKGEpO2QucHJvcHM9ZztkLnN0YXRlPWEubWVtb2l6ZWRTdGF0ZT1lO2QucmVmcz1EO2QuY29udGV4dD1tZShhLGgpO251bGwhPWEudHlwZSYmbnVsbCE9YS50eXBlLnByb3RvdHlwZSYmITA9PT1hLnR5cGUucHJvdG90eXBlLnVuc3RhYmxlX2lzQXN5bmNSZWFjdENvbXBvbmVudCYmKGEuaW50ZXJuYWxDb250ZXh0VGFnfD0xKTtcImZ1bmN0aW9uXCI9PT10eXBlb2YgZC5jb21wb25lbnRXaWxsTW91bnQmJihlPWQuc3RhdGUsZC5jb21wb25lbnRXaWxsTW91bnQoKSxlIT09ZC5zdGF0ZSYmZi5lbnF1ZXVlUmVwbGFjZVN0YXRlKGQsZC5zdGF0ZSxudWxsKSxlPWEudXBkYXRlUXVldWUsbnVsbCE9PWUmJihkLnN0YXRlPUplKGMsYSxlLGQsZyxiKSkpO1wiZnVuY3Rpb25cIj09PXR5cGVvZiBkLmNvbXBvbmVudERpZE1vdW50JiYoYS5lZmZlY3RUYWd8PVxuNCl9LHVwZGF0ZUNsYXNzSW5zdGFuY2U6ZnVuY3Rpb24oYSxiLGUpe3ZhciBnPWIuc3RhdGVOb2RlO2cucHJvcHM9Yi5tZW1vaXplZFByb3BzO2cuc3RhdGU9Yi5tZW1vaXplZFN0YXRlO3ZhciBoPWIubWVtb2l6ZWRQcm9wcyxrPWIucGVuZGluZ1Byb3BzO2t8fChrPWgsbnVsbD09az9FKFwiMTU5XCIpOnZvaWQgMCk7dmFyIHU9Zy5jb250ZXh0LHo9a2UoYik7ej1tZShiLHopO1wiZnVuY3Rpb25cIiE9PXR5cGVvZiBnLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHN8fGg9PT1rJiZ1PT09enx8KHU9Zy5zdGF0ZSxnLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoayx6KSxnLnN0YXRlIT09dSYmZi5lbnF1ZXVlUmVwbGFjZVN0YXRlKGcsZy5zdGF0ZSxudWxsKSk7dT1iLm1lbW9pemVkU3RhdGU7ZT1udWxsIT09Yi51cGRhdGVRdWV1ZT9KZShhLGIsYi51cGRhdGVRdWV1ZSxnLGssZSk6dTtpZighKGghPT1rfHx1IT09ZXx8WC5jdXJyZW50fHxudWxsIT09Yi51cGRhdGVRdWV1ZSYmYi51cGRhdGVRdWV1ZS5oYXNGb3JjZVVwZGF0ZSkpcmV0dXJuXCJmdW5jdGlvblwiIT09XG50eXBlb2YgZy5jb21wb25lbnREaWRVcGRhdGV8fGg9PT1hLm1lbW9pemVkUHJvcHMmJnU9PT1hLm1lbW9pemVkU3RhdGV8fChiLmVmZmVjdFRhZ3w9NCksITE7dmFyIEc9aztpZihudWxsPT09aHx8bnVsbCE9PWIudXBkYXRlUXVldWUmJmIudXBkYXRlUXVldWUuaGFzRm9yY2VVcGRhdGUpRz0hMDtlbHNle3ZhciBJPWIuc3RhdGVOb2RlLEw9Yi50eXBlO0c9XCJmdW5jdGlvblwiPT09dHlwZW9mIEkuc2hvdWxkQ29tcG9uZW50VXBkYXRlP0kuc2hvdWxkQ29tcG9uZW50VXBkYXRlKEcsZSx6KTpMLnByb3RvdHlwZSYmTC5wcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQ/IWVhKGgsRyl8fCFlYSh1LGUpOiEwfUc/KFwiZnVuY3Rpb25cIj09PXR5cGVvZiBnLmNvbXBvbmVudFdpbGxVcGRhdGUmJmcuY29tcG9uZW50V2lsbFVwZGF0ZShrLGUseiksXCJmdW5jdGlvblwiPT09dHlwZW9mIGcuY29tcG9uZW50RGlkVXBkYXRlJiYoYi5lZmZlY3RUYWd8PTQpKTooXCJmdW5jdGlvblwiIT09dHlwZW9mIGcuY29tcG9uZW50RGlkVXBkYXRlfHxcbmg9PT1hLm1lbW9pemVkUHJvcHMmJnU9PT1hLm1lbW9pemVkU3RhdGV8fChiLmVmZmVjdFRhZ3w9NCksYyhiLGspLGQoYixlKSk7Zy5wcm9wcz1rO2cuc3RhdGU9ZTtnLmNvbnRleHQ9ejtyZXR1cm4gR319fXZhciBRZT1cImZ1bmN0aW9uXCI9PT10eXBlb2YgU3ltYm9sJiZTeW1ib2xbXCJmb3JcIl0sUmU9UWU/U3ltYm9sW1wiZm9yXCJdKFwicmVhY3QuZWxlbWVudFwiKTo2MDEwMyxTZT1RZT9TeW1ib2xbXCJmb3JcIl0oXCJyZWFjdC5jYWxsXCIpOjYwMTA0LFRlPVFlP1N5bWJvbFtcImZvclwiXShcInJlYWN0LnJldHVyblwiKTo2MDEwNSxVZT1RZT9TeW1ib2xbXCJmb3JcIl0oXCJyZWFjdC5wb3J0YWxcIik6NjAxMDYsVmU9UWU/U3ltYm9sW1wiZm9yXCJdKFwicmVhY3QuZnJhZ21lbnRcIik6NjAxMDcsV2U9XCJmdW5jdGlvblwiPT09dHlwZW9mIFN5bWJvbCYmU3ltYm9sLml0ZXJhdG9yO1xuZnVuY3Rpb24gWGUoYSl7aWYobnVsbD09PWF8fFwidW5kZWZpbmVkXCI9PT10eXBlb2YgYSlyZXR1cm4gbnVsbDthPVdlJiZhW1dlXXx8YVtcIkBAaXRlcmF0b3JcIl07cmV0dXJuXCJmdW5jdGlvblwiPT09dHlwZW9mIGE/YTpudWxsfXZhciBZZT1BcnJheS5pc0FycmF5O1xuZnVuY3Rpb24gWmUoYSxiKXt2YXIgYz1iLnJlZjtpZihudWxsIT09YyYmXCJmdW5jdGlvblwiIT09dHlwZW9mIGMpe2lmKGIuX293bmVyKXtiPWIuX293bmVyO3ZhciBkPXZvaWQgMDtiJiYoMiE9PWIudGFnP0UoXCIxMTBcIik6dm9pZCAwLGQ9Yi5zdGF0ZU5vZGUpO2Q/dm9pZCAwOkUoXCIxNDdcIixjKTt2YXIgZT1cIlwiK2M7aWYobnVsbCE9PWEmJm51bGwhPT1hLnJlZiYmYS5yZWYuX3N0cmluZ1JlZj09PWUpcmV0dXJuIGEucmVmO2E9ZnVuY3Rpb24oYSl7dmFyIGI9ZC5yZWZzPT09RD9kLnJlZnM9e306ZC5yZWZzO251bGw9PT1hP2RlbGV0ZSBiW2VdOmJbZV09YX07YS5fc3RyaW5nUmVmPWU7cmV0dXJuIGF9XCJzdHJpbmdcIiE9PXR5cGVvZiBjP0UoXCIxNDhcIik6dm9pZCAwO2IuX293bmVyP3ZvaWQgMDpFKFwiMTQ5XCIsYyl9cmV0dXJuIGN9XG5mdW5jdGlvbiAkZShhLGIpe1widGV4dGFyZWFcIiE9PWEudHlwZSYmRShcIjMxXCIsXCJbb2JqZWN0IE9iamVjdF1cIj09PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChiKT9cIm9iamVjdCB3aXRoIGtleXMge1wiK09iamVjdC5rZXlzKGIpLmpvaW4oXCIsIFwiKStcIn1cIjpiLFwiXCIpfVxuZnVuY3Rpb24gYWYoYSl7ZnVuY3Rpb24gYihiLGMpe2lmKGEpe3ZhciBkPWIubGFzdEVmZmVjdDtudWxsIT09ZD8oZC5uZXh0RWZmZWN0PWMsYi5sYXN0RWZmZWN0PWMpOmIuZmlyc3RFZmZlY3Q9Yi5sYXN0RWZmZWN0PWM7Yy5uZXh0RWZmZWN0PW51bGw7Yy5lZmZlY3RUYWc9OH19ZnVuY3Rpb24gYyhjLGQpe2lmKCFhKXJldHVybiBudWxsO2Zvcig7bnVsbCE9PWQ7KWIoYyxkKSxkPWQuc2libGluZztyZXR1cm4gbnVsbH1mdW5jdGlvbiBkKGEsYil7Zm9yKGE9bmV3IE1hcDtudWxsIT09YjspbnVsbCE9PWIua2V5P2Euc2V0KGIua2V5LGIpOmEuc2V0KGIuaW5kZXgsYiksYj1iLnNpYmxpbmc7cmV0dXJuIGF9ZnVuY3Rpb24gZShhLGIsYyl7YT1zZShhLGIsYyk7YS5pbmRleD0wO2Euc2libGluZz1udWxsO3JldHVybiBhfWZ1bmN0aW9uIGYoYixjLGQpe2IuaW5kZXg9ZDtpZighYSlyZXR1cm4gYztkPWIuYWx0ZXJuYXRlO2lmKG51bGwhPT1kKXJldHVybiBkPWQuaW5kZXgsZDxjPyhiLmVmZmVjdFRhZz1cbjIsYyk6ZDtiLmVmZmVjdFRhZz0yO3JldHVybiBjfWZ1bmN0aW9uIGcoYil7YSYmbnVsbD09PWIuYWx0ZXJuYXRlJiYoYi5lZmZlY3RUYWc9Mik7cmV0dXJuIGJ9ZnVuY3Rpb24gaChhLGIsYyxkKXtpZihudWxsPT09Ynx8NiE9PWIudGFnKXJldHVybiBiPXZlKGMsYS5pbnRlcm5hbENvbnRleHRUYWcsZCksYltcInJldHVyblwiXT1hLGI7Yj1lKGIsYyxkKTtiW1wicmV0dXJuXCJdPWE7cmV0dXJuIGJ9ZnVuY3Rpb24gayhhLGIsYyxkKXtpZihudWxsIT09YiYmYi50eXBlPT09Yy50eXBlKXJldHVybiBkPWUoYixjLnByb3BzLGQpLGQucmVmPVplKGIsYyksZFtcInJldHVyblwiXT1hLGQ7ZD10ZShjLGEuaW50ZXJuYWxDb250ZXh0VGFnLGQpO2QucmVmPVplKGIsYyk7ZFtcInJldHVyblwiXT1hO3JldHVybiBkfWZ1bmN0aW9uIHEoYSxiLGMsZCl7aWYobnVsbD09PWJ8fDchPT1iLnRhZylyZXR1cm4gYj13ZShjLGEuaW50ZXJuYWxDb250ZXh0VGFnLGQpLGJbXCJyZXR1cm5cIl09YSxiO2I9ZShiLGMsZCk7XG5iW1wicmV0dXJuXCJdPWE7cmV0dXJuIGJ9ZnVuY3Rpb24gdihhLGIsYyxkKXtpZihudWxsPT09Ynx8OSE9PWIudGFnKXJldHVybiBiPXhlKGMsYS5pbnRlcm5hbENvbnRleHRUYWcsZCksYi50eXBlPWMudmFsdWUsYltcInJldHVyblwiXT1hLGI7Yj1lKGIsbnVsbCxkKTtiLnR5cGU9Yy52YWx1ZTtiW1wicmV0dXJuXCJdPWE7cmV0dXJuIGJ9ZnVuY3Rpb24geShhLGIsYyxkKXtpZihudWxsPT09Ynx8NCE9PWIudGFnfHxiLnN0YXRlTm9kZS5jb250YWluZXJJbmZvIT09Yy5jb250YWluZXJJbmZvfHxiLnN0YXRlTm9kZS5pbXBsZW1lbnRhdGlvbiE9PWMuaW1wbGVtZW50YXRpb24pcmV0dXJuIGI9eWUoYyxhLmludGVybmFsQ29udGV4dFRhZyxkKSxiW1wicmV0dXJuXCJdPWEsYjtiPWUoYixjLmNoaWxkcmVufHxbXSxkKTtiW1wicmV0dXJuXCJdPWE7cmV0dXJuIGJ9ZnVuY3Rpb24gdShhLGIsYyxkLGYpe2lmKG51bGw9PT1ifHwxMCE9PWIudGFnKXJldHVybiBiPXVlKGMsYS5pbnRlcm5hbENvbnRleHRUYWcsXG5kLGYpLGJbXCJyZXR1cm5cIl09YSxiO2I9ZShiLGMsZCk7YltcInJldHVyblwiXT1hO3JldHVybiBifWZ1bmN0aW9uIHooYSxiLGMpe2lmKFwic3RyaW5nXCI9PT10eXBlb2YgYnx8XCJudW1iZXJcIj09PXR5cGVvZiBiKXJldHVybiBiPXZlKFwiXCIrYixhLmludGVybmFsQ29udGV4dFRhZyxjKSxiW1wicmV0dXJuXCJdPWEsYjtpZihcIm9iamVjdFwiPT09dHlwZW9mIGImJm51bGwhPT1iKXtzd2l0Y2goYi4kJHR5cGVvZil7Y2FzZSBSZTppZihiLnR5cGU9PT1WZSlyZXR1cm4gYj11ZShiLnByb3BzLmNoaWxkcmVuLGEuaW50ZXJuYWxDb250ZXh0VGFnLGMsYi5rZXkpLGJbXCJyZXR1cm5cIl09YSxiO2M9dGUoYixhLmludGVybmFsQ29udGV4dFRhZyxjKTtjLnJlZj1aZShudWxsLGIpO2NbXCJyZXR1cm5cIl09YTtyZXR1cm4gYztjYXNlIFNlOnJldHVybiBiPXdlKGIsYS5pbnRlcm5hbENvbnRleHRUYWcsYyksYltcInJldHVyblwiXT1hLGI7Y2FzZSBUZTpyZXR1cm4gYz14ZShiLGEuaW50ZXJuYWxDb250ZXh0VGFnLFxuYyksYy50eXBlPWIudmFsdWUsY1tcInJldHVyblwiXT1hLGM7Y2FzZSBVZTpyZXR1cm4gYj15ZShiLGEuaW50ZXJuYWxDb250ZXh0VGFnLGMpLGJbXCJyZXR1cm5cIl09YSxifWlmKFllKGIpfHxYZShiKSlyZXR1cm4gYj11ZShiLGEuaW50ZXJuYWxDb250ZXh0VGFnLGMsbnVsbCksYltcInJldHVyblwiXT1hLGI7JGUoYSxiKX1yZXR1cm4gbnVsbH1mdW5jdGlvbiBHKGEsYixjLGQpe3ZhciBlPW51bGwhPT1iP2Iua2V5Om51bGw7aWYoXCJzdHJpbmdcIj09PXR5cGVvZiBjfHxcIm51bWJlclwiPT09dHlwZW9mIGMpcmV0dXJuIG51bGwhPT1lP251bGw6aChhLGIsXCJcIitjLGQpO2lmKFwib2JqZWN0XCI9PT10eXBlb2YgYyYmbnVsbCE9PWMpe3N3aXRjaChjLiQkdHlwZW9mKXtjYXNlIFJlOnJldHVybiBjLmtleT09PWU/Yy50eXBlPT09VmU/dShhLGIsYy5wcm9wcy5jaGlsZHJlbixkLGUpOmsoYSxiLGMsZCk6bnVsbDtjYXNlIFNlOnJldHVybiBjLmtleT09PWU/cShhLGIsYyxkKTpudWxsO2Nhc2UgVGU6cmV0dXJuIG51bGw9PT1cbmU/dihhLGIsYyxkKTpudWxsO2Nhc2UgVWU6cmV0dXJuIGMua2V5PT09ZT95KGEsYixjLGQpOm51bGx9aWYoWWUoYyl8fFhlKGMpKXJldHVybiBudWxsIT09ZT9udWxsOnUoYSxiLGMsZCxudWxsKTskZShhLGMpfXJldHVybiBudWxsfWZ1bmN0aW9uIEkoYSxiLGMsZCxlKXtpZihcInN0cmluZ1wiPT09dHlwZW9mIGR8fFwibnVtYmVyXCI9PT10eXBlb2YgZClyZXR1cm4gYT1hLmdldChjKXx8bnVsbCxoKGIsYSxcIlwiK2QsZSk7aWYoXCJvYmplY3RcIj09PXR5cGVvZiBkJiZudWxsIT09ZCl7c3dpdGNoKGQuJCR0eXBlb2Ype2Nhc2UgUmU6cmV0dXJuIGE9YS5nZXQobnVsbD09PWQua2V5P2M6ZC5rZXkpfHxudWxsLGQudHlwZT09PVZlP3UoYixhLGQucHJvcHMuY2hpbGRyZW4sZSxkLmtleSk6ayhiLGEsZCxlKTtjYXNlIFNlOnJldHVybiBhPWEuZ2V0KG51bGw9PT1kLmtleT9jOmQua2V5KXx8bnVsbCxxKGIsYSxkLGUpO2Nhc2UgVGU6cmV0dXJuIGE9YS5nZXQoYyl8fG51bGwsdihiLGEsZCxlKTtjYXNlIFVlOnJldHVybiBhPVxuYS5nZXQobnVsbD09PWQua2V5P2M6ZC5rZXkpfHxudWxsLHkoYixhLGQsZSl9aWYoWWUoZCl8fFhlKGQpKXJldHVybiBhPWEuZ2V0KGMpfHxudWxsLHUoYixhLGQsZSxudWxsKTskZShiLGQpfXJldHVybiBudWxsfWZ1bmN0aW9uIEwoZSxnLG0sQSl7Zm9yKHZhciBoPW51bGwscj1udWxsLG49Zyx3PWc9MCxrPW51bGw7bnVsbCE9PW4mJnc8bS5sZW5ndGg7dysrKXtuLmluZGV4Pnc/KGs9bixuPW51bGwpOms9bi5zaWJsaW5nO3ZhciB4PUcoZSxuLG1bd10sQSk7aWYobnVsbD09PXgpe251bGw9PT1uJiYobj1rKTticmVha31hJiZuJiZudWxsPT09eC5hbHRlcm5hdGUmJmIoZSxuKTtnPWYoeCxnLHcpO251bGw9PT1yP2g9eDpyLnNpYmxpbmc9eDtyPXg7bj1rfWlmKHc9PT1tLmxlbmd0aClyZXR1cm4gYyhlLG4pLGg7aWYobnVsbD09PW4pe2Zvcig7dzxtLmxlbmd0aDt3KyspaWYobj16KGUsbVt3XSxBKSlnPWYobixnLHcpLG51bGw9PT1yP2g9bjpyLnNpYmxpbmc9bixyPW47cmV0dXJuIGh9Zm9yKG49XG5kKGUsbik7dzxtLmxlbmd0aDt3KyspaWYoaz1JKG4sZSx3LG1bd10sQSkpe2lmKGEmJm51bGwhPT1rLmFsdGVybmF0ZSluW1wiZGVsZXRlXCJdKG51bGw9PT1rLmtleT93Omsua2V5KTtnPWYoayxnLHcpO251bGw9PT1yP2g9azpyLnNpYmxpbmc9aztyPWt9YSYmbi5mb3JFYWNoKGZ1bmN0aW9uKGEpe3JldHVybiBiKGUsYSl9KTtyZXR1cm4gaH1mdW5jdGlvbiBOKGUsZyxtLEEpe3ZhciBoPVhlKG0pO1wiZnVuY3Rpb25cIiE9PXR5cGVvZiBoP0UoXCIxNTBcIik6dm9pZCAwO209aC5jYWxsKG0pO251bGw9PW0/RShcIjE1MVwiKTp2b2lkIDA7Zm9yKHZhciByPWg9bnVsbCxuPWcsdz1nPTAsaz1udWxsLHg9bS5uZXh0KCk7bnVsbCE9PW4mJiF4LmRvbmU7dysrLHg9bS5uZXh0KCkpe24uaW5kZXg+dz8oaz1uLG49bnVsbCk6az1uLnNpYmxpbmc7dmFyIEo9RyhlLG4seC52YWx1ZSxBKTtpZihudWxsPT09Sil7bnx8KG49ayk7YnJlYWt9YSYmbiYmbnVsbD09PUouYWx0ZXJuYXRlJiZiKGUsbik7Zz1mKEosXG5nLHcpO251bGw9PT1yP2g9SjpyLnNpYmxpbmc9SjtyPUo7bj1rfWlmKHguZG9uZSlyZXR1cm4gYyhlLG4pLGg7aWYobnVsbD09PW4pe2Zvcig7IXguZG9uZTt3KysseD1tLm5leHQoKSl4PXooZSx4LnZhbHVlLEEpLG51bGwhPT14JiYoZz1mKHgsZyx3KSxudWxsPT09cj9oPXg6ci5zaWJsaW5nPXgscj14KTtyZXR1cm4gaH1mb3Iobj1kKGUsbik7IXguZG9uZTt3KysseD1tLm5leHQoKSlpZih4PUkobixlLHcseC52YWx1ZSxBKSxudWxsIT09eCl7aWYoYSYmbnVsbCE9PXguYWx0ZXJuYXRlKW5bXCJkZWxldGVcIl0obnVsbD09PXgua2V5P3c6eC5rZXkpO2c9Zih4LGcsdyk7bnVsbD09PXI/aD14OnIuc2libGluZz14O3I9eH1hJiZuLmZvckVhY2goZnVuY3Rpb24oYSl7cmV0dXJuIGIoZSxhKX0pO3JldHVybiBofXJldHVybiBmdW5jdGlvbihhLGQsZixoKXtcIm9iamVjdFwiPT09dHlwZW9mIGYmJm51bGwhPT1mJiZmLnR5cGU9PT1WZSYmbnVsbD09PWYua2V5JiYoZj1mLnByb3BzLmNoaWxkcmVuKTtcbnZhciBtPVwib2JqZWN0XCI9PT10eXBlb2YgZiYmbnVsbCE9PWY7aWYobSlzd2l0Y2goZi4kJHR5cGVvZil7Y2FzZSBSZTphOnt2YXIgcj1mLmtleTtmb3IobT1kO251bGwhPT1tOyl7aWYobS5rZXk9PT1yKWlmKDEwPT09bS50YWc/Zi50eXBlPT09VmU6bS50eXBlPT09Zi50eXBlKXtjKGEsbS5zaWJsaW5nKTtkPWUobSxmLnR5cGU9PT1WZT9mLnByb3BzLmNoaWxkcmVuOmYucHJvcHMsaCk7ZC5yZWY9WmUobSxmKTtkW1wicmV0dXJuXCJdPWE7YT1kO2JyZWFrIGF9ZWxzZXtjKGEsbSk7YnJlYWt9ZWxzZSBiKGEsbSk7bT1tLnNpYmxpbmd9Zi50eXBlPT09VmU/KGQ9dWUoZi5wcm9wcy5jaGlsZHJlbixhLmludGVybmFsQ29udGV4dFRhZyxoLGYua2V5KSxkW1wicmV0dXJuXCJdPWEsYT1kKTooaD10ZShmLGEuaW50ZXJuYWxDb250ZXh0VGFnLGgpLGgucmVmPVplKGQsZiksaFtcInJldHVyblwiXT1hLGE9aCl9cmV0dXJuIGcoYSk7Y2FzZSBTZTphOntmb3IobT1mLmtleTtudWxsIT09ZDspe2lmKGQua2V5PT09XG5tKWlmKDc9PT1kLnRhZyl7YyhhLGQuc2libGluZyk7ZD1lKGQsZixoKTtkW1wicmV0dXJuXCJdPWE7YT1kO2JyZWFrIGF9ZWxzZXtjKGEsZCk7YnJlYWt9ZWxzZSBiKGEsZCk7ZD1kLnNpYmxpbmd9ZD13ZShmLGEuaW50ZXJuYWxDb250ZXh0VGFnLGgpO2RbXCJyZXR1cm5cIl09YTthPWR9cmV0dXJuIGcoYSk7Y2FzZSBUZTphOntpZihudWxsIT09ZClpZig5PT09ZC50YWcpe2MoYSxkLnNpYmxpbmcpO2Q9ZShkLG51bGwsaCk7ZC50eXBlPWYudmFsdWU7ZFtcInJldHVyblwiXT1hO2E9ZDticmVhayBhfWVsc2UgYyhhLGQpO2Q9eGUoZixhLmludGVybmFsQ29udGV4dFRhZyxoKTtkLnR5cGU9Zi52YWx1ZTtkW1wicmV0dXJuXCJdPWE7YT1kfXJldHVybiBnKGEpO2Nhc2UgVWU6YTp7Zm9yKG09Zi5rZXk7bnVsbCE9PWQ7KXtpZihkLmtleT09PW0paWYoND09PWQudGFnJiZkLnN0YXRlTm9kZS5jb250YWluZXJJbmZvPT09Zi5jb250YWluZXJJbmZvJiZkLnN0YXRlTm9kZS5pbXBsZW1lbnRhdGlvbj09PVxuZi5pbXBsZW1lbnRhdGlvbil7YyhhLGQuc2libGluZyk7ZD1lKGQsZi5jaGlsZHJlbnx8W10saCk7ZFtcInJldHVyblwiXT1hO2E9ZDticmVhayBhfWVsc2V7YyhhLGQpO2JyZWFrfWVsc2UgYihhLGQpO2Q9ZC5zaWJsaW5nfWQ9eWUoZixhLmludGVybmFsQ29udGV4dFRhZyxoKTtkW1wicmV0dXJuXCJdPWE7YT1kfXJldHVybiBnKGEpfWlmKFwic3RyaW5nXCI9PT10eXBlb2YgZnx8XCJudW1iZXJcIj09PXR5cGVvZiBmKXJldHVybiBmPVwiXCIrZixudWxsIT09ZCYmNj09PWQudGFnPyhjKGEsZC5zaWJsaW5nKSxkPWUoZCxmLGgpKTooYyhhLGQpLGQ9dmUoZixhLmludGVybmFsQ29udGV4dFRhZyxoKSksZFtcInJldHVyblwiXT1hLGE9ZCxnKGEpO2lmKFllKGYpKXJldHVybiBMKGEsZCxmLGgpO2lmKFhlKGYpKXJldHVybiBOKGEsZCxmLGgpO20mJiRlKGEsZik7aWYoXCJ1bmRlZmluZWRcIj09PXR5cGVvZiBmKXN3aXRjaChhLnRhZyl7Y2FzZSAyOmNhc2UgMTpoPWEudHlwZSxFKFwiMTUyXCIsaC5kaXNwbGF5TmFtZXx8XG5oLm5hbWV8fFwiQ29tcG9uZW50XCIpfXJldHVybiBjKGEsZCl9fXZhciBiZj1hZighMCksY2Y9YWYoITEpO1xuZnVuY3Rpb24gZGYoYSxiLGMsZCxlKXtmdW5jdGlvbiBmKGEsYixjKXt2YXIgZD1iLmV4cGlyYXRpb25UaW1lO2IuY2hpbGQ9bnVsbD09PWE/Y2YoYixudWxsLGMsZCk6YmYoYixhLmNoaWxkLGMsZCl9ZnVuY3Rpb24gZyhhLGIpe3ZhciBjPWIucmVmO251bGw9PT1jfHxhJiZhLnJlZj09PWN8fChiLmVmZmVjdFRhZ3w9MTI4KX1mdW5jdGlvbiBoKGEsYixjLGQpe2coYSxiKTtpZighYylyZXR1cm4gZCYmcmUoYiwhMSkscShhLGIpO2M9Yi5zdGF0ZU5vZGU7aWQuY3VycmVudD1iO3ZhciBlPWMucmVuZGVyKCk7Yi5lZmZlY3RUYWd8PTE7ZihhLGIsZSk7Yi5tZW1vaXplZFN0YXRlPWMuc3RhdGU7Yi5tZW1vaXplZFByb3BzPWMucHJvcHM7ZCYmcmUoYiwhMCk7cmV0dXJuIGIuY2hpbGR9ZnVuY3Rpb24gayhhKXt2YXIgYj1hLnN0YXRlTm9kZTtiLnBlbmRpbmdDb250ZXh0P29lKGEsYi5wZW5kaW5nQ29udGV4dCxiLnBlbmRpbmdDb250ZXh0IT09Yi5jb250ZXh0KTpiLmNvbnRleHQmJm9lKGEsXG5iLmNvbnRleHQsITEpO0koYSxiLmNvbnRhaW5lckluZm8pfWZ1bmN0aW9uIHEoYSxiKXtudWxsIT09YSYmYi5jaGlsZCE9PWEuY2hpbGQ/RShcIjE1M1wiKTp2b2lkIDA7aWYobnVsbCE9PWIuY2hpbGQpe2E9Yi5jaGlsZDt2YXIgYz1zZShhLGEucGVuZGluZ1Byb3BzLGEuZXhwaXJhdGlvblRpbWUpO2IuY2hpbGQ9Yztmb3IoY1tcInJldHVyblwiXT1iO251bGwhPT1hLnNpYmxpbmc7KWE9YS5zaWJsaW5nLGM9Yy5zaWJsaW5nPXNlKGEsYS5wZW5kaW5nUHJvcHMsYS5leHBpcmF0aW9uVGltZSksY1tcInJldHVyblwiXT1iO2Muc2libGluZz1udWxsfXJldHVybiBiLmNoaWxkfWZ1bmN0aW9uIHYoYSxiKXtzd2l0Y2goYi50YWcpe2Nhc2UgMzprKGIpO2JyZWFrO2Nhc2UgMjpxZShiKTticmVhaztjYXNlIDQ6SShiLGIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pfXJldHVybiBudWxsfXZhciB5PWEuc2hvdWxkU2V0VGV4dENvbnRlbnQsdT1hLnVzZVN5bmNTY2hlZHVsaW5nLHo9YS5zaG91bGREZXByaW9yaXRpemVTdWJ0cmVlLFxuRz1iLnB1c2hIb3N0Q29udGV4dCxJPWIucHVzaEhvc3RDb250YWluZXIsTD1jLmVudGVySHlkcmF0aW9uU3RhdGUsTj1jLnJlc2V0SHlkcmF0aW9uU3RhdGUsSj1jLnRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlO2E9TGUoZCxlLGZ1bmN0aW9uKGEsYil7YS5tZW1vaXplZFByb3BzPWJ9LGZ1bmN0aW9uKGEsYil7YS5tZW1vaXplZFN0YXRlPWJ9KTt2YXIgdz1hLmFkb3B0Q2xhc3NJbnN0YW5jZSxtPWEuY29uc3RydWN0Q2xhc3NJbnN0YW5jZSxBPWEubW91bnRDbGFzc0luc3RhbmNlLE9iPWEudXBkYXRlQ2xhc3NJbnN0YW5jZTtyZXR1cm57YmVnaW5Xb3JrOmZ1bmN0aW9uKGEsYixjKXtpZigwPT09Yi5leHBpcmF0aW9uVGltZXx8Yi5leHBpcmF0aW9uVGltZT5jKXJldHVybiB2KGEsYik7c3dpdGNoKGIudGFnKXtjYXNlIDA6bnVsbCE9PWE/RShcIjE1NVwiKTp2b2lkIDA7dmFyIGQ9Yi50eXBlLGU9Yi5wZW5kaW5nUHJvcHMscj1rZShiKTtyPW1lKGIscik7ZD1kKGUscik7Yi5lZmZlY3RUYWd8PVxuMTtcIm9iamVjdFwiPT09dHlwZW9mIGQmJm51bGwhPT1kJiZcImZ1bmN0aW9uXCI9PT10eXBlb2YgZC5yZW5kZXI/KGIudGFnPTIsZT1xZShiKSx3KGIsZCksQShiLGMpLGI9aChhLGIsITAsZSkpOihiLnRhZz0xLGYoYSxiLGQpLGIubWVtb2l6ZWRQcm9wcz1lLGI9Yi5jaGlsZCk7cmV0dXJuIGI7Y2FzZSAxOmE6e2U9Yi50eXBlO2M9Yi5wZW5kaW5nUHJvcHM7ZD1iLm1lbW9pemVkUHJvcHM7aWYoWC5jdXJyZW50KW51bGw9PT1jJiYoYz1kKTtlbHNlIGlmKG51bGw9PT1jfHxkPT09Yyl7Yj1xKGEsYik7YnJlYWsgYX1kPWtlKGIpO2Q9bWUoYixkKTtlPWUoYyxkKTtiLmVmZmVjdFRhZ3w9MTtmKGEsYixlKTtiLm1lbW9pemVkUHJvcHM9YztiPWIuY2hpbGR9cmV0dXJuIGI7Y2FzZSAyOnJldHVybiBlPXFlKGIpLGQ9dm9pZCAwLG51bGw9PT1hP2Iuc3RhdGVOb2RlP0UoXCIxNTNcIik6KG0oYixiLnBlbmRpbmdQcm9wcyksQShiLGMpLGQ9ITApOmQ9T2IoYSxiLGMpLGgoYSxiLGQsZSk7Y2FzZSAzOnJldHVybiBrKGIpLFxuZT1iLnVwZGF0ZVF1ZXVlLG51bGwhPT1lPyhkPWIubWVtb2l6ZWRTdGF0ZSxlPUplKGEsYixlLG51bGwsbnVsbCxjKSxkPT09ZT8oTigpLGI9cShhLGIpKTooZD1lLmVsZW1lbnQscj1iLnN0YXRlTm9kZSwobnVsbD09PWF8fG51bGw9PT1hLmNoaWxkKSYmci5oeWRyYXRlJiZMKGIpPyhiLmVmZmVjdFRhZ3w9MixiLmNoaWxkPWNmKGIsbnVsbCxkLGMpKTooTigpLGYoYSxiLGQpKSxiLm1lbW9pemVkU3RhdGU9ZSxiPWIuY2hpbGQpKTooTigpLGI9cShhLGIpKSxiO2Nhc2UgNTpHKGIpO251bGw9PT1hJiZKKGIpO2U9Yi50eXBlO3ZhciBuPWIubWVtb2l6ZWRQcm9wcztkPWIucGVuZGluZ1Byb3BzO251bGw9PT1kJiYoZD1uLG51bGw9PT1kP0UoXCIxNTRcIik6dm9pZCAwKTtyPW51bGwhPT1hP2EubWVtb2l6ZWRQcm9wczpudWxsO1guY3VycmVudHx8bnVsbCE9PWQmJm4hPT1kPyhuPWQuY2hpbGRyZW4seShlLGQpP249bnVsbDpyJiZ5KGUscikmJihiLmVmZmVjdFRhZ3w9MTYpLGcoYSxiKSxcbjIxNDc0ODM2NDchPT1jJiYhdSYmeihlLGQpPyhiLmV4cGlyYXRpb25UaW1lPTIxNDc0ODM2NDcsYj1udWxsKTooZihhLGIsbiksYi5tZW1vaXplZFByb3BzPWQsYj1iLmNoaWxkKSk6Yj1xKGEsYik7cmV0dXJuIGI7Y2FzZSA2OnJldHVybiBudWxsPT09YSYmSihiKSxhPWIucGVuZGluZ1Byb3BzLG51bGw9PT1hJiYoYT1iLm1lbW9pemVkUHJvcHMpLGIubWVtb2l6ZWRQcm9wcz1hLG51bGw7Y2FzZSA4OmIudGFnPTc7Y2FzZSA3OmU9Yi5wZW5kaW5nUHJvcHM7aWYoWC5jdXJyZW50KW51bGw9PT1lJiYoZT1hJiZhLm1lbW9pemVkUHJvcHMsbnVsbD09PWU/RShcIjE1NFwiKTp2b2lkIDApO2Vsc2UgaWYobnVsbD09PWV8fGIubWVtb2l6ZWRQcm9wcz09PWUpZT1iLm1lbW9pemVkUHJvcHM7ZD1lLmNoaWxkcmVuO2Iuc3RhdGVOb2RlPW51bGw9PT1hP2NmKGIsYi5zdGF0ZU5vZGUsZCxjKTpiZihiLGIuc3RhdGVOb2RlLGQsYyk7Yi5tZW1vaXplZFByb3BzPWU7cmV0dXJuIGIuc3RhdGVOb2RlO1xuY2FzZSA5OnJldHVybiBudWxsO2Nhc2UgNDphOntJKGIsYi5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyk7ZT1iLnBlbmRpbmdQcm9wcztpZihYLmN1cnJlbnQpbnVsbD09PWUmJihlPWEmJmEubWVtb2l6ZWRQcm9wcyxudWxsPT1lP0UoXCIxNTRcIik6dm9pZCAwKTtlbHNlIGlmKG51bGw9PT1lfHxiLm1lbW9pemVkUHJvcHM9PT1lKXtiPXEoYSxiKTticmVhayBhfW51bGw9PT1hP2IuY2hpbGQ9YmYoYixudWxsLGUsYyk6ZihhLGIsZSk7Yi5tZW1vaXplZFByb3BzPWU7Yj1iLmNoaWxkfXJldHVybiBiO2Nhc2UgMTA6YTp7Yz1iLnBlbmRpbmdQcm9wcztpZihYLmN1cnJlbnQpbnVsbD09PWMmJihjPWIubWVtb2l6ZWRQcm9wcyk7ZWxzZSBpZihudWxsPT09Y3x8Yi5tZW1vaXplZFByb3BzPT09Yyl7Yj1xKGEsYik7YnJlYWsgYX1mKGEsYixjKTtiLm1lbW9pemVkUHJvcHM9YztiPWIuY2hpbGR9cmV0dXJuIGI7ZGVmYXVsdDpFKFwiMTU2XCIpfX0sYmVnaW5GYWlsZWRXb3JrOmZ1bmN0aW9uKGEsYixcbmMpe3N3aXRjaChiLnRhZyl7Y2FzZSAyOnFlKGIpO2JyZWFrO2Nhc2UgMzprKGIpO2JyZWFrO2RlZmF1bHQ6RShcIjE1N1wiKX1iLmVmZmVjdFRhZ3w9NjQ7bnVsbD09PWE/Yi5jaGlsZD1udWxsOmIuY2hpbGQhPT1hLmNoaWxkJiYoYi5jaGlsZD1hLmNoaWxkKTtpZigwPT09Yi5leHBpcmF0aW9uVGltZXx8Yi5leHBpcmF0aW9uVGltZT5jKXJldHVybiB2KGEsYik7Yi5maXJzdEVmZmVjdD1udWxsO2IubGFzdEVmZmVjdD1udWxsO2IuY2hpbGQ9bnVsbD09PWE/Y2YoYixudWxsLG51bGwsYyk6YmYoYixhLmNoaWxkLG51bGwsYyk7Mj09PWIudGFnJiYoYT1iLnN0YXRlTm9kZSxiLm1lbW9pemVkUHJvcHM9YS5wcm9wcyxiLm1lbW9pemVkU3RhdGU9YS5zdGF0ZSk7cmV0dXJuIGIuY2hpbGR9fX1cbmZ1bmN0aW9uIGVmKGEsYixjKXtmdW5jdGlvbiBkKGEpe2EuZWZmZWN0VGFnfD00fXZhciBlPWEuY3JlYXRlSW5zdGFuY2UsZj1hLmNyZWF0ZVRleHRJbnN0YW5jZSxnPWEuYXBwZW5kSW5pdGlhbENoaWxkLGg9YS5maW5hbGl6ZUluaXRpYWxDaGlsZHJlbixrPWEucHJlcGFyZVVwZGF0ZSxxPWEucGVyc2lzdGVuY2Usdj1iLmdldFJvb3RIb3N0Q29udGFpbmVyLHk9Yi5wb3BIb3N0Q29udGV4dCx1PWIuZ2V0SG9zdENvbnRleHQsej1iLnBvcEhvc3RDb250YWluZXIsRz1jLnByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2UsST1jLnByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlLEw9Yy5wb3BIeWRyYXRpb25TdGF0ZSxOPXZvaWQgMCxKPXZvaWQgMCx3PXZvaWQgMDthLm11dGF0aW9uPyhOPWZ1bmN0aW9uKCl7fSxKPWZ1bmN0aW9uKGEsYixjKXsoYi51cGRhdGVRdWV1ZT1jKSYmZChiKX0sdz1mdW5jdGlvbihhLGIsYyxlKXtjIT09ZSYmZChiKX0pOnE/RShcIjIzNVwiKTpFKFwiMjM2XCIpO1xucmV0dXJue2NvbXBsZXRlV29yazpmdW5jdGlvbihhLGIsYyl7dmFyIG09Yi5wZW5kaW5nUHJvcHM7aWYobnVsbD09PW0pbT1iLm1lbW9pemVkUHJvcHM7ZWxzZSBpZigyMTQ3NDgzNjQ3IT09Yi5leHBpcmF0aW9uVGltZXx8MjE0NzQ4MzY0Nz09PWMpYi5wZW5kaW5nUHJvcHM9bnVsbDtzd2l0Y2goYi50YWcpe2Nhc2UgMTpyZXR1cm4gbnVsbDtjYXNlIDI6cmV0dXJuIG5lKGIpLG51bGw7Y2FzZSAzOnooYik7VihYLGIpO1YoaWUsYik7bT1iLnN0YXRlTm9kZTttLnBlbmRpbmdDb250ZXh0JiYobS5jb250ZXh0PW0ucGVuZGluZ0NvbnRleHQsbS5wZW5kaW5nQ29udGV4dD1udWxsKTtpZihudWxsPT09YXx8bnVsbD09PWEuY2hpbGQpTChiKSxiLmVmZmVjdFRhZyY9LTM7TihiKTtyZXR1cm4gbnVsbDtjYXNlIDU6eShiKTtjPXYoKTt2YXIgQT1iLnR5cGU7aWYobnVsbCE9PWEmJm51bGwhPWIuc3RhdGVOb2RlKXt2YXIgcD1hLm1lbW9pemVkUHJvcHMscT1iLnN0YXRlTm9kZSx4PXUoKTtxPVxuayhxLEEscCxtLGMseCk7SihhLGIscSxBLHAsbSxjKTthLnJlZiE9PWIucmVmJiYoYi5lZmZlY3RUYWd8PTEyOCl9ZWxzZXtpZighbSlyZXR1cm4gbnVsbD09PWIuc3RhdGVOb2RlP0UoXCIxNjZcIik6dm9pZCAwLG51bGw7YT11KCk7aWYoTChiKSlHKGIsYyxhKSYmZChiKTtlbHNle2E9ZShBLG0sYyxhLGIpO2E6Zm9yKHA9Yi5jaGlsZDtudWxsIT09cDspe2lmKDU9PT1wLnRhZ3x8Nj09PXAudGFnKWcoYSxwLnN0YXRlTm9kZSk7ZWxzZSBpZig0IT09cC50YWcmJm51bGwhPT1wLmNoaWxkKXtwLmNoaWxkW1wicmV0dXJuXCJdPXA7cD1wLmNoaWxkO2NvbnRpbnVlfWlmKHA9PT1iKWJyZWFrO2Zvcig7bnVsbD09PXAuc2libGluZzspe2lmKG51bGw9PT1wW1wicmV0dXJuXCJdfHxwW1wicmV0dXJuXCJdPT09YilicmVhayBhO3A9cFtcInJldHVyblwiXX1wLnNpYmxpbmdbXCJyZXR1cm5cIl09cFtcInJldHVyblwiXTtwPXAuc2libGluZ31oKGEsQSxtLGMpJiZkKGIpO2Iuc3RhdGVOb2RlPWF9bnVsbCE9PWIucmVmJiZcbihiLmVmZmVjdFRhZ3w9MTI4KX1yZXR1cm4gbnVsbDtjYXNlIDY6aWYoYSYmbnVsbCE9Yi5zdGF0ZU5vZGUpdyhhLGIsYS5tZW1vaXplZFByb3BzLG0pO2Vsc2V7aWYoXCJzdHJpbmdcIiE9PXR5cGVvZiBtKXJldHVybiBudWxsPT09Yi5zdGF0ZU5vZGU/RShcIjE2NlwiKTp2b2lkIDAsbnVsbDthPXYoKTtjPXUoKTtMKGIpP0koYikmJmQoYik6Yi5zdGF0ZU5vZGU9ZihtLGEsYyxiKX1yZXR1cm4gbnVsbDtjYXNlIDc6KG09Yi5tZW1vaXplZFByb3BzKT92b2lkIDA6RShcIjE2NVwiKTtiLnRhZz04O0E9W107YTpmb3IoKHA9Yi5zdGF0ZU5vZGUpJiYocFtcInJldHVyblwiXT1iKTtudWxsIT09cDspe2lmKDU9PT1wLnRhZ3x8Nj09PXAudGFnfHw0PT09cC50YWcpRShcIjI0N1wiKTtlbHNlIGlmKDk9PT1wLnRhZylBLnB1c2gocC50eXBlKTtlbHNlIGlmKG51bGwhPT1wLmNoaWxkKXtwLmNoaWxkW1wicmV0dXJuXCJdPXA7cD1wLmNoaWxkO2NvbnRpbnVlfWZvcig7bnVsbD09PXAuc2libGluZzspe2lmKG51bGw9PT1cbnBbXCJyZXR1cm5cIl18fHBbXCJyZXR1cm5cIl09PT1iKWJyZWFrIGE7cD1wW1wicmV0dXJuXCJdfXAuc2libGluZ1tcInJldHVyblwiXT1wW1wicmV0dXJuXCJdO3A9cC5zaWJsaW5nfXA9bS5oYW5kbGVyO209cChtLnByb3BzLEEpO2IuY2hpbGQ9YmYoYixudWxsIT09YT9hLmNoaWxkOm51bGwsbSxjKTtyZXR1cm4gYi5jaGlsZDtjYXNlIDg6cmV0dXJuIGIudGFnPTcsbnVsbDtjYXNlIDk6cmV0dXJuIG51bGw7Y2FzZSAxMDpyZXR1cm4gbnVsbDtjYXNlIDQ6cmV0dXJuIHooYiksTihiKSxudWxsO2Nhc2UgMDpFKFwiMTY3XCIpO2RlZmF1bHQ6RShcIjE1NlwiKX19fX1cbmZ1bmN0aW9uIGZmKGEsYil7ZnVuY3Rpb24gYyhhKXt2YXIgYz1hLnJlZjtpZihudWxsIT09Yyl0cnl7YyhudWxsKX1jYXRjaChBKXtiKGEsQSl9fWZ1bmN0aW9uIGQoYSl7XCJmdW5jdGlvblwiPT09dHlwZW9mIEVlJiZFZShhKTtzd2l0Y2goYS50YWcpe2Nhc2UgMjpjKGEpO3ZhciBkPWEuc3RhdGVOb2RlO2lmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBkLmNvbXBvbmVudFdpbGxVbm1vdW50KXRyeXtkLnByb3BzPWEubWVtb2l6ZWRQcm9wcyxkLnN0YXRlPWEubWVtb2l6ZWRTdGF0ZSxkLmNvbXBvbmVudFdpbGxVbm1vdW50KCl9Y2F0Y2goQSl7YihhLEEpfWJyZWFrO2Nhc2UgNTpjKGEpO2JyZWFrO2Nhc2UgNzplKGEuc3RhdGVOb2RlKTticmVhaztjYXNlIDQ6ayYmZyhhKX19ZnVuY3Rpb24gZShhKXtmb3IodmFyIGI9YTs7KWlmKGQoYiksbnVsbD09PWIuY2hpbGR8fGsmJjQ9PT1iLnRhZyl7aWYoYj09PWEpYnJlYWs7Zm9yKDtudWxsPT09Yi5zaWJsaW5nOyl7aWYobnVsbD09PWJbXCJyZXR1cm5cIl18fFxuYltcInJldHVyblwiXT09PWEpcmV0dXJuO2I9YltcInJldHVyblwiXX1iLnNpYmxpbmdbXCJyZXR1cm5cIl09YltcInJldHVyblwiXTtiPWIuc2libGluZ31lbHNlIGIuY2hpbGRbXCJyZXR1cm5cIl09YixiPWIuY2hpbGR9ZnVuY3Rpb24gZihhKXtyZXR1cm4gNT09PWEudGFnfHwzPT09YS50YWd8fDQ9PT1hLnRhZ31mdW5jdGlvbiBnKGEpe2Zvcih2YXIgYj1hLGM9ITEsZj12b2lkIDAsZz12b2lkIDA7Oyl7aWYoIWMpe2M9YltcInJldHVyblwiXTthOmZvcig7Oyl7bnVsbD09PWM/RShcIjE2MFwiKTp2b2lkIDA7c3dpdGNoKGMudGFnKXtjYXNlIDU6Zj1jLnN0YXRlTm9kZTtnPSExO2JyZWFrIGE7Y2FzZSAzOmY9Yy5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztnPSEwO2JyZWFrIGE7Y2FzZSA0OmY9Yy5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztnPSEwO2JyZWFrIGF9Yz1jW1wicmV0dXJuXCJdfWM9ITB9aWYoNT09PWIudGFnfHw2PT09Yi50YWcpZShiKSxnP0ooZixiLnN0YXRlTm9kZSk6TihmLGIuc3RhdGVOb2RlKTtcbmVsc2UgaWYoND09PWIudGFnP2Y9Yi5zdGF0ZU5vZGUuY29udGFpbmVySW5mbzpkKGIpLG51bGwhPT1iLmNoaWxkKXtiLmNoaWxkW1wicmV0dXJuXCJdPWI7Yj1iLmNoaWxkO2NvbnRpbnVlfWlmKGI9PT1hKWJyZWFrO2Zvcig7bnVsbD09PWIuc2libGluZzspe2lmKG51bGw9PT1iW1wicmV0dXJuXCJdfHxiW1wicmV0dXJuXCJdPT09YSlyZXR1cm47Yj1iW1wicmV0dXJuXCJdOzQ9PT1iLnRhZyYmKGM9ITEpfWIuc2libGluZ1tcInJldHVyblwiXT1iW1wicmV0dXJuXCJdO2I9Yi5zaWJsaW5nfX12YXIgaD1hLmdldFB1YmxpY0luc3RhbmNlLGs9YS5tdXRhdGlvbjthPWEucGVyc2lzdGVuY2U7a3x8KGE/RShcIjIzNVwiKTpFKFwiMjM2XCIpKTt2YXIgcT1rLmNvbW1pdE1vdW50LHY9ay5jb21taXRVcGRhdGUseT1rLnJlc2V0VGV4dENvbnRlbnQsdT1rLmNvbW1pdFRleHRVcGRhdGUsej1rLmFwcGVuZENoaWxkLEc9ay5hcHBlbmRDaGlsZFRvQ29udGFpbmVyLEk9ay5pbnNlcnRCZWZvcmUsTD1rLmluc2VydEluQ29udGFpbmVyQmVmb3JlLFxuTj1rLnJlbW92ZUNoaWxkLEo9ay5yZW1vdmVDaGlsZEZyb21Db250YWluZXI7cmV0dXJue2NvbW1pdFJlc2V0VGV4dENvbnRlbnQ6ZnVuY3Rpb24oYSl7eShhLnN0YXRlTm9kZSl9LGNvbW1pdFBsYWNlbWVudDpmdW5jdGlvbihhKXthOntmb3IodmFyIGI9YVtcInJldHVyblwiXTtudWxsIT09Yjspe2lmKGYoYikpe3ZhciBjPWI7YnJlYWsgYX1iPWJbXCJyZXR1cm5cIl19RShcIjE2MFwiKTtjPXZvaWQgMH12YXIgZD1iPXZvaWQgMDtzd2l0Y2goYy50YWcpe2Nhc2UgNTpiPWMuc3RhdGVOb2RlO2Q9ITE7YnJlYWs7Y2FzZSAzOmI9Yy5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztkPSEwO2JyZWFrO2Nhc2UgNDpiPWMuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87ZD0hMDticmVhaztkZWZhdWx0OkUoXCIxNjFcIil9Yy5lZmZlY3RUYWcmMTYmJih5KGIpLGMuZWZmZWN0VGFnJj0tMTcpO2E6Yjpmb3IoYz1hOzspe2Zvcig7bnVsbD09PWMuc2libGluZzspe2lmKG51bGw9PT1jW1wicmV0dXJuXCJdfHxmKGNbXCJyZXR1cm5cIl0pKXtjPVxubnVsbDticmVhayBhfWM9Y1tcInJldHVyblwiXX1jLnNpYmxpbmdbXCJyZXR1cm5cIl09Y1tcInJldHVyblwiXTtmb3IoYz1jLnNpYmxpbmc7NSE9PWMudGFnJiY2IT09Yy50YWc7KXtpZihjLmVmZmVjdFRhZyYyKWNvbnRpbnVlIGI7aWYobnVsbD09PWMuY2hpbGR8fDQ9PT1jLnRhZyljb250aW51ZSBiO2Vsc2UgYy5jaGlsZFtcInJldHVyblwiXT1jLGM9Yy5jaGlsZH1pZighKGMuZWZmZWN0VGFnJjIpKXtjPWMuc3RhdGVOb2RlO2JyZWFrIGF9fWZvcih2YXIgZT1hOzspe2lmKDU9PT1lLnRhZ3x8Nj09PWUudGFnKWM/ZD9MKGIsZS5zdGF0ZU5vZGUsYyk6SShiLGUuc3RhdGVOb2RlLGMpOmQ/RyhiLGUuc3RhdGVOb2RlKTp6KGIsZS5zdGF0ZU5vZGUpO2Vsc2UgaWYoNCE9PWUudGFnJiZudWxsIT09ZS5jaGlsZCl7ZS5jaGlsZFtcInJldHVyblwiXT1lO2U9ZS5jaGlsZDtjb250aW51ZX1pZihlPT09YSlicmVhaztmb3IoO251bGw9PT1lLnNpYmxpbmc7KXtpZihudWxsPT09ZVtcInJldHVyblwiXXx8ZVtcInJldHVyblwiXT09PVxuYSlyZXR1cm47ZT1lW1wicmV0dXJuXCJdfWUuc2libGluZ1tcInJldHVyblwiXT1lW1wicmV0dXJuXCJdO2U9ZS5zaWJsaW5nfX0sY29tbWl0RGVsZXRpb246ZnVuY3Rpb24oYSl7ZyhhKTthW1wicmV0dXJuXCJdPW51bGw7YS5jaGlsZD1udWxsO2EuYWx0ZXJuYXRlJiYoYS5hbHRlcm5hdGUuY2hpbGQ9bnVsbCxhLmFsdGVybmF0ZVtcInJldHVyblwiXT1udWxsKX0sY29tbWl0V29yazpmdW5jdGlvbihhLGIpe3N3aXRjaChiLnRhZyl7Y2FzZSAyOmJyZWFrO2Nhc2UgNTp2YXIgYz1iLnN0YXRlTm9kZTtpZihudWxsIT1jKXt2YXIgZD1iLm1lbW9pemVkUHJvcHM7YT1udWxsIT09YT9hLm1lbW9pemVkUHJvcHM6ZDt2YXIgZT1iLnR5cGUsZj1iLnVwZGF0ZVF1ZXVlO2IudXBkYXRlUXVldWU9bnVsbDtudWxsIT09ZiYmdihjLGYsZSxhLGQsYil9YnJlYWs7Y2FzZSA2Om51bGw9PT1iLnN0YXRlTm9kZT9FKFwiMTYyXCIpOnZvaWQgMDtjPWIubWVtb2l6ZWRQcm9wczt1KGIuc3RhdGVOb2RlLG51bGwhPT1hP2EubWVtb2l6ZWRQcm9wczpcbmMsYyk7YnJlYWs7Y2FzZSAzOmJyZWFrO2RlZmF1bHQ6RShcIjE2M1wiKX19LGNvbW1pdExpZmVDeWNsZXM6ZnVuY3Rpb24oYSxiKXtzd2l0Y2goYi50YWcpe2Nhc2UgMjp2YXIgYz1iLnN0YXRlTm9kZTtpZihiLmVmZmVjdFRhZyY0KWlmKG51bGw9PT1hKWMucHJvcHM9Yi5tZW1vaXplZFByb3BzLGMuc3RhdGU9Yi5tZW1vaXplZFN0YXRlLGMuY29tcG9uZW50RGlkTW91bnQoKTtlbHNle3ZhciBkPWEubWVtb2l6ZWRQcm9wczthPWEubWVtb2l6ZWRTdGF0ZTtjLnByb3BzPWIubWVtb2l6ZWRQcm9wcztjLnN0YXRlPWIubWVtb2l6ZWRTdGF0ZTtjLmNvbXBvbmVudERpZFVwZGF0ZShkLGEpfWI9Yi51cGRhdGVRdWV1ZTtudWxsIT09YiYmS2UoYixjKTticmVhaztjYXNlIDM6Yz1iLnVwZGF0ZVF1ZXVlO251bGwhPT1jJiZLZShjLG51bGwhPT1iLmNoaWxkP2IuY2hpbGQuc3RhdGVOb2RlOm51bGwpO2JyZWFrO2Nhc2UgNTpjPWIuc3RhdGVOb2RlO251bGw9PT1hJiZiLmVmZmVjdFRhZyY0JiZxKGMsXG5iLnR5cGUsYi5tZW1vaXplZFByb3BzLGIpO2JyZWFrO2Nhc2UgNjpicmVhaztjYXNlIDQ6YnJlYWs7ZGVmYXVsdDpFKFwiMTYzXCIpfX0sY29tbWl0QXR0YWNoUmVmOmZ1bmN0aW9uKGEpe3ZhciBiPWEucmVmO2lmKG51bGwhPT1iKXt2YXIgYz1hLnN0YXRlTm9kZTtzd2l0Y2goYS50YWcpe2Nhc2UgNTpiKGgoYykpO2JyZWFrO2RlZmF1bHQ6YihjKX19fSxjb21taXREZXRhY2hSZWY6ZnVuY3Rpb24oYSl7YT1hLnJlZjtudWxsIT09YSYmYShudWxsKX19fXZhciBnZj17fTtcbmZ1bmN0aW9uIGhmKGEpe2Z1bmN0aW9uIGIoYSl7YT09PWdmP0UoXCIxNzRcIik6dm9pZCAwO3JldHVybiBhfXZhciBjPWEuZ2V0Q2hpbGRIb3N0Q29udGV4dCxkPWEuZ2V0Um9vdEhvc3RDb250ZXh0LGU9e2N1cnJlbnQ6Z2Z9LGY9e2N1cnJlbnQ6Z2Z9LGc9e2N1cnJlbnQ6Z2Z9O3JldHVybntnZXRIb3N0Q29udGV4dDpmdW5jdGlvbigpe3JldHVybiBiKGUuY3VycmVudCl9LGdldFJvb3RIb3N0Q29udGFpbmVyOmZ1bmN0aW9uKCl7cmV0dXJuIGIoZy5jdXJyZW50KX0scG9wSG9zdENvbnRhaW5lcjpmdW5jdGlvbihhKXtWKGUsYSk7VihmLGEpO1YoZyxhKX0scG9wSG9zdENvbnRleHQ6ZnVuY3Rpb24oYSl7Zi5jdXJyZW50PT09YSYmKFYoZSxhKSxWKGYsYSkpfSxwdXNoSG9zdENvbnRhaW5lcjpmdW5jdGlvbihhLGIpe1coZyxiLGEpO2I9ZChiKTtXKGYsYSxhKTtXKGUsYixhKX0scHVzaEhvc3RDb250ZXh0OmZ1bmN0aW9uKGEpe3ZhciBkPWIoZy5jdXJyZW50KSxoPWIoZS5jdXJyZW50KTtcbmQ9YyhoLGEudHlwZSxkKTtoIT09ZCYmKFcoZixhLGEpLFcoZSxkLGEpKX0scmVzZXRIb3N0Q29udGFpbmVyOmZ1bmN0aW9uKCl7ZS5jdXJyZW50PWdmO2cuY3VycmVudD1nZn19fVxuZnVuY3Rpb24gamYoYSl7ZnVuY3Rpb24gYihhLGIpe3ZhciBjPW5ldyBZKDUsbnVsbCwwKTtjLnR5cGU9XCJERUxFVEVEXCI7Yy5zdGF0ZU5vZGU9YjtjW1wicmV0dXJuXCJdPWE7Yy5lZmZlY3RUYWc9ODtudWxsIT09YS5sYXN0RWZmZWN0PyhhLmxhc3RFZmZlY3QubmV4dEVmZmVjdD1jLGEubGFzdEVmZmVjdD1jKTphLmZpcnN0RWZmZWN0PWEubGFzdEVmZmVjdD1jfWZ1bmN0aW9uIGMoYSxiKXtzd2l0Y2goYS50YWcpe2Nhc2UgNTpyZXR1cm4gYj1mKGIsYS50eXBlLGEucGVuZGluZ1Byb3BzKSxudWxsIT09Yj8oYS5zdGF0ZU5vZGU9YiwhMCk6ITE7Y2FzZSA2OnJldHVybiBiPWcoYixhLnBlbmRpbmdQcm9wcyksbnVsbCE9PWI/KGEuc3RhdGVOb2RlPWIsITApOiExO2RlZmF1bHQ6cmV0dXJuITF9fWZ1bmN0aW9uIGQoYSl7Zm9yKGE9YVtcInJldHVyblwiXTtudWxsIT09YSYmNSE9PWEudGFnJiYzIT09YS50YWc7KWE9YVtcInJldHVyblwiXTt5PWF9dmFyIGU9YS5zaG91bGRTZXRUZXh0Q29udGVudDtcbmE9YS5oeWRyYXRpb247aWYoIWEpcmV0dXJue2VudGVySHlkcmF0aW9uU3RhdGU6ZnVuY3Rpb24oKXtyZXR1cm4hMX0scmVzZXRIeWRyYXRpb25TdGF0ZTpmdW5jdGlvbigpe30sdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2U6ZnVuY3Rpb24oKXt9LHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2U6ZnVuY3Rpb24oKXtFKFwiMTc1XCIpfSxwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZTpmdW5jdGlvbigpe0UoXCIxNzZcIil9LHBvcEh5ZHJhdGlvblN0YXRlOmZ1bmN0aW9uKCl7cmV0dXJuITF9fTt2YXIgZj1hLmNhbkh5ZHJhdGVJbnN0YW5jZSxnPWEuY2FuSHlkcmF0ZVRleHRJbnN0YW5jZSxoPWEuZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nLGs9YS5nZXRGaXJzdEh5ZHJhdGFibGVDaGlsZCxxPWEuaHlkcmF0ZUluc3RhbmNlLHY9YS5oeWRyYXRlVGV4dEluc3RhbmNlLHk9bnVsbCx1PW51bGwsej0hMTtyZXR1cm57ZW50ZXJIeWRyYXRpb25TdGF0ZTpmdW5jdGlvbihhKXt1PVxuayhhLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTt5PWE7cmV0dXJuIHo9ITB9LHJlc2V0SHlkcmF0aW9uU3RhdGU6ZnVuY3Rpb24oKXt1PXk9bnVsbDt6PSExfSx0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZTpmdW5jdGlvbihhKXtpZih6KXt2YXIgZD11O2lmKGQpe2lmKCFjKGEsZCkpe2Q9aChkKTtpZighZHx8IWMoYSxkKSl7YS5lZmZlY3RUYWd8PTI7ej0hMTt5PWE7cmV0dXJufWIoeSx1KX15PWE7dT1rKGQpfWVsc2UgYS5lZmZlY3RUYWd8PTIsej0hMSx5PWF9fSxwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlOmZ1bmN0aW9uKGEsYixjKXtiPXEoYS5zdGF0ZU5vZGUsYS50eXBlLGEubWVtb2l6ZWRQcm9wcyxiLGMsYSk7YS51cGRhdGVRdWV1ZT1iO3JldHVybiBudWxsIT09Yj8hMDohMX0scHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2U6ZnVuY3Rpb24oYSl7cmV0dXJuIHYoYS5zdGF0ZU5vZGUsYS5tZW1vaXplZFByb3BzLGEpfSxwb3BIeWRyYXRpb25TdGF0ZTpmdW5jdGlvbihhKXtpZihhIT09XG55KXJldHVybiExO2lmKCF6KXJldHVybiBkKGEpLHo9ITAsITE7dmFyIGM9YS50eXBlO2lmKDUhPT1hLnRhZ3x8XCJoZWFkXCIhPT1jJiZcImJvZHlcIiE9PWMmJiFlKGMsYS5tZW1vaXplZFByb3BzKSlmb3IoYz11O2M7KWIoYSxjKSxjPWgoYyk7ZChhKTt1PXk/aChhLnN0YXRlTm9kZSk6bnVsbDtyZXR1cm4hMH19fVxuZnVuY3Rpb24ga2YoYSl7ZnVuY3Rpb24gYihhKXtRYj1qYT0hMDt2YXIgYj1hLnN0YXRlTm9kZTtiLmN1cnJlbnQ9PT1hP0UoXCIxNzdcIik6dm9pZCAwO2IuaXNSZWFkeUZvckNvbW1pdD0hMTtpZC5jdXJyZW50PW51bGw7aWYoMTxhLmVmZmVjdFRhZylpZihudWxsIT09YS5sYXN0RWZmZWN0KXthLmxhc3RFZmZlY3QubmV4dEVmZmVjdD1hO3ZhciBjPWEuZmlyc3RFZmZlY3R9ZWxzZSBjPWE7ZWxzZSBjPWEuZmlyc3RFZmZlY3Q7eWcoKTtmb3IodD1jO251bGwhPT10Oyl7dmFyIGQ9ITEsZT12b2lkIDA7dHJ5e2Zvcig7bnVsbCE9PXQ7KXt2YXIgZj10LmVmZmVjdFRhZztmJjE2JiZ6Zyh0KTtpZihmJjEyOCl7dmFyIGc9dC5hbHRlcm5hdGU7bnVsbCE9PWcmJkFnKGcpfXN3aXRjaChmJi0yNDIpe2Nhc2UgMjpOZSh0KTt0LmVmZmVjdFRhZyY9LTM7YnJlYWs7Y2FzZSA2Ok5lKHQpO3QuZWZmZWN0VGFnJj0tMztPZSh0LmFsdGVybmF0ZSx0KTticmVhaztjYXNlIDQ6T2UodC5hbHRlcm5hdGUsXG50KTticmVhaztjYXNlIDg6U2M9ITAsQmcodCksU2M9ITF9dD10Lm5leHRFZmZlY3R9fWNhdGNoKFRjKXtkPSEwLGU9VGN9ZCYmKG51bGw9PT10P0UoXCIxNzhcIik6dm9pZCAwLGgodCxlKSxudWxsIT09dCYmKHQ9dC5uZXh0RWZmZWN0KSl9Q2coKTtiLmN1cnJlbnQ9YTtmb3IodD1jO251bGwhPT10Oyl7Yz0hMTtkPXZvaWQgMDt0cnl7Zm9yKDtudWxsIT09dDspe3ZhciBrPXQuZWZmZWN0VGFnO2smMzYmJkRnKHQuYWx0ZXJuYXRlLHQpO2smMTI4JiZFZyh0KTtpZihrJjY0KXN3aXRjaChlPXQsZj12b2lkIDAsbnVsbCE9PVImJihmPVIuZ2V0KGUpLFJbXCJkZWxldGVcIl0oZSksbnVsbD09ZiYmbnVsbCE9PWUuYWx0ZXJuYXRlJiYoZT1lLmFsdGVybmF0ZSxmPVIuZ2V0KGUpLFJbXCJkZWxldGVcIl0oZSkpKSxudWxsPT1mP0UoXCIxODRcIik6dm9pZCAwLGUudGFnKXtjYXNlIDI6ZS5zdGF0ZU5vZGUuY29tcG9uZW50RGlkQ2F0Y2goZi5lcnJvcix7Y29tcG9uZW50U3RhY2s6Zi5jb21wb25lbnRTdGFja30pO1xuYnJlYWs7Y2FzZSAzOm51bGw9PT1jYSYmKGNhPWYuZXJyb3IpO2JyZWFrO2RlZmF1bHQ6RShcIjE1N1wiKX12YXIgUWM9dC5uZXh0RWZmZWN0O3QubmV4dEVmZmVjdD1udWxsO3Q9UWN9fWNhdGNoKFRjKXtjPSEwLGQ9VGN9YyYmKG51bGw9PT10P0UoXCIxNzhcIik6dm9pZCAwLGgodCxkKSxudWxsIT09dCYmKHQ9dC5uZXh0RWZmZWN0KSl9amE9UWI9ITE7XCJmdW5jdGlvblwiPT09dHlwZW9mIERlJiZEZShhLnN0YXRlTm9kZSk7aGEmJihoYS5mb3JFYWNoKEcpLGhhPW51bGwpO251bGwhPT1jYSYmKGE9Y2EsY2E9bnVsbCxPYihhKSk7Yj1iLmN1cnJlbnQuZXhwaXJhdGlvblRpbWU7MD09PWImJihxYT1SPW51bGwpO3JldHVybiBifWZ1bmN0aW9uIGMoYSl7Zm9yKDs7KXt2YXIgYj1GZyhhLmFsdGVybmF0ZSxhLEgpLGM9YVtcInJldHVyblwiXSxkPWEuc2libGluZzt2YXIgZT1hO2lmKDIxNDc0ODM2NDc9PT1IfHwyMTQ3NDgzNjQ3IT09ZS5leHBpcmF0aW9uVGltZSl7aWYoMiE9PWUudGFnJiYzIT09XG5lLnRhZyl2YXIgZj0wO2Vsc2UgZj1lLnVwZGF0ZVF1ZXVlLGY9bnVsbD09PWY/MDpmLmV4cGlyYXRpb25UaW1lO2Zvcih2YXIgZz1lLmNoaWxkO251bGwhPT1nOykwIT09Zy5leHBpcmF0aW9uVGltZSYmKDA9PT1mfHxmPmcuZXhwaXJhdGlvblRpbWUpJiYoZj1nLmV4cGlyYXRpb25UaW1lKSxnPWcuc2libGluZztlLmV4cGlyYXRpb25UaW1lPWZ9aWYobnVsbCE9PWIpcmV0dXJuIGI7bnVsbCE9PWMmJihudWxsPT09Yy5maXJzdEVmZmVjdCYmKGMuZmlyc3RFZmZlY3Q9YS5maXJzdEVmZmVjdCksbnVsbCE9PWEubGFzdEVmZmVjdCYmKG51bGwhPT1jLmxhc3RFZmZlY3QmJihjLmxhc3RFZmZlY3QubmV4dEVmZmVjdD1hLmZpcnN0RWZmZWN0KSxjLmxhc3RFZmZlY3Q9YS5sYXN0RWZmZWN0KSwxPGEuZWZmZWN0VGFnJiYobnVsbCE9PWMubGFzdEVmZmVjdD9jLmxhc3RFZmZlY3QubmV4dEVmZmVjdD1hOmMuZmlyc3RFZmZlY3Q9YSxjLmxhc3RFZmZlY3Q9YSkpO2lmKG51bGwhPT1kKXJldHVybiBkO1xuaWYobnVsbCE9PWMpYT1jO2Vsc2V7YS5zdGF0ZU5vZGUuaXNSZWFkeUZvckNvbW1pdD0hMDticmVha319cmV0dXJuIG51bGx9ZnVuY3Rpb24gZChhKXt2YXIgYj1yZyhhLmFsdGVybmF0ZSxhLEgpO251bGw9PT1iJiYoYj1jKGEpKTtpZC5jdXJyZW50PW51bGw7cmV0dXJuIGJ9ZnVuY3Rpb24gZShhKXt2YXIgYj1HZyhhLmFsdGVybmF0ZSxhLEgpO251bGw9PT1iJiYoYj1jKGEpKTtpZC5jdXJyZW50PW51bGw7cmV0dXJuIGJ9ZnVuY3Rpb24gZihhKXtpZihudWxsIT09Uil7aWYoISgwPT09SHx8SD5hKSlpZihIPD1VYylmb3IoO251bGwhPT1GOylGPWsoRik/ZShGKTpkKEYpO2Vsc2UgZm9yKDtudWxsIT09RiYmIUEoKTspRj1rKEYpP2UoRik6ZChGKX1lbHNlIGlmKCEoMD09PUh8fEg+YSkpaWYoSDw9VWMpZm9yKDtudWxsIT09RjspRj1kKEYpO2Vsc2UgZm9yKDtudWxsIT09RiYmIUEoKTspRj1kKEYpfWZ1bmN0aW9uIGcoYSxiKXtqYT9FKFwiMjQzXCIpOnZvaWQgMDtqYT0hMDthLmlzUmVhZHlGb3JDb21taXQ9XG4hMTtpZihhIT09cmF8fGIhPT1IfHxudWxsPT09Ril7Zm9yKDstMTxoZTspZ2VbaGVdPW51bGwsaGUtLTtqZT1EO2llLmN1cnJlbnQ9RDtYLmN1cnJlbnQ9ITE7eCgpO3JhPWE7SD1iO0Y9c2UocmEuY3VycmVudCxudWxsLGIpfXZhciBjPSExLGQ9bnVsbDt0cnl7ZihiKX1jYXRjaChSYyl7Yz0hMCxkPVJjfWZvcig7Yzspe2lmKGViKXtjYT1kO2JyZWFrfXZhciBnPUY7aWYobnVsbD09PWcpZWI9ITA7ZWxzZXt2YXIgaz1oKGcsZCk7bnVsbD09PWs/RShcIjE4M1wiKTp2b2lkIDA7aWYoIWViKXt0cnl7Yz1rO2Q9Yjtmb3Ioaz1jO251bGwhPT1nOyl7c3dpdGNoKGcudGFnKXtjYXNlIDI6bmUoZyk7YnJlYWs7Y2FzZSA1OnFnKGcpO2JyZWFrO2Nhc2UgMzpwKGcpO2JyZWFrO2Nhc2UgNDpwKGcpfWlmKGc9PT1rfHxnLmFsdGVybmF0ZT09PWspYnJlYWs7Zz1nW1wicmV0dXJuXCJdfUY9ZShjKTtmKGQpfWNhdGNoKFJjKXtjPSEwO2Q9UmM7Y29udGludWV9YnJlYWt9fX1iPWNhO2ViPWphPSExO2NhPVxubnVsbDtudWxsIT09YiYmT2IoYik7cmV0dXJuIGEuaXNSZWFkeUZvckNvbW1pdD9hLmN1cnJlbnQuYWx0ZXJuYXRlOm51bGx9ZnVuY3Rpb24gaChhLGIpe3ZhciBjPWlkLmN1cnJlbnQ9bnVsbCxkPSExLGU9ITEsZj1udWxsO2lmKDM9PT1hLnRhZyljPWEscShhKSYmKGViPSEwKTtlbHNlIGZvcih2YXIgZz1hW1wicmV0dXJuXCJdO251bGwhPT1nJiZudWxsPT09YzspezI9PT1nLnRhZz9cImZ1bmN0aW9uXCI9PT10eXBlb2YgZy5zdGF0ZU5vZGUuY29tcG9uZW50RGlkQ2F0Y2gmJihkPSEwLGY9amQoZyksYz1nLGU9ITApOjM9PT1nLnRhZyYmKGM9Zyk7aWYocShnKSl7aWYoU2N8fG51bGwhPT1oYSYmKGhhLmhhcyhnKXx8bnVsbCE9PWcuYWx0ZXJuYXRlJiZoYS5oYXMoZy5hbHRlcm5hdGUpKSlyZXR1cm4gbnVsbDtjPW51bGw7ZT0hMX1nPWdbXCJyZXR1cm5cIl19aWYobnVsbCE9PWMpe251bGw9PT1xYSYmKHFhPW5ldyBTZXQpO3FhLmFkZChjKTt2YXIgaD1cIlwiO2c9YTtkb3thOnN3aXRjaChnLnRhZyl7Y2FzZSAwOmNhc2UgMTpjYXNlIDI6Y2FzZSA1OnZhciBrPVxuZy5fZGVidWdPd25lcixRYz1nLl9kZWJ1Z1NvdXJjZTt2YXIgbT1qZChnKTt2YXIgbj1udWxsO2smJihuPWpkKGspKTtrPVFjO209XCJcXG4gICAgaW4gXCIrKG18fFwiVW5rbm93blwiKSsoaz9cIiAoYXQgXCIray5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLFwiXCIpK1wiOlwiK2subGluZU51bWJlcitcIilcIjpuP1wiIChjcmVhdGVkIGJ5IFwiK24rXCIpXCI6XCJcIik7YnJlYWsgYTtkZWZhdWx0Om09XCJcIn1oKz1tO2c9Z1tcInJldHVyblwiXX13aGlsZShnKTtnPWg7YT1qZChhKTtudWxsPT09UiYmKFI9bmV3IE1hcCk7Yj17Y29tcG9uZW50TmFtZTphLGNvbXBvbmVudFN0YWNrOmcsZXJyb3I6YixlcnJvckJvdW5kYXJ5OmQ/Yy5zdGF0ZU5vZGU6bnVsbCxlcnJvckJvdW5kYXJ5Rm91bmQ6ZCxlcnJvckJvdW5kYXJ5TmFtZTpmLHdpbGxSZXRyeTplfTtSLnNldChjLGIpO3RyeXt2YXIgcD1iLmVycm9yO3AmJnAuc3VwcHJlc3NSZWFjdEVycm9yTG9nZ2luZ3x8Y29uc29sZS5lcnJvcihwKX1jYXRjaChWYyl7VmMmJlxuVmMuc3VwcHJlc3NSZWFjdEVycm9yTG9nZ2luZ3x8Y29uc29sZS5lcnJvcihWYyl9UWI/KG51bGw9PT1oYSYmKGhhPW5ldyBTZXQpLGhhLmFkZChjKSk6RyhjKTtyZXR1cm4gY31udWxsPT09Y2EmJihjYT1iKTtyZXR1cm4gbnVsbH1mdW5jdGlvbiBrKGEpe3JldHVybiBudWxsIT09UiYmKFIuaGFzKGEpfHxudWxsIT09YS5hbHRlcm5hdGUmJlIuaGFzKGEuYWx0ZXJuYXRlKSl9ZnVuY3Rpb24gcShhKXtyZXR1cm4gbnVsbCE9PXFhJiYocWEuaGFzKGEpfHxudWxsIT09YS5hbHRlcm5hdGUmJnFhLmhhcyhhLmFsdGVybmF0ZSkpfWZ1bmN0aW9uIHYoKXtyZXR1cm4gMjAqKCgoSSgpKzEwMCkvMjB8MCkrMSl9ZnVuY3Rpb24geShhKXtyZXR1cm4gMCE9PWthP2thOmphP1FiPzE6SDohSGd8fGEuaW50ZXJuYWxDb250ZXh0VGFnJjE/digpOjF9ZnVuY3Rpb24gdShhLGIpe3JldHVybiB6KGEsYiwhMSl9ZnVuY3Rpb24geihhLGIpe2Zvcig7bnVsbCE9PWE7KXtpZigwPT09YS5leHBpcmF0aW9uVGltZXx8XG5hLmV4cGlyYXRpb25UaW1lPmIpYS5leHBpcmF0aW9uVGltZT1iO251bGwhPT1hLmFsdGVybmF0ZSYmKDA9PT1hLmFsdGVybmF0ZS5leHBpcmF0aW9uVGltZXx8YS5hbHRlcm5hdGUuZXhwaXJhdGlvblRpbWU+YikmJihhLmFsdGVybmF0ZS5leHBpcmF0aW9uVGltZT1iKTtpZihudWxsPT09YVtcInJldHVyblwiXSlpZigzPT09YS50YWcpe3ZhciBjPWEuc3RhdGVOb2RlOyFqYSYmYz09PXJhJiZiPEgmJihGPXJhPW51bGwsSD0wKTt2YXIgZD1jLGU9YjtSYj5JZyYmRShcIjE4NVwiKTtpZihudWxsPT09ZC5uZXh0U2NoZWR1bGVkUm9vdClkLnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lPWUsbnVsbD09PU8/KHNhPU89ZCxkLm5leHRTY2hlZHVsZWRSb290PWQpOihPPU8ubmV4dFNjaGVkdWxlZFJvb3Q9ZCxPLm5leHRTY2hlZHVsZWRSb290PXNhKTtlbHNle3ZhciBmPWQucmVtYWluaW5nRXhwaXJhdGlvblRpbWU7aWYoMD09PWZ8fGU8ZilkLnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lPWV9RmF8fChsYT9cblNiJiYobWE9ZCxuYT0xLG0obWEsbmEpKToxPT09ZT93KDEsbnVsbCk6TChlKSk7IWphJiZjPT09cmEmJmI8SCYmKEY9cmE9bnVsbCxIPTApfWVsc2UgYnJlYWs7YT1hW1wicmV0dXJuXCJdfX1mdW5jdGlvbiBHKGEpe3ooYSwxLCEwKX1mdW5jdGlvbiBJKCl7cmV0dXJuIFVjPSgoV2MoKS1QZSkvMTB8MCkrMn1mdW5jdGlvbiBMKGEpe2lmKDAhPT1UYil7aWYoYT5UYilyZXR1cm47SmcoWGMpfXZhciBiPVdjKCktUGU7VGI9YTtYYz1LZyhKLHt0aW1lb3V0OjEwKihhLTIpLWJ9KX1mdW5jdGlvbiBOKCl7dmFyIGE9MCxiPW51bGw7aWYobnVsbCE9PU8pZm9yKHZhciBjPU8sZD1zYTtudWxsIT09ZDspe3ZhciBlPWQucmVtYWluaW5nRXhwaXJhdGlvblRpbWU7aWYoMD09PWUpe251bGw9PT1jfHxudWxsPT09Tz9FKFwiMjQ0XCIpOnZvaWQgMDtpZihkPT09ZC5uZXh0U2NoZWR1bGVkUm9vdCl7c2E9Tz1kLm5leHRTY2hlZHVsZWRSb290PW51bGw7YnJlYWt9ZWxzZSBpZihkPT09c2Epc2E9ZT1kLm5leHRTY2hlZHVsZWRSb290LFxuTy5uZXh0U2NoZWR1bGVkUm9vdD1lLGQubmV4dFNjaGVkdWxlZFJvb3Q9bnVsbDtlbHNlIGlmKGQ9PT1PKXtPPWM7Ty5uZXh0U2NoZWR1bGVkUm9vdD1zYTtkLm5leHRTY2hlZHVsZWRSb290PW51bGw7YnJlYWt9ZWxzZSBjLm5leHRTY2hlZHVsZWRSb290PWQubmV4dFNjaGVkdWxlZFJvb3QsZC5uZXh0U2NoZWR1bGVkUm9vdD1udWxsO2Q9Yy5uZXh0U2NoZWR1bGVkUm9vdH1lbHNle2lmKDA9PT1hfHxlPGEpYT1lLGI9ZDtpZihkPT09TylicmVhaztjPWQ7ZD1kLm5leHRTY2hlZHVsZWRSb290fX1jPW1hO251bGwhPT1jJiZjPT09Yj9SYisrOlJiPTA7bWE9YjtuYT1hfWZ1bmN0aW9uIEooYSl7dygwLGEpfWZ1bmN0aW9uIHcoYSxiKXtmYj1iO2ZvcihOKCk7bnVsbCE9PW1hJiYwIT09bmEmJigwPT09YXx8bmE8PWEpJiYhWWM7KW0obWEsbmEpLE4oKTtudWxsIT09ZmImJihUYj0wLFhjPS0xKTswIT09bmEmJkwobmEpO2ZiPW51bGw7WWM9ITE7UmI9MDtpZihVYil0aHJvdyBhPVpjLFpjPVxubnVsbCxVYj0hMSxhO31mdW5jdGlvbiBtKGEsYyl7RmE/RShcIjI0NVwiKTp2b2lkIDA7RmE9ITA7aWYoYzw9SSgpKXt2YXIgZD1hLmZpbmlzaGVkV29yaztudWxsIT09ZD8oYS5maW5pc2hlZFdvcms9bnVsbCxhLnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lPWIoZCkpOihhLmZpbmlzaGVkV29yaz1udWxsLGQ9ZyhhLGMpLG51bGwhPT1kJiYoYS5yZW1haW5pbmdFeHBpcmF0aW9uVGltZT1iKGQpKSl9ZWxzZSBkPWEuZmluaXNoZWRXb3JrLG51bGwhPT1kPyhhLmZpbmlzaGVkV29yaz1udWxsLGEucmVtYWluaW5nRXhwaXJhdGlvblRpbWU9YihkKSk6KGEuZmluaXNoZWRXb3JrPW51bGwsZD1nKGEsYyksbnVsbCE9PWQmJihBKCk/YS5maW5pc2hlZFdvcms9ZDphLnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lPWIoZCkpKTtGYT0hMX1mdW5jdGlvbiBBKCl7cmV0dXJuIG51bGw9PT1mYnx8ZmIudGltZVJlbWFpbmluZygpPkxnPyExOlljPSEwfWZ1bmN0aW9uIE9iKGEpe251bGw9PT1tYT9FKFwiMjQ2XCIpOlxudm9pZCAwO21hLnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lPTA7VWJ8fChVYj0hMCxaYz1hKX12YXIgcj1oZihhKSxuPWpmKGEpLHA9ci5wb3BIb3N0Q29udGFpbmVyLHFnPXIucG9wSG9zdENvbnRleHQseD1yLnJlc2V0SG9zdENvbnRhaW5lcixNZT1kZihhLHIsbix1LHkpLHJnPU1lLmJlZ2luV29yayxHZz1NZS5iZWdpbkZhaWxlZFdvcmssRmc9ZWYoYSxyLG4pLmNvbXBsZXRlV29yaztyPWZmKGEsaCk7dmFyIHpnPXIuY29tbWl0UmVzZXRUZXh0Q29udGVudCxOZT1yLmNvbW1pdFBsYWNlbWVudCxCZz1yLmNvbW1pdERlbGV0aW9uLE9lPXIuY29tbWl0V29yayxEZz1yLmNvbW1pdExpZmVDeWNsZXMsRWc9ci5jb21taXRBdHRhY2hSZWYsQWc9ci5jb21taXREZXRhY2hSZWYsV2M9YS5ub3csS2c9YS5zY2hlZHVsZURlZmVycmVkQ2FsbGJhY2ssSmc9YS5jYW5jZWxEZWZlcnJlZENhbGxiYWNrLEhnPWEudXNlU3luY1NjaGVkdWxpbmcseWc9YS5wcmVwYXJlRm9yQ29tbWl0LENnPWEucmVzZXRBZnRlckNvbW1pdCxcblBlPVdjKCksVWM9MixrYT0wLGphPSExLEY9bnVsbCxyYT1udWxsLEg9MCx0PW51bGwsUj1udWxsLHFhPW51bGwsaGE9bnVsbCxjYT1udWxsLGViPSExLFFiPSExLFNjPSExLHNhPW51bGwsTz1udWxsLFRiPTAsWGM9LTEsRmE9ITEsbWE9bnVsbCxuYT0wLFljPSExLFViPSExLFpjPW51bGwsZmI9bnVsbCxsYT0hMSxTYj0hMSxJZz0xRTMsUmI9MCxMZz0xO3JldHVybntjb21wdXRlQXN5bmNFeHBpcmF0aW9uOnYsY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcjp5LHNjaGVkdWxlV29yazp1LGJhdGNoZWRVcGRhdGVzOmZ1bmN0aW9uKGEsYil7dmFyIGM9bGE7bGE9ITA7dHJ5e3JldHVybiBhKGIpfWZpbmFsbHl7KGxhPWMpfHxGYXx8dygxLG51bGwpfX0sdW5iYXRjaGVkVXBkYXRlczpmdW5jdGlvbihhKXtpZihsYSYmIVNiKXtTYj0hMDt0cnl7cmV0dXJuIGEoKX1maW5hbGx5e1NiPSExfX1yZXR1cm4gYSgpfSxmbHVzaFN5bmM6ZnVuY3Rpb24oYSl7dmFyIGI9bGE7bGE9ITA7dHJ5e2E6e3ZhciBjPVxua2E7a2E9MTt0cnl7dmFyIGQ9YSgpO2JyZWFrIGF9ZmluYWxseXtrYT1jfWQ9dm9pZCAwfXJldHVybiBkfWZpbmFsbHl7bGE9YixGYT9FKFwiMTg3XCIpOnZvaWQgMCx3KDEsbnVsbCl9fSxkZWZlcnJlZFVwZGF0ZXM6ZnVuY3Rpb24oYSl7dmFyIGI9a2E7a2E9digpO3RyeXtyZXR1cm4gYSgpfWZpbmFsbHl7a2E9Yn19fX1cbmZ1bmN0aW9uIGxmKGEpe2Z1bmN0aW9uIGIoYSl7YT1vZChhKTtyZXR1cm4gbnVsbD09PWE/bnVsbDphLnN0YXRlTm9kZX12YXIgYz1hLmdldFB1YmxpY0luc3RhbmNlO2E9a2YoYSk7dmFyIGQ9YS5jb21wdXRlQXN5bmNFeHBpcmF0aW9uLGU9YS5jb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyLGY9YS5zY2hlZHVsZVdvcms7cmV0dXJue2NyZWF0ZUNvbnRhaW5lcjpmdW5jdGlvbihhLGIpe3ZhciBjPW5ldyBZKDMsbnVsbCwwKTthPXtjdXJyZW50OmMsY29udGFpbmVySW5mbzphLHBlbmRpbmdDaGlsZHJlbjpudWxsLHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lOjAsaXNSZWFkeUZvckNvbW1pdDohMSxmaW5pc2hlZFdvcms6bnVsbCxjb250ZXh0Om51bGwscGVuZGluZ0NvbnRleHQ6bnVsbCxoeWRyYXRlOmIsbmV4dFNjaGVkdWxlZFJvb3Q6bnVsbH07cmV0dXJuIGMuc3RhdGVOb2RlPWF9LHVwZGF0ZUNvbnRhaW5lcjpmdW5jdGlvbihhLGIsYyxxKXt2YXIgZz1iLmN1cnJlbnQ7aWYoYyl7Yz1cbmMuX3JlYWN0SW50ZXJuYWxGaWJlcjt2YXIgaDtiOnsyPT09a2QoYykmJjI9PT1jLnRhZz92b2lkIDA6RShcIjE3MFwiKTtmb3IoaD1jOzMhPT1oLnRhZzspe2lmKGxlKGgpKXtoPWguc3RhdGVOb2RlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0O2JyZWFrIGJ9KGg9aFtcInJldHVyblwiXSk/dm9pZCAwOkUoXCIxNzFcIil9aD1oLnN0YXRlTm9kZS5jb250ZXh0fWM9bGUoYyk/cGUoYyxoKTpofWVsc2UgYz1EO251bGw9PT1iLmNvbnRleHQ/Yi5jb250ZXh0PWM6Yi5wZW5kaW5nQ29udGV4dD1jO2I9cTtiPXZvaWQgMD09PWI/bnVsbDpiO3E9bnVsbCE9YSYmbnVsbCE9YS50eXBlJiZudWxsIT1hLnR5cGUucHJvdG90eXBlJiYhMD09PWEudHlwZS5wcm90b3R5cGUudW5zdGFibGVfaXNBc3luY1JlYWN0Q29tcG9uZW50P2QoKTplKGcpO0hlKGcse2V4cGlyYXRpb25UaW1lOnEscGFydGlhbFN0YXRlOntlbGVtZW50OmF9LGNhbGxiYWNrOmIsaXNSZXBsYWNlOiExLGlzRm9yY2VkOiExLFxubmV4dENhbGxiYWNrOm51bGwsbmV4dDpudWxsfSk7ZihnLHEpfSxiYXRjaGVkVXBkYXRlczphLmJhdGNoZWRVcGRhdGVzLHVuYmF0Y2hlZFVwZGF0ZXM6YS51bmJhdGNoZWRVcGRhdGVzLGRlZmVycmVkVXBkYXRlczphLmRlZmVycmVkVXBkYXRlcyxmbHVzaFN5bmM6YS5mbHVzaFN5bmMsZ2V0UHVibGljUm9vdEluc3RhbmNlOmZ1bmN0aW9uKGEpe2E9YS5jdXJyZW50O2lmKCFhLmNoaWxkKXJldHVybiBudWxsO3N3aXRjaChhLmNoaWxkLnRhZyl7Y2FzZSA1OnJldHVybiBjKGEuY2hpbGQuc3RhdGVOb2RlKTtkZWZhdWx0OnJldHVybiBhLmNoaWxkLnN0YXRlTm9kZX19LGZpbmRIb3N0SW5zdGFuY2U6YixmaW5kSG9zdEluc3RhbmNlV2l0aE5vUG9ydGFsczpmdW5jdGlvbihhKXthPXBkKGEpO3JldHVybiBudWxsPT09YT9udWxsOmEuc3RhdGVOb2RlfSxpbmplY3RJbnRvRGV2VG9vbHM6ZnVuY3Rpb24oYSl7dmFyIGM9YS5maW5kRmliZXJCeUhvc3RJbnN0YW5jZTtyZXR1cm4gQ2UoQih7fSxcbmEse2ZpbmRIb3N0SW5zdGFuY2VCeUZpYmVyOmZ1bmN0aW9uKGEpe3JldHVybiBiKGEpfSxmaW5kRmliZXJCeUhvc3RJbnN0YW5jZTpmdW5jdGlvbihhKXtyZXR1cm4gYz9jKGEpOm51bGx9fSkpfX19dmFyIG1mPU9iamVjdC5mcmVlemUoe2RlZmF1bHQ6bGZ9KSxuZj1tZiYmbGZ8fG1mLG9mPW5mW1wiZGVmYXVsdFwiXT9uZltcImRlZmF1bHRcIl06bmY7ZnVuY3Rpb24gcGYoYSxiLGMpe3ZhciBkPTM8YXJndW1lbnRzLmxlbmd0aCYmdm9pZCAwIT09YXJndW1lbnRzWzNdP2FyZ3VtZW50c1szXTpudWxsO3JldHVybnskJHR5cGVvZjpVZSxrZXk6bnVsbD09ZD9udWxsOlwiXCIrZCxjaGlsZHJlbjphLGNvbnRhaW5lckluZm86YixpbXBsZW1lbnRhdGlvbjpjfX12YXIgcWY9XCJvYmplY3RcIj09PXR5cGVvZiBwZXJmb3JtYW5jZSYmXCJmdW5jdGlvblwiPT09dHlwZW9mIHBlcmZvcm1hbmNlLm5vdyxyZj12b2lkIDA7cmY9cWY/ZnVuY3Rpb24oKXtyZXR1cm4gcGVyZm9ybWFuY2Uubm93KCl9OmZ1bmN0aW9uKCl7cmV0dXJuIERhdGUubm93KCl9O1xudmFyIHNmPXZvaWQgMCx0Zj12b2lkIDA7XG5pZihsLmNhblVzZURPTSlpZihcImZ1bmN0aW9uXCIhPT10eXBlb2YgcmVxdWVzdElkbGVDYWxsYmFja3x8XCJmdW5jdGlvblwiIT09dHlwZW9mIGNhbmNlbElkbGVDYWxsYmFjayl7dmFyIHVmPW51bGwsdmY9ITEsd2Y9LTEseGY9ITEseWY9MCx6Zj0zMyxBZj0zMyxCZjtCZj1xZj97ZGlkVGltZW91dDohMSx0aW1lUmVtYWluaW5nOmZ1bmN0aW9uKCl7dmFyIGE9eWYtcGVyZm9ybWFuY2Uubm93KCk7cmV0dXJuIDA8YT9hOjB9fTp7ZGlkVGltZW91dDohMSx0aW1lUmVtYWluaW5nOmZ1bmN0aW9uKCl7dmFyIGE9eWYtRGF0ZS5ub3coKTtyZXR1cm4gMDxhP2E6MH19O3ZhciBDZj1cIl9fcmVhY3RJZGxlQ2FsbGJhY2skXCIrTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsZnVuY3Rpb24oYSl7aWYoYS5zb3VyY2U9PT13aW5kb3cmJmEuZGF0YT09PUNmKXt2Zj0hMTthPXJmKCk7aWYoMD49eWYtYSlpZigtMSE9PXdmJiZ3Zjw9XG5hKUJmLmRpZFRpbWVvdXQ9ITA7ZWxzZXt4Znx8KHhmPSEwLHJlcXVlc3RBbmltYXRpb25GcmFtZShEZikpO3JldHVybn1lbHNlIEJmLmRpZFRpbWVvdXQ9ITE7d2Y9LTE7YT11Zjt1Zj1udWxsO251bGwhPT1hJiZhKEJmKX19LCExKTt2YXIgRGY9ZnVuY3Rpb24oYSl7eGY9ITE7dmFyIGI9YS15ZitBZjtiPEFmJiZ6ZjxBZj8oOD5iJiYoYj04KSxBZj1iPHpmP3pmOmIpOnpmPWI7eWY9YStBZjt2Znx8KHZmPSEwLHdpbmRvdy5wb3N0TWVzc2FnZShDZixcIipcIikpfTtzZj1mdW5jdGlvbihhLGIpe3VmPWE7bnVsbCE9YiYmXCJudW1iZXJcIj09PXR5cGVvZiBiLnRpbWVvdXQmJih3Zj1yZigpK2IudGltZW91dCk7eGZ8fCh4Zj0hMCxyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoRGYpKTtyZXR1cm4gMH07dGY9ZnVuY3Rpb24oKXt1Zj1udWxsO3ZmPSExO3dmPS0xfX1lbHNlIHNmPXdpbmRvdy5yZXF1ZXN0SWRsZUNhbGxiYWNrLHRmPXdpbmRvdy5jYW5jZWxJZGxlQ2FsbGJhY2s7ZWxzZSBzZj1mdW5jdGlvbihhKXtyZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpe2Eoe3RpbWVSZW1haW5pbmc6ZnVuY3Rpb24oKXtyZXR1cm4gSW5maW5pdHl9fSl9KX0sXG50Zj1mdW5jdGlvbihhKXtjbGVhclRpbWVvdXQoYSl9O3ZhciBFZj0vXls6QS1aX2EtelxcdTAwQzAtXFx1MDBENlxcdTAwRDgtXFx1MDBGNlxcdTAwRjgtXFx1MDJGRlxcdTAzNzAtXFx1MDM3RFxcdTAzN0YtXFx1MUZGRlxcdTIwMEMtXFx1MjAwRFxcdTIwNzAtXFx1MjE4RlxcdTJDMDAtXFx1MkZFRlxcdTMwMDEtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZGRF1bOkEtWl9hLXpcXHUwMEMwLVxcdTAwRDZcXHUwMEQ4LVxcdTAwRjZcXHUwMEY4LVxcdTAyRkZcXHUwMzcwLVxcdTAzN0RcXHUwMzdGLVxcdTFGRkZcXHUyMDBDLVxcdTIwMERcXHUyMDcwLVxcdTIxOEZcXHUyQzAwLVxcdTJGRUZcXHUzMDAxLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRkRcXC0uMC05XFx1MDBCN1xcdTAzMDAtXFx1MDM2RlxcdTIwM0YtXFx1MjA0MF0qJC8sRmY9e30sR2Y9e307XG5mdW5jdGlvbiBIZihhKXtpZihHZi5oYXNPd25Qcm9wZXJ0eShhKSlyZXR1cm4hMDtpZihGZi5oYXNPd25Qcm9wZXJ0eShhKSlyZXR1cm4hMTtpZihFZi50ZXN0KGEpKXJldHVybiBHZlthXT0hMDtGZlthXT0hMDtyZXR1cm4hMX1cbmZ1bmN0aW9uIElmKGEsYixjKXt2YXIgZD13YShiKTtpZihkJiZ2YShiLGMpKXt2YXIgZT1kLm11dGF0aW9uTWV0aG9kO2U/ZShhLGMpOm51bGw9PWN8fGQuaGFzQm9vbGVhblZhbHVlJiYhY3x8ZC5oYXNOdW1lcmljVmFsdWUmJmlzTmFOKGMpfHxkLmhhc1Bvc2l0aXZlTnVtZXJpY1ZhbHVlJiYxPmN8fGQuaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZSYmITE9PT1jP0pmKGEsYik6ZC5tdXN0VXNlUHJvcGVydHk/YVtkLnByb3BlcnR5TmFtZV09YzooYj1kLmF0dHJpYnV0ZU5hbWUsKGU9ZC5hdHRyaWJ1dGVOYW1lc3BhY2UpP2Euc2V0QXR0cmlidXRlTlMoZSxiLFwiXCIrYyk6ZC5oYXNCb29sZWFuVmFsdWV8fGQuaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZSYmITA9PT1jP2Euc2V0QXR0cmlidXRlKGIsXCJcIik6YS5zZXRBdHRyaWJ1dGUoYixcIlwiK2MpKX1lbHNlIEtmKGEsYix2YShiLGMpP2M6bnVsbCl9XG5mdW5jdGlvbiBLZihhLGIsYyl7SGYoYikmJihudWxsPT1jP2EucmVtb3ZlQXR0cmlidXRlKGIpOmEuc2V0QXR0cmlidXRlKGIsXCJcIitjKSl9ZnVuY3Rpb24gSmYoYSxiKXt2YXIgYz13YShiKTtjPyhiPWMubXV0YXRpb25NZXRob2QpP2IoYSx2b2lkIDApOmMubXVzdFVzZVByb3BlcnR5P2FbYy5wcm9wZXJ0eU5hbWVdPWMuaGFzQm9vbGVhblZhbHVlPyExOlwiXCI6YS5yZW1vdmVBdHRyaWJ1dGUoYy5hdHRyaWJ1dGVOYW1lKTphLnJlbW92ZUF0dHJpYnV0ZShiKX1cbmZ1bmN0aW9uIExmKGEsYil7dmFyIGM9Yi52YWx1ZSxkPWIuY2hlY2tlZDtyZXR1cm4gQih7dHlwZTp2b2lkIDAsc3RlcDp2b2lkIDAsbWluOnZvaWQgMCxtYXg6dm9pZCAwfSxiLHtkZWZhdWx0Q2hlY2tlZDp2b2lkIDAsZGVmYXVsdFZhbHVlOnZvaWQgMCx2YWx1ZTpudWxsIT1jP2M6YS5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZSxjaGVja2VkOm51bGwhPWQ/ZDphLl93cmFwcGVyU3RhdGUuaW5pdGlhbENoZWNrZWR9KX1mdW5jdGlvbiBNZihhLGIpe3ZhciBjPWIuZGVmYXVsdFZhbHVlO2EuX3dyYXBwZXJTdGF0ZT17aW5pdGlhbENoZWNrZWQ6bnVsbCE9Yi5jaGVja2VkP2IuY2hlY2tlZDpiLmRlZmF1bHRDaGVja2VkLGluaXRpYWxWYWx1ZTpudWxsIT1iLnZhbHVlP2IudmFsdWU6Yyxjb250cm9sbGVkOlwiY2hlY2tib3hcIj09PWIudHlwZXx8XCJyYWRpb1wiPT09Yi50eXBlP251bGwhPWIuY2hlY2tlZDpudWxsIT1iLnZhbHVlfX1cbmZ1bmN0aW9uIE5mKGEsYil7Yj1iLmNoZWNrZWQ7bnVsbCE9YiYmSWYoYSxcImNoZWNrZWRcIixiKX1mdW5jdGlvbiBPZihhLGIpe05mKGEsYik7dmFyIGM9Yi52YWx1ZTtpZihudWxsIT1jKWlmKDA9PT1jJiZcIlwiPT09YS52YWx1ZSlhLnZhbHVlPVwiMFwiO2Vsc2UgaWYoXCJudW1iZXJcIj09PWIudHlwZSl7aWYoYj1wYXJzZUZsb2F0KGEudmFsdWUpfHwwLGMhPWJ8fGM9PWImJmEudmFsdWUhPWMpYS52YWx1ZT1cIlwiK2N9ZWxzZSBhLnZhbHVlIT09XCJcIitjJiYoYS52YWx1ZT1cIlwiK2MpO2Vsc2UgbnVsbD09Yi52YWx1ZSYmbnVsbCE9Yi5kZWZhdWx0VmFsdWUmJmEuZGVmYXVsdFZhbHVlIT09XCJcIitiLmRlZmF1bHRWYWx1ZSYmKGEuZGVmYXVsdFZhbHVlPVwiXCIrYi5kZWZhdWx0VmFsdWUpLG51bGw9PWIuY2hlY2tlZCYmbnVsbCE9Yi5kZWZhdWx0Q2hlY2tlZCYmKGEuZGVmYXVsdENoZWNrZWQ9ISFiLmRlZmF1bHRDaGVja2VkKX1cbmZ1bmN0aW9uIFBmKGEsYil7c3dpdGNoKGIudHlwZSl7Y2FzZSBcInN1Ym1pdFwiOmNhc2UgXCJyZXNldFwiOmJyZWFrO2Nhc2UgXCJjb2xvclwiOmNhc2UgXCJkYXRlXCI6Y2FzZSBcImRhdGV0aW1lXCI6Y2FzZSBcImRhdGV0aW1lLWxvY2FsXCI6Y2FzZSBcIm1vbnRoXCI6Y2FzZSBcInRpbWVcIjpjYXNlIFwid2Vla1wiOmEudmFsdWU9XCJcIjthLnZhbHVlPWEuZGVmYXVsdFZhbHVlO2JyZWFrO2RlZmF1bHQ6YS52YWx1ZT1hLnZhbHVlfWI9YS5uYW1lO1wiXCIhPT1iJiYoYS5uYW1lPVwiXCIpO2EuZGVmYXVsdENoZWNrZWQ9IWEuZGVmYXVsdENoZWNrZWQ7YS5kZWZhdWx0Q2hlY2tlZD0hYS5kZWZhdWx0Q2hlY2tlZDtcIlwiIT09YiYmKGEubmFtZT1iKX1mdW5jdGlvbiBRZihhKXt2YXIgYj1cIlwiO2FhLkNoaWxkcmVuLmZvckVhY2goYSxmdW5jdGlvbihhKXtudWxsPT1hfHxcInN0cmluZ1wiIT09dHlwZW9mIGEmJlwibnVtYmVyXCIhPT10eXBlb2YgYXx8KGIrPWEpfSk7cmV0dXJuIGJ9XG5mdW5jdGlvbiBSZihhLGIpe2E9Qih7Y2hpbGRyZW46dm9pZCAwfSxiKTtpZihiPVFmKGIuY2hpbGRyZW4pKWEuY2hpbGRyZW49YjtyZXR1cm4gYX1mdW5jdGlvbiBTZihhLGIsYyxkKXthPWEub3B0aW9ucztpZihiKXtiPXt9O2Zvcih2YXIgZT0wO2U8Yy5sZW5ndGg7ZSsrKWJbXCIkXCIrY1tlXV09ITA7Zm9yKGM9MDtjPGEubGVuZ3RoO2MrKyllPWIuaGFzT3duUHJvcGVydHkoXCIkXCIrYVtjXS52YWx1ZSksYVtjXS5zZWxlY3RlZCE9PWUmJihhW2NdLnNlbGVjdGVkPWUpLGUmJmQmJihhW2NdLmRlZmF1bHRTZWxlY3RlZD0hMCl9ZWxzZXtjPVwiXCIrYztiPW51bGw7Zm9yKGU9MDtlPGEubGVuZ3RoO2UrKyl7aWYoYVtlXS52YWx1ZT09PWMpe2FbZV0uc2VsZWN0ZWQ9ITA7ZCYmKGFbZV0uZGVmYXVsdFNlbGVjdGVkPSEwKTtyZXR1cm59bnVsbCE9PWJ8fGFbZV0uZGlzYWJsZWR8fChiPWFbZV0pfW51bGwhPT1iJiYoYi5zZWxlY3RlZD0hMCl9fVxuZnVuY3Rpb24gVGYoYSxiKXt2YXIgYz1iLnZhbHVlO2EuX3dyYXBwZXJTdGF0ZT17aW5pdGlhbFZhbHVlOm51bGwhPWM/YzpiLmRlZmF1bHRWYWx1ZSx3YXNNdWx0aXBsZTohIWIubXVsdGlwbGV9fWZ1bmN0aW9uIFVmKGEsYil7bnVsbCE9Yi5kYW5nZXJvdXNseVNldElubmVySFRNTD9FKFwiOTFcIik6dm9pZCAwO3JldHVybiBCKHt9LGIse3ZhbHVlOnZvaWQgMCxkZWZhdWx0VmFsdWU6dm9pZCAwLGNoaWxkcmVuOlwiXCIrYS5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZX0pfWZ1bmN0aW9uIFZmKGEsYil7dmFyIGM9Yi52YWx1ZTtudWxsPT1jJiYoYz1iLmRlZmF1bHRWYWx1ZSxiPWIuY2hpbGRyZW4sbnVsbCE9YiYmKG51bGwhPWM/RShcIjkyXCIpOnZvaWQgMCxBcnJheS5pc0FycmF5KGIpJiYoMT49Yi5sZW5ndGg/dm9pZCAwOkUoXCI5M1wiKSxiPWJbMF0pLGM9XCJcIitiKSxudWxsPT1jJiYoYz1cIlwiKSk7YS5fd3JhcHBlclN0YXRlPXtpbml0aWFsVmFsdWU6XCJcIitjfX1cbmZ1bmN0aW9uIFdmKGEsYil7dmFyIGM9Yi52YWx1ZTtudWxsIT1jJiYoYz1cIlwiK2MsYyE9PWEudmFsdWUmJihhLnZhbHVlPWMpLG51bGw9PWIuZGVmYXVsdFZhbHVlJiYoYS5kZWZhdWx0VmFsdWU9YykpO251bGwhPWIuZGVmYXVsdFZhbHVlJiYoYS5kZWZhdWx0VmFsdWU9Yi5kZWZhdWx0VmFsdWUpfWZ1bmN0aW9uIFhmKGEpe3ZhciBiPWEudGV4dENvbnRlbnQ7Yj09PWEuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUmJihhLnZhbHVlPWIpfXZhciBZZj17aHRtbDpcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIixtYXRobWw6XCJodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MXCIsc3ZnOlwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIn07XG5mdW5jdGlvbiBaZihhKXtzd2l0Y2goYSl7Y2FzZSBcInN2Z1wiOnJldHVyblwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIjtjYXNlIFwibWF0aFwiOnJldHVyblwiaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTFwiO2RlZmF1bHQ6cmV0dXJuXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCJ9fWZ1bmN0aW9uICRmKGEsYil7cmV0dXJuIG51bGw9PWF8fFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiPT09YT9aZihiKTpcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI9PT1hJiZcImZvcmVpZ25PYmplY3RcIj09PWI/XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCI6YX1cbnZhciBhZz12b2lkIDAsYmc9ZnVuY3Rpb24oYSl7cmV0dXJuXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBNU0FwcCYmTVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24/ZnVuY3Rpb24oYixjLGQsZSl7TVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24oZnVuY3Rpb24oKXtyZXR1cm4gYShiLGMsZCxlKX0pfTphfShmdW5jdGlvbihhLGIpe2lmKGEubmFtZXNwYWNlVVJJIT09WWYuc3ZnfHxcImlubmVySFRNTFwiaW4gYSlhLmlubmVySFRNTD1iO2Vsc2V7YWc9YWd8fGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7YWcuaW5uZXJIVE1MPVwiXFx4M2NzdmdcXHgzZVwiK2IrXCJcXHgzYy9zdmdcXHgzZVwiO2ZvcihiPWFnLmZpcnN0Q2hpbGQ7YS5maXJzdENoaWxkOylhLnJlbW92ZUNoaWxkKGEuZmlyc3RDaGlsZCk7Zm9yKDtiLmZpcnN0Q2hpbGQ7KWEuYXBwZW5kQ2hpbGQoYi5maXJzdENoaWxkKX19KTtcbmZ1bmN0aW9uIGNnKGEsYil7aWYoYil7dmFyIGM9YS5maXJzdENoaWxkO2lmKGMmJmM9PT1hLmxhc3RDaGlsZCYmMz09PWMubm9kZVR5cGUpe2Mubm9kZVZhbHVlPWI7cmV0dXJufX1hLnRleHRDb250ZW50PWJ9XG52YXIgZGc9e2FuaW1hdGlvbkl0ZXJhdGlvbkNvdW50OiEwLGJvcmRlckltYWdlT3V0c2V0OiEwLGJvcmRlckltYWdlU2xpY2U6ITAsYm9yZGVySW1hZ2VXaWR0aDohMCxib3hGbGV4OiEwLGJveEZsZXhHcm91cDohMCxib3hPcmRpbmFsR3JvdXA6ITAsY29sdW1uQ291bnQ6ITAsY29sdW1uczohMCxmbGV4OiEwLGZsZXhHcm93OiEwLGZsZXhQb3NpdGl2ZTohMCxmbGV4U2hyaW5rOiEwLGZsZXhOZWdhdGl2ZTohMCxmbGV4T3JkZXI6ITAsZ3JpZFJvdzohMCxncmlkUm93RW5kOiEwLGdyaWRSb3dTcGFuOiEwLGdyaWRSb3dTdGFydDohMCxncmlkQ29sdW1uOiEwLGdyaWRDb2x1bW5FbmQ6ITAsZ3JpZENvbHVtblNwYW46ITAsZ3JpZENvbHVtblN0YXJ0OiEwLGZvbnRXZWlnaHQ6ITAsbGluZUNsYW1wOiEwLGxpbmVIZWlnaHQ6ITAsb3BhY2l0eTohMCxvcmRlcjohMCxvcnBoYW5zOiEwLHRhYlNpemU6ITAsd2lkb3dzOiEwLHpJbmRleDohMCx6b29tOiEwLGZpbGxPcGFjaXR5OiEwLGZsb29kT3BhY2l0eTohMCxcbnN0b3BPcGFjaXR5OiEwLHN0cm9rZURhc2hhcnJheTohMCxzdHJva2VEYXNob2Zmc2V0OiEwLHN0cm9rZU1pdGVybGltaXQ6ITAsc3Ryb2tlT3BhY2l0eTohMCxzdHJva2VXaWR0aDohMH0sZWc9W1wiV2Via2l0XCIsXCJtc1wiLFwiTW96XCIsXCJPXCJdO09iamVjdC5rZXlzKGRnKS5mb3JFYWNoKGZ1bmN0aW9uKGEpe2VnLmZvckVhY2goZnVuY3Rpb24oYil7Yj1iK2EuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrYS5zdWJzdHJpbmcoMSk7ZGdbYl09ZGdbYV19KX0pO1xuZnVuY3Rpb24gZmcoYSxiKXthPWEuc3R5bGU7Zm9yKHZhciBjIGluIGIpaWYoYi5oYXNPd25Qcm9wZXJ0eShjKSl7dmFyIGQ9MD09PWMuaW5kZXhPZihcIi0tXCIpO3ZhciBlPWM7dmFyIGY9YltjXTtlPW51bGw9PWZ8fFwiYm9vbGVhblwiPT09dHlwZW9mIGZ8fFwiXCI9PT1mP1wiXCI6ZHx8XCJudW1iZXJcIiE9PXR5cGVvZiBmfHwwPT09Znx8ZGcuaGFzT3duUHJvcGVydHkoZSkmJmRnW2VdPyhcIlwiK2YpLnRyaW0oKTpmK1wicHhcIjtcImZsb2F0XCI9PT1jJiYoYz1cImNzc0Zsb2F0XCIpO2Q/YS5zZXRQcm9wZXJ0eShjLGUpOmFbY109ZX19dmFyIGdnPUIoe21lbnVpdGVtOiEwfSx7YXJlYTohMCxiYXNlOiEwLGJyOiEwLGNvbDohMCxlbWJlZDohMCxocjohMCxpbWc6ITAsaW5wdXQ6ITAsa2V5Z2VuOiEwLGxpbms6ITAsbWV0YTohMCxwYXJhbTohMCxzb3VyY2U6ITAsdHJhY2s6ITAsd2JyOiEwfSk7XG5mdW5jdGlvbiBoZyhhLGIsYyl7YiYmKGdnW2FdJiYobnVsbCE9Yi5jaGlsZHJlbnx8bnVsbCE9Yi5kYW5nZXJvdXNseVNldElubmVySFRNTD9FKFwiMTM3XCIsYSxjKCkpOnZvaWQgMCksbnVsbCE9Yi5kYW5nZXJvdXNseVNldElubmVySFRNTCYmKG51bGwhPWIuY2hpbGRyZW4/RShcIjYwXCIpOnZvaWQgMCxcIm9iamVjdFwiPT09dHlwZW9mIGIuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwmJlwiX19odG1sXCJpbiBiLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MP3ZvaWQgMDpFKFwiNjFcIikpLG51bGwhPWIuc3R5bGUmJlwib2JqZWN0XCIhPT10eXBlb2YgYi5zdHlsZT9FKFwiNjJcIixjKCkpOnZvaWQgMCl9XG5mdW5jdGlvbiBpZyhhLGIpe2lmKC0xPT09YS5pbmRleE9mKFwiLVwiKSlyZXR1cm5cInN0cmluZ1wiPT09dHlwZW9mIGIuaXM7c3dpdGNoKGEpe2Nhc2UgXCJhbm5vdGF0aW9uLXhtbFwiOmNhc2UgXCJjb2xvci1wcm9maWxlXCI6Y2FzZSBcImZvbnQtZmFjZVwiOmNhc2UgXCJmb250LWZhY2Utc3JjXCI6Y2FzZSBcImZvbnQtZmFjZS11cmlcIjpjYXNlIFwiZm9udC1mYWNlLWZvcm1hdFwiOmNhc2UgXCJmb250LWZhY2UtbmFtZVwiOmNhc2UgXCJtaXNzaW5nLWdseXBoXCI6cmV0dXJuITE7ZGVmYXVsdDpyZXR1cm4hMH19dmFyIGpnPVlmLmh0bWwsa2c9Qy50aGF0UmV0dXJucyhcIlwiKTtcbmZ1bmN0aW9uIGxnKGEsYil7YT05PT09YS5ub2RlVHlwZXx8MTE9PT1hLm5vZGVUeXBlP2E6YS5vd25lckRvY3VtZW50O3ZhciBjPUhkKGEpO2I9U2FbYl07Zm9yKHZhciBkPTA7ZDxiLmxlbmd0aDtkKyspe3ZhciBlPWJbZF07Yy5oYXNPd25Qcm9wZXJ0eShlKSYmY1tlXXx8KFwidG9wU2Nyb2xsXCI9PT1lP3dkKFwidG9wU2Nyb2xsXCIsXCJzY3JvbGxcIixhKTpcInRvcEZvY3VzXCI9PT1lfHxcInRvcEJsdXJcIj09PWU/KHdkKFwidG9wRm9jdXNcIixcImZvY3VzXCIsYSksd2QoXCJ0b3BCbHVyXCIsXCJibHVyXCIsYSksYy50b3BCbHVyPSEwLGMudG9wRm9jdXM9ITApOlwidG9wQ2FuY2VsXCI9PT1lPyh5YyhcImNhbmNlbFwiLCEwKSYmd2QoXCJ0b3BDYW5jZWxcIixcImNhbmNlbFwiLGEpLGMudG9wQ2FuY2VsPSEwKTpcInRvcENsb3NlXCI9PT1lPyh5YyhcImNsb3NlXCIsITApJiZ3ZChcInRvcENsb3NlXCIsXCJjbG9zZVwiLGEpLGMudG9wQ2xvc2U9ITApOkRkLmhhc093blByb3BlcnR5KGUpJiZVKGUsRGRbZV0sYSksY1tlXT0hMCl9fVxudmFyIG1nPXt0b3BBYm9ydDpcImFib3J0XCIsdG9wQ2FuUGxheTpcImNhbnBsYXlcIix0b3BDYW5QbGF5VGhyb3VnaDpcImNhbnBsYXl0aHJvdWdoXCIsdG9wRHVyYXRpb25DaGFuZ2U6XCJkdXJhdGlvbmNoYW5nZVwiLHRvcEVtcHRpZWQ6XCJlbXB0aWVkXCIsdG9wRW5jcnlwdGVkOlwiZW5jcnlwdGVkXCIsdG9wRW5kZWQ6XCJlbmRlZFwiLHRvcEVycm9yOlwiZXJyb3JcIix0b3BMb2FkZWREYXRhOlwibG9hZGVkZGF0YVwiLHRvcExvYWRlZE1ldGFkYXRhOlwibG9hZGVkbWV0YWRhdGFcIix0b3BMb2FkU3RhcnQ6XCJsb2Fkc3RhcnRcIix0b3BQYXVzZTpcInBhdXNlXCIsdG9wUGxheTpcInBsYXlcIix0b3BQbGF5aW5nOlwicGxheWluZ1wiLHRvcFByb2dyZXNzOlwicHJvZ3Jlc3NcIix0b3BSYXRlQ2hhbmdlOlwicmF0ZWNoYW5nZVwiLHRvcFNlZWtlZDpcInNlZWtlZFwiLHRvcFNlZWtpbmc6XCJzZWVraW5nXCIsdG9wU3RhbGxlZDpcInN0YWxsZWRcIix0b3BTdXNwZW5kOlwic3VzcGVuZFwiLHRvcFRpbWVVcGRhdGU6XCJ0aW1ldXBkYXRlXCIsdG9wVm9sdW1lQ2hhbmdlOlwidm9sdW1lY2hhbmdlXCIsXG50b3BXYWl0aW5nOlwid2FpdGluZ1wifTtmdW5jdGlvbiBuZyhhLGIsYyxkKXtjPTk9PT1jLm5vZGVUeXBlP2M6Yy5vd25lckRvY3VtZW50O2Q9PT1qZyYmKGQ9WmYoYSkpO2Q9PT1qZz9cInNjcmlwdFwiPT09YT8oYT1jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksYS5pbm5lckhUTUw9XCJcXHgzY3NjcmlwdFxceDNlXFx4M2Mvc2NyaXB0XFx4M2VcIixhPWEucmVtb3ZlQ2hpbGQoYS5maXJzdENoaWxkKSk6YT1cInN0cmluZ1wiPT09dHlwZW9mIGIuaXM/Yy5jcmVhdGVFbGVtZW50KGEse2lzOmIuaXN9KTpjLmNyZWF0ZUVsZW1lbnQoYSk6YT1jLmNyZWF0ZUVsZW1lbnROUyhkLGEpO3JldHVybiBhfWZ1bmN0aW9uIG9nKGEsYil7cmV0dXJuKDk9PT1iLm5vZGVUeXBlP2I6Yi5vd25lckRvY3VtZW50KS5jcmVhdGVUZXh0Tm9kZShhKX1cbmZ1bmN0aW9uIHBnKGEsYixjLGQpe3ZhciBlPWlnKGIsYyk7c3dpdGNoKGIpe2Nhc2UgXCJpZnJhbWVcIjpjYXNlIFwib2JqZWN0XCI6VShcInRvcExvYWRcIixcImxvYWRcIixhKTt2YXIgZj1jO2JyZWFrO2Nhc2UgXCJ2aWRlb1wiOmNhc2UgXCJhdWRpb1wiOmZvcihmIGluIG1nKW1nLmhhc093blByb3BlcnR5KGYpJiZVKGYsbWdbZl0sYSk7Zj1jO2JyZWFrO2Nhc2UgXCJzb3VyY2VcIjpVKFwidG9wRXJyb3JcIixcImVycm9yXCIsYSk7Zj1jO2JyZWFrO2Nhc2UgXCJpbWdcIjpjYXNlIFwiaW1hZ2VcIjpVKFwidG9wRXJyb3JcIixcImVycm9yXCIsYSk7VShcInRvcExvYWRcIixcImxvYWRcIixhKTtmPWM7YnJlYWs7Y2FzZSBcImZvcm1cIjpVKFwidG9wUmVzZXRcIixcInJlc2V0XCIsYSk7VShcInRvcFN1Ym1pdFwiLFwic3VibWl0XCIsYSk7Zj1jO2JyZWFrO2Nhc2UgXCJkZXRhaWxzXCI6VShcInRvcFRvZ2dsZVwiLFwidG9nZ2xlXCIsYSk7Zj1jO2JyZWFrO2Nhc2UgXCJpbnB1dFwiOk1mKGEsYyk7Zj1MZihhLGMpO1UoXCJ0b3BJbnZhbGlkXCIsXCJpbnZhbGlkXCIsYSk7XG5sZyhkLFwib25DaGFuZ2VcIik7YnJlYWs7Y2FzZSBcIm9wdGlvblwiOmY9UmYoYSxjKTticmVhaztjYXNlIFwic2VsZWN0XCI6VGYoYSxjKTtmPUIoe30sYyx7dmFsdWU6dm9pZCAwfSk7VShcInRvcEludmFsaWRcIixcImludmFsaWRcIixhKTtsZyhkLFwib25DaGFuZ2VcIik7YnJlYWs7Y2FzZSBcInRleHRhcmVhXCI6VmYoYSxjKTtmPVVmKGEsYyk7VShcInRvcEludmFsaWRcIixcImludmFsaWRcIixhKTtsZyhkLFwib25DaGFuZ2VcIik7YnJlYWs7ZGVmYXVsdDpmPWN9aGcoYixmLGtnKTt2YXIgZz1mLGg7Zm9yKGggaW4gZylpZihnLmhhc093blByb3BlcnR5KGgpKXt2YXIgaz1nW2hdO1wic3R5bGVcIj09PWg/ZmcoYSxrLGtnKTpcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI9PT1oPyhrPWs/ay5fX2h0bWw6dm9pZCAwLG51bGwhPWsmJmJnKGEsaykpOlwiY2hpbGRyZW5cIj09PWg/XCJzdHJpbmdcIj09PXR5cGVvZiBrPyhcInRleHRhcmVhXCIhPT1ifHxcIlwiIT09aykmJmNnKGEsayk6XCJudW1iZXJcIj09PXR5cGVvZiBrJiZjZyhhLFxuXCJcIitrKTpcInN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZ1wiIT09aCYmXCJzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmdcIiE9PWgmJlwiYXV0b0ZvY3VzXCIhPT1oJiYoUmEuaGFzT3duUHJvcGVydHkoaCk/bnVsbCE9ayYmbGcoZCxoKTplP0tmKGEsaCxrKTpudWxsIT1rJiZJZihhLGgsaykpfXN3aXRjaChiKXtjYXNlIFwiaW5wdXRcIjpCYyhhKTtQZihhLGMpO2JyZWFrO2Nhc2UgXCJ0ZXh0YXJlYVwiOkJjKGEpO1hmKGEsYyk7YnJlYWs7Y2FzZSBcIm9wdGlvblwiOm51bGwhPWMudmFsdWUmJmEuc2V0QXR0cmlidXRlKFwidmFsdWVcIixjLnZhbHVlKTticmVhaztjYXNlIFwic2VsZWN0XCI6YS5tdWx0aXBsZT0hIWMubXVsdGlwbGU7Yj1jLnZhbHVlO251bGwhPWI/U2YoYSwhIWMubXVsdGlwbGUsYiwhMSk6bnVsbCE9Yy5kZWZhdWx0VmFsdWUmJlNmKGEsISFjLm11bHRpcGxlLGMuZGVmYXVsdFZhbHVlLCEwKTticmVhaztkZWZhdWx0OlwiZnVuY3Rpb25cIj09PXR5cGVvZiBmLm9uQ2xpY2smJihhLm9uY2xpY2s9XG5DKX19XG5mdW5jdGlvbiBzZyhhLGIsYyxkLGUpe3ZhciBmPW51bGw7c3dpdGNoKGIpe2Nhc2UgXCJpbnB1dFwiOmM9TGYoYSxjKTtkPUxmKGEsZCk7Zj1bXTticmVhaztjYXNlIFwib3B0aW9uXCI6Yz1SZihhLGMpO2Q9UmYoYSxkKTtmPVtdO2JyZWFrO2Nhc2UgXCJzZWxlY3RcIjpjPUIoe30sYyx7dmFsdWU6dm9pZCAwfSk7ZD1CKHt9LGQse3ZhbHVlOnZvaWQgMH0pO2Y9W107YnJlYWs7Y2FzZSBcInRleHRhcmVhXCI6Yz1VZihhLGMpO2Q9VWYoYSxkKTtmPVtdO2JyZWFrO2RlZmF1bHQ6XCJmdW5jdGlvblwiIT09dHlwZW9mIGMub25DbGljayYmXCJmdW5jdGlvblwiPT09dHlwZW9mIGQub25DbGljayYmKGEub25jbGljaz1DKX1oZyhiLGQsa2cpO3ZhciBnLGg7YT1udWxsO2ZvcihnIGluIGMpaWYoIWQuaGFzT3duUHJvcGVydHkoZykmJmMuaGFzT3duUHJvcGVydHkoZykmJm51bGwhPWNbZ10paWYoXCJzdHlsZVwiPT09Zylmb3IoaCBpbiBiPWNbZ10sYiliLmhhc093blByb3BlcnR5KGgpJiYoYXx8KGE9e30pLGFbaF09XG5cIlwiKTtlbHNlXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiIT09ZyYmXCJjaGlsZHJlblwiIT09ZyYmXCJzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmdcIiE9PWcmJlwic3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nXCIhPT1nJiZcImF1dG9Gb2N1c1wiIT09ZyYmKFJhLmhhc093blByb3BlcnR5KGcpP2Z8fChmPVtdKTooZj1mfHxbXSkucHVzaChnLG51bGwpKTtmb3IoZyBpbiBkKXt2YXIgaz1kW2ddO2I9bnVsbCE9Yz9jW2ddOnZvaWQgMDtpZihkLmhhc093blByb3BlcnR5KGcpJiZrIT09YiYmKG51bGwhPWt8fG51bGwhPWIpKWlmKFwic3R5bGVcIj09PWcpaWYoYil7Zm9yKGggaW4gYikhYi5oYXNPd25Qcm9wZXJ0eShoKXx8ayYmay5oYXNPd25Qcm9wZXJ0eShoKXx8KGF8fChhPXt9KSxhW2hdPVwiXCIpO2ZvcihoIGluIGspay5oYXNPd25Qcm9wZXJ0eShoKSYmYltoXSE9PWtbaF0mJihhfHwoYT17fSksYVtoXT1rW2hdKX1lbHNlIGF8fChmfHwoZj1bXSksZi5wdXNoKGcsYSkpLGE9aztlbHNlXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiPT09XG5nPyhrPWs/ay5fX2h0bWw6dm9pZCAwLGI9Yj9iLl9faHRtbDp2b2lkIDAsbnVsbCE9ayYmYiE9PWsmJihmPWZ8fFtdKS5wdXNoKGcsXCJcIitrKSk6XCJjaGlsZHJlblwiPT09Zz9iPT09a3x8XCJzdHJpbmdcIiE9PXR5cGVvZiBrJiZcIm51bWJlclwiIT09dHlwZW9mIGt8fChmPWZ8fFtdKS5wdXNoKGcsXCJcIitrKTpcInN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZ1wiIT09ZyYmXCJzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmdcIiE9PWcmJihSYS5oYXNPd25Qcm9wZXJ0eShnKT8obnVsbCE9ayYmbGcoZSxnKSxmfHxiPT09a3x8KGY9W10pKTooZj1mfHxbXSkucHVzaChnLGspKX1hJiYoZj1mfHxbXSkucHVzaChcInN0eWxlXCIsYSk7cmV0dXJuIGZ9XG5mdW5jdGlvbiB0ZyhhLGIsYyxkLGUpe1wiaW5wdXRcIj09PWMmJlwicmFkaW9cIj09PWUudHlwZSYmbnVsbCE9ZS5uYW1lJiZOZihhLGUpO2lnKGMsZCk7ZD1pZyhjLGUpO2Zvcih2YXIgZj0wO2Y8Yi5sZW5ndGg7Zis9Mil7dmFyIGc9YltmXSxoPWJbZisxXTtcInN0eWxlXCI9PT1nP2ZnKGEsaCxrZyk6XCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiPT09Zz9iZyhhLGgpOlwiY2hpbGRyZW5cIj09PWc/Y2coYSxoKTpkP251bGwhPWg/S2YoYSxnLGgpOmEucmVtb3ZlQXR0cmlidXRlKGcpOm51bGwhPWg/SWYoYSxnLGgpOkpmKGEsZyl9c3dpdGNoKGMpe2Nhc2UgXCJpbnB1dFwiOk9mKGEsZSk7YnJlYWs7Y2FzZSBcInRleHRhcmVhXCI6V2YoYSxlKTticmVhaztjYXNlIFwic2VsZWN0XCI6YS5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZT12b2lkIDAsYj1hLl93cmFwcGVyU3RhdGUud2FzTXVsdGlwbGUsYS5fd3JhcHBlclN0YXRlLndhc011bHRpcGxlPSEhZS5tdWx0aXBsZSxjPWUudmFsdWUsbnVsbCE9Yz9TZihhLFxuISFlLm11bHRpcGxlLGMsITEpOmIhPT0hIWUubXVsdGlwbGUmJihudWxsIT1lLmRlZmF1bHRWYWx1ZT9TZihhLCEhZS5tdWx0aXBsZSxlLmRlZmF1bHRWYWx1ZSwhMCk6U2YoYSwhIWUubXVsdGlwbGUsZS5tdWx0aXBsZT9bXTpcIlwiLCExKSl9fVxuZnVuY3Rpb24gdWcoYSxiLGMsZCxlKXtzd2l0Y2goYil7Y2FzZSBcImlmcmFtZVwiOmNhc2UgXCJvYmplY3RcIjpVKFwidG9wTG9hZFwiLFwibG9hZFwiLGEpO2JyZWFrO2Nhc2UgXCJ2aWRlb1wiOmNhc2UgXCJhdWRpb1wiOmZvcih2YXIgZiBpbiBtZyltZy5oYXNPd25Qcm9wZXJ0eShmKSYmVShmLG1nW2ZdLGEpO2JyZWFrO2Nhc2UgXCJzb3VyY2VcIjpVKFwidG9wRXJyb3JcIixcImVycm9yXCIsYSk7YnJlYWs7Y2FzZSBcImltZ1wiOmNhc2UgXCJpbWFnZVwiOlUoXCJ0b3BFcnJvclwiLFwiZXJyb3JcIixhKTtVKFwidG9wTG9hZFwiLFwibG9hZFwiLGEpO2JyZWFrO2Nhc2UgXCJmb3JtXCI6VShcInRvcFJlc2V0XCIsXCJyZXNldFwiLGEpO1UoXCJ0b3BTdWJtaXRcIixcInN1Ym1pdFwiLGEpO2JyZWFrO2Nhc2UgXCJkZXRhaWxzXCI6VShcInRvcFRvZ2dsZVwiLFwidG9nZ2xlXCIsYSk7YnJlYWs7Y2FzZSBcImlucHV0XCI6TWYoYSxjKTtVKFwidG9wSW52YWxpZFwiLFwiaW52YWxpZFwiLGEpO2xnKGUsXCJvbkNoYW5nZVwiKTticmVhaztjYXNlIFwic2VsZWN0XCI6VGYoYSxjKTtcblUoXCJ0b3BJbnZhbGlkXCIsXCJpbnZhbGlkXCIsYSk7bGcoZSxcIm9uQ2hhbmdlXCIpO2JyZWFrO2Nhc2UgXCJ0ZXh0YXJlYVwiOlZmKGEsYyksVShcInRvcEludmFsaWRcIixcImludmFsaWRcIixhKSxsZyhlLFwib25DaGFuZ2VcIil9aGcoYixjLGtnKTtkPW51bGw7Zm9yKHZhciBnIGluIGMpYy5oYXNPd25Qcm9wZXJ0eShnKSYmKGY9Y1tnXSxcImNoaWxkcmVuXCI9PT1nP1wic3RyaW5nXCI9PT10eXBlb2YgZj9hLnRleHRDb250ZW50IT09ZiYmKGQ9W1wiY2hpbGRyZW5cIixmXSk6XCJudW1iZXJcIj09PXR5cGVvZiBmJiZhLnRleHRDb250ZW50IT09XCJcIitmJiYoZD1bXCJjaGlsZHJlblwiLFwiXCIrZl0pOlJhLmhhc093blByb3BlcnR5KGcpJiZudWxsIT1mJiZsZyhlLGcpKTtzd2l0Y2goYil7Y2FzZSBcImlucHV0XCI6QmMoYSk7UGYoYSxjKTticmVhaztjYXNlIFwidGV4dGFyZWFcIjpCYyhhKTtYZihhLGMpO2JyZWFrO2Nhc2UgXCJzZWxlY3RcIjpjYXNlIFwib3B0aW9uXCI6YnJlYWs7ZGVmYXVsdDpcImZ1bmN0aW9uXCI9PT10eXBlb2YgYy5vbkNsaWNrJiZcbihhLm9uY2xpY2s9Qyl9cmV0dXJuIGR9ZnVuY3Rpb24gdmcoYSxiKXtyZXR1cm4gYS5ub2RlVmFsdWUhPT1ifVxudmFyIHdnPU9iamVjdC5mcmVlemUoe2NyZWF0ZUVsZW1lbnQ6bmcsY3JlYXRlVGV4dE5vZGU6b2csc2V0SW5pdGlhbFByb3BlcnRpZXM6cGcsZGlmZlByb3BlcnRpZXM6c2csdXBkYXRlUHJvcGVydGllczp0ZyxkaWZmSHlkcmF0ZWRQcm9wZXJ0aWVzOnVnLGRpZmZIeWRyYXRlZFRleHQ6dmcsd2FybkZvclVubWF0Y2hlZFRleHQ6ZnVuY3Rpb24oKXt9LHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZUVsZW1lbnQ6ZnVuY3Rpb24oKXt9LHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZVRleHQ6ZnVuY3Rpb24oKXt9LHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkRWxlbWVudDpmdW5jdGlvbigpe30sd2FybkZvckluc2VydGVkSHlkcmF0ZWRUZXh0OmZ1bmN0aW9uKCl7fSxyZXN0b3JlQ29udHJvbGxlZFN0YXRlOmZ1bmN0aW9uKGEsYixjKXtzd2l0Y2goYil7Y2FzZSBcImlucHV0XCI6T2YoYSxjKTtiPWMubmFtZTtpZihcInJhZGlvXCI9PT1jLnR5cGUmJm51bGwhPWIpe2ZvcihjPWE7Yy5wYXJlbnROb2RlOyljPVxuYy5wYXJlbnROb2RlO2M9Yy5xdWVyeVNlbGVjdG9yQWxsKFwiaW5wdXRbbmFtZVxceDNkXCIrSlNPTi5zdHJpbmdpZnkoXCJcIitiKSsnXVt0eXBlXFx4M2RcInJhZGlvXCJdJyk7Zm9yKGI9MDtiPGMubGVuZ3RoO2IrKyl7dmFyIGQ9Y1tiXTtpZihkIT09YSYmZC5mb3JtPT09YS5mb3JtKXt2YXIgZT1yYihkKTtlP3ZvaWQgMDpFKFwiOTBcIik7Q2MoZCk7T2YoZCxlKX19fWJyZWFrO2Nhc2UgXCJ0ZXh0YXJlYVwiOldmKGEsYyk7YnJlYWs7Y2FzZSBcInNlbGVjdFwiOmI9Yy52YWx1ZSxudWxsIT1iJiZTZihhLCEhYy5tdWx0aXBsZSxiLCExKX19fSk7bmMuaW5qZWN0RmliZXJDb250cm9sbGVkSG9zdENvbXBvbmVudCh3Zyk7dmFyIHhnPW51bGwsTWc9bnVsbDtmdW5jdGlvbiBOZyhhKXtyZXR1cm4hKCFhfHwxIT09YS5ub2RlVHlwZSYmOSE9PWEubm9kZVR5cGUmJjExIT09YS5ub2RlVHlwZSYmKDghPT1hLm5vZGVUeXBlfHxcIiByZWFjdC1tb3VudC1wb2ludC11bnN0YWJsZSBcIiE9PWEubm9kZVZhbHVlKSl9XG5mdW5jdGlvbiBPZyhhKXthPWE/OT09PWEubm9kZVR5cGU/YS5kb2N1bWVudEVsZW1lbnQ6YS5maXJzdENoaWxkOm51bGw7cmV0dXJuISghYXx8MSE9PWEubm9kZVR5cGV8fCFhLmhhc0F0dHJpYnV0ZShcImRhdGEtcmVhY3Ryb290XCIpKX1cbnZhciBaPW9mKHtnZXRSb290SG9zdENvbnRleHQ6ZnVuY3Rpb24oYSl7dmFyIGI9YS5ub2RlVHlwZTtzd2l0Y2goYil7Y2FzZSA5OmNhc2UgMTE6YT0oYT1hLmRvY3VtZW50RWxlbWVudCk/YS5uYW1lc3BhY2VVUkk6JGYobnVsbCxcIlwiKTticmVhaztkZWZhdWx0OmI9OD09PWI/YS5wYXJlbnROb2RlOmEsYT1iLm5hbWVzcGFjZVVSSXx8bnVsbCxiPWIudGFnTmFtZSxhPSRmKGEsYil9cmV0dXJuIGF9LGdldENoaWxkSG9zdENvbnRleHQ6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gJGYoYSxiKX0sZ2V0UHVibGljSW5zdGFuY2U6ZnVuY3Rpb24oYSl7cmV0dXJuIGF9LHByZXBhcmVGb3JDb21taXQ6ZnVuY3Rpb24oKXt4Zz10ZDt2YXIgYT1kYSgpO2lmKEtkKGEpKXtpZihcInNlbGVjdGlvblN0YXJ0XCJpbiBhKXZhciBiPXtzdGFydDphLnNlbGVjdGlvblN0YXJ0LGVuZDphLnNlbGVjdGlvbkVuZH07ZWxzZSBhOnt2YXIgYz13aW5kb3cuZ2V0U2VsZWN0aW9uJiZ3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG5pZihjJiYwIT09Yy5yYW5nZUNvdW50KXtiPWMuYW5jaG9yTm9kZTt2YXIgZD1jLmFuY2hvck9mZnNldCxlPWMuZm9jdXNOb2RlO2M9Yy5mb2N1c09mZnNldDt0cnl7Yi5ub2RlVHlwZSxlLm5vZGVUeXBlfWNhdGNoKHope2I9bnVsbDticmVhayBhfXZhciBmPTAsZz0tMSxoPS0xLGs9MCxxPTAsdj1hLHk9bnVsbDtiOmZvcig7Oyl7Zm9yKHZhciB1Ozspe3YhPT1ifHwwIT09ZCYmMyE9PXYubm9kZVR5cGV8fChnPWYrZCk7diE9PWV8fDAhPT1jJiYzIT09di5ub2RlVHlwZXx8KGg9ZitjKTszPT09di5ub2RlVHlwZSYmKGYrPXYubm9kZVZhbHVlLmxlbmd0aCk7aWYobnVsbD09PSh1PXYuZmlyc3RDaGlsZCkpYnJlYWs7eT12O3Y9dX1mb3IoOzspe2lmKHY9PT1hKWJyZWFrIGI7eT09PWImJisraz09PWQmJihnPWYpO3k9PT1lJiYrK3E9PT1jJiYoaD1mKTtpZihudWxsIT09KHU9di5uZXh0U2libGluZykpYnJlYWs7dj15O3k9di5wYXJlbnROb2RlfXY9dX1iPS0xPT09Z3x8LTE9PT1oP251bGw6XG57c3RhcnQ6ZyxlbmQ6aH19ZWxzZSBiPW51bGx9Yj1ifHx7c3RhcnQ6MCxlbmQ6MH19ZWxzZSBiPW51bGw7TWc9e2ZvY3VzZWRFbGVtOmEsc2VsZWN0aW9uUmFuZ2U6Yn07dWQoITEpfSxyZXNldEFmdGVyQ29tbWl0OmZ1bmN0aW9uKCl7dmFyIGE9TWcsYj1kYSgpLGM9YS5mb2N1c2VkRWxlbSxkPWEuc2VsZWN0aW9uUmFuZ2U7aWYoYiE9PWMmJmZhKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxjKSl7aWYoS2QoYykpaWYoYj1kLnN0YXJ0LGE9ZC5lbmQsdm9pZCAwPT09YSYmKGE9YiksXCJzZWxlY3Rpb25TdGFydFwiaW4gYyljLnNlbGVjdGlvblN0YXJ0PWIsYy5zZWxlY3Rpb25FbmQ9TWF0aC5taW4oYSxjLnZhbHVlLmxlbmd0aCk7ZWxzZSBpZih3aW5kb3cuZ2V0U2VsZWN0aW9uKXtiPXdpbmRvdy5nZXRTZWxlY3Rpb24oKTt2YXIgZT1jW0ViKCldLmxlbmd0aDthPU1hdGgubWluKGQuc3RhcnQsZSk7ZD12b2lkIDA9PT1kLmVuZD9hOk1hdGgubWluKGQuZW5kLGUpOyFiLmV4dGVuZCYmYT5cbmQmJihlPWQsZD1hLGE9ZSk7ZT1KZChjLGEpO3ZhciBmPUpkKGMsZCk7aWYoZSYmZiYmKDEhPT1iLnJhbmdlQ291bnR8fGIuYW5jaG9yTm9kZSE9PWUubm9kZXx8Yi5hbmNob3JPZmZzZXQhPT1lLm9mZnNldHx8Yi5mb2N1c05vZGUhPT1mLm5vZGV8fGIuZm9jdXNPZmZzZXQhPT1mLm9mZnNldCkpe3ZhciBnPWRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7Zy5zZXRTdGFydChlLm5vZGUsZS5vZmZzZXQpO2IucmVtb3ZlQWxsUmFuZ2VzKCk7YT5kPyhiLmFkZFJhbmdlKGcpLGIuZXh0ZW5kKGYubm9kZSxmLm9mZnNldCkpOihnLnNldEVuZChmLm5vZGUsZi5vZmZzZXQpLGIuYWRkUmFuZ2UoZykpfX1iPVtdO2ZvcihhPWM7YT1hLnBhcmVudE5vZGU7KTE9PT1hLm5vZGVUeXBlJiZiLnB1c2goe2VsZW1lbnQ6YSxsZWZ0OmEuc2Nyb2xsTGVmdCx0b3A6YS5zY3JvbGxUb3B9KTtpYShjKTtmb3IoYz0wO2M8Yi5sZW5ndGg7YysrKWE9YltjXSxhLmVsZW1lbnQuc2Nyb2xsTGVmdD1hLmxlZnQsYS5lbGVtZW50LnNjcm9sbFRvcD1cbmEudG9wfU1nPW51bGw7dWQoeGcpO3hnPW51bGx9LGNyZWF0ZUluc3RhbmNlOmZ1bmN0aW9uKGEsYixjLGQsZSl7YT1uZyhhLGIsYyxkKTthW1FdPWU7YVtvYl09YjtyZXR1cm4gYX0sYXBwZW5kSW5pdGlhbENoaWxkOmZ1bmN0aW9uKGEsYil7YS5hcHBlbmRDaGlsZChiKX0sZmluYWxpemVJbml0aWFsQ2hpbGRyZW46ZnVuY3Rpb24oYSxiLGMsZCl7cGcoYSxiLGMsZCk7YTp7c3dpdGNoKGIpe2Nhc2UgXCJidXR0b25cIjpjYXNlIFwiaW5wdXRcIjpjYXNlIFwic2VsZWN0XCI6Y2FzZSBcInRleHRhcmVhXCI6YT0hIWMuYXV0b0ZvY3VzO2JyZWFrIGF9YT0hMX1yZXR1cm4gYX0scHJlcGFyZVVwZGF0ZTpmdW5jdGlvbihhLGIsYyxkLGUpe3JldHVybiBzZyhhLGIsYyxkLGUpfSxzaG91bGRTZXRUZXh0Q29udGVudDpmdW5jdGlvbihhLGIpe3JldHVyblwidGV4dGFyZWFcIj09PWF8fFwic3RyaW5nXCI9PT10eXBlb2YgYi5jaGlsZHJlbnx8XCJudW1iZXJcIj09PXR5cGVvZiBiLmNoaWxkcmVufHxcIm9iamVjdFwiPT09XG50eXBlb2YgYi5kYW5nZXJvdXNseVNldElubmVySFRNTCYmbnVsbCE9PWIuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwmJlwic3RyaW5nXCI9PT10eXBlb2YgYi5kYW5nZXJvdXNseVNldElubmVySFRNTC5fX2h0bWx9LHNob3VsZERlcHJpb3JpdGl6ZVN1YnRyZWU6ZnVuY3Rpb24oYSxiKXtyZXR1cm4hIWIuaGlkZGVufSxjcmVhdGVUZXh0SW5zdGFuY2U6ZnVuY3Rpb24oYSxiLGMsZCl7YT1vZyhhLGIpO2FbUV09ZDtyZXR1cm4gYX0sbm93OnJmLG11dGF0aW9uOntjb21taXRNb3VudDpmdW5jdGlvbihhKXthLmZvY3VzKCl9LGNvbW1pdFVwZGF0ZTpmdW5jdGlvbihhLGIsYyxkLGUpe2Fbb2JdPWU7dGcoYSxiLGMsZCxlKX0scmVzZXRUZXh0Q29udGVudDpmdW5jdGlvbihhKXthLnRleHRDb250ZW50PVwiXCJ9LGNvbW1pdFRleHRVcGRhdGU6ZnVuY3Rpb24oYSxiLGMpe2Eubm9kZVZhbHVlPWN9LGFwcGVuZENoaWxkOmZ1bmN0aW9uKGEsYil7YS5hcHBlbmRDaGlsZChiKX0sYXBwZW5kQ2hpbGRUb0NvbnRhaW5lcjpmdW5jdGlvbihhLFxuYil7OD09PWEubm9kZVR5cGU/YS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShiLGEpOmEuYXBwZW5kQ2hpbGQoYil9LGluc2VydEJlZm9yZTpmdW5jdGlvbihhLGIsYyl7YS5pbnNlcnRCZWZvcmUoYixjKX0saW5zZXJ0SW5Db250YWluZXJCZWZvcmU6ZnVuY3Rpb24oYSxiLGMpezg9PT1hLm5vZGVUeXBlP2EucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoYixjKTphLmluc2VydEJlZm9yZShiLGMpfSxyZW1vdmVDaGlsZDpmdW5jdGlvbihhLGIpe2EucmVtb3ZlQ2hpbGQoYil9LHJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lcjpmdW5jdGlvbihhLGIpezg9PT1hLm5vZGVUeXBlP2EucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChiKTphLnJlbW92ZUNoaWxkKGIpfX0saHlkcmF0aW9uOntjYW5IeWRyYXRlSW5zdGFuY2U6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gMSE9PWEubm9kZVR5cGV8fGIudG9Mb3dlckNhc2UoKSE9PWEubm9kZU5hbWUudG9Mb3dlckNhc2UoKT9udWxsOmF9LGNhbkh5ZHJhdGVUZXh0SW5zdGFuY2U6ZnVuY3Rpb24oYSxcbmIpe3JldHVyblwiXCI9PT1ifHwzIT09YS5ub2RlVHlwZT9udWxsOmF9LGdldE5leHRIeWRyYXRhYmxlU2libGluZzpmdW5jdGlvbihhKXtmb3IoYT1hLm5leHRTaWJsaW5nO2EmJjEhPT1hLm5vZGVUeXBlJiYzIT09YS5ub2RlVHlwZTspYT1hLm5leHRTaWJsaW5nO3JldHVybiBhfSxnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZDpmdW5jdGlvbihhKXtmb3IoYT1hLmZpcnN0Q2hpbGQ7YSYmMSE9PWEubm9kZVR5cGUmJjMhPT1hLm5vZGVUeXBlOylhPWEubmV4dFNpYmxpbmc7cmV0dXJuIGF9LGh5ZHJhdGVJbnN0YW5jZTpmdW5jdGlvbihhLGIsYyxkLGUsZil7YVtRXT1mO2Fbb2JdPWM7cmV0dXJuIHVnKGEsYixjLGUsZCl9LGh5ZHJhdGVUZXh0SW5zdGFuY2U6ZnVuY3Rpb24oYSxiLGMpe2FbUV09YztyZXR1cm4gdmcoYSxiKX0sZGlkTm90TWF0Y2hIeWRyYXRlZENvbnRhaW5lclRleHRJbnN0YW5jZTpmdW5jdGlvbigpe30sZGlkTm90TWF0Y2hIeWRyYXRlZFRleHRJbnN0YW5jZTpmdW5jdGlvbigpe30sXG5kaWROb3RIeWRyYXRlQ29udGFpbmVySW5zdGFuY2U6ZnVuY3Rpb24oKXt9LGRpZE5vdEh5ZHJhdGVJbnN0YW5jZTpmdW5jdGlvbigpe30sZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJJbnN0YW5jZTpmdW5jdGlvbigpe30sZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJUZXh0SW5zdGFuY2U6ZnVuY3Rpb24oKXt9LGRpZE5vdEZpbmRIeWRyYXRhYmxlSW5zdGFuY2U6ZnVuY3Rpb24oKXt9LGRpZE5vdEZpbmRIeWRyYXRhYmxlVGV4dEluc3RhbmNlOmZ1bmN0aW9uKCl7fX0sc2NoZWR1bGVEZWZlcnJlZENhbGxiYWNrOnNmLGNhbmNlbERlZmVycmVkQ2FsbGJhY2s6dGYsdXNlU3luY1NjaGVkdWxpbmc6ITB9KTtyYz1aLmJhdGNoZWRVcGRhdGVzO1xuZnVuY3Rpb24gUGcoYSxiLGMsZCxlKXtOZyhjKT92b2lkIDA6RShcIjIwMFwiKTt2YXIgZj1jLl9yZWFjdFJvb3RDb250YWluZXI7aWYoZilaLnVwZGF0ZUNvbnRhaW5lcihiLGYsYSxlKTtlbHNle2Q9ZHx8T2coYyk7aWYoIWQpZm9yKGY9dm9pZCAwO2Y9Yy5sYXN0Q2hpbGQ7KWMucmVtb3ZlQ2hpbGQoZik7dmFyIGc9Wi5jcmVhdGVDb250YWluZXIoYyxkKTtmPWMuX3JlYWN0Um9vdENvbnRhaW5lcj1nO1oudW5iYXRjaGVkVXBkYXRlcyhmdW5jdGlvbigpe1oudXBkYXRlQ29udGFpbmVyKGIsZyxhLGUpfSl9cmV0dXJuIFouZ2V0UHVibGljUm9vdEluc3RhbmNlKGYpfWZ1bmN0aW9uIFFnKGEsYil7dmFyIGM9Mjxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOm51bGw7TmcoYik/dm9pZCAwOkUoXCIyMDBcIik7cmV0dXJuIHBmKGEsYixudWxsLGMpfVxuZnVuY3Rpb24gUmcoYSxiKXt0aGlzLl9yZWFjdFJvb3RDb250YWluZXI9Wi5jcmVhdGVDb250YWluZXIoYSxiKX1SZy5wcm90b3R5cGUucmVuZGVyPWZ1bmN0aW9uKGEsYil7Wi51cGRhdGVDb250YWluZXIoYSx0aGlzLl9yZWFjdFJvb3RDb250YWluZXIsbnVsbCxiKX07UmcucHJvdG90eXBlLnVubW91bnQ9ZnVuY3Rpb24oYSl7Wi51cGRhdGVDb250YWluZXIobnVsbCx0aGlzLl9yZWFjdFJvb3RDb250YWluZXIsbnVsbCxhKX07XG52YXIgU2c9e2NyZWF0ZVBvcnRhbDpRZyxmaW5kRE9NTm9kZTpmdW5jdGlvbihhKXtpZihudWxsPT1hKXJldHVybiBudWxsO2lmKDE9PT1hLm5vZGVUeXBlKXJldHVybiBhO3ZhciBiPWEuX3JlYWN0SW50ZXJuYWxGaWJlcjtpZihiKXJldHVybiBaLmZpbmRIb3N0SW5zdGFuY2UoYik7XCJmdW5jdGlvblwiPT09dHlwZW9mIGEucmVuZGVyP0UoXCIxODhcIik6RShcIjIxM1wiLE9iamVjdC5rZXlzKGEpKX0saHlkcmF0ZTpmdW5jdGlvbihhLGIsYyl7cmV0dXJuIFBnKG51bGwsYSxiLCEwLGMpfSxyZW5kZXI6ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBQZyhudWxsLGEsYiwhMSxjKX0sdW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXI6ZnVuY3Rpb24oYSxiLGMsZCl7bnVsbD09YXx8dm9pZCAwPT09YS5fcmVhY3RJbnRlcm5hbEZpYmVyP0UoXCIzOFwiKTp2b2lkIDA7cmV0dXJuIFBnKGEsYixjLCExLGQpfSx1bm1vdW50Q29tcG9uZW50QXROb2RlOmZ1bmN0aW9uKGEpe05nKGEpP3ZvaWQgMDpcbkUoXCI0MFwiKTtyZXR1cm4gYS5fcmVhY3RSb290Q29udGFpbmVyPyhaLnVuYmF0Y2hlZFVwZGF0ZXMoZnVuY3Rpb24oKXtQZyhudWxsLG51bGwsYSwhMSxmdW5jdGlvbigpe2EuX3JlYWN0Um9vdENvbnRhaW5lcj1udWxsfSl9KSwhMCk6ITF9LHVuc3RhYmxlX2NyZWF0ZVBvcnRhbDpRZyx1bnN0YWJsZV9iYXRjaGVkVXBkYXRlczp0Yyx1bnN0YWJsZV9kZWZlcnJlZFVwZGF0ZXM6Wi5kZWZlcnJlZFVwZGF0ZXMsZmx1c2hTeW5jOlouZmx1c2hTeW5jLF9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEOntFdmVudFBsdWdpbkh1YjptYixFdmVudFBsdWdpblJlZ2lzdHJ5OlZhLEV2ZW50UHJvcGFnYXRvcnM6Q2IsUmVhY3RDb250cm9sbGVkQ29tcG9uZW50OnFjLFJlYWN0RE9NQ29tcG9uZW50VHJlZTpzYixSZWFjdERPTUV2ZW50TGlzdGVuZXI6eGR9fTtcblouaW5qZWN0SW50b0RldlRvb2xzKHtmaW5kRmliZXJCeUhvc3RJbnN0YW5jZTpwYixidW5kbGVUeXBlOjAsdmVyc2lvbjpcIjE2LjIuMFwiLHJlbmRlcmVyUGFja2FnZU5hbWU6XCJyZWFjdC1kb21cIn0pO3ZhciBUZz1PYmplY3QuZnJlZXplKHtkZWZhdWx0OlNnfSksVWc9VGcmJlNnfHxUZzttb2R1bGUuZXhwb3J0cz1VZ1tcImRlZmF1bHRcIl0/VWdbXCJkZWZhdWx0XCJdOlVnO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9janMvcmVhY3QtZG9tLnByb2R1Y3Rpb24ubWluLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxudmFyIGlzTm9kZSA9IHJlcXVpcmUoJy4vaXNOb2RlJyk7XG5cbi8qKlxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIG9iamVjdCB0byBjaGVjay5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBvYmplY3QgaXMgYSBET00gdGV4dCBub2RlLlxuICovXG5mdW5jdGlvbiBpc1RleHROb2RlKG9iamVjdCkge1xuICByZXR1cm4gaXNOb2RlKG9iamVjdCkgJiYgb2JqZWN0Lm5vZGVUeXBlID09IDM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNUZXh0Tm9kZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaXNUZXh0Tm9kZS5qcyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbi8qKlxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIG9iamVjdCB0byBjaGVjay5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBvYmplY3QgaXMgYSBET00gbm9kZS5cbiAqL1xuZnVuY3Rpb24gaXNOb2RlKG9iamVjdCkge1xuICB2YXIgZG9jID0gb2JqZWN0ID8gb2JqZWN0Lm93bmVyRG9jdW1lbnQgfHwgb2JqZWN0IDogZG9jdW1lbnQ7XG4gIHZhciBkZWZhdWx0VmlldyA9IGRvYy5kZWZhdWx0VmlldyB8fCB3aW5kb3c7XG4gIHJldHVybiAhIShvYmplY3QgJiYgKHR5cGVvZiBkZWZhdWx0Vmlldy5Ob2RlID09PSAnZnVuY3Rpb24nID8gb2JqZWN0IGluc3RhbmNlb2YgZGVmYXVsdFZpZXcuTm9kZSA6IHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvYmplY3Qubm9kZVR5cGUgPT09ICdudW1iZXInICYmIHR5cGVvZiBvYmplY3Qubm9kZU5hbWUgPT09ICdzdHJpbmcnKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNOb2RlO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9pc05vZGUuanMiLCIvKiogQGxpY2Vuc2UgUmVhY3QgdjE2LjIuMFxuICogcmVhY3QtZG9tLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIEV2ZW50TGlzdGVuZXIgPSByZXF1aXJlKCdmYmpzL2xpYi9FdmVudExpc3RlbmVyJyk7XG52YXIgZ2V0QWN0aXZlRWxlbWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL2dldEFjdGl2ZUVsZW1lbnQnKTtcbnZhciBzaGFsbG93RXF1YWwgPSByZXF1aXJlKCdmYmpzL2xpYi9zaGFsbG93RXF1YWwnKTtcbnZhciBjb250YWluc05vZGUgPSByZXF1aXJlKCdmYmpzL2xpYi9jb250YWluc05vZGUnKTtcbnZhciBmb2N1c05vZGUgPSByZXF1aXJlKCdmYmpzL2xpYi9mb2N1c05vZGUnKTtcbnZhciBlbXB0eU9iamVjdCA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5T2JqZWN0Jyk7XG52YXIgY2hlY2tQcm9wVHlwZXMgPSByZXF1aXJlKCdwcm9wLXR5cGVzL2NoZWNrUHJvcFR5cGVzJyk7XG52YXIgaHlwaGVuYXRlU3R5bGVOYW1lID0gcmVxdWlyZSgnZmJqcy9saWIvaHlwaGVuYXRlU3R5bGVOYW1lJyk7XG52YXIgY2FtZWxpemVTdHlsZU5hbWUgPSByZXF1aXJlKCdmYmpzL2xpYi9jYW1lbGl6ZVN0eWxlTmFtZScpO1xuXG4vKipcbiAqIFdBUk5JTkc6IERPIE5PVCBtYW51YWxseSByZXF1aXJlIHRoaXMgbW9kdWxlLlxuICogVGhpcyBpcyBhIHJlcGxhY2VtZW50IGZvciBgaW52YXJpYW50KC4uLilgIHVzZWQgYnkgdGhlIGVycm9yIGNvZGUgc3lzdGVtXG4gKiBhbmQgd2lsbCBfb25seV8gYmUgcmVxdWlyZWQgYnkgdGhlIGNvcnJlc3BvbmRpbmcgYmFiZWwgcGFzcy5cbiAqIEl0IGFsd2F5cyB0aHJvd3MuXG4gKi9cblxuIVJlYWN0ID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RET00gd2FzIGxvYWRlZCBiZWZvcmUgUmVhY3QuIE1ha2Ugc3VyZSB5b3UgbG9hZCB0aGUgUmVhY3QgcGFja2FnZSBiZWZvcmUgbG9hZGluZyBSZWFjdERPTS4nKSA6IHZvaWQgMDtcblxuLy8gVGhlc2UgYXR0cmlidXRlcyBzaG91bGQgYmUgYWxsIGxvd2VyY2FzZSB0byBhbGxvdyBmb3Jcbi8vIGNhc2UgaW5zZW5zaXRpdmUgY2hlY2tzXG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGNoaWxkcmVuOiB0cnVlLFxuICBkYW5nZXJvdXNseVNldElubmVySFRNTDogdHJ1ZSxcbiAgZGVmYXVsdFZhbHVlOiB0cnVlLFxuICBkZWZhdWx0Q2hlY2tlZDogdHJ1ZSxcbiAgaW5uZXJIVE1MOiB0cnVlLFxuICBzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmc6IHRydWUsXG4gIHN1cHByZXNzSHlkcmF0aW9uV2FybmluZzogdHJ1ZSxcbiAgc3R5bGU6IHRydWVcbn07XG5cbmZ1bmN0aW9uIGNoZWNrTWFzayh2YWx1ZSwgYml0bWFzaykge1xuICByZXR1cm4gKHZhbHVlICYgYml0bWFzaykgPT09IGJpdG1hc2s7XG59XG5cbnZhciBET01Qcm9wZXJ0eUluamVjdGlvbiA9IHtcbiAgLyoqXG4gICAqIE1hcHBpbmcgZnJvbSBub3JtYWxpemVkLCBjYW1lbGNhc2VkIHByb3BlcnR5IG5hbWVzIHRvIGEgY29uZmlndXJhdGlvbiB0aGF0XG4gICAqIHNwZWNpZmllcyBob3cgdGhlIGFzc29jaWF0ZWQgRE9NIHByb3BlcnR5IHNob3VsZCBiZSBhY2Nlc3NlZCBvciByZW5kZXJlZC5cbiAgICovXG4gIE1VU1RfVVNFX1BST1BFUlRZOiAweDEsXG4gIEhBU19CT09MRUFOX1ZBTFVFOiAweDQsXG4gIEhBU19OVU1FUklDX1ZBTFVFOiAweDgsXG4gIEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFOiAweDEwIHwgMHg4LFxuICBIQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFOiAweDIwLFxuICBIQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUU6IDB4NDAsXG5cbiAgLyoqXG4gICAqIEluamVjdCBzb21lIHNwZWNpYWxpemVkIGtub3dsZWRnZSBhYm91dCB0aGUgRE9NLiBUaGlzIHRha2VzIGEgY29uZmlnIG9iamVjdFxuICAgKiB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICpcbiAgICogUHJvcGVydGllczogb2JqZWN0IG1hcHBpbmcgRE9NIHByb3BlcnR5IG5hbWUgdG8gb25lIG9mIHRoZVxuICAgKiBET01Qcm9wZXJ0eUluamVjdGlvbiBjb25zdGFudHMgb3IgbnVsbC4gSWYgeW91ciBhdHRyaWJ1dGUgaXNuJ3QgaW4gaGVyZSxcbiAgICogaXQgd29uJ3QgZ2V0IHdyaXR0ZW4gdG8gdGhlIERPTS5cbiAgICpcbiAgICogRE9NQXR0cmlidXRlTmFtZXM6IG9iamVjdCBtYXBwaW5nIFJlYWN0IGF0dHJpYnV0ZSBuYW1lIHRvIHRoZSBET01cbiAgICogYXR0cmlidXRlIG5hbWUuIEF0dHJpYnV0ZSBuYW1lcyBub3Qgc3BlY2lmaWVkIHVzZSB0aGUgKipsb3dlcmNhc2UqKlxuICAgKiBub3JtYWxpemVkIG5hbWUuXG4gICAqXG4gICAqIERPTUF0dHJpYnV0ZU5hbWVzcGFjZXM6IG9iamVjdCBtYXBwaW5nIFJlYWN0IGF0dHJpYnV0ZSBuYW1lIHRvIHRoZSBET01cbiAgICogYXR0cmlidXRlIG5hbWVzcGFjZSBVUkwuIChBdHRyaWJ1dGUgbmFtZXMgbm90IHNwZWNpZmllZCB1c2Ugbm8gbmFtZXNwYWNlLilcbiAgICpcbiAgICogRE9NUHJvcGVydHlOYW1lczogc2ltaWxhciB0byBET01BdHRyaWJ1dGVOYW1lcyBidXQgZm9yIERPTSBwcm9wZXJ0aWVzLlxuICAgKiBQcm9wZXJ0eSBuYW1lcyBub3Qgc3BlY2lmaWVkIHVzZSB0aGUgbm9ybWFsaXplZCBuYW1lLlxuICAgKlxuICAgKiBET01NdXRhdGlvbk1ldGhvZHM6IFByb3BlcnRpZXMgdGhhdCByZXF1aXJlIHNwZWNpYWwgbXV0YXRpb24gbWV0aG9kcy4gSWZcbiAgICogYHZhbHVlYCBpcyB1bmRlZmluZWQsIHRoZSBtdXRhdGlvbiBtZXRob2Qgc2hvdWxkIHVuc2V0IHRoZSBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGRvbVByb3BlcnR5Q29uZmlnIHRoZSBjb25maWcgYXMgZGVzY3JpYmVkIGFib3ZlLlxuICAgKi9cbiAgaW5qZWN0RE9NUHJvcGVydHlDb25maWc6IGZ1bmN0aW9uIChkb21Qcm9wZXJ0eUNvbmZpZykge1xuICAgIHZhciBJbmplY3Rpb24gPSBET01Qcm9wZXJ0eUluamVjdGlvbjtcbiAgICB2YXIgUHJvcGVydGllcyA9IGRvbVByb3BlcnR5Q29uZmlnLlByb3BlcnRpZXMgfHwge307XG4gICAgdmFyIERPTUF0dHJpYnV0ZU5hbWVzcGFjZXMgPSBkb21Qcm9wZXJ0eUNvbmZpZy5ET01BdHRyaWJ1dGVOYW1lc3BhY2VzIHx8IHt9O1xuICAgIHZhciBET01BdHRyaWJ1dGVOYW1lcyA9IGRvbVByb3BlcnR5Q29uZmlnLkRPTUF0dHJpYnV0ZU5hbWVzIHx8IHt9O1xuICAgIHZhciBET01NdXRhdGlvbk1ldGhvZHMgPSBkb21Qcm9wZXJ0eUNvbmZpZy5ET01NdXRhdGlvbk1ldGhvZHMgfHwge307XG5cbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBQcm9wZXJ0aWVzKSB7XG4gICAgICAhIXByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpID8gaW52YXJpYW50KGZhbHNlLCBcImluamVjdERPTVByb3BlcnR5Q29uZmlnKC4uLik6IFlvdSdyZSB0cnlpbmcgdG8gaW5qZWN0IERPTSBwcm9wZXJ0eSAnJXMnIHdoaWNoIGhhcyBhbHJlYWR5IGJlZW4gaW5qZWN0ZWQuIFlvdSBtYXkgYmUgYWNjaWRlbnRhbGx5IGluamVjdGluZyB0aGUgc2FtZSBET00gcHJvcGVydHkgY29uZmlnIHR3aWNlLCBvciB5b3UgbWF5IGJlIGluamVjdGluZyB0d28gY29uZmlncyB0aGF0IGhhdmUgY29uZmxpY3RpbmcgcHJvcGVydHkgbmFtZXMuXCIsIHByb3BOYW1lKSA6IHZvaWQgMDtcblxuICAgICAgdmFyIGxvd2VyQ2FzZWQgPSBwcm9wTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFyIHByb3BDb25maWcgPSBQcm9wZXJ0aWVzW3Byb3BOYW1lXTtcblxuICAgICAgdmFyIHByb3BlcnR5SW5mbyA9IHtcbiAgICAgICAgYXR0cmlidXRlTmFtZTogbG93ZXJDYXNlZCxcbiAgICAgICAgYXR0cmlidXRlTmFtZXNwYWNlOiBudWxsLFxuICAgICAgICBwcm9wZXJ0eU5hbWU6IHByb3BOYW1lLFxuICAgICAgICBtdXRhdGlvbk1ldGhvZDogbnVsbCxcblxuICAgICAgICBtdXN0VXNlUHJvcGVydHk6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uTVVTVF9VU0VfUFJPUEVSVFkpLFxuICAgICAgICBoYXNCb29sZWFuVmFsdWU6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX0JPT0xFQU5fVkFMVUUpLFxuICAgICAgICBoYXNOdW1lcmljVmFsdWU6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX05VTUVSSUNfVkFMVUUpLFxuICAgICAgICBoYXNQb3NpdGl2ZU51bWVyaWNWYWx1ZTogY2hlY2tNYXNrKHByb3BDb25maWcsIEluamVjdGlvbi5IQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSksXG4gICAgICAgIGhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWU6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRSksXG4gICAgICAgIGhhc1N0cmluZ0Jvb2xlYW5WYWx1ZTogY2hlY2tNYXNrKHByb3BDb25maWcsIEluamVjdGlvbi5IQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUUpXG4gICAgICB9O1xuICAgICAgIShwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlICsgcHJvcGVydHlJbmZvLmhhc051bWVyaWNWYWx1ZSArIHByb3BlcnR5SW5mby5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlIDw9IDEpID8gaW52YXJpYW50KGZhbHNlLCBcIkRPTVByb3BlcnR5OiBWYWx1ZSBjYW4gYmUgb25lIG9mIGJvb2xlYW4sIG92ZXJsb2FkZWQgYm9vbGVhbiwgb3IgbnVtZXJpYyB2YWx1ZSwgYnV0IG5vdCBhIGNvbWJpbmF0aW9uOiAlc1wiLCBwcm9wTmFtZSkgOiB2b2lkIDA7XG5cbiAgICAgIGlmIChET01BdHRyaWJ1dGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBET01BdHRyaWJ1dGVOYW1lc1twcm9wTmFtZV07XG5cbiAgICAgICAgcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWUgPSBhdHRyaWJ1dGVOYW1lO1xuICAgICAgfVxuXG4gICAgICBpZiAoRE9NQXR0cmlidXRlTmFtZXNwYWNlcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWVzcGFjZSA9IERPTUF0dHJpYnV0ZU5hbWVzcGFjZXNbcHJvcE5hbWVdO1xuICAgICAgfVxuXG4gICAgICBpZiAoRE9NTXV0YXRpb25NZXRob2RzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wZXJ0eUluZm8ubXV0YXRpb25NZXRob2QgPSBET01NdXRhdGlvbk1ldGhvZHNbcHJvcE5hbWVdO1xuICAgICAgfVxuXG4gICAgICAvLyBEb3duY2FzZSByZWZlcmVuY2VzIHRvIHdoaXRlbGlzdCBwcm9wZXJ0aWVzIHRvIGNoZWNrIGZvciBtZW1iZXJzaGlwXG4gICAgICAvLyB3aXRob3V0IGNhc2Utc2Vuc2l0aXZpdHkuIFRoaXMgYWxsb3dzIHRoZSB3aGl0ZWxpc3QgdG8gcGljayB1cFxuICAgICAgLy8gYGFsbG93ZnVsbHNjcmVlbmAsIHdoaWNoIHNob3VsZCBiZSB3cml0dGVuIHVzaW5nIHRoZSBwcm9wZXJ0eSBjb25maWd1cmF0aW9uXG4gICAgICAvLyBmb3IgYGFsbG93RnVsbHNjcmVlbmBcbiAgICAgIHByb3BlcnRpZXNbcHJvcE5hbWVdID0gcHJvcGVydHlJbmZvO1xuICAgIH1cbiAgfVxufTtcblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xudmFyIEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIgPSBcIjpBLVpfYS16XFxcXHUwMEMwLVxcXFx1MDBENlxcXFx1MDBEOC1cXFxcdTAwRjZcXFxcdTAwRjgtXFxcXHUwMkZGXFxcXHUwMzcwLVxcXFx1MDM3RFxcXFx1MDM3Ri1cXFxcdTFGRkZcXFxcdTIwMEMtXFxcXHUyMDBEXFxcXHUyMDcwLVxcXFx1MjE4RlxcXFx1MkMwMC1cXFxcdTJGRUZcXFxcdTMwMDEtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRkRcIjtcbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xudmFyIEFUVFJJQlVURV9OQU1FX0NIQVIgPSBBVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSICsgXCJcXFxcLS4wLTlcXFxcdTAwQjdcXFxcdTAzMDAtXFxcXHUwMzZGXFxcXHUyMDNGLVxcXFx1MjA0MFwiO1xuXG5cbnZhciBST09UX0FUVFJJQlVURV9OQU1FID0gJ2RhdGEtcmVhY3Ryb290JztcblxuLyoqXG4gKiBNYXAgZnJvbSBwcm9wZXJ0eSBcInN0YW5kYXJkIG5hbWVcIiB0byBhbiBvYmplY3Qgd2l0aCBpbmZvIGFib3V0IGhvdyB0byBzZXRcbiAqIHRoZSBwcm9wZXJ0eSBpbiB0aGUgRE9NLiBFYWNoIG9iamVjdCBjb250YWluczpcbiAqXG4gKiBhdHRyaWJ1dGVOYW1lOlxuICogICBVc2VkIHdoZW4gcmVuZGVyaW5nIG1hcmt1cCBvciB3aXRoIGAqQXR0cmlidXRlKClgLlxuICogYXR0cmlidXRlTmFtZXNwYWNlXG4gKiBwcm9wZXJ0eU5hbWU6XG4gKiAgIFVzZWQgb24gRE9NIG5vZGUgaW5zdGFuY2VzLiAoVGhpcyBpbmNsdWRlcyBwcm9wZXJ0aWVzIHRoYXQgbXV0YXRlIGR1ZSB0b1xuICogICBleHRlcm5hbCBmYWN0b3JzLilcbiAqIG11dGF0aW9uTWV0aG9kOlxuICogICBJZiBub24tbnVsbCwgdXNlZCBpbnN0ZWFkIG9mIHRoZSBwcm9wZXJ0eSBvciBgc2V0QXR0cmlidXRlKClgIGFmdGVyXG4gKiAgIGluaXRpYWwgcmVuZGVyLlxuICogbXVzdFVzZVByb3BlcnR5OlxuICogICBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBtdXN0IGJlIGFjY2Vzc2VkIGFuZCBtdXRhdGVkIGFzIGFuIG9iamVjdCBwcm9wZXJ0eS5cbiAqIGhhc0Jvb2xlYW5WYWx1ZTpcbiAqICAgV2hldGhlciB0aGUgcHJvcGVydHkgc2hvdWxkIGJlIHJlbW92ZWQgd2hlbiBzZXQgdG8gYSBmYWxzZXkgdmFsdWUuXG4gKiBoYXNOdW1lcmljVmFsdWU6XG4gKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IG11c3QgYmUgbnVtZXJpYyBvciBwYXJzZSBhcyBhIG51bWVyaWMgYW5kIHNob3VsZCBiZVxuICogICByZW1vdmVkIHdoZW4gc2V0IHRvIGEgZmFsc2V5IHZhbHVlLlxuICogaGFzUG9zaXRpdmVOdW1lcmljVmFsdWU6XG4gKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IG11c3QgYmUgcG9zaXRpdmUgbnVtZXJpYyBvciBwYXJzZSBhcyBhIHBvc2l0aXZlXG4gKiAgIG51bWVyaWMgYW5kIHNob3VsZCBiZSByZW1vdmVkIHdoZW4gc2V0IHRvIGEgZmFsc2V5IHZhbHVlLlxuICogaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZTpcbiAqICAgV2hldGhlciB0aGUgcHJvcGVydHkgY2FuIGJlIHVzZWQgYXMgYSBmbGFnIGFzIHdlbGwgYXMgd2l0aCBhIHZhbHVlLlxuICogICBSZW1vdmVkIHdoZW4gc3RyaWN0bHkgZXF1YWwgdG8gZmFsc2U7IHByZXNlbnQgd2l0aG91dCBhIHZhbHVlIHdoZW5cbiAqICAgc3RyaWN0bHkgZXF1YWwgdG8gdHJ1ZTsgcHJlc2VudCB3aXRoIGEgdmFsdWUgb3RoZXJ3aXNlLlxuICovXG52YXIgcHJvcGVydGllcyA9IHt9O1xuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGEgcHJvcGVydHkgbmFtZSBpcyBhIHdyaXRlYWJsZSBhdHRyaWJ1dGUuXG4gKiBAbWV0aG9kXG4gKi9cbmZ1bmN0aW9uIHNob3VsZFNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSkge1xuICBpZiAoaXNSZXNlcnZlZFByb3AobmFtZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKG5hbWUubGVuZ3RoID4gMiAmJiAobmFtZVswXSA9PT0gJ28nIHx8IG5hbWVbMF0gPT09ICdPJykgJiYgKG5hbWVbMV0gPT09ICduJyB8fCBuYW1lWzFdID09PSAnTicpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gc2hvdWxkQXR0cmlidXRlQWNjZXB0Qm9vbGVhblZhbHVlKG5hbWUpO1xuICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgLy8gZnVuY3Rpb24sIHN5bWJvbFxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFByb3BlcnR5SW5mbyhuYW1lKSB7XG4gIHJldHVybiBwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KG5hbWUpID8gcHJvcGVydGllc1tuYW1lXSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIHNob3VsZEF0dHJpYnV0ZUFjY2VwdEJvb2xlYW5WYWx1ZShuYW1lKSB7XG4gIGlmIChpc1Jlc2VydmVkUHJvcChuYW1lKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBwcm9wZXJ0eUluZm8gPSBnZXRQcm9wZXJ0eUluZm8obmFtZSk7XG4gIGlmIChwcm9wZXJ0eUluZm8pIHtcbiAgICByZXR1cm4gcHJvcGVydHlJbmZvLmhhc0Jvb2xlYW5WYWx1ZSB8fCBwcm9wZXJ0eUluZm8uaGFzU3RyaW5nQm9vbGVhblZhbHVlIHx8IHByb3BlcnR5SW5mby5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlO1xuICB9XG4gIHZhciBwcmVmaXggPSBuYW1lLnRvTG93ZXJDYXNlKCkuc2xpY2UoMCwgNSk7XG4gIHJldHVybiBwcmVmaXggPT09ICdkYXRhLScgfHwgcHJlZml4ID09PSAnYXJpYS0nO1xufVxuXG4vKipcbiAqIENoZWNrcyB0byBzZWUgaWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHdpdGhpbiB0aGUgbGlzdCBvZiBwcm9wZXJ0aWVzXG4gKiByZXNlcnZlZCBmb3IgaW50ZXJuYWwgUmVhY3Qgb3BlcmF0aW9ucy4gVGhlc2UgcHJvcGVydGllcyBzaG91bGRcbiAqIG5vdCBiZSBzZXQgb24gYW4gSFRNTCBlbGVtZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Ym9vbGVhbn0gSWYgdGhlIG5hbWUgaXMgd2l0aGluIHJlc2VydmVkIHByb3BzXG4gKi9cbmZ1bmN0aW9uIGlzUmVzZXJ2ZWRQcm9wKG5hbWUpIHtcbiAgcmV0dXJuIFJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KG5hbWUpO1xufVxuXG52YXIgaW5qZWN0aW9uID0gRE9NUHJvcGVydHlJbmplY3Rpb247XG5cbnZhciBNVVNUX1VTRV9QUk9QRVJUWSA9IGluamVjdGlvbi5NVVNUX1VTRV9QUk9QRVJUWTtcbnZhciBIQVNfQk9PTEVBTl9WQUxVRSA9IGluamVjdGlvbi5IQVNfQk9PTEVBTl9WQUxVRTtcbnZhciBIQVNfTlVNRVJJQ19WQUxVRSA9IGluamVjdGlvbi5IQVNfTlVNRVJJQ19WQUxVRTtcbnZhciBIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSA9IGluamVjdGlvbi5IQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRTtcbnZhciBIQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFID0gaW5qZWN0aW9uLkhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUU7XG52YXIgSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFID0gaW5qZWN0aW9uLkhBU19TVFJJTkdfQk9PTEVBTl9WQUxVRTtcblxudmFyIEhUTUxET01Qcm9wZXJ0eUNvbmZpZyA9IHtcbiAgLy8gV2hlbiBhZGRpbmcgYXR0cmlidXRlcyB0byB0aGlzIGxpc3QsIGJlIHN1cmUgdG8gYWxzbyBhZGQgdGhlbSB0b1xuICAvLyB0aGUgYHBvc3NpYmxlU3RhbmRhcmROYW1lc2AgbW9kdWxlIHRvIGVuc3VyZSBjYXNpbmcgYW5kIGluY29ycmVjdFxuICAvLyBuYW1lIHdhcm5pbmdzLlxuICBQcm9wZXJ0aWVzOiB7XG4gICAgYWxsb3dGdWxsU2NyZWVuOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICAvLyBzcGVjaWZpZXMgdGFyZ2V0IGNvbnRleHQgZm9yIGxpbmtzIHdpdGggYHByZWxvYWRgIHR5cGVcbiAgICBhc3luYzogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgLy8gTm90ZTogdGhlcmUgaXMgYSBzcGVjaWFsIGNhc2UgdGhhdCBwcmV2ZW50cyBpdCBmcm9tIGJlaW5nIHdyaXR0ZW4gdG8gdGhlIERPTVxuICAgIC8vIG9uIHRoZSBjbGllbnQgc2lkZSBiZWNhdXNlIHRoZSBicm93c2VycyBhcmUgaW5jb25zaXN0ZW50LiBJbnN0ZWFkIHdlIGNhbGwgZm9jdXMoKS5cbiAgICBhdXRvRm9jdXM6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGF1dG9QbGF5OiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBjYXB0dXJlOiBIQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFLFxuICAgIGNoZWNrZWQ6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgY29sczogSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUsXG4gICAgY29udGVudEVkaXRhYmxlOiBIQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUUsXG4gICAgY29udHJvbHM6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgICdkZWZhdWx0JzogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgZGVmZXI6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGRpc2FibGVkOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBkb3dubG9hZDogSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRSxcbiAgICBkcmFnZ2FibGU6IEhBU19TVFJJTkdfQk9PTEVBTl9WQUxVRSxcbiAgICBmb3JtTm9WYWxpZGF0ZTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgaGlkZGVuOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBsb29wOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICAvLyBDYXV0aW9uOyBgb3B0aW9uLnNlbGVjdGVkYCBpcyBub3QgdXBkYXRlZCBpZiBgc2VsZWN0Lm11bHRpcGxlYCBpc1xuICAgIC8vIGRpc2FibGVkIHdpdGggYHJlbW92ZUF0dHJpYnV0ZWAuXG4gICAgbXVsdGlwbGU6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgbXV0ZWQ6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgbm9WYWxpZGF0ZTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgb3BlbjogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgcGxheXNJbmxpbmU6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHJlYWRPbmx5OiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICByZXF1aXJlZDogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgcmV2ZXJzZWQ6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHJvd3M6IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxuICAgIHJvd1NwYW46IEhBU19OVU1FUklDX1ZBTFVFLFxuICAgIHNjb3BlZDogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgc2VhbWxlc3M6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHNlbGVjdGVkOiBNVVNUX1VTRV9QUk9QRVJUWSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHNpemU6IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxuICAgIHN0YXJ0OiBIQVNfTlVNRVJJQ19WQUxVRSxcbiAgICAvLyBzdXBwb3J0IGZvciBwcm9qZWN0aW5nIHJlZ3VsYXIgRE9NIEVsZW1lbnRzIHZpYSBWMSBuYW1lZCBzbG90cyAoIHNoYWRvdyBkb20gKVxuICAgIHNwYW46IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxuICAgIHNwZWxsQ2hlY2s6IEhBU19TVFJJTkdfQk9PTEVBTl9WQUxVRSxcbiAgICAvLyBTdHlsZSBtdXN0IGJlIGV4cGxpY2l0bHkgc2V0IGluIHRoZSBhdHRyaWJ1dGUgbGlzdC4gUmVhY3QgY29tcG9uZW50c1xuICAgIC8vIGV4cGVjdCBhIHN0eWxlIG9iamVjdFxuICAgIHN0eWxlOiAwLFxuICAgIC8vIEtlZXAgaXQgaW4gdGhlIHdoaXRlbGlzdCBiZWNhdXNlIGl0IGlzIGNhc2Utc2Vuc2l0aXZlIGZvciBTVkcuXG4gICAgdGFiSW5kZXg6IDAsXG4gICAgLy8gaXRlbVNjb3BlIGlzIGZvciBmb3IgTWljcm9kYXRhIHN1cHBvcnQuXG4gICAgLy8gU2VlIGh0dHA6Ly9zY2hlbWEub3JnL2RvY3MvZ3MuaHRtbFxuICAgIGl0ZW1TY29wZTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgLy8gVGhlc2UgYXR0cmlidXRlcyBtdXN0IHN0YXkgaW4gdGhlIHdoaXRlLWxpc3QgYmVjYXVzZSB0aGV5IGhhdmVcbiAgICAvLyBkaWZmZXJlbnQgYXR0cmlidXRlIG5hbWVzIChzZWUgRE9NQXR0cmlidXRlTmFtZXMgYmVsb3cpXG4gICAgYWNjZXB0Q2hhcnNldDogMCxcbiAgICBjbGFzc05hbWU6IDAsXG4gICAgaHRtbEZvcjogMCxcbiAgICBodHRwRXF1aXY6IDAsXG4gICAgLy8gQXR0cmlidXRlcyB3aXRoIG11dGF0aW9uIG1ldGhvZHMgbXVzdCBiZSBzcGVjaWZpZWQgaW4gdGhlIHdoaXRlbGlzdFxuICAgIC8vIFNldCB0aGUgc3RyaW5nIGJvb2xlYW4gZmxhZyB0byBhbGxvdyB0aGUgYmVoYXZpb3JcbiAgICB2YWx1ZTogSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFXG4gIH0sXG4gIERPTUF0dHJpYnV0ZU5hbWVzOiB7XG4gICAgYWNjZXB0Q2hhcnNldDogJ2FjY2VwdC1jaGFyc2V0JyxcbiAgICBjbGFzc05hbWU6ICdjbGFzcycsXG4gICAgaHRtbEZvcjogJ2ZvcicsXG4gICAgaHR0cEVxdWl2OiAnaHR0cC1lcXVpdidcbiAgfSxcbiAgRE9NTXV0YXRpb25NZXRob2RzOiB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIChub2RlLCB2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUucmVtb3ZlQXR0cmlidXRlKCd2YWx1ZScpO1xuICAgICAgfVxuXG4gICAgICAvLyBOdW1iZXIgaW5wdXRzIGdldCBzcGVjaWFsIHRyZWF0bWVudCBkdWUgdG8gc29tZSBlZGdlIGNhc2VzIGluXG4gICAgICAvLyBDaHJvbWUuIExldCBldmVyeXRoaW5nIGVsc2UgYXNzaWduIHRoZSB2YWx1ZSBhdHRyaWJ1dGUgYXMgbm9ybWFsLlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MjUzI2lzc3VlY29tbWVudC0yMzYwNzQzMjZcbiAgICAgIGlmIChub2RlLnR5cGUgIT09ICdudW1iZXInIHx8IG5vZGUuaGFzQXR0cmlidXRlKCd2YWx1ZScpID09PSBmYWxzZSkge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgndmFsdWUnLCAnJyArIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAobm9kZS52YWxpZGl0eSAmJiAhbm9kZS52YWxpZGl0eS5iYWRJbnB1dCAmJiBub2RlLm93bmVyRG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gbm9kZSkge1xuICAgICAgICAvLyBEb24ndCBhc3NpZ24gYW4gYXR0cmlidXRlIGlmIHZhbGlkYXRpb24gcmVwb3J0cyBiYWRcbiAgICAgICAgLy8gaW5wdXQuIENocm9tZSB3aWxsIGNsZWFyIHRoZSB2YWx1ZS4gQWRkaXRpb25hbGx5LCBkb24ndFxuICAgICAgICAvLyBvcGVyYXRlIG9uIGlucHV0cyB0aGF0IGhhdmUgZm9jdXMsIG90aGVyd2lzZSBDaHJvbWUgbWlnaHRcbiAgICAgICAgLy8gc3RyaXAgb2ZmIHRyYWlsaW5nIGRlY2ltYWwgcGxhY2VzIGFuZCBjYXVzZSB0aGUgdXNlcidzXG4gICAgICAgIC8vIGN1cnNvciBwb3NpdGlvbiB0byBqdW1wIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGlucHV0LlxuICAgICAgICAvL1xuICAgICAgICAvLyBJbiBSZWFjdERPTUlucHV0LCB3ZSBoYXZlIGFuIG9uQmx1ciBldmVudCB0aGF0IHdpbGwgdHJpZ2dlclxuICAgICAgICAvLyB0aGlzIGZ1bmN0aW9uIGFnYWluIHdoZW4gZm9jdXMgaXMgbG9zdC5cbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgJycgKyB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFJDEgPSBpbmplY3Rpb24uSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFO1xuXG5cbnZhciBOUyA9IHtcbiAgeGxpbms6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJyxcbiAgeG1sOiAnaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlJ1xufTtcblxuLyoqXG4gKiBUaGlzIGlzIGEgbGlzdCBvZiBhbGwgU1ZHIGF0dHJpYnV0ZXMgdGhhdCBuZWVkIHNwZWNpYWwgY2FzaW5nLFxuICogbmFtZXNwYWNpbmcsIG9yIGJvb2xlYW4gdmFsdWUgYXNzaWdubWVudC5cbiAqXG4gKiBXaGVuIGFkZGluZyBhdHRyaWJ1dGVzIHRvIHRoaXMgbGlzdCwgYmUgc3VyZSB0byBhbHNvIGFkZCB0aGVtIHRvXG4gKiB0aGUgYHBvc3NpYmxlU3RhbmRhcmROYW1lc2AgbW9kdWxlIHRvIGVuc3VyZSBjYXNpbmcgYW5kIGluY29ycmVjdFxuICogbmFtZSB3YXJuaW5ncy5cbiAqXG4gKiBTVkcgQXR0cmlidXRlcyBMaXN0OlxuICogaHR0cHM6Ly93d3cudzMub3JnL1RSL1NWRy9hdHRpbmRleC5odG1sXG4gKiBTTUlMIFNwZWM6XG4gKiBodHRwczovL3d3dy53My5vcmcvVFIvc21pbFxuICovXG52YXIgQVRUUlMgPSBbJ2FjY2VudC1oZWlnaHQnLCAnYWxpZ25tZW50LWJhc2VsaW5lJywgJ2FyYWJpYy1mb3JtJywgJ2Jhc2VsaW5lLXNoaWZ0JywgJ2NhcC1oZWlnaHQnLCAnY2xpcC1wYXRoJywgJ2NsaXAtcnVsZScsICdjb2xvci1pbnRlcnBvbGF0aW9uJywgJ2NvbG9yLWludGVycG9sYXRpb24tZmlsdGVycycsICdjb2xvci1wcm9maWxlJywgJ2NvbG9yLXJlbmRlcmluZycsICdkb21pbmFudC1iYXNlbGluZScsICdlbmFibGUtYmFja2dyb3VuZCcsICdmaWxsLW9wYWNpdHknLCAnZmlsbC1ydWxlJywgJ2Zsb29kLWNvbG9yJywgJ2Zsb29kLW9wYWNpdHknLCAnZm9udC1mYW1pbHknLCAnZm9udC1zaXplJywgJ2ZvbnQtc2l6ZS1hZGp1c3QnLCAnZm9udC1zdHJldGNoJywgJ2ZvbnQtc3R5bGUnLCAnZm9udC12YXJpYW50JywgJ2ZvbnQtd2VpZ2h0JywgJ2dseXBoLW5hbWUnLCAnZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbCcsICdnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbCcsICdob3Jpei1hZHYteCcsICdob3Jpei1vcmlnaW4teCcsICdpbWFnZS1yZW5kZXJpbmcnLCAnbGV0dGVyLXNwYWNpbmcnLCAnbGlnaHRpbmctY29sb3InLCAnbWFya2VyLWVuZCcsICdtYXJrZXItbWlkJywgJ21hcmtlci1zdGFydCcsICdvdmVybGluZS1wb3NpdGlvbicsICdvdmVybGluZS10aGlja25lc3MnLCAncGFpbnQtb3JkZXInLCAncGFub3NlLTEnLCAncG9pbnRlci1ldmVudHMnLCAncmVuZGVyaW5nLWludGVudCcsICdzaGFwZS1yZW5kZXJpbmcnLCAnc3RvcC1jb2xvcicsICdzdG9wLW9wYWNpdHknLCAnc3RyaWtldGhyb3VnaC1wb3NpdGlvbicsICdzdHJpa2V0aHJvdWdoLXRoaWNrbmVzcycsICdzdHJva2UtZGFzaGFycmF5JywgJ3N0cm9rZS1kYXNob2Zmc2V0JywgJ3N0cm9rZS1saW5lY2FwJywgJ3N0cm9rZS1saW5lam9pbicsICdzdHJva2UtbWl0ZXJsaW1pdCcsICdzdHJva2Utb3BhY2l0eScsICdzdHJva2Utd2lkdGgnLCAndGV4dC1hbmNob3InLCAndGV4dC1kZWNvcmF0aW9uJywgJ3RleHQtcmVuZGVyaW5nJywgJ3VuZGVybGluZS1wb3NpdGlvbicsICd1bmRlcmxpbmUtdGhpY2tuZXNzJywgJ3VuaWNvZGUtYmlkaScsICd1bmljb2RlLXJhbmdlJywgJ3VuaXRzLXBlci1lbScsICd2LWFscGhhYmV0aWMnLCAndi1oYW5naW5nJywgJ3YtaWRlb2dyYXBoaWMnLCAndi1tYXRoZW1hdGljYWwnLCAndmVjdG9yLWVmZmVjdCcsICd2ZXJ0LWFkdi15JywgJ3ZlcnQtb3JpZ2luLXgnLCAndmVydC1vcmlnaW4teScsICd3b3JkLXNwYWNpbmcnLCAnd3JpdGluZy1tb2RlJywgJ3gtaGVpZ2h0JywgJ3hsaW5rOmFjdHVhdGUnLCAneGxpbms6YXJjcm9sZScsICd4bGluazpocmVmJywgJ3hsaW5rOnJvbGUnLCAneGxpbms6c2hvdycsICd4bGluazp0aXRsZScsICd4bGluazp0eXBlJywgJ3htbDpiYXNlJywgJ3htbG5zOnhsaW5rJywgJ3htbDpsYW5nJywgJ3htbDpzcGFjZSddO1xuXG52YXIgU1ZHRE9NUHJvcGVydHlDb25maWcgPSB7XG4gIFByb3BlcnRpZXM6IHtcbiAgICBhdXRvUmV2ZXJzZTogSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFJDEsXG4gICAgZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZDogSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFJDEsXG4gICAgcHJlc2VydmVBbHBoYTogSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFJDFcbiAgfSxcbiAgRE9NQXR0cmlidXRlTmFtZXM6IHtcbiAgICBhdXRvUmV2ZXJzZTogJ2F1dG9SZXZlcnNlJyxcbiAgICBleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkOiAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsXG4gICAgcHJlc2VydmVBbHBoYTogJ3ByZXNlcnZlQWxwaGEnXG4gIH0sXG4gIERPTUF0dHJpYnV0ZU5hbWVzcGFjZXM6IHtcbiAgICB4bGlua0FjdHVhdGU6IE5TLnhsaW5rLFxuICAgIHhsaW5rQXJjcm9sZTogTlMueGxpbmssXG4gICAgeGxpbmtIcmVmOiBOUy54bGluayxcbiAgICB4bGlua1JvbGU6IE5TLnhsaW5rLFxuICAgIHhsaW5rU2hvdzogTlMueGxpbmssXG4gICAgeGxpbmtUaXRsZTogTlMueGxpbmssXG4gICAgeGxpbmtUeXBlOiBOUy54bGluayxcbiAgICB4bWxCYXNlOiBOUy54bWwsXG4gICAgeG1sTGFuZzogTlMueG1sLFxuICAgIHhtbFNwYWNlOiBOUy54bWxcbiAgfVxufTtcblxudmFyIENBTUVMSVpFID0gL1tcXC1cXDpdKFthLXpdKS9nO1xudmFyIGNhcGl0YWxpemUgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgcmV0dXJuIHRva2VuWzFdLnRvVXBwZXJDYXNlKCk7XG59O1xuXG5BVFRSUy5mb3JFYWNoKGZ1bmN0aW9uIChvcmlnaW5hbCkge1xuICB2YXIgcmVhY3ROYW1lID0gb3JpZ2luYWwucmVwbGFjZShDQU1FTElaRSwgY2FwaXRhbGl6ZSk7XG5cbiAgU1ZHRE9NUHJvcGVydHlDb25maWcuUHJvcGVydGllc1tyZWFjdE5hbWVdID0gMDtcbiAgU1ZHRE9NUHJvcGVydHlDb25maWcuRE9NQXR0cmlidXRlTmFtZXNbcmVhY3ROYW1lXSA9IG9yaWdpbmFsO1xufSk7XG5cbmluamVjdGlvbi5pbmplY3RET01Qcm9wZXJ0eUNvbmZpZyhIVE1MRE9NUHJvcGVydHlDb25maWcpO1xuaW5qZWN0aW9uLmluamVjdERPTVByb3BlcnR5Q29uZmlnKFNWR0RPTVByb3BlcnR5Q29uZmlnKTtcblxudmFyIFJlYWN0RXJyb3JVdGlscyA9IHtcbiAgLy8gVXNlZCBieSBGaWJlciB0byBzaW11bGF0ZSBhIHRyeS1jYXRjaC5cbiAgX2NhdWdodEVycm9yOiBudWxsLFxuICBfaGFzQ2F1Z2h0RXJyb3I6IGZhbHNlLFxuXG4gIC8vIFVzZWQgYnkgZXZlbnQgc3lzdGVtIHRvIGNhcHR1cmUvcmV0aHJvdyB0aGUgZmlyc3QgZXJyb3IuXG4gIF9yZXRocm93RXJyb3I6IG51bGwsXG4gIF9oYXNSZXRocm93RXJyb3I6IGZhbHNlLFxuXG4gIGluamVjdGlvbjoge1xuICAgIGluamVjdEVycm9yVXRpbHM6IGZ1bmN0aW9uIChpbmplY3RlZEVycm9yVXRpbHMpIHtcbiAgICAgICEodHlwZW9mIGluamVjdGVkRXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2sgPT09ICdmdW5jdGlvbicpID8gaW52YXJpYW50KGZhbHNlLCAnSW5qZWN0ZWQgaW52b2tlR3VhcmRlZENhbGxiYWNrKCkgbXVzdCBiZSBhIGZ1bmN0aW9uLicpIDogdm9pZCAwO1xuICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrID0gaW5qZWN0ZWRFcnJvclV0aWxzLmludm9rZUd1YXJkZWRDYWxsYmFjaztcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbGwgYSBmdW5jdGlvbiB3aGlsZSBndWFyZGluZyBhZ2FpbnN0IGVycm9ycyB0aGF0IGhhcHBlbnMgd2l0aGluIGl0LlxuICAgKiBSZXR1cm5zIGFuIGVycm9yIGlmIGl0IHRocm93cywgb3RoZXJ3aXNlIG51bGwuXG4gICAqXG4gICAqIEluIHByb2R1Y3Rpb24sIHRoaXMgaXMgaW1wbGVtZW50ZWQgdXNpbmcgYSB0cnktY2F0Y2guIFRoZSByZWFzb24gd2UgZG9uJ3RcbiAgICogdXNlIGEgdHJ5LWNhdGNoIGRpcmVjdGx5IGlzIHNvIHRoYXQgd2UgY2FuIHN3YXAgb3V0IGEgZGlmZmVyZW50XG4gICAqIGltcGxlbWVudGF0aW9uIGluIERFViBtb2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiB0aGUgZ3VhcmQgdG8gdXNlIGZvciBsb2dnaW5nIG9yIGRlYnVnZ2luZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2VcbiAgICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIHVzZSB3aGVuIGNhbGxpbmcgdGhlIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7Li4uKn0gYXJncyBBcmd1bWVudHMgZm9yIGZ1bmN0aW9uXG4gICAqL1xuICBpbnZva2VHdWFyZGVkQ2FsbGJhY2s6IGZ1bmN0aW9uIChuYW1lLCBmdW5jLCBjb250ZXh0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgaW52b2tlR3VhcmRlZENhbGxiYWNrLmFwcGx5KFJlYWN0RXJyb3JVdGlscywgYXJndW1lbnRzKTtcbiAgfSxcblxuICAvKipcbiAgICogU2FtZSBhcyBpbnZva2VHdWFyZGVkQ2FsbGJhY2ssIGJ1dCBpbnN0ZWFkIG9mIHJldHVybmluZyBhbiBlcnJvciwgaXQgc3RvcmVzXG4gICAqIGl0IGluIGEgZ2xvYmFsIHNvIGl0IGNhbiBiZSByZXRocm93biBieSBgcmV0aHJvd0NhdWdodEVycm9yYCBsYXRlci5cbiAgICogVE9ETzogU2VlIGlmIF9jYXVnaHRFcnJvciBhbmQgX3JldGhyb3dFcnJvciBjYW4gYmUgdW5pZmllZC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgb2YgdGhlIGd1YXJkIHRvIHVzZSBmb3IgbG9nZ2luZyBvciBkZWJ1Z2dpbmdcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlXG4gICAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byB1c2Ugd2hlbiBjYWxsaW5nIHRoZSBmdW5jdGlvblxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3MgQXJndW1lbnRzIGZvciBmdW5jdGlvblxuICAgKi9cbiAgaW52b2tlR3VhcmRlZENhbGxiYWNrQW5kQ2F0Y2hGaXJzdEVycm9yOiBmdW5jdGlvbiAobmFtZSwgZnVuYywgY29udGV4dCwgYSwgYiwgYywgZCwgZSwgZikge1xuICAgIFJlYWN0RXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAoUmVhY3RFcnJvclV0aWxzLmhhc0NhdWdodEVycm9yKCkpIHtcbiAgICAgIHZhciBlcnJvciA9IFJlYWN0RXJyb3JVdGlscy5jbGVhckNhdWdodEVycm9yKCk7XG4gICAgICBpZiAoIVJlYWN0RXJyb3JVdGlscy5faGFzUmV0aHJvd0Vycm9yKSB7XG4gICAgICAgIFJlYWN0RXJyb3JVdGlscy5faGFzUmV0aHJvd0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgUmVhY3RFcnJvclV0aWxzLl9yZXRocm93RXJyb3IgPSBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIER1cmluZyBleGVjdXRpb24gb2YgZ3VhcmRlZCBmdW5jdGlvbnMgd2Ugd2lsbCBjYXB0dXJlIHRoZSBmaXJzdCBlcnJvciB3aGljaFxuICAgKiB3ZSB3aWxsIHJldGhyb3cgdG8gYmUgaGFuZGxlZCBieSB0aGUgdG9wIGxldmVsIGVycm9yIGhhbmRsZXIuXG4gICAqL1xuICByZXRocm93Q2F1Z2h0RXJyb3I6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcmV0aHJvd0NhdWdodEVycm9yLmFwcGx5KFJlYWN0RXJyb3JVdGlscywgYXJndW1lbnRzKTtcbiAgfSxcblxuICBoYXNDYXVnaHRFcnJvcjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBSZWFjdEVycm9yVXRpbHMuX2hhc0NhdWdodEVycm9yO1xuICB9LFxuXG4gIGNsZWFyQ2F1Z2h0RXJyb3I6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoUmVhY3RFcnJvclV0aWxzLl9oYXNDYXVnaHRFcnJvcikge1xuICAgICAgdmFyIGVycm9yID0gUmVhY3RFcnJvclV0aWxzLl9jYXVnaHRFcnJvcjtcbiAgICAgIFJlYWN0RXJyb3JVdGlscy5fY2F1Z2h0RXJyb3IgPSBudWxsO1xuICAgICAgUmVhY3RFcnJvclV0aWxzLl9oYXNDYXVnaHRFcnJvciA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdjbGVhckNhdWdodEVycm9yIHdhcyBjYWxsZWQgYnV0IG5vIGVycm9yIHdhcyBjYXB0dXJlZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBpbnZva2VHdWFyZGVkQ2FsbGJhY2sgPSBmdW5jdGlvbiAobmFtZSwgZnVuYywgY29udGV4dCwgYSwgYiwgYywgZCwgZSwgZikge1xuICBSZWFjdEVycm9yVXRpbHMuX2hhc0NhdWdodEVycm9yID0gZmFsc2U7XG4gIFJlYWN0RXJyb3JVdGlscy5fY2F1Z2h0RXJyb3IgPSBudWxsO1xuICB2YXIgZnVuY0FyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDMpO1xuICB0cnkge1xuICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgZnVuY0FyZ3MpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIFJlYWN0RXJyb3JVdGlscy5fY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgICBSZWFjdEVycm9yVXRpbHMuX2hhc0NhdWdodEVycm9yID0gdHJ1ZTtcbiAgfVxufTtcblxue1xuICAvLyBJbiBERVYgbW9kZSwgd2Ugc3dhcCBvdXQgaW52b2tlR3VhcmRlZENhbGxiYWNrIGZvciBhIHNwZWNpYWwgdmVyc2lvblxuICAvLyB0aGF0IHBsYXlzIG1vcmUgbmljZWx5IHdpdGggdGhlIGJyb3dzZXIncyBEZXZUb29scy4gVGhlIGlkZWEgaXMgdG8gcHJlc2VydmVcbiAgLy8gXCJQYXVzZSBvbiBleGNlcHRpb25zXCIgYmVoYXZpb3IuIEJlY2F1c2UgUmVhY3Qgd3JhcHMgYWxsIHVzZXItcHJvdmlkZWRcbiAgLy8gZnVuY3Rpb25zIGluIGludm9rZUd1YXJkZWRDYWxsYmFjaywgYW5kIHRoZSBwcm9kdWN0aW9uIHZlcnNpb24gb2ZcbiAgLy8gaW52b2tlR3VhcmRlZENhbGxiYWNrIHVzZXMgYSB0cnktY2F0Y2gsIGFsbCB1c2VyIGV4Y2VwdGlvbnMgYXJlIHRyZWF0ZWRcbiAgLy8gbGlrZSBjYXVnaHQgZXhjZXB0aW9ucywgYW5kIHRoZSBEZXZUb29scyB3b24ndCBwYXVzZSB1bmxlc3MgdGhlIGRldmVsb3BlclxuICAvLyB0YWtlcyB0aGUgZXh0cmEgc3RlcCBvZiBlbmFibGluZyBwYXVzZSBvbiBjYXVnaHQgZXhjZXB0aW9ucy4gVGhpcyBpc1xuICAvLyB1bnRpbnR1aXRpdmUsIHRob3VnaCwgYmVjYXVzZSBldmVuIHRob3VnaCBSZWFjdCBoYXMgY2F1Z2h0IHRoZSBlcnJvciwgZnJvbVxuICAvLyB0aGUgZGV2ZWxvcGVyJ3MgcGVyc3BlY3RpdmUsIHRoZSBlcnJvciBpcyB1bmNhdWdodC5cbiAgLy9cbiAgLy8gVG8gcHJlc2VydmUgdGhlIGV4cGVjdGVkIFwiUGF1c2Ugb24gZXhjZXB0aW9uc1wiIGJlaGF2aW9yLCB3ZSBkb24ndCB1c2UgYVxuICAvLyB0cnktY2F0Y2ggaW4gREVWLiBJbnN0ZWFkLCB3ZSBzeW5jaHJvbm91c2x5IGRpc3BhdGNoIGEgZmFrZSBldmVudCB0byBhIGZha2VcbiAgLy8gRE9NIG5vZGUsIGFuZCBjYWxsIHRoZSB1c2VyLXByb3ZpZGVkIGNhbGxiYWNrIGZyb20gaW5zaWRlIGFuIGV2ZW50IGhhbmRsZXJcbiAgLy8gZm9yIHRoYXQgZmFrZSBldmVudC4gSWYgdGhlIGNhbGxiYWNrIHRocm93cywgdGhlIGVycm9yIGlzIFwiY2FwdHVyZWRcIiB1c2luZ1xuICAvLyBhIGdsb2JhbCBldmVudCBoYW5kbGVyLiBCdXQgYmVjYXVzZSB0aGUgZXJyb3IgaGFwcGVucyBpbiBhIGRpZmZlcmVudFxuICAvLyBldmVudCBsb29wIGNvbnRleHQsIGl0IGRvZXMgbm90IGludGVycnVwdCB0aGUgbm9ybWFsIHByb2dyYW0gZmxvdy5cbiAgLy8gRWZmZWN0aXZlbHksIHRoaXMgZ2l2ZXMgdXMgdHJ5LWNhdGNoIGJlaGF2aW9yIHdpdGhvdXQgYWN0dWFsbHkgdXNpbmdcbiAgLy8gdHJ5LWNhdGNoLiBOZWF0IVxuXG4gIC8vIENoZWNrIHRoYXQgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdGhlIEFQSXMgd2UgbmVlZCB0byBpbXBsZW1lbnQgb3VyIHNwZWNpYWxcbiAgLy8gREVWIHZlcnNpb24gb2YgaW52b2tlR3VhcmRlZENhbGxiYWNrXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRpc3BhdGNoRXZlbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRXZlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZmFrZU5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdyZWFjdCcpO1xuXG4gICAgdmFyIGludm9rZUd1YXJkZWRDYWxsYmFja0RldiA9IGZ1bmN0aW9uIChuYW1lLCBmdW5jLCBjb250ZXh0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgICAvLyBLZWVwcyB0cmFjayBvZiB3aGV0aGVyIHRoZSB1c2VyLXByb3ZpZGVkIGNhbGxiYWNrIHRocmV3IGFuIGVycm9yLiBXZVxuICAgICAgLy8gc2V0IHRoaXMgdG8gdHJ1ZSBhdCB0aGUgYmVnaW5uaW5nLCB0aGVuIHNldCBpdCB0byBmYWxzZSByaWdodCBhZnRlclxuICAgICAgLy8gY2FsbGluZyB0aGUgZnVuY3Rpb24uIElmIHRoZSBmdW5jdGlvbiBlcnJvcnMsIGBkaWRFcnJvcmAgd2lsbCBuZXZlciBiZVxuICAgICAgLy8gc2V0IHRvIGZhbHNlLiBUaGlzIHN0cmF0ZWd5IHdvcmtzIGV2ZW4gaWYgdGhlIGJyb3dzZXIgaXMgZmxha3kgYW5kXG4gICAgICAvLyBmYWlscyB0byBjYWxsIG91ciBnbG9iYWwgZXJyb3IgaGFuZGxlciwgYmVjYXVzZSBpdCBkb2Vzbid0IHJlbHkgb25cbiAgICAgIC8vIHRoZSBlcnJvciBldmVudCBhdCBhbGwuXG4gICAgICB2YXIgZGlkRXJyb3IgPSB0cnVlO1xuXG4gICAgICAvLyBDcmVhdGUgYW4gZXZlbnQgaGFuZGxlciBmb3Igb3VyIGZha2UgZXZlbnQuIFdlIHdpbGwgc3luY2hyb25vdXNseVxuICAgICAgLy8gZGlzcGF0Y2ggb3VyIGZha2UgZXZlbnQgdXNpbmcgYGRpc3BhdGNoRXZlbnRgLiBJbnNpZGUgdGhlIGhhbmRsZXIsIHdlXG4gICAgICAvLyBjYWxsIHRoZSB1c2VyLXByb3ZpZGVkIGNhbGxiYWNrLlxuICAgICAgdmFyIGZ1bmNBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAzKTtcbiAgICAgIGZ1bmN0aW9uIGNhbGxDYWxsYmFjaygpIHtcbiAgICAgICAgLy8gV2UgaW1tZWRpYXRlbHkgcmVtb3ZlIHRoZSBjYWxsYmFjayBmcm9tIGV2ZW50IGxpc3RlbmVycyBzbyB0aGF0XG4gICAgICAgIC8vIG5lc3RlZCBgaW52b2tlR3VhcmRlZENhbGxiYWNrYCBjYWxscyBkbyBub3QgY2xhc2guIE90aGVyd2lzZSwgYVxuICAgICAgICAvLyBuZXN0ZWQgY2FsbCB3b3VsZCB0cmlnZ2VyIHRoZSBmYWtlIGV2ZW50IGhhbmRsZXJzIG9mIGFueSBjYWxsIGhpZ2hlclxuICAgICAgICAvLyBpbiB0aGUgc3RhY2suXG4gICAgICAgIGZha2VOb2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgY2FsbENhbGxiYWNrLCBmYWxzZSk7XG4gICAgICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgZnVuY0FyZ3MpO1xuICAgICAgICBkaWRFcnJvciA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgYSBnbG9iYWwgZXJyb3IgZXZlbnQgaGFuZGxlci4gV2UgdXNlIHRoaXMgdG8gY2FwdHVyZSB0aGUgdmFsdWVcbiAgICAgIC8vIHRoYXQgd2FzIHRocm93bi4gSXQncyBwb3NzaWJsZSB0aGF0IHRoaXMgZXJyb3IgaGFuZGxlciB3aWxsIGZpcmUgbW9yZVxuICAgICAgLy8gdGhhbiBvbmNlOyBmb3IgZXhhbXBsZSwgaWYgbm9uLVJlYWN0IGNvZGUgYWxzbyBjYWxscyBgZGlzcGF0Y2hFdmVudGBcbiAgICAgIC8vIGFuZCBhIGhhbmRsZXIgZm9yIHRoYXQgZXZlbnQgdGhyb3dzLiBXZSBzaG91bGQgYmUgcmVzaWxpZW50IHRvIG1vc3Qgb2ZcbiAgICAgIC8vIHRob3NlIGNhc2VzLiBFdmVuIGlmIG91ciBlcnJvciBldmVudCBoYW5kbGVyIGZpcmVzIG1vcmUgdGhhbiBvbmNlLCB0aGVcbiAgICAgIC8vIGxhc3QgZXJyb3IgZXZlbnQgaXMgYWx3YXlzIHVzZWQuIElmIHRoZSBjYWxsYmFjayBhY3R1YWxseSBkb2VzIGVycm9yLFxuICAgICAgLy8gd2Uga25vdyB0aGF0IHRoZSBsYXN0IGVycm9yIGV2ZW50IGlzIHRoZSBjb3JyZWN0IG9uZSwgYmVjYXVzZSBpdCdzIG5vdFxuICAgICAgLy8gcG9zc2libGUgZm9yIGFueXRoaW5nIGVsc2UgdG8gaGF2ZSBoYXBwZW5lZCBpbiBiZXR3ZWVuIG91ciBjYWxsYmFja1xuICAgICAgLy8gZXJyb3JpbmcgYW5kIHRoZSBjb2RlIHRoYXQgZm9sbG93cyB0aGUgYGRpc3BhdGNoRXZlbnRgIGNhbGwgYmVsb3cuIElmXG4gICAgICAvLyB0aGUgY2FsbGJhY2sgZG9lc24ndCBlcnJvciwgYnV0IHRoZSBlcnJvciBldmVudCB3YXMgZmlyZWQsIHdlIGtub3cgdG9cbiAgICAgIC8vIGlnbm9yZSBpdCBiZWNhdXNlIGBkaWRFcnJvcmAgd2lsbCBiZSBmYWxzZSwgYXMgZGVzY3JpYmVkIGFib3ZlLlxuICAgICAgdmFyIGVycm9yID0gdm9pZCAwO1xuICAgICAgLy8gVXNlIHRoaXMgdG8gdHJhY2sgd2hldGhlciB0aGUgZXJyb3IgZXZlbnQgaXMgZXZlciBjYWxsZWQuXG4gICAgICB2YXIgZGlkU2V0RXJyb3IgPSBmYWxzZTtcbiAgICAgIHZhciBpc0Nyb3NzT3JpZ2luRXJyb3IgPSBmYWxzZTtcblxuICAgICAgZnVuY3Rpb24gb25FcnJvcihldmVudCkge1xuICAgICAgICBlcnJvciA9IGV2ZW50LmVycm9yO1xuICAgICAgICBkaWRTZXRFcnJvciA9IHRydWU7XG4gICAgICAgIGlmIChlcnJvciA9PT0gbnVsbCAmJiBldmVudC5jb2xubyA9PT0gMCAmJiBldmVudC5saW5lbm8gPT09IDApIHtcbiAgICAgICAgICBpc0Nyb3NzT3JpZ2luRXJyb3IgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZSBhIGZha2UgZXZlbnQgdHlwZS5cbiAgICAgIHZhciBldnRUeXBlID0gJ3JlYWN0LScgKyAobmFtZSA/IG5hbWUgOiAnaW52b2tlZ3VhcmRlZGNhbGxiYWNrJyk7XG5cbiAgICAgIC8vIEF0dGFjaCBvdXIgZXZlbnQgaGFuZGxlcnNcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3IpO1xuICAgICAgZmFrZU5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBjYWxsQ2FsbGJhY2ssIGZhbHNlKTtcblxuICAgICAgLy8gU3luY2hyb25vdXNseSBkaXNwYXRjaCBvdXIgZmFrZSBldmVudC4gSWYgdGhlIHVzZXItcHJvdmlkZWQgZnVuY3Rpb25cbiAgICAgIC8vIGVycm9ycywgaXQgd2lsbCB0cmlnZ2VyIG91ciBnbG9iYWwgZXJyb3IgaGFuZGxlci5cbiAgICAgIHZhciBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICAgIGV2dC5pbml0RXZlbnQoZXZ0VHlwZSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgIGZha2VOb2RlLmRpc3BhdGNoRXZlbnQoZXZ0KTtcblxuICAgICAgaWYgKGRpZEVycm9yKSB7XG4gICAgICAgIGlmICghZGlkU2V0RXJyb3IpIHtcbiAgICAgICAgICAvLyBUaGUgY2FsbGJhY2sgZXJyb3JlZCwgYnV0IHRoZSBlcnJvciBldmVudCBuZXZlciBmaXJlZC5cbiAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcignQW4gZXJyb3Igd2FzIHRocm93biBpbnNpZGUgb25lIG9mIHlvdXIgY29tcG9uZW50cywgYnV0IFJlYWN0ICcgKyBcImRvZXNuJ3Qga25vdyB3aGF0IGl0IHdhcy4gVGhpcyBpcyBsaWtlbHkgZHVlIHRvIGJyb3dzZXIgXCIgKyAnZmxha2luZXNzLiBSZWFjdCBkb2VzIGl0cyBiZXN0IHRvIHByZXNlcnZlIHRoZSBcIlBhdXNlIG9uICcgKyAnZXhjZXB0aW9uc1wiIGJlaGF2aW9yIG9mIHRoZSBEZXZUb29scywgd2hpY2ggcmVxdWlyZXMgc29tZSAnICsgXCJERVYtbW9kZSBvbmx5IHRyaWNrcy4gSXQncyBwb3NzaWJsZSB0aGF0IHRoZXNlIGRvbid0IHdvcmsgaW4gXCIgKyAneW91ciBicm93c2VyLiBUcnkgdHJpZ2dlcmluZyB0aGUgZXJyb3IgaW4gcHJvZHVjdGlvbiBtb2RlLCAnICsgJ29yIHN3aXRjaGluZyB0byBhIG1vZGVybiBicm93c2VyLiBJZiB5b3Ugc3VzcGVjdCB0aGF0IHRoaXMgaXMgJyArICdhY3R1YWxseSBhbiBpc3N1ZSB3aXRoIFJlYWN0LCBwbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0Nyb3NzT3JpZ2luRXJyb3IpIHtcbiAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcihcIkEgY3Jvc3Mtb3JpZ2luIGVycm9yIHdhcyB0aHJvd24uIFJlYWN0IGRvZXNuJ3QgaGF2ZSBhY2Nlc3MgdG8gXCIgKyAndGhlIGFjdHVhbCBlcnJvciBvYmplY3QgaW4gZGV2ZWxvcG1lbnQuICcgKyAnU2VlIGh0dHBzOi8vZmIubWUvcmVhY3QtY3Jvc3NvcmlnaW4tZXJyb3IgZm9yIG1vcmUgaW5mb3JtYXRpb24uJyk7XG4gICAgICAgIH1cbiAgICAgICAgUmVhY3RFcnJvclV0aWxzLl9oYXNDYXVnaHRFcnJvciA9IHRydWU7XG4gICAgICAgIFJlYWN0RXJyb3JVdGlscy5fY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFJlYWN0RXJyb3JVdGlscy5faGFzQ2F1Z2h0RXJyb3IgPSBmYWxzZTtcbiAgICAgICAgUmVhY3RFcnJvclV0aWxzLl9jYXVnaHRFcnJvciA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSBvdXIgZXZlbnQgbGlzdGVuZXJzXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yKTtcbiAgICB9O1xuXG4gICAgaW52b2tlR3VhcmRlZENhbGxiYWNrID0gaW52b2tlR3VhcmRlZENhbGxiYWNrRGV2O1xuICB9XG59XG5cbnZhciByZXRocm93Q2F1Z2h0RXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChSZWFjdEVycm9yVXRpbHMuX2hhc1JldGhyb3dFcnJvcikge1xuICAgIHZhciBlcnJvciA9IFJlYWN0RXJyb3JVdGlscy5fcmV0aHJvd0Vycm9yO1xuICAgIFJlYWN0RXJyb3JVdGlscy5fcmV0aHJvd0Vycm9yID0gbnVsbDtcbiAgICBSZWFjdEVycm9yVXRpbHMuX2hhc1JldGhyb3dFcnJvciA9IGZhbHNlO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG4vKipcbiAqIEluamVjdGFibGUgb3JkZXJpbmcgb2YgZXZlbnQgcGx1Z2lucy5cbiAqL1xudmFyIGV2ZW50UGx1Z2luT3JkZXIgPSBudWxsO1xuXG4vKipcbiAqIEluamVjdGFibGUgbWFwcGluZyBmcm9tIG5hbWVzIHRvIGV2ZW50IHBsdWdpbiBtb2R1bGVzLlxuICovXG52YXIgbmFtZXNUb1BsdWdpbnMgPSB7fTtcblxuLyoqXG4gKiBSZWNvbXB1dGVzIHRoZSBwbHVnaW4gbGlzdCB1c2luZyB0aGUgaW5qZWN0ZWQgcGx1Z2lucyBhbmQgcGx1Z2luIG9yZGVyaW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nKCkge1xuICBpZiAoIWV2ZW50UGx1Z2luT3JkZXIpIHtcbiAgICAvLyBXYWl0IHVudGlsIGFuIGBldmVudFBsdWdpbk9yZGVyYCBpcyBpbmplY3RlZC5cbiAgICByZXR1cm47XG4gIH1cbiAgZm9yICh2YXIgcGx1Z2luTmFtZSBpbiBuYW1lc1RvUGx1Z2lucykge1xuICAgIHZhciBwbHVnaW5Nb2R1bGUgPSBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXTtcbiAgICB2YXIgcGx1Z2luSW5kZXggPSBldmVudFBsdWdpbk9yZGVyLmluZGV4T2YocGx1Z2luTmFtZSk7XG4gICAgIShwbHVnaW5JbmRleCA+IC0xKSA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IENhbm5vdCBpbmplY3QgZXZlbnQgcGx1Z2lucyB0aGF0IGRvIG5vdCBleGlzdCBpbiB0aGUgcGx1Z2luIG9yZGVyaW5nLCBgJXNgLicsIHBsdWdpbk5hbWUpIDogdm9pZCAwO1xuICAgIGlmIChwbHVnaW5zW3BsdWdpbkluZGV4XSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgICFwbHVnaW5Nb2R1bGUuZXh0cmFjdEV2ZW50cyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IEV2ZW50IHBsdWdpbnMgbXVzdCBpbXBsZW1lbnQgYW4gYGV4dHJhY3RFdmVudHNgIG1ldGhvZCwgYnV0IGAlc2AgZG9lcyBub3QuJywgcGx1Z2luTmFtZSkgOiB2b2lkIDA7XG4gICAgcGx1Z2luc1twbHVnaW5JbmRleF0gPSBwbHVnaW5Nb2R1bGU7XG4gICAgdmFyIHB1Ymxpc2hlZEV2ZW50cyA9IHBsdWdpbk1vZHVsZS5ldmVudFR5cGVzO1xuICAgIGZvciAodmFyIGV2ZW50TmFtZSBpbiBwdWJsaXNoZWRFdmVudHMpIHtcbiAgICAgICFwdWJsaXNoRXZlbnRGb3JQbHVnaW4ocHVibGlzaGVkRXZlbnRzW2V2ZW50TmFtZV0sIHBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKSA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IEZhaWxlZCB0byBwdWJsaXNoIGV2ZW50IGAlc2AgZm9yIHBsdWdpbiBgJXNgLicsIGV2ZW50TmFtZSwgcGx1Z2luTmFtZSkgOiB2b2lkIDA7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUHVibGlzaGVzIGFuIGV2ZW50IHNvIHRoYXQgaXQgY2FuIGJlIGRpc3BhdGNoZWQgYnkgdGhlIHN1cHBsaWVkIHBsdWdpbi5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgRGlzcGF0Y2ggY29uZmlndXJhdGlvbiBmb3IgdGhlIGV2ZW50LlxuICogQHBhcmFtIHtvYmplY3R9IFBsdWdpbk1vZHVsZSBQbHVnaW4gcHVibGlzaGluZyB0aGUgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBldmVudCB3YXMgc3VjY2Vzc2Z1bGx5IHB1Ymxpc2hlZC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHB1Ymxpc2hFdmVudEZvclBsdWdpbihkaXNwYXRjaENvbmZpZywgcGx1Z2luTW9kdWxlLCBldmVudE5hbWUpIHtcbiAgISFldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luSHViOiBNb3JlIHRoYW4gb25lIHBsdWdpbiBhdHRlbXB0ZWQgdG8gcHVibGlzaCB0aGUgc2FtZSBldmVudCBuYW1lLCBgJXNgLicsIGV2ZW50TmFtZSkgOiB2b2lkIDA7XG4gIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlnc1tldmVudE5hbWVdID0gZGlzcGF0Y2hDb25maWc7XG5cbiAgdmFyIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzID0gZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM7XG4gIGlmIChwaGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgIGZvciAodmFyIHBoYXNlTmFtZSBpbiBwaGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgICAgaWYgKHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzLmhhc093blByb3BlcnR5KHBoYXNlTmFtZSkpIHtcbiAgICAgICAgdmFyIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWUgPSBwaGFzZWRSZWdpc3RyYXRpb25OYW1lc1twaGFzZU5hbWVdO1xuICAgICAgICBwdWJsaXNoUmVnaXN0cmF0aW9uTmFtZShwaGFzZWRSZWdpc3RyYXRpb25OYW1lLCBwbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICBwdWJsaXNoUmVnaXN0cmF0aW9uTmFtZShkaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lLCBwbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFB1Ymxpc2hlcyBhIHJlZ2lzdHJhdGlvbiBuYW1lIHRoYXQgaXMgdXNlZCB0byBpZGVudGlmeSBkaXNwYXRjaGVkIGV2ZW50cy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBSZWdpc3RyYXRpb24gbmFtZSB0byBhZGQuXG4gKiBAcGFyYW0ge29iamVjdH0gUGx1Z2luTW9kdWxlIFBsdWdpbiBwdWJsaXNoaW5nIHRoZSBldmVudC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHB1Ymxpc2hSZWdpc3RyYXRpb25OYW1lKHJlZ2lzdHJhdGlvbk5hbWUsIHBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKSB7XG4gICEhcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV0gPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpbkh1YjogTW9yZSB0aGFuIG9uZSBwbHVnaW4gYXR0ZW1wdGVkIHRvIHB1Ymxpc2ggdGhlIHNhbWUgcmVnaXN0cmF0aW9uIG5hbWUsIGAlc2AuJywgcmVnaXN0cmF0aW9uTmFtZSkgOiB2b2lkIDA7XG4gIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdID0gcGx1Z2luTW9kdWxlO1xuICByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzW3JlZ2lzdHJhdGlvbk5hbWVdID0gcGx1Z2luTW9kdWxlLmV2ZW50VHlwZXNbZXZlbnROYW1lXS5kZXBlbmRlbmNpZXM7XG5cbiAge1xuICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IHJlZ2lzdHJhdGlvbk5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzW2xvd2VyQ2FzZWROYW1lXSA9IHJlZ2lzdHJhdGlvbk5hbWU7XG5cbiAgICBpZiAocmVnaXN0cmF0aW9uTmFtZSA9PT0gJ29uRG91YmxlQ2xpY2snKSB7XG4gICAgICBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzLm9uZGJsY2xpY2sgPSByZWdpc3RyYXRpb25OYW1lO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlZ2lzdGVycyBwbHVnaW5zIHNvIHRoYXQgdGhleSBjYW4gZXh0cmFjdCBhbmQgZGlzcGF0Y2ggZXZlbnRzLlxuICpcbiAqIEBzZWUge0V2ZW50UGx1Z2luSHVifVxuICovXG5cbi8qKlxuICogT3JkZXJlZCBsaXN0IG9mIGluamVjdGVkIHBsdWdpbnMuXG4gKi9cbnZhciBwbHVnaW5zID0gW107XG5cbi8qKlxuICogTWFwcGluZyBmcm9tIGV2ZW50IG5hbWUgdG8gZGlzcGF0Y2ggY29uZmlnXG4gKi9cbnZhciBldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MgPSB7fTtcblxuLyoqXG4gKiBNYXBwaW5nIGZyb20gcmVnaXN0cmF0aW9uIG5hbWUgdG8gcGx1Z2luIG1vZHVsZVxuICovXG52YXIgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMgPSB7fTtcblxuLyoqXG4gKiBNYXBwaW5nIGZyb20gcmVnaXN0cmF0aW9uIG5hbWUgdG8gZXZlbnQgbmFtZVxuICovXG52YXIgcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcyA9IHt9O1xuXG4vKipcbiAqIE1hcHBpbmcgZnJvbSBsb3dlcmNhc2UgcmVnaXN0cmF0aW9uIG5hbWVzIHRvIHRoZSBwcm9wZXJseSBjYXNlZCB2ZXJzaW9uLFxuICogdXNlZCB0byB3YXJuIGluIHRoZSBjYXNlIG9mIG1pc3NpbmcgZXZlbnQgaGFuZGxlcnMuIEF2YWlsYWJsZVxuICogb25seSBpbiB0cnVlLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xudmFyIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMgPSB7fTtcbi8vIFRydXN0IHRoZSBkZXZlbG9wZXIgdG8gb25seSB1c2UgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lcyBpbiB0cnVlXG5cbi8qKlxuICogSW5qZWN0cyBhbiBvcmRlcmluZyBvZiBwbHVnaW5zIChieSBwbHVnaW4gbmFtZSkuIFRoaXMgYWxsb3dzIHRoZSBvcmRlcmluZ1xuICogdG8gYmUgZGVjb3VwbGVkIGZyb20gaW5qZWN0aW9uIG9mIHRoZSBhY3R1YWwgcGx1Z2lucyBzbyB0aGF0IG9yZGVyaW5nIGlzXG4gKiBhbHdheXMgZGV0ZXJtaW5pc3RpYyByZWdhcmRsZXNzIG9mIHBhY2thZ2luZywgb24tdGhlLWZseSBpbmplY3Rpb24sIGV0Yy5cbiAqXG4gKiBAcGFyYW0ge2FycmF5fSBJbmplY3RlZEV2ZW50UGx1Z2luT3JkZXJcbiAqIEBpbnRlcm5hbFxuICogQHNlZSB7RXZlbnRQbHVnaW5IdWIuaW5qZWN0aW9uLmluamVjdEV2ZW50UGx1Z2luT3JkZXJ9XG4gKi9cbmZ1bmN0aW9uIGluamVjdEV2ZW50UGx1Z2luT3JkZXIoaW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyKSB7XG4gICEhZXZlbnRQbHVnaW5PcmRlciA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IENhbm5vdCBpbmplY3QgZXZlbnQgcGx1Z2luIG9yZGVyaW5nIG1vcmUgdGhhbiBvbmNlLiBZb3UgYXJlIGxpa2VseSB0cnlpbmcgdG8gbG9hZCBtb3JlIHRoYW4gb25lIGNvcHkgb2YgUmVhY3QuJykgOiB2b2lkIDA7XG4gIC8vIENsb25lIHRoZSBvcmRlcmluZyBzbyBpdCBjYW5ub3QgYmUgZHluYW1pY2FsbHkgbXV0YXRlZC5cbiAgZXZlbnRQbHVnaW5PcmRlciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGluamVjdGVkRXZlbnRQbHVnaW5PcmRlcik7XG4gIHJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nKCk7XG59XG5cbi8qKlxuICogSW5qZWN0cyBwbHVnaW5zIHRvIGJlIHVzZWQgYnkgYEV2ZW50UGx1Z2luSHViYC4gVGhlIHBsdWdpbiBuYW1lcyBtdXN0IGJlXG4gKiBpbiB0aGUgb3JkZXJpbmcgaW5qZWN0ZWQgYnkgYGluamVjdEV2ZW50UGx1Z2luT3JkZXJgLlxuICpcbiAqIFBsdWdpbnMgY2FuIGJlIGluamVjdGVkIGFzIHBhcnQgb2YgcGFnZSBpbml0aWFsaXphdGlvbiBvciBvbi10aGUtZmx5LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBpbmplY3RlZE5hbWVzVG9QbHVnaW5zIE1hcCBmcm9tIG5hbWVzIHRvIHBsdWdpbiBtb2R1bGVzLlxuICogQGludGVybmFsXG4gKiBAc2VlIHtFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24uaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lfVxuICovXG5mdW5jdGlvbiBpbmplY3RFdmVudFBsdWdpbnNCeU5hbWUoaW5qZWN0ZWROYW1lc1RvUGx1Z2lucykge1xuICB2YXIgaXNPcmRlcmluZ0RpcnR5ID0gZmFsc2U7XG4gIGZvciAodmFyIHBsdWdpbk5hbWUgaW4gaW5qZWN0ZWROYW1lc1RvUGx1Z2lucykge1xuICAgIGlmICghaW5qZWN0ZWROYW1lc1RvUGx1Z2lucy5oYXNPd25Qcm9wZXJ0eShwbHVnaW5OYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBwbHVnaW5Nb2R1bGUgPSBpbmplY3RlZE5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdO1xuICAgIGlmICghbmFtZXNUb1BsdWdpbnMuaGFzT3duUHJvcGVydHkocGx1Z2luTmFtZSkgfHwgbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV0gIT09IHBsdWdpbk1vZHVsZSkge1xuICAgICAgISFuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXSA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IENhbm5vdCBpbmplY3QgdHdvIGRpZmZlcmVudCBldmVudCBwbHVnaW5zIHVzaW5nIHRoZSBzYW1lIG5hbWUsIGAlc2AuJywgcGx1Z2luTmFtZSkgOiB2b2lkIDA7XG4gICAgICBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXSA9IHBsdWdpbk1vZHVsZTtcbiAgICAgIGlzT3JkZXJpbmdEaXJ0eSA9IHRydWU7XG4gICAgfVxuICB9XG4gIGlmIChpc09yZGVyaW5nRGlydHkpIHtcbiAgICByZWNvbXB1dGVQbHVnaW5PcmRlcmluZygpO1xuICB9XG59XG5cbnZhciBFdmVudFBsdWdpblJlZ2lzdHJ5ID0gT2JqZWN0LmZyZWV6ZSh7XG5cdHBsdWdpbnM6IHBsdWdpbnMsXG5cdGV2ZW50TmFtZURpc3BhdGNoQ29uZmlnczogZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzLFxuXHRyZWdpc3RyYXRpb25OYW1lTW9kdWxlczogcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMsXG5cdHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXM6IHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXMsXG5cdHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXM6IHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMsXG5cdGluamVjdEV2ZW50UGx1Z2luT3JkZXI6IGluamVjdEV2ZW50UGx1Z2luT3JkZXIsXG5cdGluamVjdEV2ZW50UGx1Z2luc0J5TmFtZTogaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lXG59KTtcblxudmFyIGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUgPSBudWxsO1xudmFyIGdldEluc3RhbmNlRnJvbU5vZGUgPSBudWxsO1xudmFyIGdldE5vZGVGcm9tSW5zdGFuY2UgPSBudWxsO1xuXG52YXIgaW5qZWN0aW9uJDIgPSB7XG4gIGluamVjdENvbXBvbmVudFRyZWU6IGZ1bmN0aW9uIChJbmplY3RlZCkge1xuICAgIGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUgPSBJbmplY3RlZC5nZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlO1xuICAgIGdldEluc3RhbmNlRnJvbU5vZGUgPSBJbmplY3RlZC5nZXRJbnN0YW5jZUZyb21Ob2RlO1xuICAgIGdldE5vZGVGcm9tSW5zdGFuY2UgPSBJbmplY3RlZC5nZXROb2RlRnJvbUluc3RhbmNlO1xuXG4gICAge1xuICAgICAgd2FybmluZyhnZXROb2RlRnJvbUluc3RhbmNlICYmIGdldEluc3RhbmNlRnJvbU5vZGUsICdFdmVudFBsdWdpblV0aWxzLmluamVjdGlvbi5pbmplY3RDb21wb25lbnRUcmVlKC4uLik6IEluamVjdGVkICcgKyAnbW9kdWxlIGlzIG1pc3NpbmcgZ2V0Tm9kZUZyb21JbnN0YW5jZSBvciBnZXRJbnN0YW5jZUZyb21Ob2RlLicpO1xuICAgIH1cbiAgfVxufTtcblxuXG5cblxuXG5cbnZhciB2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcztcbntcbiAgdmFsaWRhdGVFdmVudERpc3BhdGNoZXMgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgZGlzcGF0Y2hMaXN0ZW5lcnMgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG4gICAgdmFyIGRpc3BhdGNoSW5zdGFuY2VzID0gZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzO1xuXG4gICAgdmFyIGxpc3RlbmVyc0lzQXJyID0gQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVycyk7XG4gICAgdmFyIGxpc3RlbmVyc0xlbiA9IGxpc3RlbmVyc0lzQXJyID8gZGlzcGF0Y2hMaXN0ZW5lcnMubGVuZ3RoIDogZGlzcGF0Y2hMaXN0ZW5lcnMgPyAxIDogMDtcblxuICAgIHZhciBpbnN0YW5jZXNJc0FyciA9IEFycmF5LmlzQXJyYXkoZGlzcGF0Y2hJbnN0YW5jZXMpO1xuICAgIHZhciBpbnN0YW5jZXNMZW4gPSBpbnN0YW5jZXNJc0FyciA/IGRpc3BhdGNoSW5zdGFuY2VzLmxlbmd0aCA6IGRpc3BhdGNoSW5zdGFuY2VzID8gMSA6IDA7XG5cbiAgICB3YXJuaW5nKGluc3RhbmNlc0lzQXJyID09PSBsaXN0ZW5lcnNJc0FyciAmJiBpbnN0YW5jZXNMZW4gPT09IGxpc3RlbmVyc0xlbiwgJ0V2ZW50UGx1Z2luVXRpbHM6IEludmFsaWQgYGV2ZW50YC4nKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBEaXNwYXRjaCB0aGUgZXZlbnQgdG8gdGhlIGxpc3RlbmVyLlxuICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnQgU3ludGhldGljRXZlbnQgdG8gaGFuZGxlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNpbXVsYXRlZCBJZiB0aGUgZXZlbnQgaXMgc2ltdWxhdGVkIChjaGFuZ2VzIGV4biBiZWhhdmlvcilcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpc3RlbmVyIEFwcGxpY2F0aW9uLWxldmVsIGNhbGxiYWNrXG4gKiBAcGFyYW0geyp9IGluc3QgSW50ZXJuYWwgY29tcG9uZW50IGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaChldmVudCwgc2ltdWxhdGVkLCBsaXN0ZW5lciwgaW5zdCkge1xuICB2YXIgdHlwZSA9IGV2ZW50LnR5cGUgfHwgJ3Vua25vd24tZXZlbnQnO1xuICBldmVudC5jdXJyZW50VGFyZ2V0ID0gZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcbiAgUmVhY3RFcnJvclV0aWxzLmludm9rZUd1YXJkZWRDYWxsYmFja0FuZENhdGNoRmlyc3RFcnJvcih0eXBlLCBsaXN0ZW5lciwgdW5kZWZpbmVkLCBldmVudCk7XG4gIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBudWxsO1xufVxuXG4vKipcbiAqIFN0YW5kYXJkL3NpbXBsZSBpdGVyYXRpb24gdGhyb3VnaCBhbiBldmVudCdzIGNvbGxlY3RlZCBkaXNwYXRjaGVzLlxuICovXG5mdW5jdGlvbiBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXIoZXZlbnQsIHNpbXVsYXRlZCkge1xuICB2YXIgZGlzcGF0Y2hMaXN0ZW5lcnMgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG4gIHZhciBkaXNwYXRjaEluc3RhbmNlcyA9IGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcztcbiAge1xuICAgIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzKGV2ZW50KTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVycykpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpc3BhdGNoTGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIExpc3RlbmVycyBhbmQgSW5zdGFuY2VzIGFyZSB0d28gcGFyYWxsZWwgYXJyYXlzIHRoYXQgYXJlIGFsd2F5cyBpbiBzeW5jLlxuICAgICAgZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBzaW11bGF0ZWQsIGRpc3BhdGNoTGlzdGVuZXJzW2ldLCBkaXNwYXRjaEluc3RhbmNlc1tpXSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGRpc3BhdGNoTGlzdGVuZXJzKSB7XG4gICAgZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBzaW11bGF0ZWQsIGRpc3BhdGNoTGlzdGVuZXJzLCBkaXNwYXRjaEluc3RhbmNlcyk7XG4gIH1cbiAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gbnVsbDtcbiAgZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzID0gbnVsbDtcbn1cblxuLyoqXG4gKiBAc2VlIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWVJbXBsXG4gKi9cblxuXG4vKipcbiAqIEV4ZWN1dGlvbiBvZiBhIFwiZGlyZWN0XCIgZGlzcGF0Y2ggLSB0aGVyZSBtdXN0IGJlIGF0IG1vc3Qgb25lIGRpc3BhdGNoXG4gKiBhY2N1bXVsYXRlZCBvbiB0aGUgZXZlbnQgb3IgaXQgaXMgY29uc2lkZXJlZCBhbiBlcnJvci4gSXQgZG9lc24ndCByZWFsbHkgbWFrZVxuICogc2Vuc2UgZm9yIGFuIGV2ZW50IHdpdGggbXVsdGlwbGUgZGlzcGF0Y2hlcyAoYnViYmxlZCkgdG8ga2VlcCB0cmFjayBvZiB0aGVcbiAqIHJldHVybiB2YWx1ZXMgYXQgZWFjaCBkaXNwYXRjaCBleGVjdXRpb24sIGJ1dCBpdCBkb2VzIHRlbmQgdG8gbWFrZSBzZW5zZSB3aGVuXG4gKiBkZWFsaW5nIHdpdGggXCJkaXJlY3RcIiBkaXNwYXRjaGVzLlxuICpcbiAqIEByZXR1cm4geyp9IFRoZSByZXR1cm4gdmFsdWUgb2YgZXhlY3V0aW5nIHRoZSBzaW5nbGUgZGlzcGF0Y2guXG4gKi9cblxuXG4vKipcbiAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmZiBudW1iZXIgb2YgZGlzcGF0Y2hlcyBhY2N1bXVsYXRlZCBpcyBncmVhdGVyIHRoYW4gMC5cbiAqL1xuXG4vKipcbiAqIEFjY3VtdWxhdGVzIGl0ZW1zIHRoYXQgbXVzdCBub3QgYmUgbnVsbCBvciB1bmRlZmluZWQgaW50byB0aGUgZmlyc3Qgb25lLiBUaGlzXG4gKiBpcyB1c2VkIHRvIGNvbnNlcnZlIG1lbW9yeSBieSBhdm9pZGluZyBhcnJheSBhbGxvY2F0aW9ucywgYW5kIHRodXMgc2FjcmlmaWNlc1xuICogQVBJIGNsZWFubmVzcy4gU2luY2UgYGN1cnJlbnRgIGNhbiBiZSBudWxsIGJlZm9yZSBiZWluZyBwYXNzZWQgaW4gYW5kIG5vdFxuICogbnVsbCBhZnRlciB0aGlzIGZ1bmN0aW9uLCBtYWtlIHN1cmUgdG8gYXNzaWduIGl0IGJhY2sgdG8gYGN1cnJlbnRgOlxuICpcbiAqIGBhID0gYWNjdW11bGF0ZUludG8oYSwgYik7YFxuICpcbiAqIFRoaXMgQVBJIHNob3VsZCBiZSBzcGFyaW5nbHkgdXNlZC4gVHJ5IGBhY2N1bXVsYXRlYCBmb3Igc29tZXRoaW5nIGNsZWFuZXIuXG4gKlxuICogQHJldHVybiB7KnxhcnJheTwqPn0gQW4gYWNjdW11bGF0aW9uIG9mIGl0ZW1zLlxuICovXG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVJbnRvKGN1cnJlbnQsIG5leHQpIHtcbiAgIShuZXh0ICE9IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnYWNjdW11bGF0ZUludG8oLi4uKTogQWNjdW11bGF0ZWQgaXRlbXMgbXVzdCBub3QgYmUgbnVsbCBvciB1bmRlZmluZWQuJykgOiB2b2lkIDA7XG5cbiAgaWYgKGN1cnJlbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiBuZXh0O1xuICB9XG5cbiAgLy8gQm90aCBhcmUgbm90IGVtcHR5LiBXYXJuaW5nOiBOZXZlciBjYWxsIHguY29uY2F0KHkpIHdoZW4geW91IGFyZSBub3RcbiAgLy8gY2VydGFpbiB0aGF0IHggaXMgYW4gQXJyYXkgKHggY291bGQgYmUgYSBzdHJpbmcgd2l0aCBjb25jYXQgbWV0aG9kKS5cbiAgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudCkpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShuZXh0KSkge1xuICAgICAgY3VycmVudC5wdXNoLmFwcGx5KGN1cnJlbnQsIG5leHQpO1xuICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgfVxuICAgIGN1cnJlbnQucHVzaChuZXh0KTtcbiAgICByZXR1cm4gY3VycmVudDtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KG5leHQpKSB7XG4gICAgLy8gQSBiaXQgdG9vIGRhbmdlcm91cyB0byBtdXRhdGUgYG5leHRgLlxuICAgIHJldHVybiBbY3VycmVudF0uY29uY2F0KG5leHQpO1xuICB9XG5cbiAgcmV0dXJuIFtjdXJyZW50LCBuZXh0XTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FycmF5fSBhcnIgYW4gXCJhY2N1bXVsYXRpb25cIiBvZiBpdGVtcyB3aGljaCBpcyBlaXRoZXIgYW4gQXJyYXkgb3JcbiAqIGEgc2luZ2xlIGl0ZW0uIFVzZWZ1bCB3aGVuIHBhaXJlZCB3aXRoIHRoZSBgYWNjdW11bGF0ZWAgbW9kdWxlLiBUaGlzIGlzIGFcbiAqIHNpbXBsZSB1dGlsaXR5IHRoYXQgYWxsb3dzIHVzIHRvIHJlYXNvbiBhYm91dCBhIGNvbGxlY3Rpb24gb2YgaXRlbXMsIGJ1dFxuICogaGFuZGxpbmcgdGhlIGNhc2Ugd2hlbiB0aGVyZSBpcyBleGFjdGx5IG9uZSBpdGVtIChhbmQgd2UgZG8gbm90IG5lZWQgdG9cbiAqIGFsbG9jYXRlIGFuIGFycmF5KS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNiIENhbGxiYWNrIGludm9rZWQgd2l0aCBlYWNoIGVsZW1lbnQgb3IgYSBjb2xsZWN0aW9uLlxuICogQHBhcmFtIHs/fSBbc2NvcGVdIFNjb3BlIHVzZWQgYXMgYHRoaXNgIGluIGEgY2FsbGJhY2suXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2hBY2N1bXVsYXRlZChhcnIsIGNiLCBzY29wZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgYXJyLmZvckVhY2goY2IsIHNjb3BlKTtcbiAgfSBlbHNlIGlmIChhcnIpIHtcbiAgICBjYi5jYWxsKHNjb3BlLCBhcnIpO1xuICB9XG59XG5cbi8qKlxuICogSW50ZXJuYWwgcXVldWUgb2YgZXZlbnRzIHRoYXQgaGF2ZSBhY2N1bXVsYXRlZCB0aGVpciBkaXNwYXRjaGVzIGFuZCBhcmVcbiAqIHdhaXRpbmcgdG8gaGF2ZSB0aGVpciBkaXNwYXRjaGVzIGV4ZWN1dGVkLlxuICovXG52YXIgZXZlbnRRdWV1ZSA9IG51bGw7XG5cbi8qKlxuICogRGlzcGF0Y2hlcyBhbiBldmVudCBhbmQgcmVsZWFzZXMgaXQgYmFjayBpbnRvIHRoZSBwb29sLCB1bmxlc3MgcGVyc2lzdGVudC5cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IGV2ZW50IFN5bnRoZXRpYyBldmVudCB0byBiZSBkaXNwYXRjaGVkLlxuICogQHBhcmFtIHtib29sZWFufSBzaW11bGF0ZWQgSWYgdGhlIGV2ZW50IGlzIHNpbXVsYXRlZCAoY2hhbmdlcyBleG4gYmVoYXZpb3IpXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlID0gZnVuY3Rpb24gKGV2ZW50LCBzaW11bGF0ZWQpIHtcbiAgaWYgKGV2ZW50KSB7XG4gICAgZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyKGV2ZW50LCBzaW11bGF0ZWQpO1xuXG4gICAgaWYgKCFldmVudC5pc1BlcnNpc3RlbnQoKSkge1xuICAgICAgZXZlbnQuY29uc3RydWN0b3IucmVsZWFzZShldmVudCk7XG4gICAgfVxuICB9XG59O1xudmFyIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVNpbXVsYXRlZCA9IGZ1bmN0aW9uIChlKSB7XG4gIHJldHVybiBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2UoZSwgdHJ1ZSk7XG59O1xudmFyIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVRvcExldmVsID0gZnVuY3Rpb24gKGUpIHtcbiAgcmV0dXJuIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZShlLCBmYWxzZSk7XG59O1xuXG5mdW5jdGlvbiBpc0ludGVyYWN0aXZlKHRhZykge1xuICByZXR1cm4gdGFnID09PSAnYnV0dG9uJyB8fCB0YWcgPT09ICdpbnB1dCcgfHwgdGFnID09PSAnc2VsZWN0JyB8fCB0YWcgPT09ICd0ZXh0YXJlYSc7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFByZXZlbnRNb3VzZUV2ZW50KG5hbWUsIHR5cGUsIHByb3BzKSB7XG4gIHN3aXRjaCAobmFtZSkge1xuICAgIGNhc2UgJ29uQ2xpY2snOlxuICAgIGNhc2UgJ29uQ2xpY2tDYXB0dXJlJzpcbiAgICBjYXNlICdvbkRvdWJsZUNsaWNrJzpcbiAgICBjYXNlICdvbkRvdWJsZUNsaWNrQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Nb3VzZURvd24nOlxuICAgIGNhc2UgJ29uTW91c2VEb3duQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Nb3VzZU1vdmUnOlxuICAgIGNhc2UgJ29uTW91c2VNb3ZlQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Nb3VzZVVwJzpcbiAgICBjYXNlICdvbk1vdXNlVXBDYXB0dXJlJzpcbiAgICAgIHJldHVybiAhIShwcm9wcy5kaXNhYmxlZCAmJiBpc0ludGVyYWN0aXZlKHR5cGUpKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBpcyBhIHVuaWZpZWQgaW50ZXJmYWNlIGZvciBldmVudCBwbHVnaW5zIHRvIGJlIGluc3RhbGxlZCBhbmQgY29uZmlndXJlZC5cbiAqXG4gKiBFdmVudCBwbHVnaW5zIGNhbiBpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgYGV4dHJhY3RFdmVudHNgIHtmdW5jdGlvbihzdHJpbmcsIERPTUV2ZW50VGFyZ2V0LCBzdHJpbmcsIG9iamVjdCk6ICp9XG4gKiAgICAgUmVxdWlyZWQuIFdoZW4gYSB0b3AtbGV2ZWwgZXZlbnQgaXMgZmlyZWQsIHRoaXMgbWV0aG9kIGlzIGV4cGVjdGVkIHRvXG4gKiAgICAgZXh0cmFjdCBzeW50aGV0aWMgZXZlbnRzIHRoYXQgd2lsbCBpbiB0dXJuIGJlIHF1ZXVlZCBhbmQgZGlzcGF0Y2hlZC5cbiAqXG4gKiAgIGBldmVudFR5cGVzYCB7b2JqZWN0fVxuICogICAgIE9wdGlvbmFsLCBwbHVnaW5zIHRoYXQgZmlyZSBldmVudHMgbXVzdCBwdWJsaXNoIGEgbWFwcGluZyBvZiByZWdpc3RyYXRpb25cbiAqICAgICBuYW1lcyB0aGF0IGFyZSB1c2VkIHRvIHJlZ2lzdGVyIGxpc3RlbmVycy4gVmFsdWVzIG9mIHRoaXMgbWFwcGluZyBtdXN0XG4gKiAgICAgYmUgb2JqZWN0cyB0aGF0IGNvbnRhaW4gYHJlZ2lzdHJhdGlvbk5hbWVgIG9yIGBwaGFzZWRSZWdpc3RyYXRpb25OYW1lc2AuXG4gKlxuICogICBgZXhlY3V0ZURpc3BhdGNoYCB7ZnVuY3Rpb24ob2JqZWN0LCBmdW5jdGlvbiwgc3RyaW5nKX1cbiAqICAgICBPcHRpb25hbCwgYWxsb3dzIHBsdWdpbnMgdG8gb3ZlcnJpZGUgaG93IGFuIGV2ZW50IGdldHMgZGlzcGF0Y2hlZC4gQnlcbiAqICAgICBkZWZhdWx0LCB0aGUgbGlzdGVuZXIgaXMgc2ltcGx5IGludm9rZWQuXG4gKlxuICogRWFjaCBwbHVnaW4gdGhhdCBpcyBpbmplY3RlZCBpbnRvIGBFdmVudHNQbHVnaW5IdWJgIGlzIGltbWVkaWF0ZWx5IG9wZXJhYmxlLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIE1ldGhvZHMgZm9yIGluamVjdGluZyBkZXBlbmRlbmNpZXMuXG4gKi9cbnZhciBpbmplY3Rpb24kMSA9IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7YXJyYXl9IEluamVjdGVkRXZlbnRQbHVnaW5PcmRlclxuICAgKiBAcHVibGljXG4gICAqL1xuICBpbmplY3RFdmVudFBsdWdpbk9yZGVyOiBpbmplY3RFdmVudFBsdWdpbk9yZGVyLFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5qZWN0ZWROYW1lc1RvUGx1Z2lucyBNYXAgZnJvbSBuYW1lcyB0byBwbHVnaW4gbW9kdWxlcy5cbiAgICovXG4gIGluamVjdEV2ZW50UGx1Z2luc0J5TmFtZTogaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBpbnN0IFRoZSBpbnN0YW5jZSwgd2hpY2ggaXMgdGhlIHNvdXJjZSBvZiBldmVudHMuXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXG4gKiBAcmV0dXJuIHs/ZnVuY3Rpb259IFRoZSBzdG9yZWQgY2FsbGJhY2suXG4gKi9cbmZ1bmN0aW9uIGdldExpc3RlbmVyKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgdmFyIGxpc3RlbmVyO1xuXG4gIC8vIFRPRE86IHNob3VsZFByZXZlbnRNb3VzZUV2ZW50IGlzIERPTS1zcGVjaWZpYyBhbmQgZGVmaW5pdGVseSBzaG91bGQgbm90XG4gIC8vIGxpdmUgaGVyZTsgbmVlZHMgdG8gYmUgbW92ZWQgdG8gYSBiZXR0ZXIgcGxhY2Ugc29vblxuICB2YXIgc3RhdGVOb2RlID0gaW5zdC5zdGF0ZU5vZGU7XG4gIGlmICghc3RhdGVOb2RlKSB7XG4gICAgLy8gV29yayBpbiBwcm9ncmVzcyAoZXg6IG9ubG9hZCBldmVudHMgaW4gaW5jcmVtZW50YWwgbW9kZSkuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIHByb3BzID0gZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZShzdGF0ZU5vZGUpO1xuICBpZiAoIXByb3BzKSB7XG4gICAgLy8gV29yayBpbiBwcm9ncmVzcy5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBsaXN0ZW5lciA9IHByb3BzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuICBpZiAoc2hvdWxkUHJldmVudE1vdXNlRXZlbnQocmVnaXN0cmF0aW9uTmFtZSwgaW5zdC50eXBlLCBwcm9wcykpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAhKCFsaXN0ZW5lciB8fCB0eXBlb2YgbGlzdGVuZXIgPT09ICdmdW5jdGlvbicpID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgYCVzYCBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLCBpbnN0ZWFkIGdvdCBhIHZhbHVlIG9mIGAlc2AgdHlwZS4nLCByZWdpc3RyYXRpb25OYW1lLCB0eXBlb2YgbGlzdGVuZXIpIDogdm9pZCAwO1xuICByZXR1cm4gbGlzdGVuZXI7XG59XG5cbi8qKlxuICogQWxsb3dzIHJlZ2lzdGVyZWQgcGx1Z2lucyBhbiBvcHBvcnR1bml0eSB0byBleHRyYWN0IGV2ZW50cyBmcm9tIHRvcC1sZXZlbFxuICogbmF0aXZlIGJyb3dzZXIgZXZlbnRzLlxuICpcbiAqIEByZXR1cm4geyp9IEFuIGFjY3VtdWxhdGlvbiBvZiBzeW50aGV0aWMgZXZlbnRzLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RFdmVudHModG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgdmFyIGV2ZW50cztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gTm90IGV2ZXJ5IHBsdWdpbiBpbiB0aGUgb3JkZXJpbmcgbWF5IGJlIGxvYWRlZCBhdCBydW50aW1lLlxuICAgIHZhciBwb3NzaWJsZVBsdWdpbiA9IHBsdWdpbnNbaV07XG4gICAgaWYgKHBvc3NpYmxlUGx1Z2luKSB7XG4gICAgICB2YXIgZXh0cmFjdGVkRXZlbnRzID0gcG9zc2libGVQbHVnaW4uZXh0cmFjdEV2ZW50cyh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgICBpZiAoZXh0cmFjdGVkRXZlbnRzKSB7XG4gICAgICAgIGV2ZW50cyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50cywgZXh0cmFjdGVkRXZlbnRzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGV2ZW50cztcbn1cblxuLyoqXG4gKiBFbnF1ZXVlcyBhIHN5bnRoZXRpYyBldmVudCB0aGF0IHNob3VsZCBiZSBkaXNwYXRjaGVkIHdoZW5cbiAqIGBwcm9jZXNzRXZlbnRRdWV1ZWAgaXMgaW52b2tlZC5cbiAqXG4gKiBAcGFyYW0geyp9IGV2ZW50cyBBbiBhY2N1bXVsYXRpb24gb2Ygc3ludGhldGljIGV2ZW50cy5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBlbnF1ZXVlRXZlbnRzKGV2ZW50cykge1xuICBpZiAoZXZlbnRzKSB7XG4gICAgZXZlbnRRdWV1ZSA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50UXVldWUsIGV2ZW50cyk7XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNwYXRjaGVzIGFsbCBzeW50aGV0aWMgZXZlbnRzIG9uIHRoZSBldmVudCBxdWV1ZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gcHJvY2Vzc0V2ZW50UXVldWUoc2ltdWxhdGVkKSB7XG4gIC8vIFNldCBgZXZlbnRRdWV1ZWAgdG8gbnVsbCBiZWZvcmUgcHJvY2Vzc2luZyBpdCBzbyB0aGF0IHdlIGNhbiB0ZWxsIGlmIG1vcmVcbiAgLy8gZXZlbnRzIGdldCBlbnF1ZXVlZCB3aGlsZSBwcm9jZXNzaW5nLlxuICB2YXIgcHJvY2Vzc2luZ0V2ZW50UXVldWUgPSBldmVudFF1ZXVlO1xuICBldmVudFF1ZXVlID0gbnVsbDtcblxuICBpZiAoIXByb2Nlc3NpbmdFdmVudFF1ZXVlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHNpbXVsYXRlZCkge1xuICAgIGZvckVhY2hBY2N1bXVsYXRlZChwcm9jZXNzaW5nRXZlbnRRdWV1ZSwgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlU2ltdWxhdGVkKTtcbiAgfSBlbHNlIHtcbiAgICBmb3JFYWNoQWNjdW11bGF0ZWQocHJvY2Vzc2luZ0V2ZW50UXVldWUsIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVRvcExldmVsKTtcbiAgfVxuICAhIWV2ZW50UXVldWUgPyBpbnZhcmlhbnQoZmFsc2UsICdwcm9jZXNzRXZlbnRRdWV1ZSgpOiBBZGRpdGlvbmFsIGV2ZW50cyB3ZXJlIGVucXVldWVkIHdoaWxlIHByb2Nlc3NpbmcgYW4gZXZlbnQgcXVldWUuIFN1cHBvcnQgZm9yIHRoaXMgaGFzIG5vdCB5ZXQgYmVlbiBpbXBsZW1lbnRlZC4nKSA6IHZvaWQgMDtcbiAgLy8gVGhpcyB3b3VsZCBiZSBhIGdvb2QgdGltZSB0byByZXRocm93IGlmIGFueSBvZiB0aGUgZXZlbnQgaGFuZGxlcnMgdGhyZXcuXG4gIFJlYWN0RXJyb3JVdGlscy5yZXRocm93Q2F1Z2h0RXJyb3IoKTtcbn1cblxudmFyIEV2ZW50UGx1Z2luSHViID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGluamVjdGlvbjogaW5qZWN0aW9uJDEsXG5cdGdldExpc3RlbmVyOiBnZXRMaXN0ZW5lcixcblx0ZXh0cmFjdEV2ZW50czogZXh0cmFjdEV2ZW50cyxcblx0ZW5xdWV1ZUV2ZW50czogZW5xdWV1ZUV2ZW50cyxcblx0cHJvY2Vzc0V2ZW50UXVldWU6IHByb2Nlc3NFdmVudFF1ZXVlXG59KTtcblxudmFyIEluZGV0ZXJtaW5hdGVDb21wb25lbnQgPSAwOyAvLyBCZWZvcmUgd2Uga25vdyB3aGV0aGVyIGl0IGlzIGZ1bmN0aW9uYWwgb3IgY2xhc3NcbnZhciBGdW5jdGlvbmFsQ29tcG9uZW50ID0gMTtcbnZhciBDbGFzc0NvbXBvbmVudCA9IDI7XG52YXIgSG9zdFJvb3QgPSAzOyAvLyBSb290IG9mIGEgaG9zdCB0cmVlLiBDb3VsZCBiZSBuZXN0ZWQgaW5zaWRlIGFub3RoZXIgbm9kZS5cbnZhciBIb3N0UG9ydGFsID0gNDsgLy8gQSBzdWJ0cmVlLiBDb3VsZCBiZSBhbiBlbnRyeSBwb2ludCB0byBhIGRpZmZlcmVudCByZW5kZXJlci5cbnZhciBIb3N0Q29tcG9uZW50ID0gNTtcbnZhciBIb3N0VGV4dCA9IDY7XG52YXIgQ2FsbENvbXBvbmVudCA9IDc7XG52YXIgQ2FsbEhhbmRsZXJQaGFzZSA9IDg7XG52YXIgUmV0dXJuQ29tcG9uZW50ID0gOTtcbnZhciBGcmFnbWVudCA9IDEwO1xuXG52YXIgcmFuZG9tS2V5ID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7XG52YXIgaW50ZXJuYWxJbnN0YW5jZUtleSA9ICdfX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSQnICsgcmFuZG9tS2V5O1xudmFyIGludGVybmFsRXZlbnRIYW5kbGVyc0tleSA9ICdfX3JlYWN0RXZlbnRIYW5kbGVycyQnICsgcmFuZG9tS2V5O1xuXG5mdW5jdGlvbiBwcmVjYWNoZUZpYmVyTm9kZSQxKGhvc3RJbnN0LCBub2RlKSB7XG4gIG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV0gPSBob3N0SW5zdDtcbn1cblxuLyoqXG4gKiBHaXZlbiBhIERPTSBub2RlLCByZXR1cm4gdGhlIGNsb3Nlc3QgUmVhY3RET01Db21wb25lbnQgb3JcbiAqIFJlYWN0RE9NVGV4dENvbXBvbmVudCBpbnN0YW5jZSBhbmNlc3Rvci5cbiAqL1xuZnVuY3Rpb24gZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUobm9kZSkge1xuICBpZiAobm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XSkge1xuICAgIHJldHVybiBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldO1xuICB9XG5cbiAgLy8gV2FsayB1cCB0aGUgdHJlZSB1bnRpbCB3ZSBmaW5kIGFuIGFuY2VzdG9yIHdob3NlIGluc3RhbmNlIHdlIGhhdmUgY2FjaGVkLlxuICB2YXIgcGFyZW50cyA9IFtdO1xuICB3aGlsZSAoIW5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV0pIHtcbiAgICBwYXJlbnRzLnB1c2gobm9kZSk7XG4gICAgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVG9wIG9mIHRoZSB0cmVlLiBUaGlzIG5vZGUgbXVzdCBub3QgYmUgcGFydCBvZiBhIFJlYWN0IHRyZWUgKG9yIGlzXG4gICAgICAvLyB1bm1vdW50ZWQsIHBvdGVudGlhbGx5KS5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjbG9zZXN0ID0gdm9pZCAwO1xuICB2YXIgaW5zdCA9IG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV07XG4gIGlmIChpbnN0LnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBpbnN0LnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAvLyBJbiBGaWJlciwgdGhpcyB3aWxsIGFsd2F5cyBiZSB0aGUgZGVlcGVzdCByb290LlxuICAgIHJldHVybiBpbnN0O1xuICB9XG4gIGZvciAoOyBub2RlICYmIChpbnN0ID0gbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XSk7IG5vZGUgPSBwYXJlbnRzLnBvcCgpKSB7XG4gICAgY2xvc2VzdCA9IGluc3Q7XG4gIH1cblxuICByZXR1cm4gY2xvc2VzdDtcbn1cblxuLyoqXG4gKiBHaXZlbiBhIERPTSBub2RlLCByZXR1cm4gdGhlIFJlYWN0RE9NQ29tcG9uZW50IG9yIFJlYWN0RE9NVGV4dENvbXBvbmVudFxuICogaW5zdGFuY2UsIG9yIG51bGwgaWYgdGhlIG5vZGUgd2FzIG5vdCByZW5kZXJlZCBieSB0aGlzIFJlYWN0LlxuICovXG5mdW5jdGlvbiBnZXRJbnN0YW5jZUZyb21Ob2RlJDEobm9kZSkge1xuICB2YXIgaW5zdCA9IG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV07XG4gIGlmIChpbnN0KSB7XG4gICAgaWYgKGluc3QudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IGluc3QudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgcmV0dXJuIGluc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBHaXZlbiBhIFJlYWN0RE9NQ29tcG9uZW50IG9yIFJlYWN0RE9NVGV4dENvbXBvbmVudCwgcmV0dXJuIHRoZSBjb3JyZXNwb25kaW5nXG4gKiBET00gbm9kZS5cbiAqL1xuZnVuY3Rpb24gZ2V0Tm9kZUZyb21JbnN0YW5jZSQxKGluc3QpIHtcbiAgaWYgKGluc3QudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IGluc3QudGFnID09PSBIb3N0VGV4dCkge1xuICAgIC8vIEluIEZpYmVyIHRoaXMsIGlzIGp1c3QgdGhlIHN0YXRlIG5vZGUgcmlnaHQgbm93LiBXZSBhc3N1bWUgaXQgd2lsbCBiZVxuICAgIC8vIGEgaG9zdCBjb21wb25lbnQgb3IgaG9zdCB0ZXh0LlxuICAgIHJldHVybiBpbnN0LnN0YXRlTm9kZTtcbiAgfVxuXG4gIC8vIFdpdGhvdXQgdGhpcyBmaXJzdCBpbnZhcmlhbnQsIHBhc3NpbmcgYSBub24tRE9NLWNvbXBvbmVudCB0cmlnZ2VycyB0aGUgbmV4dFxuICAvLyBpbnZhcmlhbnQgZm9yIGEgbWlzc2luZyBwYXJlbnQsIHdoaWNoIGlzIHN1cGVyIGNvbmZ1c2luZy5cbiAgaW52YXJpYW50KGZhbHNlLCAnZ2V0Tm9kZUZyb21JbnN0YW5jZTogSW52YWxpZCBhcmd1bWVudC4nKTtcbn1cblxuZnVuY3Rpb24gZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZSQxKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGVbaW50ZXJuYWxFdmVudEhhbmRsZXJzS2V5XSB8fCBudWxsO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVGaWJlclByb3BzJDEobm9kZSwgcHJvcHMpIHtcbiAgbm9kZVtpbnRlcm5hbEV2ZW50SGFuZGxlcnNLZXldID0gcHJvcHM7XG59XG5cbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSBPYmplY3QuZnJlZXplKHtcblx0cHJlY2FjaGVGaWJlck5vZGU6IHByZWNhY2hlRmliZXJOb2RlJDEsXG5cdGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlOiBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZSxcblx0Z2V0SW5zdGFuY2VGcm9tTm9kZTogZ2V0SW5zdGFuY2VGcm9tTm9kZSQxLFxuXHRnZXROb2RlRnJvbUluc3RhbmNlOiBnZXROb2RlRnJvbUluc3RhbmNlJDEsXG5cdGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGU6IGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUkMSxcblx0dXBkYXRlRmliZXJQcm9wczogdXBkYXRlRmliZXJQcm9wcyQxXG59KTtcblxuZnVuY3Rpb24gZ2V0UGFyZW50KGluc3QpIHtcbiAgZG8ge1xuICAgIGluc3QgPSBpbnN0WydyZXR1cm4nXTtcbiAgICAvLyBUT0RPOiBJZiB0aGlzIGlzIGEgSG9zdFJvb3Qgd2UgbWlnaHQgd2FudCB0byBiYWlsIG91dC5cbiAgICAvLyBUaGF0IGlzIGRlcGVuZGluZyBvbiBpZiB3ZSB3YW50IG5lc3RlZCBzdWJ0cmVlcyAobGF5ZXJzKSB0byBidWJibGVcbiAgICAvLyBldmVudHMgdG8gdGhlaXIgcGFyZW50LiBXZSBjb3VsZCBhbHNvIGdvIHRocm91Z2ggcGFyZW50Tm9kZSBvbiB0aGVcbiAgICAvLyBob3N0IG5vZGUgYnV0IHRoYXQgd291bGRuJ3Qgd29yayBmb3IgUmVhY3QgTmF0aXZlIGFuZCBkb2Vzbid0IGxldCB1c1xuICAgIC8vIGRvIHRoZSBwb3J0YWwgZmVhdHVyZS5cbiAgfSB3aGlsZSAoaW5zdCAmJiBpbnN0LnRhZyAhPT0gSG9zdENvbXBvbmVudCk7XG4gIGlmIChpbnN0KSB7XG4gICAgcmV0dXJuIGluc3Q7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBsb3dlc3QgY29tbW9uIGFuY2VzdG9yIG9mIEEgYW5kIEIsIG9yIG51bGwgaWYgdGhleSBhcmUgaW5cbiAqIGRpZmZlcmVudCB0cmVlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IoaW5zdEEsIGluc3RCKSB7XG4gIHZhciBkZXB0aEEgPSAwO1xuICBmb3IgKHZhciB0ZW1wQSA9IGluc3RBOyB0ZW1wQTsgdGVtcEEgPSBnZXRQYXJlbnQodGVtcEEpKSB7XG4gICAgZGVwdGhBKys7XG4gIH1cbiAgdmFyIGRlcHRoQiA9IDA7XG4gIGZvciAodmFyIHRlbXBCID0gaW5zdEI7IHRlbXBCOyB0ZW1wQiA9IGdldFBhcmVudCh0ZW1wQikpIHtcbiAgICBkZXB0aEIrKztcbiAgfVxuXG4gIC8vIElmIEEgaXMgZGVlcGVyLCBjcmF3bCB1cC5cbiAgd2hpbGUgKGRlcHRoQSAtIGRlcHRoQiA+IDApIHtcbiAgICBpbnN0QSA9IGdldFBhcmVudChpbnN0QSk7XG4gICAgZGVwdGhBLS07XG4gIH1cblxuICAvLyBJZiBCIGlzIGRlZXBlciwgY3Jhd2wgdXAuXG4gIHdoaWxlIChkZXB0aEIgLSBkZXB0aEEgPiAwKSB7XG4gICAgaW5zdEIgPSBnZXRQYXJlbnQoaW5zdEIpO1xuICAgIGRlcHRoQi0tO1xuICB9XG5cbiAgLy8gV2FsayBpbiBsb2Nrc3RlcCB1bnRpbCB3ZSBmaW5kIGEgbWF0Y2guXG4gIHZhciBkZXB0aCA9IGRlcHRoQTtcbiAgd2hpbGUgKGRlcHRoLS0pIHtcbiAgICBpZiAoaW5zdEEgPT09IGluc3RCIHx8IGluc3RBID09PSBpbnN0Qi5hbHRlcm5hdGUpIHtcbiAgICAgIHJldHVybiBpbnN0QTtcbiAgICB9XG4gICAgaW5zdEEgPSBnZXRQYXJlbnQoaW5zdEEpO1xuICAgIGluc3RCID0gZ2V0UGFyZW50KGluc3RCKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gaWYgQSBpcyBhbiBhbmNlc3RvciBvZiBCLlxuICovXG5cblxuLyoqXG4gKiBSZXR1cm4gdGhlIHBhcmVudCBpbnN0YW5jZSBvZiB0aGUgcGFzc2VkLWluIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBnZXRQYXJlbnRJbnN0YW5jZShpbnN0KSB7XG4gIHJldHVybiBnZXRQYXJlbnQoaW5zdCk7XG59XG5cbi8qKlxuICogU2ltdWxhdGVzIHRoZSB0cmF2ZXJzYWwgb2YgYSB0d28tcGhhc2UsIGNhcHR1cmUvYnViYmxlIGV2ZW50IGRpc3BhdGNoLlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZVR3b1BoYXNlKGluc3QsIGZuLCBhcmcpIHtcbiAgdmFyIHBhdGggPSBbXTtcbiAgd2hpbGUgKGluc3QpIHtcbiAgICBwYXRoLnB1c2goaW5zdCk7XG4gICAgaW5zdCA9IGdldFBhcmVudChpbnN0KTtcbiAgfVxuICB2YXIgaTtcbiAgZm9yIChpID0gcGF0aC5sZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgZm4ocGF0aFtpXSwgJ2NhcHR1cmVkJywgYXJnKTtcbiAgfVxuICBmb3IgKGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgIGZuKHBhdGhbaV0sICdidWJibGVkJywgYXJnKTtcbiAgfVxufVxuXG4vKipcbiAqIFRyYXZlcnNlcyB0aGUgSUQgaGllcmFyY2h5IGFuZCBpbnZva2VzIHRoZSBzdXBwbGllZCBgY2JgIG9uIGFueSBJRHMgdGhhdFxuICogc2hvdWxkIHdvdWxkIHJlY2VpdmUgYSBgbW91c2VFbnRlcmAgb3IgYG1vdXNlTGVhdmVgIGV2ZW50LlxuICpcbiAqIERvZXMgbm90IGludm9rZSB0aGUgY2FsbGJhY2sgb24gdGhlIG5lYXJlc3QgY29tbW9uIGFuY2VzdG9yIGJlY2F1c2Ugbm90aGluZ1xuICogXCJlbnRlcmVkXCIgb3IgXCJsZWZ0XCIgdGhhdCBlbGVtZW50LlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZUVudGVyTGVhdmUoZnJvbSwgdG8sIGZuLCBhcmdGcm9tLCBhcmdUbykge1xuICB2YXIgY29tbW9uID0gZnJvbSAmJiB0byA/IGdldExvd2VzdENvbW1vbkFuY2VzdG9yKGZyb20sIHRvKSA6IG51bGw7XG4gIHZhciBwYXRoRnJvbSA9IFtdO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmICghZnJvbSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChmcm9tID09PSBjb21tb24pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB2YXIgYWx0ZXJuYXRlID0gZnJvbS5hbHRlcm5hdGU7XG4gICAgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCAmJiBhbHRlcm5hdGUgPT09IGNvbW1vbikge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHBhdGhGcm9tLnB1c2goZnJvbSk7XG4gICAgZnJvbSA9IGdldFBhcmVudChmcm9tKTtcbiAgfVxuICB2YXIgcGF0aFRvID0gW107XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKCF0bykge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmICh0byA9PT0gY29tbW9uKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgdmFyIF9hbHRlcm5hdGUgPSB0by5hbHRlcm5hdGU7XG4gICAgaWYgKF9hbHRlcm5hdGUgIT09IG51bGwgJiYgX2FsdGVybmF0ZSA9PT0gY29tbW9uKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcGF0aFRvLnB1c2godG8pO1xuICAgIHRvID0gZ2V0UGFyZW50KHRvKTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGhGcm9tLmxlbmd0aDsgaSsrKSB7XG4gICAgZm4ocGF0aEZyb21baV0sICdidWJibGVkJywgYXJnRnJvbSk7XG4gIH1cbiAgZm9yICh2YXIgX2kgPSBwYXRoVG8ubGVuZ3RoOyBfaS0tID4gMDspIHtcbiAgICBmbihwYXRoVG9bX2ldLCAnY2FwdHVyZWQnLCBhcmdUbyk7XG4gIH1cbn1cblxuLyoqXG4gKiBTb21lIGV2ZW50IHR5cGVzIGhhdmUgYSBub3Rpb24gb2YgZGlmZmVyZW50IHJlZ2lzdHJhdGlvbiBuYW1lcyBmb3IgZGlmZmVyZW50XG4gKiBcInBoYXNlc1wiIG9mIHByb3BhZ2F0aW9uLiBUaGlzIGZpbmRzIGxpc3RlbmVycyBieSBhIGdpdmVuIHBoYXNlLlxuICovXG5mdW5jdGlvbiBsaXN0ZW5lckF0UGhhc2UoaW5zdCwgZXZlbnQsIHByb3BhZ2F0aW9uUGhhc2UpIHtcbiAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBldmVudC5kaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lc1twcm9wYWdhdGlvblBoYXNlXTtcbiAgcmV0dXJuIGdldExpc3RlbmVyKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpO1xufVxuXG4vKipcbiAqIEEgc21hbGwgc2V0IG9mIHByb3BhZ2F0aW9uIHBhdHRlcm5zLCBlYWNoIG9mIHdoaWNoIHdpbGwgYWNjZXB0IGEgc21hbGwgYW1vdW50XG4gKiBvZiBpbmZvcm1hdGlvbiwgYW5kIGdlbmVyYXRlIGEgc2V0IG9mIFwiZGlzcGF0Y2ggcmVhZHkgZXZlbnQgb2JqZWN0c1wiIC0gd2hpY2hcbiAqIGFyZSBzZXRzIG9mIGV2ZW50cyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIGFubm90YXRlZCB3aXRoIGEgc2V0IG9mIGRpc3BhdGNoZWRcbiAqIGxpc3RlbmVyIGZ1bmN0aW9ucy9pZHMuIFRoZSBBUEkgaXMgZGVzaWduZWQgdGhpcyB3YXkgdG8gZGlzY291cmFnZSB0aGVzZVxuICogcHJvcGFnYXRpb24gc3RyYXRlZ2llcyBmcm9tIGFjdHVhbGx5IGV4ZWN1dGluZyB0aGUgZGlzcGF0Y2hlcywgc2luY2Ugd2VcbiAqIGFsd2F5cyB3YW50IHRvIGNvbGxlY3QgdGhlIGVudGlyZSBzZXQgb2YgZGlzcGF0Y2hlcyBiZWZvcmUgZXhlY3V0aW5nIGV2ZW4gYVxuICogc2luZ2xlIG9uZS5cbiAqL1xuXG4vKipcbiAqIFRhZ3MgYSBgU3ludGhldGljRXZlbnRgIHdpdGggZGlzcGF0Y2hlZCBsaXN0ZW5lcnMuIENyZWF0aW5nIHRoaXMgZnVuY3Rpb25cbiAqIGhlcmUsIGFsbG93cyB1cyB0byBub3QgaGF2ZSB0byBiaW5kIG9yIGNyZWF0ZSBmdW5jdGlvbnMgZm9yIGVhY2ggZXZlbnQuXG4gKiBNdXRhdGluZyB0aGUgZXZlbnQncyBtZW1iZXJzIGFsbG93cyB1cyB0byBub3QgaGF2ZSB0byBjcmVhdGUgYSB3cmFwcGluZ1xuICogXCJkaXNwYXRjaFwiIG9iamVjdCB0aGF0IHBhaXJzIHRoZSBldmVudCB3aXRoIHRoZSBsaXN0ZW5lci5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZURpcmVjdGlvbmFsRGlzcGF0Y2hlcyhpbnN0LCBwaGFzZSwgZXZlbnQpIHtcbiAge1xuICAgIHdhcm5pbmcoaW5zdCwgJ0Rpc3BhdGNoaW5nIGluc3QgbXVzdCBub3QgYmUgbnVsbCcpO1xuICB9XG4gIHZhciBsaXN0ZW5lciA9IGxpc3RlbmVyQXRQaGFzZShpbnN0LCBldmVudCwgcGhhc2UpO1xuICBpZiAobGlzdGVuZXIpIHtcbiAgICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMsIGxpc3RlbmVyKTtcbiAgICBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMgPSBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMsIGluc3QpO1xuICB9XG59XG5cbi8qKlxuICogQ29sbGVjdCBkaXNwYXRjaGVzIChtdXN0IGJlIGVudGlyZWx5IGNvbGxlY3RlZCBiZWZvcmUgZGlzcGF0Y2hpbmcgLSBzZWUgdW5pdFxuICogdGVzdHMpLiBMYXppbHkgYWxsb2NhdGUgdGhlIGFycmF5IHRvIGNvbnNlcnZlIG1lbW9yeS4gIFdlIG11c3QgbG9vcCB0aHJvdWdoXG4gKiBlYWNoIGV2ZW50IGFuZCBwZXJmb3JtIHRoZSB0cmF2ZXJzYWwgZm9yIGVhY2ggb25lLiBXZSBjYW5ub3QgcGVyZm9ybSBhXG4gKiBzaW5nbGUgdHJhdmVyc2FsIGZvciB0aGUgZW50aXJlIGNvbGxlY3Rpb24gb2YgZXZlbnRzIGJlY2F1c2UgZWFjaCBldmVudCBtYXlcbiAqIGhhdmUgYSBkaWZmZXJlbnQgdGFyZ2V0LlxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlKGV2ZW50KSB7XG4gIGlmIChldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgIHRyYXZlcnNlVHdvUGhhc2UoZXZlbnQuX3RhcmdldEluc3QsIGFjY3VtdWxhdGVEaXJlY3Rpb25hbERpc3BhdGNoZXMsIGV2ZW50KTtcbiAgfVxufVxuXG4vKipcbiAqIFNhbWUgYXMgYGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGVgLCBidXQgc2tpcHMgb3ZlciB0aGUgdGFyZ2V0SUQuXG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGVTa2lwVGFyZ2V0KGV2ZW50KSB7XG4gIGlmIChldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgIHZhciB0YXJnZXRJbnN0ID0gZXZlbnQuX3RhcmdldEluc3Q7XG4gICAgdmFyIHBhcmVudEluc3QgPSB0YXJnZXRJbnN0ID8gZ2V0UGFyZW50SW5zdGFuY2UodGFyZ2V0SW5zdCkgOiBudWxsO1xuICAgIHRyYXZlcnNlVHdvUGhhc2UocGFyZW50SW5zdCwgYWNjdW11bGF0ZURpcmVjdGlvbmFsRGlzcGF0Y2hlcywgZXZlbnQpO1xuICB9XG59XG5cbi8qKlxuICogQWNjdW11bGF0ZXMgd2l0aG91dCByZWdhcmQgdG8gZGlyZWN0aW9uLCBkb2VzIG5vdCBsb29rIGZvciBwaGFzZWRcbiAqIHJlZ2lzdHJhdGlvbiBuYW1lcy4gU2FtZSBhcyBgYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXNTaW5nbGVgIGJ1dCB3aXRob3V0XG4gKiByZXF1aXJpbmcgdGhhdCB0aGUgYGRpc3BhdGNoTWFya2VyYCBiZSB0aGUgc2FtZSBhcyB0aGUgZGlzcGF0Y2hlZCBJRC5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZURpc3BhdGNoZXMoaW5zdCwgaWdub3JlZERpcmVjdGlvbiwgZXZlbnQpIHtcbiAgaWYgKGluc3QgJiYgZXZlbnQgJiYgZXZlbnQuZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIHZhciByZWdpc3RyYXRpb25OYW1lID0gZXZlbnQuZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZTtcbiAgICB2YXIgbGlzdGVuZXIgPSBnZXRMaXN0ZW5lcihpbnN0LCByZWdpc3RyYXRpb25OYW1lKTtcbiAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgIGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycywgbGlzdGVuZXIpO1xuICAgICAgZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzLCBpbnN0KTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBY2N1bXVsYXRlcyBkaXNwYXRjaGVzIG9uIGFuIGBTeW50aGV0aWNFdmVudGAsIGJ1dCBvbmx5IGZvciB0aGVcbiAqIGBkaXNwYXRjaE1hcmtlcmAuXG4gKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudFxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1NpbmdsZShldmVudCkge1xuICBpZiAoZXZlbnQgJiYgZXZlbnQuZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIGFjY3VtdWxhdGVEaXNwYXRjaGVzKGV2ZW50Ll90YXJnZXRJbnN0LCBudWxsLCBldmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudHMpIHtcbiAgZm9yRWFjaEFjY3VtdWxhdGVkKGV2ZW50cywgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZSk7XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTa2lwVGFyZ2V0KGV2ZW50cykge1xuICBmb3JFYWNoQWNjdW11bGF0ZWQoZXZlbnRzLCBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlU2tpcFRhcmdldCk7XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVFbnRlckxlYXZlRGlzcGF0Y2hlcyhsZWF2ZSwgZW50ZXIsIGZyb20sIHRvKSB7XG4gIHRyYXZlcnNlRW50ZXJMZWF2ZShmcm9tLCB0bywgYWNjdW11bGF0ZURpc3BhdGNoZXMsIGxlYXZlLCBlbnRlcik7XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzKGV2ZW50cykge1xuICBmb3JFYWNoQWNjdW11bGF0ZWQoZXZlbnRzLCBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1NpbmdsZSk7XG59XG5cbnZhciBFdmVudFByb3BhZ2F0b3JzID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXM6IGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMsXG5cdGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTa2lwVGFyZ2V0OiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2tpcFRhcmdldCxcblx0YWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzOiBhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXMsXG5cdGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzOiBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1xufSk7XG5cbnZhciBjb250ZW50S2V5ID0gbnVsbDtcblxuLyoqXG4gKiBHZXRzIHRoZSBrZXkgdXNlZCB0byBhY2Nlc3MgdGV4dCBjb250ZW50IG9uIGEgRE9NIG5vZGUuXG4gKlxuICogQHJldHVybiB7P3N0cmluZ30gS2V5IHVzZWQgdG8gYWNjZXNzIHRleHQgY29udGVudC5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBnZXRUZXh0Q29udGVudEFjY2Vzc29yKCkge1xuICBpZiAoIWNvbnRlbnRLZXkgJiYgRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gICAgLy8gUHJlZmVyIHRleHRDb250ZW50IHRvIGlubmVyVGV4dCBiZWNhdXNlIG1hbnkgYnJvd3NlcnMgc3VwcG9ydCBib3RoIGJ1dFxuICAgIC8vIFNWRyA8dGV4dD4gZWxlbWVudHMgZG9uJ3Qgc3VwcG9ydCBpbm5lclRleHQgZXZlbiB3aGVuIDxkaXY+IGRvZXMuXG4gICAgY29udGVudEtleSA9ICd0ZXh0Q29udGVudCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ID8gJ3RleHRDb250ZW50JyA6ICdpbm5lclRleHQnO1xuICB9XG4gIHJldHVybiBjb250ZW50S2V5O1xufVxuXG4vKipcbiAqIFRoaXMgaGVscGVyIG9iamVjdCBzdG9yZXMgaW5mb3JtYXRpb24gYWJvdXQgdGV4dCBjb250ZW50IG9mIGEgdGFyZ2V0IG5vZGUsXG4gKiBhbGxvd2luZyBjb21wYXJpc29uIG9mIGNvbnRlbnQgYmVmb3JlIGFuZCBhZnRlciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIElkZW50aWZ5IHRoZSBub2RlIHdoZXJlIHNlbGVjdGlvbiBjdXJyZW50bHkgYmVnaW5zLCB0aGVuIG9ic2VydmVcbiAqIGJvdGggaXRzIHRleHQgY29udGVudCBhbmQgaXRzIGN1cnJlbnQgcG9zaXRpb24gaW4gdGhlIERPTS4gU2luY2UgdGhlXG4gKiBicm93c2VyIG1heSBuYXRpdmVseSByZXBsYWNlIHRoZSB0YXJnZXQgbm9kZSBkdXJpbmcgY29tcG9zaXRpb24sIHdlIGNhblxuICogdXNlIGl0cyBwb3NpdGlvbiB0byBmaW5kIGl0cyByZXBsYWNlbWVudC5cbiAqXG4gKlxuICovXG52YXIgY29tcG9zaXRpb25TdGF0ZSA9IHtcbiAgX3Jvb3Q6IG51bGwsXG4gIF9zdGFydFRleHQ6IG51bGwsXG4gIF9mYWxsYmFja1RleHQ6IG51bGxcbn07XG5cbmZ1bmN0aW9uIGluaXRpYWxpemUobmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgY29tcG9zaXRpb25TdGF0ZS5fcm9vdCA9IG5hdGl2ZUV2ZW50VGFyZ2V0O1xuICBjb21wb3NpdGlvblN0YXRlLl9zdGFydFRleHQgPSBnZXRUZXh0KCk7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZXNldCgpIHtcbiAgY29tcG9zaXRpb25TdGF0ZS5fcm9vdCA9IG51bGw7XG4gIGNvbXBvc2l0aW9uU3RhdGUuX3N0YXJ0VGV4dCA9IG51bGw7XG4gIGNvbXBvc2l0aW9uU3RhdGUuX2ZhbGxiYWNrVGV4dCA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldERhdGEoKSB7XG4gIGlmIChjb21wb3NpdGlvblN0YXRlLl9mYWxsYmFja1RleHQpIHtcbiAgICByZXR1cm4gY29tcG9zaXRpb25TdGF0ZS5fZmFsbGJhY2tUZXh0O1xuICB9XG5cbiAgdmFyIHN0YXJ0O1xuICB2YXIgc3RhcnRWYWx1ZSA9IGNvbXBvc2l0aW9uU3RhdGUuX3N0YXJ0VGV4dDtcbiAgdmFyIHN0YXJ0TGVuZ3RoID0gc3RhcnRWYWx1ZS5sZW5ndGg7XG4gIHZhciBlbmQ7XG4gIHZhciBlbmRWYWx1ZSA9IGdldFRleHQoKTtcbiAgdmFyIGVuZExlbmd0aCA9IGVuZFZhbHVlLmxlbmd0aDtcblxuICBmb3IgKHN0YXJ0ID0gMDsgc3RhcnQgPCBzdGFydExlbmd0aDsgc3RhcnQrKykge1xuICAgIGlmIChzdGFydFZhbHVlW3N0YXJ0XSAhPT0gZW5kVmFsdWVbc3RhcnRdKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB2YXIgbWluRW5kID0gc3RhcnRMZW5ndGggLSBzdGFydDtcbiAgZm9yIChlbmQgPSAxOyBlbmQgPD0gbWluRW5kOyBlbmQrKykge1xuICAgIGlmIChzdGFydFZhbHVlW3N0YXJ0TGVuZ3RoIC0gZW5kXSAhPT0gZW5kVmFsdWVbZW5kTGVuZ3RoIC0gZW5kXSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIHNsaWNlVGFpbCA9IGVuZCA+IDEgPyAxIC0gZW5kIDogdW5kZWZpbmVkO1xuICBjb21wb3NpdGlvblN0YXRlLl9mYWxsYmFja1RleHQgPSBlbmRWYWx1ZS5zbGljZShzdGFydCwgc2xpY2VUYWlsKTtcbiAgcmV0dXJuIGNvbXBvc2l0aW9uU3RhdGUuX2ZhbGxiYWNrVGV4dDtcbn1cblxuZnVuY3Rpb24gZ2V0VGV4dCgpIHtcbiAgaWYgKCd2YWx1ZScgaW4gY29tcG9zaXRpb25TdGF0ZS5fcm9vdCkge1xuICAgIHJldHVybiBjb21wb3NpdGlvblN0YXRlLl9yb290LnZhbHVlO1xuICB9XG4gIHJldHVybiBjb21wb3NpdGlvblN0YXRlLl9yb290W2dldFRleHRDb250ZW50QWNjZXNzb3IoKV07XG59XG5cbi8qIGVzbGludCB2YWxpZC10eXBlb2Y6IDAgKi9cblxudmFyIGRpZFdhcm5Gb3JBZGRlZE5ld1Byb3BlcnR5ID0gZmFsc2U7XG52YXIgaXNQcm94eVN1cHBvcnRlZCA9IHR5cGVvZiBQcm94eSA9PT0gJ2Z1bmN0aW9uJztcbnZhciBFVkVOVF9QT09MX1NJWkUgPSAxMDtcblxudmFyIHNob3VsZEJlUmVsZWFzZWRQcm9wZXJ0aWVzID0gWydkaXNwYXRjaENvbmZpZycsICdfdGFyZ2V0SW5zdCcsICduYXRpdmVFdmVudCcsICdpc0RlZmF1bHRQcmV2ZW50ZWQnLCAnaXNQcm9wYWdhdGlvblN0b3BwZWQnLCAnX2Rpc3BhdGNoTGlzdGVuZXJzJywgJ19kaXNwYXRjaEluc3RhbmNlcyddO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHR5cGU6IG51bGwsXG4gIHRhcmdldDogbnVsbCxcbiAgLy8gY3VycmVudFRhcmdldCBpcyBzZXQgd2hlbiBkaXNwYXRjaGluZzsgbm8gdXNlIGluIGNvcHlpbmcgaXQgaGVyZVxuICBjdXJyZW50VGFyZ2V0OiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCxcbiAgZXZlbnRQaGFzZTogbnVsbCxcbiAgYnViYmxlczogbnVsbCxcbiAgY2FuY2VsYWJsZTogbnVsbCxcbiAgdGltZVN0YW1wOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQudGltZVN0YW1wIHx8IERhdGUubm93KCk7XG4gIH0sXG4gIGRlZmF1bHRQcmV2ZW50ZWQ6IG51bGwsXG4gIGlzVHJ1c3RlZDogbnVsbFxufTtcblxuLyoqXG4gKiBTeW50aGV0aWMgZXZlbnRzIGFyZSBkaXNwYXRjaGVkIGJ5IGV2ZW50IHBsdWdpbnMsIHR5cGljYWxseSBpbiByZXNwb25zZSB0byBhXG4gKiB0b3AtbGV2ZWwgZXZlbnQgZGVsZWdhdGlvbiBoYW5kbGVyLlxuICpcbiAqIFRoZXNlIHN5c3RlbXMgc2hvdWxkIGdlbmVyYWxseSB1c2UgcG9vbGluZyB0byByZWR1Y2UgdGhlIGZyZXF1ZW5jeSBvZiBnYXJiYWdlXG4gKiBjb2xsZWN0aW9uLiBUaGUgc3lzdGVtIHNob3VsZCBjaGVjayBgaXNQZXJzaXN0ZW50YCB0byBkZXRlcm1pbmUgd2hldGhlciB0aGVcbiAqIGV2ZW50IHNob3VsZCBiZSByZWxlYXNlZCBpbnRvIHRoZSBwb29sIGFmdGVyIGJlaW5nIGRpc3BhdGNoZWQuIFVzZXJzIHRoYXRcbiAqIG5lZWQgYSBwZXJzaXN0ZWQgZXZlbnQgc2hvdWxkIGludm9rZSBgcGVyc2lzdGAuXG4gKlxuICogU3ludGhldGljIGV2ZW50cyAoYW5kIHN1YmNsYXNzZXMpIGltcGxlbWVudCB0aGUgRE9NIExldmVsIDMgRXZlbnRzIEFQSSBieVxuICogbm9ybWFsaXppbmcgYnJvd3NlciBxdWlya3MuIFN1YmNsYXNzZXMgZG8gbm90IG5lY2Vzc2FyaWx5IGhhdmUgdG8gaW1wbGVtZW50IGFcbiAqIERPTSBpbnRlcmZhY2U7IGN1c3RvbSBhcHBsaWNhdGlvbi1zcGVjaWZpYyBldmVudHMgY2FuIGFsc28gc3ViY2xhc3MgdGhpcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0geyp9IHRhcmdldEluc3QgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSBuYXRpdmVFdmVudFRhcmdldCBUYXJnZXQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljRXZlbnQoZGlzcGF0Y2hDb25maWcsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICB7XG4gICAgLy8gdGhlc2UgaGF2ZSBhIGdldHRlci9zZXR0ZXIgZm9yIHdhcm5pbmdzXG4gICAgZGVsZXRlIHRoaXMubmF0aXZlRXZlbnQ7XG4gICAgZGVsZXRlIHRoaXMucHJldmVudERlZmF1bHQ7XG4gICAgZGVsZXRlIHRoaXMuc3RvcFByb3BhZ2F0aW9uO1xuICB9XG5cbiAgdGhpcy5kaXNwYXRjaENvbmZpZyA9IGRpc3BhdGNoQ29uZmlnO1xuICB0aGlzLl90YXJnZXRJbnN0ID0gdGFyZ2V0SW5zdDtcbiAgdGhpcy5uYXRpdmVFdmVudCA9IG5hdGl2ZUV2ZW50O1xuXG4gIHZhciBJbnRlcmZhY2UgPSB0aGlzLmNvbnN0cnVjdG9yLkludGVyZmFjZTtcbiAgZm9yICh2YXIgcHJvcE5hbWUgaW4gSW50ZXJmYWNlKSB7XG4gICAgaWYgKCFJbnRlcmZhY2UuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAge1xuICAgICAgZGVsZXRlIHRoaXNbcHJvcE5hbWVdOyAvLyB0aGlzIGhhcyBhIGdldHRlci9zZXR0ZXIgZm9yIHdhcm5pbmdzXG4gICAgfVxuICAgIHZhciBub3JtYWxpemUgPSBJbnRlcmZhY2VbcHJvcE5hbWVdO1xuICAgIGlmIChub3JtYWxpemUpIHtcbiAgICAgIHRoaXNbcHJvcE5hbWVdID0gbm9ybWFsaXplKG5hdGl2ZUV2ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb3BOYW1lID09PSAndGFyZ2V0Jykge1xuICAgICAgICB0aGlzLnRhcmdldCA9IG5hdGl2ZUV2ZW50VGFyZ2V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpc1twcm9wTmFtZV0gPSBuYXRpdmVFdmVudFtwcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGRlZmF1bHRQcmV2ZW50ZWQgPSBuYXRpdmVFdmVudC5kZWZhdWx0UHJldmVudGVkICE9IG51bGwgPyBuYXRpdmVFdmVudC5kZWZhdWx0UHJldmVudGVkIDogbmF0aXZlRXZlbnQucmV0dXJuVmFsdWUgPT09IGZhbHNlO1xuICBpZiAoZGVmYXVsdFByZXZlbnRlZCkge1xuICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWU7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2U7XG4gIH1cbiAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbl9hc3NpZ24oU3ludGhldGljRXZlbnQucHJvdG90eXBlLCB7XG4gIHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kZWZhdWx0UHJldmVudGVkID0gdHJ1ZTtcbiAgICB2YXIgZXZlbnQgPSB0aGlzLm5hdGl2ZUV2ZW50O1xuICAgIGlmICghZXZlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQucHJldmVudERlZmF1bHQpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXZlbnQucmV0dXJuVmFsdWUgIT09ICd1bmtub3duJykge1xuICAgICAgZXZlbnQucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSxcblxuICBzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXZlbnQgPSB0aGlzLm5hdGl2ZUV2ZW50O1xuICAgIGlmICghZXZlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQuc3RvcFByb3BhZ2F0aW9uKSB7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBldmVudC5jYW5jZWxCdWJibGUgIT09ICd1bmtub3duJykge1xuICAgICAgLy8gVGhlIENoYW5nZUV2ZW50UGx1Z2luIHJlZ2lzdGVycyBhIFwicHJvcGVydHljaGFuZ2VcIiBldmVudCBmb3JcbiAgICAgIC8vIElFLiBUaGlzIGV2ZW50IGRvZXMgbm90IHN1cHBvcnQgYnViYmxpbmcgb3IgY2FuY2VsbGluZywgYW5kXG4gICAgICAvLyBhbnkgcmVmZXJlbmNlcyB0byBjYW5jZWxCdWJibGUgdGhyb3cgXCJNZW1iZXIgbm90IGZvdW5kXCIuICBBXG4gICAgICAvLyB0eXBlb2YgY2hlY2sgb2YgXCJ1bmtub3duXCIgY2lyY3VtdmVudHMgdGhpcyBpc3N1ZSAoYW5kIGlzIGFsc29cbiAgICAgIC8vIElFIHNwZWNpZmljKS5cbiAgICAgIGV2ZW50LmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBXZSByZWxlYXNlIGFsbCBkaXNwYXRjaGVkIGBTeW50aGV0aWNFdmVudGBzIGFmdGVyIGVhY2ggZXZlbnQgbG9vcCwgYWRkaW5nXG4gICAqIHRoZW0gYmFjayBpbnRvIHRoZSBwb29sLiBUaGlzIGFsbG93cyBhIHdheSB0byBob2xkIG9udG8gYSByZWZlcmVuY2UgdGhhdFxuICAgKiB3b24ndCBiZSBhZGRlZCBiYWNrIGludG8gdGhlIHBvb2wuXG4gICAqL1xuICBwZXJzaXN0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pc1BlcnNpc3RlbnQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoaXMgZXZlbnQgc2hvdWxkIGJlIHJlbGVhc2VkIGJhY2sgaW50byB0aGUgcG9vbC5cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGlzIHNob3VsZCBub3QgYmUgcmVsZWFzZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGlzUGVyc2lzdGVudDogZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlLFxuXG4gIC8qKlxuICAgKiBgUG9vbGVkQ2xhc3NgIGxvb2tzIGZvciBgZGVzdHJ1Y3RvcmAgb24gZWFjaCBpbnN0YW5jZSBpdCByZWxlYXNlcy5cbiAgICovXG4gIGRlc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgSW50ZXJmYWNlID0gdGhpcy5jb25zdHJ1Y3Rvci5JbnRlcmZhY2U7XG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gSW50ZXJmYWNlKSB7XG4gICAgICB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBwcm9wTmFtZSwgZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbihwcm9wTmFtZSwgSW50ZXJmYWNlW3Byb3BOYW1lXSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNob3VsZEJlUmVsZWFzZWRQcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzW3Nob3VsZEJlUmVsZWFzZWRQcm9wZXJ0aWVzW2ldXSA9IG51bGw7XG4gICAgfVxuICAgIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbmF0aXZlRXZlbnQnLCBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKCduYXRpdmVFdmVudCcsIG51bGwpKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncHJldmVudERlZmF1bHQnLCBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKCdwcmV2ZW50RGVmYXVsdCcsIGVtcHR5RnVuY3Rpb24pKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnc3RvcFByb3BhZ2F0aW9uJywgZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbignc3RvcFByb3BhZ2F0aW9uJywgZW1wdHlGdW5jdGlvbikpO1xuICAgIH1cbiAgfVxufSk7XG5cblN5bnRoZXRpY0V2ZW50LkludGVyZmFjZSA9IEV2ZW50SW50ZXJmYWNlO1xuXG4vKipcbiAqIEhlbHBlciB0byByZWR1Y2UgYm9pbGVycGxhdGUgd2hlbiBjcmVhdGluZyBzdWJjbGFzc2VzLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IENsYXNzXG4gKiBAcGFyYW0gez9vYmplY3R9IEludGVyZmFjZVxuICovXG5TeW50aGV0aWNFdmVudC5hdWdtZW50Q2xhc3MgPSBmdW5jdGlvbiAoQ2xhc3MsIEludGVyZmFjZSkge1xuICB2YXIgU3VwZXIgPSB0aGlzO1xuXG4gIHZhciBFID0gZnVuY3Rpb24gKCkge307XG4gIEUucHJvdG90eXBlID0gU3VwZXIucHJvdG90eXBlO1xuICB2YXIgcHJvdG90eXBlID0gbmV3IEUoKTtcblxuICBfYXNzaWduKHByb3RvdHlwZSwgQ2xhc3MucHJvdG90eXBlKTtcbiAgQ2xhc3MucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICBDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDbGFzcztcblxuICBDbGFzcy5JbnRlcmZhY2UgPSBfYXNzaWduKHt9LCBTdXBlci5JbnRlcmZhY2UsIEludGVyZmFjZSk7XG4gIENsYXNzLmF1Z21lbnRDbGFzcyA9IFN1cGVyLmF1Z21lbnRDbGFzcztcbiAgYWRkRXZlbnRQb29saW5nVG8oQ2xhc3MpO1xufTtcblxuLyoqIFByb3h5aW5nIGFmdGVyIGV2ZXJ5dGhpbmcgc2V0IG9uIFN5bnRoZXRpY0V2ZW50XG4gKiB0byByZXNvbHZlIFByb3h5IGlzc3VlIG9uIHNvbWUgV2ViS2l0IGJyb3dzZXJzXG4gKiBpbiB3aGljaCBzb21lIEV2ZW50IHByb3BlcnRpZXMgYXJlIHNldCB0byB1bmRlZmluZWQgKEdIIzEwMDEwKVxuICovXG57XG4gIGlmIChpc1Byb3h5U3VwcG9ydGVkKSB7XG4gICAgLyplc2xpbnQtZGlzYWJsZSBuby1mdW5jLWFzc2lnbiAqL1xuICAgIFN5bnRoZXRpY0V2ZW50ID0gbmV3IFByb3h5KFN5bnRoZXRpY0V2ZW50LCB7XG4gICAgICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uICh0YXJnZXQsIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHkodGFyZ2V0LCBPYmplY3QuY3JlYXRlKHRhcmdldC5wcm90b3R5cGUpLCBhcmdzKTtcbiAgICAgIH0sXG4gICAgICBhcHBseTogZnVuY3Rpb24gKGNvbnN0cnVjdG9yLCB0aGF0LCBhcmdzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJveHkoY29uc3RydWN0b3IuYXBwbHkodGhhdCwgYXJncyksIHtcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0YXJnZXQsIHByb3AsIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAocHJvcCAhPT0gJ2lzUGVyc2lzdGVudCcgJiYgIXRhcmdldC5jb25zdHJ1Y3Rvci5JbnRlcmZhY2UuaGFzT3duUHJvcGVydHkocHJvcCkgJiYgc2hvdWxkQmVSZWxlYXNlZFByb3BlcnRpZXMuaW5kZXhPZihwcm9wKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgd2FybmluZyhkaWRXYXJuRm9yQWRkZWROZXdQcm9wZXJ0eSB8fCB0YXJnZXQuaXNQZXJzaXN0ZW50KCksIFwiVGhpcyBzeW50aGV0aWMgZXZlbnQgaXMgcmV1c2VkIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLiBJZiB5b3UncmUgXCIgKyBcInNlZWluZyB0aGlzLCB5b3UncmUgYWRkaW5nIGEgbmV3IHByb3BlcnR5IGluIHRoZSBzeW50aGV0aWMgZXZlbnQgb2JqZWN0LiBcIiArICdUaGUgcHJvcGVydHkgaXMgbmV2ZXIgcmVsZWFzZWQuIFNlZSAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtZXZlbnQtcG9vbGluZyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nKTtcbiAgICAgICAgICAgICAgZGlkV2FybkZvckFkZGVkTmV3UHJvcGVydHkgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFyZ2V0W3Byb3BdID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8qZXNsaW50LWVuYWJsZSBuby1mdW5jLWFzc2lnbiAqL1xuICB9XG59XG5cbmFkZEV2ZW50UG9vbGluZ1RvKFN5bnRoZXRpY0V2ZW50KTtcblxuLyoqXG4gKiBIZWxwZXIgdG8gbnVsbGlmeSBzeW50aGV0aWNFdmVudCBpbnN0YW5jZSBwcm9wZXJ0aWVzIHdoZW4gZGVzdHJ1Y3RpbmdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcE5hbWVcbiAqIEBwYXJhbSB7P29iamVjdH0gZ2V0VmFsXG4gKiBAcmV0dXJuIHtvYmplY3R9IGRlZmluZVByb3BlcnR5IG9iamVjdFxuICovXG5mdW5jdGlvbiBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKHByb3BOYW1lLCBnZXRWYWwpIHtcbiAgdmFyIGlzRnVuY3Rpb24gPSB0eXBlb2YgZ2V0VmFsID09PSAnZnVuY3Rpb24nO1xuICByZXR1cm4ge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBzZXQ6IHNldCxcbiAgICBnZXQ6IGdldFxuICB9O1xuXG4gIGZ1bmN0aW9uIHNldCh2YWwpIHtcbiAgICB2YXIgYWN0aW9uID0gaXNGdW5jdGlvbiA/ICdzZXR0aW5nIHRoZSBtZXRob2QnIDogJ3NldHRpbmcgdGhlIHByb3BlcnR5JztcbiAgICB3YXJuKGFjdGlvbiwgJ1RoaXMgaXMgZWZmZWN0aXZlbHkgYSBuby1vcCcpO1xuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICBmdW5jdGlvbiBnZXQoKSB7XG4gICAgdmFyIGFjdGlvbiA9IGlzRnVuY3Rpb24gPyAnYWNjZXNzaW5nIHRoZSBtZXRob2QnIDogJ2FjY2Vzc2luZyB0aGUgcHJvcGVydHknO1xuICAgIHZhciByZXN1bHQgPSBpc0Z1bmN0aW9uID8gJ1RoaXMgaXMgYSBuby1vcCBmdW5jdGlvbicgOiAnVGhpcyBpcyBzZXQgdG8gbnVsbCc7XG4gICAgd2FybihhY3Rpb24sIHJlc3VsdCk7XG4gICAgcmV0dXJuIGdldFZhbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdhcm4oYWN0aW9uLCByZXN1bHQpIHtcbiAgICB2YXIgd2FybmluZ0NvbmRpdGlvbiA9IGZhbHNlO1xuICAgIHdhcm5pbmcod2FybmluZ0NvbmRpdGlvbiwgXCJUaGlzIHN5bnRoZXRpYyBldmVudCBpcyByZXVzZWQgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuIElmIHlvdSdyZSBzZWVpbmcgdGhpcywgXCIgKyBcInlvdSdyZSAlcyBgJXNgIG9uIGEgcmVsZWFzZWQvbnVsbGlmaWVkIHN5bnRoZXRpYyBldmVudC4gJXMuIFwiICsgJ0lmIHlvdSBtdXN0IGtlZXAgdGhlIG9yaWdpbmFsIHN5bnRoZXRpYyBldmVudCBhcm91bmQsIHVzZSBldmVudC5wZXJzaXN0KCkuICcgKyAnU2VlIGh0dHBzOi8vZmIubWUvcmVhY3QtZXZlbnQtcG9vbGluZyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLCBhY3Rpb24sIHByb3BOYW1lLCByZXN1bHQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFBvb2xlZEV2ZW50KGRpc3BhdGNoQ29uZmlnLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlSW5zdCkge1xuICB2YXIgRXZlbnRDb25zdHJ1Y3RvciA9IHRoaXM7XG4gIGlmIChFdmVudENvbnN0cnVjdG9yLmV2ZW50UG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBFdmVudENvbnN0cnVjdG9yLmV2ZW50UG9vbC5wb3AoKTtcbiAgICBFdmVudENvbnN0cnVjdG9yLmNhbGwoaW5zdGFuY2UsIGRpc3BhdGNoQ29uZmlnLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlSW5zdCk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9XG4gIHJldHVybiBuZXcgRXZlbnRDb25zdHJ1Y3RvcihkaXNwYXRjaENvbmZpZywgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUluc3QpO1xufVxuXG5mdW5jdGlvbiByZWxlYXNlUG9vbGVkRXZlbnQoZXZlbnQpIHtcbiAgdmFyIEV2ZW50Q29uc3RydWN0b3IgPSB0aGlzO1xuICAhKGV2ZW50IGluc3RhbmNlb2YgRXZlbnRDb25zdHJ1Y3RvcikgPyBpbnZhcmlhbnQoZmFsc2UsICdUcnlpbmcgdG8gcmVsZWFzZSBhbiBldmVudCBpbnN0YW5jZSAgaW50byBhIHBvb2wgb2YgYSBkaWZmZXJlbnQgdHlwZS4nKSA6IHZvaWQgMDtcbiAgZXZlbnQuZGVzdHJ1Y3RvcigpO1xuICBpZiAoRXZlbnRDb25zdHJ1Y3Rvci5ldmVudFBvb2wubGVuZ3RoIDwgRVZFTlRfUE9PTF9TSVpFKSB7XG4gICAgRXZlbnRDb25zdHJ1Y3Rvci5ldmVudFBvb2wucHVzaChldmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkRXZlbnRQb29saW5nVG8oRXZlbnRDb25zdHJ1Y3Rvcikge1xuICBFdmVudENvbnN0cnVjdG9yLmV2ZW50UG9vbCA9IFtdO1xuICBFdmVudENvbnN0cnVjdG9yLmdldFBvb2xlZCA9IGdldFBvb2xlZEV2ZW50O1xuICBFdmVudENvbnN0cnVjdG9yLnJlbGVhc2UgPSByZWxlYXNlUG9vbGVkRXZlbnQ7XG59XG5cbnZhciBTeW50aGV0aWNFdmVudCQxID0gU3ludGhldGljRXZlbnQ7XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50cy1jb21wb3NpdGlvbmV2ZW50c1xuICovXG52YXIgQ29tcG9zaXRpb25FdmVudEludGVyZmFjZSA9IHtcbiAgZGF0YTogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50JDEuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50JDEuYXVnbWVudENsYXNzKFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQsIENvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAxMzExMDVcbiAqICAgICAgLyNldmVudHMtaW5wdXRldmVudHNcbiAqL1xudmFyIElucHV0RXZlbnRJbnRlcmZhY2UgPSB7XG4gIGRhdGE6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNJbnB1dEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNFdmVudCQxLmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNFdmVudCQxLmF1Z21lbnRDbGFzcyhTeW50aGV0aWNJbnB1dEV2ZW50LCBJbnB1dEV2ZW50SW50ZXJmYWNlKTtcblxudmFyIEVORF9LRVlDT0RFUyA9IFs5LCAxMywgMjcsIDMyXTsgLy8gVGFiLCBSZXR1cm4sIEVzYywgU3BhY2VcbnZhciBTVEFSVF9LRVlDT0RFID0gMjI5O1xuXG52YXIgY2FuVXNlQ29tcG9zaXRpb25FdmVudCA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAnQ29tcG9zaXRpb25FdmVudCcgaW4gd2luZG93O1xuXG52YXIgZG9jdW1lbnRNb2RlID0gbnVsbDtcbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQpIHtcbiAgZG9jdW1lbnRNb2RlID0gZG9jdW1lbnQuZG9jdW1lbnRNb2RlO1xufVxuXG4vLyBXZWJraXQgb2ZmZXJzIGEgdmVyeSB1c2VmdWwgYHRleHRJbnB1dGAgZXZlbnQgdGhhdCBjYW4gYmUgdXNlZCB0b1xuLy8gZGlyZWN0bHkgcmVwcmVzZW50IGBiZWZvcmVJbnB1dGAuIFRoZSBJRSBgdGV4dGlucHV0YCBldmVudCBpcyBub3QgYXNcbi8vIHVzZWZ1bCwgc28gd2UgZG9uJ3QgdXNlIGl0LlxudmFyIGNhblVzZVRleHRJbnB1dEV2ZW50ID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICdUZXh0RXZlbnQnIGluIHdpbmRvdyAmJiAhZG9jdW1lbnRNb2RlICYmICFpc1ByZXN0bygpO1xuXG4vLyBJbiBJRTkrLCB3ZSBoYXZlIGFjY2VzcyB0byBjb21wb3NpdGlvbiBldmVudHMsIGJ1dCB0aGUgZGF0YSBzdXBwbGllZFxuLy8gYnkgdGhlIG5hdGl2ZSBjb21wb3NpdGlvbmVuZCBldmVudCBtYXkgYmUgaW5jb3JyZWN0LiBKYXBhbmVzZSBpZGVvZ3JhcGhpY1xuLy8gc3BhY2VzLCBmb3IgaW5zdGFuY2UgKFxcdTMwMDApIGFyZSBub3QgcmVjb3JkZWQgY29ycmVjdGx5LlxudmFyIHVzZUZhbGxiYWNrQ29tcG9zaXRpb25EYXRhID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICghY2FuVXNlQ29tcG9zaXRpb25FdmVudCB8fCBkb2N1bWVudE1vZGUgJiYgZG9jdW1lbnRNb2RlID4gOCAmJiBkb2N1bWVudE1vZGUgPD0gMTEpO1xuXG4vKipcbiAqIE9wZXJhIDw9IDEyIGluY2x1ZGVzIFRleHRFdmVudCBpbiB3aW5kb3csIGJ1dCBkb2VzIG5vdCBmaXJlXG4gKiB0ZXh0IGlucHV0IGV2ZW50cy4gUmVseSBvbiBrZXlwcmVzcyBpbnN0ZWFkLlxuICovXG5mdW5jdGlvbiBpc1ByZXN0bygpIHtcbiAgdmFyIG9wZXJhID0gd2luZG93Lm9wZXJhO1xuICByZXR1cm4gdHlwZW9mIG9wZXJhID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb3BlcmEudmVyc2lvbiA9PT0gJ2Z1bmN0aW9uJyAmJiBwYXJzZUludChvcGVyYS52ZXJzaW9uKCksIDEwKSA8PSAxMjtcbn1cblxudmFyIFNQQUNFQkFSX0NPREUgPSAzMjtcbnZhciBTUEFDRUJBUl9DSEFSID0gU3RyaW5nLmZyb21DaGFyQ29kZShTUEFDRUJBUl9DT0RFKTtcblxuLy8gRXZlbnRzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIHByb3BlcnR5IG5hbWVzLlxudmFyIGV2ZW50VHlwZXMgPSB7XG4gIGJlZm9yZUlucHV0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6ICdvbkJlZm9yZUlucHV0JyxcbiAgICAgIGNhcHR1cmVkOiAnb25CZWZvcmVJbnB1dENhcHR1cmUnXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFsndG9wQ29tcG9zaXRpb25FbmQnLCAndG9wS2V5UHJlc3MnLCAndG9wVGV4dElucHV0JywgJ3RvcFBhc3RlJ11cbiAgfSxcbiAgY29tcG9zaXRpb25FbmQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogJ29uQ29tcG9zaXRpb25FbmQnLFxuICAgICAgY2FwdHVyZWQ6ICdvbkNvbXBvc2l0aW9uRW5kQ2FwdHVyZSdcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogWyd0b3BCbHVyJywgJ3RvcENvbXBvc2l0aW9uRW5kJywgJ3RvcEtleURvd24nLCAndG9wS2V5UHJlc3MnLCAndG9wS2V5VXAnLCAndG9wTW91c2VEb3duJ11cbiAgfSxcbiAgY29tcG9zaXRpb25TdGFydDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiAnb25Db21wb3NpdGlvblN0YXJ0JyxcbiAgICAgIGNhcHR1cmVkOiAnb25Db21wb3NpdGlvblN0YXJ0Q2FwdHVyZSdcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogWyd0b3BCbHVyJywgJ3RvcENvbXBvc2l0aW9uU3RhcnQnLCAndG9wS2V5RG93bicsICd0b3BLZXlQcmVzcycsICd0b3BLZXlVcCcsICd0b3BNb3VzZURvd24nXVxuICB9LFxuICBjb21wb3NpdGlvblVwZGF0ZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiAnb25Db21wb3NpdGlvblVwZGF0ZScsXG4gICAgICBjYXB0dXJlZDogJ29uQ29tcG9zaXRpb25VcGRhdGVDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcEJsdXInLCAndG9wQ29tcG9zaXRpb25VcGRhdGUnLCAndG9wS2V5RG93bicsICd0b3BLZXlQcmVzcycsICd0b3BLZXlVcCcsICd0b3BNb3VzZURvd24nXVxuICB9XG59O1xuXG4vLyBUcmFjayB3aGV0aGVyIHdlJ3ZlIGV2ZXIgaGFuZGxlZCBhIGtleXByZXNzIG9uIHRoZSBzcGFjZSBrZXkuXG52YXIgaGFzU3BhY2VLZXlwcmVzcyA9IGZhbHNlO1xuXG4vKipcbiAqIFJldHVybiB3aGV0aGVyIGEgbmF0aXZlIGtleXByZXNzIGV2ZW50IGlzIGFzc3VtZWQgdG8gYmUgYSBjb21tYW5kLlxuICogVGhpcyBpcyByZXF1aXJlZCBiZWNhdXNlIEZpcmVmb3ggZmlyZXMgYGtleXByZXNzYCBldmVudHMgZm9yIGtleSBjb21tYW5kc1xuICogKGN1dCwgY29weSwgc2VsZWN0LWFsbCwgZXRjLikgZXZlbiB0aG91Z2ggbm8gY2hhcmFjdGVyIGlzIGluc2VydGVkLlxuICovXG5mdW5jdGlvbiBpc0tleXByZXNzQ29tbWFuZChuYXRpdmVFdmVudCkge1xuICByZXR1cm4gKG5hdGl2ZUV2ZW50LmN0cmxLZXkgfHwgbmF0aXZlRXZlbnQuYWx0S2V5IHx8IG5hdGl2ZUV2ZW50Lm1ldGFLZXkpICYmXG4gIC8vIGN0cmxLZXkgJiYgYWx0S2V5IGlzIGVxdWl2YWxlbnQgdG8gQWx0R3IsIGFuZCBpcyBub3QgYSBjb21tYW5kLlxuICAhKG5hdGl2ZUV2ZW50LmN0cmxLZXkgJiYgbmF0aXZlRXZlbnQuYWx0S2V5KTtcbn1cblxuLyoqXG4gKiBUcmFuc2xhdGUgbmF0aXZlIHRvcCBsZXZlbCBldmVudHMgaW50byBldmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldENvbXBvc2l0aW9uRXZlbnRUeXBlKHRvcExldmVsVHlwZSkge1xuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgJ3RvcENvbXBvc2l0aW9uU3RhcnQnOlxuICAgICAgcmV0dXJuIGV2ZW50VHlwZXMuY29tcG9zaXRpb25TdGFydDtcbiAgICBjYXNlICd0b3BDb21wb3NpdGlvbkVuZCc6XG4gICAgICByZXR1cm4gZXZlbnRUeXBlcy5jb21wb3NpdGlvbkVuZDtcbiAgICBjYXNlICd0b3BDb21wb3NpdGlvblVwZGF0ZSc6XG4gICAgICByZXR1cm4gZXZlbnRUeXBlcy5jb21wb3NpdGlvblVwZGF0ZTtcbiAgfVxufVxuXG4vKipcbiAqIERvZXMgb3VyIGZhbGxiYWNrIGJlc3QtZ3Vlc3MgbW9kZWwgdGhpbmsgdGhpcyBldmVudCBzaWduaWZpZXMgdGhhdFxuICogY29tcG9zaXRpb24gaGFzIGJlZ3VuP1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNGYWxsYmFja0NvbXBvc2l0aW9uU3RhcnQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICByZXR1cm4gdG9wTGV2ZWxUeXBlID09PSAndG9wS2V5RG93bicgJiYgbmF0aXZlRXZlbnQua2V5Q29kZSA9PT0gU1RBUlRfS0VZQ09ERTtcbn1cblxuLyoqXG4gKiBEb2VzIG91ciBmYWxsYmFjayBtb2RlIHRoaW5rIHRoYXQgdGhpcyBldmVudCBpcyB0aGUgZW5kIG9mIGNvbXBvc2l0aW9uP1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNGYWxsYmFja0NvbXBvc2l0aW9uRW5kKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICBjYXNlICd0b3BLZXlVcCc6XG4gICAgICAvLyBDb21tYW5kIGtleXMgaW5zZXJ0IG9yIGNsZWFyIElNRSBpbnB1dC5cbiAgICAgIHJldHVybiBFTkRfS0VZQ09ERVMuaW5kZXhPZihuYXRpdmVFdmVudC5rZXlDb2RlKSAhPT0gLTE7XG4gICAgY2FzZSAndG9wS2V5RG93bic6XG4gICAgICAvLyBFeHBlY3QgSU1FIGtleUNvZGUgb24gZWFjaCBrZXlkb3duLiBJZiB3ZSBnZXQgYW55IG90aGVyXG4gICAgICAvLyBjb2RlIHdlIG11c3QgaGF2ZSBleGl0ZWQgZWFybGllci5cbiAgICAgIHJldHVybiBuYXRpdmVFdmVudC5rZXlDb2RlICE9PSBTVEFSVF9LRVlDT0RFO1xuICAgIGNhc2UgJ3RvcEtleVByZXNzJzpcbiAgICBjYXNlICd0b3BNb3VzZURvd24nOlxuICAgIGNhc2UgJ3RvcEJsdXInOlxuICAgICAgLy8gRXZlbnRzIGFyZSBub3QgcG9zc2libGUgd2l0aG91dCBjYW5jZWxsaW5nIElNRS5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBHb29nbGUgSW5wdXQgVG9vbHMgcHJvdmlkZXMgY29tcG9zaXRpb24gZGF0YSB2aWEgYSBDdXN0b21FdmVudCxcbiAqIHdpdGggdGhlIGBkYXRhYCBwcm9wZXJ0eSBwb3B1bGF0ZWQgaW4gdGhlIGBkZXRhaWxgIG9iamVjdC4gSWYgdGhpc1xuICogaXMgYXZhaWxhYmxlIG9uIHRoZSBldmVudCBvYmplY3QsIHVzZSBpdC4gSWYgbm90LCB0aGlzIGlzIGEgcGxhaW5cbiAqIGNvbXBvc2l0aW9uIGV2ZW50IGFuZCB3ZSBoYXZlIG5vdGhpbmcgc3BlY2lhbCB0byBleHRyYWN0LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHJldHVybiB7P3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0RGF0YUZyb21DdXN0b21FdmVudChuYXRpdmVFdmVudCkge1xuICB2YXIgZGV0YWlsID0gbmF0aXZlRXZlbnQuZGV0YWlsO1xuICBpZiAodHlwZW9mIGRldGFpbCA9PT0gJ29iamVjdCcgJiYgJ2RhdGEnIGluIGRldGFpbCkge1xuICAgIHJldHVybiBkZXRhaWwuZGF0YTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gVHJhY2sgdGhlIGN1cnJlbnQgSU1FIGNvbXBvc2l0aW9uIHN0YXR1cywgaWYgYW55LlxudmFyIGlzQ29tcG9zaW5nID0gZmFsc2U7XG5cbi8qKlxuICogQHJldHVybiB7P29iamVjdH0gQSBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50LlxuICovXG5mdW5jdGlvbiBleHRyYWN0Q29tcG9zaXRpb25FdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICB2YXIgZXZlbnRUeXBlO1xuICB2YXIgZmFsbGJhY2tEYXRhO1xuXG4gIGlmIChjYW5Vc2VDb21wb3NpdGlvbkV2ZW50KSB7XG4gICAgZXZlbnRUeXBlID0gZ2V0Q29tcG9zaXRpb25FdmVudFR5cGUodG9wTGV2ZWxUeXBlKTtcbiAgfSBlbHNlIGlmICghaXNDb21wb3NpbmcpIHtcbiAgICBpZiAoaXNGYWxsYmFja0NvbXBvc2l0aW9uU3RhcnQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkpIHtcbiAgICAgIGV2ZW50VHlwZSA9IGV2ZW50VHlwZXMuY29tcG9zaXRpb25TdGFydDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNGYWxsYmFja0NvbXBvc2l0aW9uRW5kKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpKSB7XG4gICAgZXZlbnRUeXBlID0gZXZlbnRUeXBlcy5jb21wb3NpdGlvbkVuZDtcbiAgfVxuXG4gIGlmICghZXZlbnRUeXBlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAodXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEpIHtcbiAgICAvLyBUaGUgY3VycmVudCBjb21wb3NpdGlvbiBpcyBzdG9yZWQgc3RhdGljYWxseSBhbmQgbXVzdCBub3QgYmVcbiAgICAvLyBvdmVyd3JpdHRlbiB3aGlsZSBjb21wb3NpdGlvbiBjb250aW51ZXMuXG4gICAgaWYgKCFpc0NvbXBvc2luZyAmJiBldmVudFR5cGUgPT09IGV2ZW50VHlwZXMuY29tcG9zaXRpb25TdGFydCkge1xuICAgICAgaXNDb21wb3NpbmcgPSBpbml0aWFsaXplKG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICB9IGVsc2UgaWYgKGV2ZW50VHlwZSA9PT0gZXZlbnRUeXBlcy5jb21wb3NpdGlvbkVuZCkge1xuICAgICAgaWYgKGlzQ29tcG9zaW5nKSB7XG4gICAgICAgIGZhbGxiYWNrRGF0YSA9IGdldERhdGEoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgZXZlbnQgPSBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50LmdldFBvb2xlZChldmVudFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG5cbiAgaWYgKGZhbGxiYWNrRGF0YSkge1xuICAgIC8vIEluamVjdCBkYXRhIGdlbmVyYXRlZCBmcm9tIGZhbGxiYWNrIHBhdGggaW50byB0aGUgc3ludGhldGljIGV2ZW50LlxuICAgIC8vIFRoaXMgbWF0Y2hlcyB0aGUgcHJvcGVydHkgb2YgbmF0aXZlIENvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UuXG4gICAgZXZlbnQuZGF0YSA9IGZhbGxiYWNrRGF0YTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VzdG9tRGF0YSA9IGdldERhdGFGcm9tQ3VzdG9tRXZlbnQobmF0aXZlRXZlbnQpO1xuICAgIGlmIChjdXN0b21EYXRhICE9PSBudWxsKSB7XG4gICAgICBldmVudC5kYXRhID0gY3VzdG9tRGF0YTtcbiAgICB9XG4gIH1cblxuICBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgcmV0dXJuIGV2ZW50O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VG9wTGV2ZWxUeXBlc30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBCcm93c2VyRXZlbnRDb25zdGFudHNgLlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7P3N0cmluZ30gVGhlIHN0cmluZyBjb3JyZXNwb25kaW5nIHRvIHRoaXMgYGJlZm9yZUlucHV0YCBldmVudC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlQmVmb3JlSW5wdXRDaGFycyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgY2FzZSAndG9wQ29tcG9zaXRpb25FbmQnOlxuICAgICAgcmV0dXJuIGdldERhdGFGcm9tQ3VzdG9tRXZlbnQobmF0aXZlRXZlbnQpO1xuICAgIGNhc2UgJ3RvcEtleVByZXNzJzpcbiAgICAgIC8qKlxuICAgICAgICogSWYgbmF0aXZlIGB0ZXh0SW5wdXRgIGV2ZW50cyBhcmUgYXZhaWxhYmxlLCBvdXIgZ29hbCBpcyB0byBtYWtlXG4gICAgICAgKiB1c2Ugb2YgdGhlbS4gSG93ZXZlciwgdGhlcmUgaXMgYSBzcGVjaWFsIGNhc2U6IHRoZSBzcGFjZWJhciBrZXkuXG4gICAgICAgKiBJbiBXZWJraXQsIHByZXZlbnRpbmcgZGVmYXVsdCBvbiBhIHNwYWNlYmFyIGB0ZXh0SW5wdXRgIGV2ZW50XG4gICAgICAgKiBjYW5jZWxzIGNoYXJhY3RlciBpbnNlcnRpb24sIGJ1dCBpdCAqYWxzbyogY2F1c2VzIHRoZSBicm93c2VyXG4gICAgICAgKiB0byBmYWxsIGJhY2sgdG8gaXRzIGRlZmF1bHQgc3BhY2ViYXIgYmVoYXZpb3Igb2Ygc2Nyb2xsaW5nIHRoZVxuICAgICAgICogcGFnZS5cbiAgICAgICAqXG4gICAgICAgKiBUcmFja2luZyBhdDpcbiAgICAgICAqIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zNTUxMDNcbiAgICAgICAqXG4gICAgICAgKiBUbyBhdm9pZCB0aGlzIGlzc3VlLCB1c2UgdGhlIGtleXByZXNzIGV2ZW50IGFzIGlmIG5vIGB0ZXh0SW5wdXRgXG4gICAgICAgKiBldmVudCBpcyBhdmFpbGFibGUuXG4gICAgICAgKi9cbiAgICAgIHZhciB3aGljaCA9IG5hdGl2ZUV2ZW50LndoaWNoO1xuICAgICAgaWYgKHdoaWNoICE9PSBTUEFDRUJBUl9DT0RFKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBoYXNTcGFjZUtleXByZXNzID0gdHJ1ZTtcbiAgICAgIHJldHVybiBTUEFDRUJBUl9DSEFSO1xuXG4gICAgY2FzZSAndG9wVGV4dElucHV0JzpcbiAgICAgIC8vIFJlY29yZCB0aGUgY2hhcmFjdGVycyB0byBiZSBhZGRlZCB0byB0aGUgRE9NLlxuICAgICAgdmFyIGNoYXJzID0gbmF0aXZlRXZlbnQuZGF0YTtcblxuICAgICAgLy8gSWYgaXQncyBhIHNwYWNlYmFyIGNoYXJhY3RlciwgYXNzdW1lIHRoYXQgd2UgaGF2ZSBhbHJlYWR5IGhhbmRsZWRcbiAgICAgIC8vIGl0IGF0IHRoZSBrZXlwcmVzcyBsZXZlbCBhbmQgYmFpbCBpbW1lZGlhdGVseS4gQW5kcm9pZCBDaHJvbWVcbiAgICAgIC8vIGRvZXNuJ3QgZ2l2ZSB1cyBrZXljb2Rlcywgc28gd2UgbmVlZCB0byBibGFja2xpc3QgaXQuXG4gICAgICBpZiAoY2hhcnMgPT09IFNQQUNFQkFSX0NIQVIgJiYgaGFzU3BhY2VLZXlwcmVzcykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNoYXJzO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIEZvciBvdGhlciBuYXRpdmUgZXZlbnQgdHlwZXMsIGRvIG5vdGhpbmcuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEZvciBicm93c2VycyB0aGF0IGRvIG5vdCBwcm92aWRlIHRoZSBgdGV4dElucHV0YCBldmVudCwgZXh0cmFjdCB0aGVcbiAqIGFwcHJvcHJpYXRlIHN0cmluZyB0byB1c2UgZm9yIFN5bnRoZXRpY0lucHV0RXZlbnQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgQnJvd3NlckV2ZW50Q29uc3RhbnRzYC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4gez9zdHJpbmd9IFRoZSBmYWxsYmFjayBzdHJpbmcgZm9yIHRoaXMgYGJlZm9yZUlucHV0YCBldmVudC5cbiAqL1xuZnVuY3Rpb24gZ2V0RmFsbGJhY2tCZWZvcmVJbnB1dENoYXJzKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgLy8gSWYgd2UgYXJlIGN1cnJlbnRseSBjb21wb3NpbmcgKElNRSkgYW5kIHVzaW5nIGEgZmFsbGJhY2sgdG8gZG8gc28sXG4gIC8vIHRyeSB0byBleHRyYWN0IHRoZSBjb21wb3NlZCBjaGFyYWN0ZXJzIGZyb20gdGhlIGZhbGxiYWNrIG9iamVjdC5cbiAgLy8gSWYgY29tcG9zaXRpb24gZXZlbnQgaXMgYXZhaWxhYmxlLCB3ZSBleHRyYWN0IGEgc3RyaW5nIG9ubHkgYXRcbiAgLy8gY29tcG9zaXRpb25ldmVudCwgb3RoZXJ3aXNlIGV4dHJhY3QgaXQgYXQgZmFsbGJhY2sgZXZlbnRzLlxuICBpZiAoaXNDb21wb3NpbmcpIHtcbiAgICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wQ29tcG9zaXRpb25FbmQnIHx8ICFjYW5Vc2VDb21wb3NpdGlvbkV2ZW50ICYmIGlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSkge1xuICAgICAgdmFyIGNoYXJzID0gZ2V0RGF0YSgpO1xuICAgICAgcmVzZXQoKTtcbiAgICAgIGlzQ29tcG9zaW5nID0gZmFsc2U7XG4gICAgICByZXR1cm4gY2hhcnM7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICBjYXNlICd0b3BQYXN0ZSc6XG4gICAgICAvLyBJZiBhIHBhc3RlIGV2ZW50IG9jY3VycyBhZnRlciBhIGtleXByZXNzLCB0aHJvdyBvdXQgdGhlIGlucHV0XG4gICAgICAvLyBjaGFycy4gUGFzdGUgZXZlbnRzIHNob3VsZCBub3QgbGVhZCB0byBCZWZvcmVJbnB1dCBldmVudHMuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjYXNlICd0b3BLZXlQcmVzcyc6XG4gICAgICAvKipcbiAgICAgICAqIEFzIG9mIHYyNywgRmlyZWZveCBtYXkgZmlyZSBrZXlwcmVzcyBldmVudHMgZXZlbiB3aGVuIG5vIGNoYXJhY3RlclxuICAgICAgICogd2lsbCBiZSBpbnNlcnRlZC4gQSBmZXcgcG9zc2liaWxpdGllczpcbiAgICAgICAqXG4gICAgICAgKiAtIGB3aGljaGAgaXMgYDBgLiBBcnJvdyBrZXlzLCBFc2Mga2V5LCBldGMuXG4gICAgICAgKlxuICAgICAgICogLSBgd2hpY2hgIGlzIHRoZSBwcmVzc2VkIGtleSBjb2RlLCBidXQgbm8gY2hhciBpcyBhdmFpbGFibGUuXG4gICAgICAgKiAgIEV4OiAnQWx0R3IgKyBkYCBpbiBQb2xpc2guIFRoZXJlIGlzIG5vIG1vZGlmaWVkIGNoYXJhY3RlciBmb3JcbiAgICAgICAqICAgdGhpcyBrZXkgY29tYmluYXRpb24gYW5kIG5vIGNoYXJhY3RlciBpcyBpbnNlcnRlZCBpbnRvIHRoZVxuICAgICAgICogICBkb2N1bWVudCwgYnV0IEZGIGZpcmVzIHRoZSBrZXlwcmVzcyBmb3IgY2hhciBjb2RlIGAxMDBgIGFueXdheS5cbiAgICAgICAqICAgTm8gYGlucHV0YCBldmVudCB3aWxsIG9jY3VyLlxuICAgICAgICpcbiAgICAgICAqIC0gYHdoaWNoYCBpcyB0aGUgcHJlc3NlZCBrZXkgY29kZSwgYnV0IGEgY29tbWFuZCBjb21iaW5hdGlvbiBpc1xuICAgICAgICogICBiZWluZyB1c2VkLiBFeDogYENtZCtDYC4gTm8gY2hhcmFjdGVyIGlzIGluc2VydGVkLCBhbmQgbm9cbiAgICAgICAqICAgYGlucHV0YCBldmVudCB3aWxsIG9jY3VyLlxuICAgICAgICovXG4gICAgICBpZiAoIWlzS2V5cHJlc3NDb21tYW5kKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAvLyBJRSBmaXJlcyB0aGUgYGtleXByZXNzYCBldmVudCB3aGVuIGEgdXNlciB0eXBlcyBhbiBlbW9qaSB2aWFcbiAgICAgICAgLy8gVG91Y2gga2V5Ym9hcmQgb2YgV2luZG93cy4gIEluIHN1Y2ggYSBjYXNlLCB0aGUgYGNoYXJgIHByb3BlcnR5XG4gICAgICAgIC8vIGhvbGRzIGFuIGVtb2ppIGNoYXJhY3RlciBsaWtlIGBcXHVEODNEXFx1REUwQWAuICBCZWNhdXNlIGl0cyBsZW5ndGhcbiAgICAgICAgLy8gaXMgMiwgdGhlIHByb3BlcnR5IGB3aGljaGAgZG9lcyBub3QgcmVwcmVzZW50IGFuIGVtb2ppIGNvcnJlY3RseS5cbiAgICAgICAgLy8gSW4gc3VjaCBhIGNhc2UsIHdlIGRpcmVjdGx5IHJldHVybiB0aGUgYGNoYXJgIHByb3BlcnR5IGluc3RlYWQgb2ZcbiAgICAgICAgLy8gdXNpbmcgYHdoaWNoYC5cbiAgICAgICAgaWYgKG5hdGl2ZUV2ZW50LmNoYXIgJiYgbmF0aXZlRXZlbnQuY2hhci5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgcmV0dXJuIG5hdGl2ZUV2ZW50LmNoYXI7XG4gICAgICAgIH0gZWxzZSBpZiAobmF0aXZlRXZlbnQud2hpY2gpIHtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShuYXRpdmVFdmVudC53aGljaCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgJ3RvcENvbXBvc2l0aW9uRW5kJzpcbiAgICAgIHJldHVybiB1c2VGYWxsYmFja0NvbXBvc2l0aW9uRGF0YSA/IG51bGwgOiBuYXRpdmVFdmVudC5kYXRhO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEV4dHJhY3QgYSBTeW50aGV0aWNJbnB1dEV2ZW50IGZvciBgYmVmb3JlSW5wdXRgLCBiYXNlZCBvbiBlaXRoZXIgbmF0aXZlXG4gKiBgdGV4dElucHV0YCBvciBmYWxsYmFjayBiZWhhdmlvci5cbiAqXG4gKiBAcmV0dXJuIHs/b2JqZWN0fSBBIFN5bnRoZXRpY0lucHV0RXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RCZWZvcmVJbnB1dEV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHZhciBjaGFycztcblxuICBpZiAoY2FuVXNlVGV4dElucHV0RXZlbnQpIHtcbiAgICBjaGFycyA9IGdldE5hdGl2ZUJlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCk7XG4gIH0gZWxzZSB7XG4gICAgY2hhcnMgPSBnZXRGYWxsYmFja0JlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCk7XG4gIH1cblxuICAvLyBJZiBubyBjaGFyYWN0ZXJzIGFyZSBiZWluZyBpbnNlcnRlZCwgbm8gQmVmb3JlSW5wdXQgZXZlbnQgc2hvdWxkXG4gIC8vIGJlIGZpcmVkLlxuICBpZiAoIWNoYXJzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgZXZlbnQgPSBTeW50aGV0aWNJbnB1dEV2ZW50LmdldFBvb2xlZChldmVudFR5cGVzLmJlZm9yZUlucHV0LCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gIGV2ZW50LmRhdGEgPSBjaGFycztcbiAgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudCk7XG4gIHJldHVybiBldmVudDtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gYG9uQmVmb3JlSW5wdXRgIGV2ZW50IHRvIG1hdGNoXG4gKiBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDEzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDEzMTEwNS8jZXZlbnRzLWlucHV0ZXZlbnRzLlxuICpcbiAqIFRoaXMgZXZlbnQgcGx1Z2luIGlzIGJhc2VkIG9uIHRoZSBuYXRpdmUgYHRleHRJbnB1dGAgZXZlbnRcbiAqIGF2YWlsYWJsZSBpbiBDaHJvbWUsIFNhZmFyaSwgT3BlcmEsIGFuZCBJRS4gVGhpcyBldmVudCBmaXJlcyBhZnRlclxuICogYG9uS2V5UHJlc3NgIGFuZCBgb25Db21wb3NpdGlvbkVuZGAsIGJ1dCBiZWZvcmUgYG9uSW5wdXRgLlxuICpcbiAqIGBiZWZvcmVJbnB1dGAgaXMgc3BlYydkIGJ1dCBub3QgaW1wbGVtZW50ZWQgaW4gYW55IGJyb3dzZXJzLCBhbmRcbiAqIHRoZSBgaW5wdXRgIGV2ZW50IGRvZXMgbm90IHByb3ZpZGUgYW55IHVzZWZ1bCBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGhhc1xuICogYWN0dWFsbHkgYmVlbiBhZGRlZCwgY29udHJhcnkgdG8gdGhlIHNwZWMuIFRodXMsIGB0ZXh0SW5wdXRgIGlzIHRoZSBiZXN0XG4gKiBhdmFpbGFibGUgZXZlbnQgdG8gaWRlbnRpZnkgdGhlIGNoYXJhY3RlcnMgdGhhdCBoYXZlIGFjdHVhbGx5IGJlZW4gaW5zZXJ0ZWRcbiAqIGludG8gdGhlIHRhcmdldCBub2RlLlxuICpcbiAqIFRoaXMgcGx1Z2luIGlzIGFsc28gcmVzcG9uc2libGUgZm9yIGVtaXR0aW5nIGBjb21wb3NpdGlvbmAgZXZlbnRzLCB0aHVzXG4gKiBhbGxvd2luZyB1cyB0byBzaGFyZSBjb21wb3NpdGlvbiBmYWxsYmFjayBjb2RlIGZvciBib3RoIGBiZWZvcmVJbnB1dGAgYW5kXG4gKiBgY29tcG9zaXRpb25gIGV2ZW50IHR5cGVzLlxuICovXG52YXIgQmVmb3JlSW5wdXRFdmVudFBsdWdpbiA9IHtcbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyxcblxuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICByZXR1cm4gW2V4dHJhY3RDb21wb3NpdGlvbkV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSwgZXh0cmFjdEJlZm9yZUlucHV0RXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpXTtcbiAgfVxufTtcblxuLy8gVXNlIHRvIHJlc3RvcmUgY29udHJvbGxlZCBzdGF0ZSBhZnRlciBhIGNoYW5nZSBldmVudCBoYXMgZmlyZWQuXG5cbnZhciBmaWJlckhvc3RDb21wb25lbnQgPSBudWxsO1xuXG52YXIgUmVhY3RDb250cm9sbGVkQ29tcG9uZW50SW5qZWN0aW9uID0ge1xuICBpbmplY3RGaWJlckNvbnRyb2xsZWRIb3N0Q29tcG9uZW50OiBmdW5jdGlvbiAoaG9zdENvbXBvbmVudEltcGwpIHtcbiAgICAvLyBUaGUgZmliZXIgaW1wbGVtZW50YXRpb24gZG9lc24ndCB1c2UgZHluYW1pYyBkaXNwYXRjaCBzbyB3ZSBuZWVkIHRvXG4gICAgLy8gaW5qZWN0IHRoZSBpbXBsZW1lbnRhdGlvbi5cbiAgICBmaWJlckhvc3RDb21wb25lbnQgPSBob3N0Q29tcG9uZW50SW1wbDtcbiAgfVxufTtcblxudmFyIHJlc3RvcmVUYXJnZXQgPSBudWxsO1xudmFyIHJlc3RvcmVRdWV1ZSA9IG51bGw7XG5cbmZ1bmN0aW9uIHJlc3RvcmVTdGF0ZU9mVGFyZ2V0KHRhcmdldCkge1xuICAvLyBXZSBwZXJmb3JtIHRoaXMgdHJhbnNsYXRpb24gYXQgdGhlIGVuZCBvZiB0aGUgZXZlbnQgbG9vcCBzbyB0aGF0IHdlXG4gIC8vIGFsd2F5cyByZWNlaXZlIHRoZSBjb3JyZWN0IGZpYmVyIGhlcmVcbiAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBnZXRJbnN0YW5jZUZyb21Ob2RlKHRhcmdldCk7XG4gIGlmICghaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgIC8vIFVubW91bnRlZFxuICAgIHJldHVybjtcbiAgfVxuICAhKGZpYmVySG9zdENvbXBvbmVudCAmJiB0eXBlb2YgZmliZXJIb3N0Q29tcG9uZW50LnJlc3RvcmVDb250cm9sbGVkU3RhdGUgPT09ICdmdW5jdGlvbicpID8gaW52YXJpYW50KGZhbHNlLCAnRmliZXIgbmVlZHMgdG8gYmUgaW5qZWN0ZWQgdG8gaGFuZGxlIGEgZmliZXIgdGFyZ2V0IGZvciBjb250cm9sbGVkIGV2ZW50cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgdmFyIHByb3BzID0gZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZShpbnRlcm5hbEluc3RhbmNlLnN0YXRlTm9kZSk7XG4gIGZpYmVySG9zdENvbXBvbmVudC5yZXN0b3JlQ29udHJvbGxlZFN0YXRlKGludGVybmFsSW5zdGFuY2Uuc3RhdGVOb2RlLCBpbnRlcm5hbEluc3RhbmNlLnR5cGUsIHByb3BzKTtcbn1cblxudmFyIGluamVjdGlvbiQzID0gUmVhY3RDb250cm9sbGVkQ29tcG9uZW50SW5qZWN0aW9uO1xuXG5mdW5jdGlvbiBlbnF1ZXVlU3RhdGVSZXN0b3JlKHRhcmdldCkge1xuICBpZiAocmVzdG9yZVRhcmdldCkge1xuICAgIGlmIChyZXN0b3JlUXVldWUpIHtcbiAgICAgIHJlc3RvcmVRdWV1ZS5wdXNoKHRhcmdldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3RvcmVRdWV1ZSA9IFt0YXJnZXRdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXN0b3JlVGFyZ2V0ID0gdGFyZ2V0O1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3RvcmVTdGF0ZUlmTmVlZGVkKCkge1xuICBpZiAoIXJlc3RvcmVUYXJnZXQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHRhcmdldCA9IHJlc3RvcmVUYXJnZXQ7XG4gIHZhciBxdWV1ZWRUYXJnZXRzID0gcmVzdG9yZVF1ZXVlO1xuICByZXN0b3JlVGFyZ2V0ID0gbnVsbDtcbiAgcmVzdG9yZVF1ZXVlID0gbnVsbDtcblxuICByZXN0b3JlU3RhdGVPZlRhcmdldCh0YXJnZXQpO1xuICBpZiAocXVldWVkVGFyZ2V0cykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWVkVGFyZ2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgcmVzdG9yZVN0YXRlT2ZUYXJnZXQocXVldWVkVGFyZ2V0c1tpXSk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdENvbnRyb2xsZWRDb21wb25lbnQgPSBPYmplY3QuZnJlZXplKHtcblx0aW5qZWN0aW9uOiBpbmplY3Rpb24kMyxcblx0ZW5xdWV1ZVN0YXRlUmVzdG9yZTogZW5xdWV1ZVN0YXRlUmVzdG9yZSxcblx0cmVzdG9yZVN0YXRlSWZOZWVkZWQ6IHJlc3RvcmVTdGF0ZUlmTmVlZGVkXG59KTtcblxuLy8gVXNlZCBhcyBhIHdheSB0byBjYWxsIGJhdGNoZWRVcGRhdGVzIHdoZW4gd2UgZG9uJ3QgaGF2ZSBhIHJlZmVyZW5jZSB0b1xuLy8gdGhlIHJlbmRlcmVyLiBTdWNoIGFzIHdoZW4gd2UncmUgZGlzcGF0Y2hpbmcgZXZlbnRzIG9yIGlmIHRoaXJkIHBhcnR5XG4vLyBsaWJyYXJpZXMgbmVlZCB0byBjYWxsIGJhdGNoZWRVcGRhdGVzLiBFdmVudHVhbGx5LCB0aGlzIEFQSSB3aWxsIGdvIGF3YXkgd2hlblxuLy8gZXZlcnl0aGluZyBpcyBiYXRjaGVkIGJ5IGRlZmF1bHQuIFdlJ2xsIHRoZW4gaGF2ZSBhIHNpbWlsYXIgQVBJIHRvIG9wdC1vdXQgb2Zcbi8vIHNjaGVkdWxlZCB3b3JrIGFuZCBpbnN0ZWFkIGRvIHN5bmNocm9ub3VzIHdvcmsuXG5cbi8vIERlZmF1bHRzXG52YXIgZmliZXJCYXRjaGVkVXBkYXRlcyA9IGZ1bmN0aW9uIChmbiwgYm9va2tlZXBpbmcpIHtcbiAgcmV0dXJuIGZuKGJvb2trZWVwaW5nKTtcbn07XG5cbnZhciBpc05lc3RpbmdCYXRjaGVkID0gZmFsc2U7XG5mdW5jdGlvbiBiYXRjaGVkVXBkYXRlcyhmbiwgYm9va2tlZXBpbmcpIHtcbiAgaWYgKGlzTmVzdGluZ0JhdGNoZWQpIHtcbiAgICAvLyBJZiB3ZSBhcmUgY3VycmVudGx5IGluc2lkZSBhbm90aGVyIGJhdGNoLCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgaXRcbiAgICAvLyBmdWxseSBjb21wbGV0ZXMgYmVmb3JlIHJlc3RvcmluZyBzdGF0ZS4gVGhlcmVmb3JlLCB3ZSBhZGQgdGhlIHRhcmdldCB0b1xuICAgIC8vIGEgcXVldWUgb2Ygd29yay5cbiAgICByZXR1cm4gZmliZXJCYXRjaGVkVXBkYXRlcyhmbiwgYm9va2tlZXBpbmcpO1xuICB9XG4gIGlzTmVzdGluZ0JhdGNoZWQgPSB0cnVlO1xuICB0cnkge1xuICAgIHJldHVybiBmaWJlckJhdGNoZWRVcGRhdGVzKGZuLCBib29ra2VlcGluZyk7XG4gIH0gZmluYWxseSB7XG4gICAgLy8gSGVyZSB3ZSB3YWl0IHVudGlsIGFsbCB1cGRhdGVzIGhhdmUgcHJvcGFnYXRlZCwgd2hpY2ggaXMgaW1wb3J0YW50XG4gICAgLy8gd2hlbiB1c2luZyBjb250cm9sbGVkIGNvbXBvbmVudHMgd2l0aGluIGxheWVyczpcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE2OThcbiAgICAvLyBUaGVuIHdlIHJlc3RvcmUgc3RhdGUgb2YgYW55IGNvbnRyb2xsZWQgY29tcG9uZW50LlxuICAgIGlzTmVzdGluZ0JhdGNoZWQgPSBmYWxzZTtcbiAgICByZXN0b3JlU3RhdGVJZk5lZWRlZCgpO1xuICB9XG59XG5cbnZhciBSZWFjdEdlbmVyaWNCYXRjaGluZ0luamVjdGlvbiA9IHtcbiAgaW5qZWN0RmliZXJCYXRjaGVkVXBkYXRlczogZnVuY3Rpb24gKF9iYXRjaGVkVXBkYXRlcykge1xuICAgIGZpYmVyQmF0Y2hlZFVwZGF0ZXMgPSBfYmF0Y2hlZFVwZGF0ZXM7XG4gIH1cbn07XG5cbnZhciBpbmplY3Rpb24kNCA9IFJlYWN0R2VuZXJpY0JhdGNoaW5nSW5qZWN0aW9uO1xuXG4vKipcbiAqIEBzZWUgaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLWlucHV0LWVsZW1lbnQuaHRtbCNpbnB1dC10eXBlLWF0dHItc3VtbWFyeVxuICovXG52YXIgc3VwcG9ydGVkSW5wdXRUeXBlcyA9IHtcbiAgY29sb3I6IHRydWUsXG4gIGRhdGU6IHRydWUsXG4gIGRhdGV0aW1lOiB0cnVlLFxuICAnZGF0ZXRpbWUtbG9jYWwnOiB0cnVlLFxuICBlbWFpbDogdHJ1ZSxcbiAgbW9udGg6IHRydWUsXG4gIG51bWJlcjogdHJ1ZSxcbiAgcGFzc3dvcmQ6IHRydWUsXG4gIHJhbmdlOiB0cnVlLFxuICBzZWFyY2g6IHRydWUsXG4gIHRlbDogdHJ1ZSxcbiAgdGV4dDogdHJ1ZSxcbiAgdGltZTogdHJ1ZSxcbiAgdXJsOiB0cnVlLFxuICB3ZWVrOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBpc1RleHRJbnB1dEVsZW1lbnQoZWxlbSkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtICYmIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gIGlmIChub2RlTmFtZSA9PT0gJ2lucHV0Jykge1xuICAgIHJldHVybiAhIXN1cHBvcnRlZElucHV0VHlwZXNbZWxlbS50eXBlXTtcbiAgfVxuXG4gIGlmIChub2RlTmFtZSA9PT0gJ3RleHRhcmVhJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEhUTUwgbm9kZVR5cGUgdmFsdWVzIHRoYXQgcmVwcmVzZW50IHRoZSB0eXBlIG9mIHRoZSBub2RlXG4gKi9cblxudmFyIEVMRU1FTlRfTk9ERSA9IDE7XG52YXIgVEVYVF9OT0RFID0gMztcbnZhciBDT01NRU5UX05PREUgPSA4O1xudmFyIERPQ1VNRU5UX05PREUgPSA5O1xudmFyIERPQ1VNRU5UX0ZSQUdNRU5UX05PREUgPSAxMTtcblxuLyoqXG4gKiBHZXRzIHRoZSB0YXJnZXQgbm9kZSBmcm9tIGEgbmF0aXZlIGJyb3dzZXIgZXZlbnQgYnkgYWNjb3VudGluZyBmb3JcbiAqIGluY29uc2lzdGVuY2llcyBpbiBicm93c2VyIERPTSBBUElzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge0RPTUV2ZW50VGFyZ2V0fSBUYXJnZXQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gZ2V0RXZlbnRUYXJnZXQobmF0aXZlRXZlbnQpIHtcbiAgdmFyIHRhcmdldCA9IG5hdGl2ZUV2ZW50LnRhcmdldCB8fCBuYXRpdmVFdmVudC5zcmNFbGVtZW50IHx8IHdpbmRvdztcblxuICAvLyBOb3JtYWxpemUgU1ZHIDx1c2U+IGVsZW1lbnQgZXZlbnRzICM0OTYzXG4gIGlmICh0YXJnZXQuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQpIHtcbiAgICB0YXJnZXQgPSB0YXJnZXQuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQ7XG4gIH1cblxuICAvLyBTYWZhcmkgbWF5IGZpcmUgZXZlbnRzIG9uIHRleHQgbm9kZXMgKE5vZGUuVEVYVF9OT0RFIGlzIDMpLlxuICAvLyBAc2VlIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvanMvZXZlbnRzX3Byb3BlcnRpZXMuaHRtbFxuICByZXR1cm4gdGFyZ2V0Lm5vZGVUeXBlID09PSBURVhUX05PREUgPyB0YXJnZXQucGFyZW50Tm9kZSA6IHRhcmdldDtcbn1cblxudmFyIHVzZUhhc0ZlYXR1cmU7XG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIHVzZUhhc0ZlYXR1cmUgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbiAmJiBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlICYmXG4gIC8vIGFsd2F5cyByZXR1cm5zIHRydWUgaW4gbmV3ZXIgYnJvd3NlcnMgYXMgcGVyIHRoZSBzdGFuZGFyZC5cbiAgLy8gQHNlZSBodHRwOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jZG9tLWRvbWltcGxlbWVudGF0aW9uLWhhc2ZlYXR1cmVcbiAgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZSgnJywgJycpICE9PSB0cnVlO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhbiBldmVudCBpcyBzdXBwb3J0ZWQgaW4gdGhlIGN1cnJlbnQgZXhlY3V0aW9uIGVudmlyb25tZW50LlxuICpcbiAqIE5PVEU6IFRoaXMgd2lsbCBub3Qgd29yayBjb3JyZWN0bHkgZm9yIG5vbi1nZW5lcmljIGV2ZW50cyBzdWNoIGFzIGBjaGFuZ2VgLFxuICogYHJlc2V0YCwgYGxvYWRgLCBgZXJyb3JgLCBhbmQgYHNlbGVjdGAuXG4gKlxuICogQm9ycm93cyBmcm9tIE1vZGVybml6ci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lU3VmZml4IEV2ZW50IG5hbWUsIGUuZy4gXCJjbGlja1wiLlxuICogQHBhcmFtIHs/Ym9vbGVhbn0gY2FwdHVyZSBDaGVjayBpZiB0aGUgY2FwdHVyZSBwaGFzZSBpcyBzdXBwb3J0ZWQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBldmVudCBpcyBzdXBwb3J0ZWQuXG4gKiBAaW50ZXJuYWxcbiAqIEBsaWNlbnNlIE1vZGVybml6ciAzLjAuMHByZSAoQ3VzdG9tIEJ1aWxkKSB8IE1JVFxuICovXG5mdW5jdGlvbiBpc0V2ZW50U3VwcG9ydGVkKGV2ZW50TmFtZVN1ZmZpeCwgY2FwdHVyZSkge1xuICBpZiAoIUV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSB8fCBjYXB0dXJlICYmICEoJ2FkZEV2ZW50TGlzdGVuZXInIGluIGRvY3VtZW50KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBldmVudE5hbWUgPSAnb24nICsgZXZlbnROYW1lU3VmZml4O1xuICB2YXIgaXNTdXBwb3J0ZWQgPSBldmVudE5hbWUgaW4gZG9jdW1lbnQ7XG5cbiAgaWYgKCFpc1N1cHBvcnRlZCkge1xuICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoZXZlbnROYW1lLCAncmV0dXJuOycpO1xuICAgIGlzU3VwcG9ydGVkID0gdHlwZW9mIGVsZW1lbnRbZXZlbnROYW1lXSA9PT0gJ2Z1bmN0aW9uJztcbiAgfVxuXG4gIGlmICghaXNTdXBwb3J0ZWQgJiYgdXNlSGFzRmVhdHVyZSAmJiBldmVudE5hbWVTdWZmaXggPT09ICd3aGVlbCcpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBvbmx5IHdheSB0byB0ZXN0IHN1cHBvcnQgZm9yIHRoZSBgd2hlZWxgIGV2ZW50IGluIElFOSsuXG4gICAgaXNTdXBwb3J0ZWQgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKCdFdmVudHMud2hlZWwnLCAnMy4wJyk7XG4gIH1cblxuICByZXR1cm4gaXNTdXBwb3J0ZWQ7XG59XG5cbmZ1bmN0aW9uIGlzQ2hlY2thYmxlKGVsZW0pIHtcbiAgdmFyIHR5cGUgPSBlbGVtLnR5cGU7XG4gIHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWU7XG4gIHJldHVybiBub2RlTmFtZSAmJiBub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnICYmICh0eXBlID09PSAnY2hlY2tib3gnIHx8IHR5cGUgPT09ICdyYWRpbycpO1xufVxuXG5mdW5jdGlvbiBnZXRUcmFja2VyKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuX3ZhbHVlVHJhY2tlcjtcbn1cblxuZnVuY3Rpb24gZGV0YWNoVHJhY2tlcihub2RlKSB7XG4gIG5vZGUuX3ZhbHVlVHJhY2tlciA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldFZhbHVlRnJvbU5vZGUobm9kZSkge1xuICB2YXIgdmFsdWUgPSAnJztcbiAgaWYgKCFub2RlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgaWYgKGlzQ2hlY2thYmxlKG5vZGUpKSB7XG4gICAgdmFsdWUgPSBub2RlLmNoZWNrZWQgPyAndHJ1ZScgOiAnZmFsc2UnO1xuICB9IGVsc2Uge1xuICAgIHZhbHVlID0gbm9kZS52YWx1ZTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gdHJhY2tWYWx1ZU9uTm9kZShub2RlKSB7XG4gIHZhciB2YWx1ZUZpZWxkID0gaXNDaGVja2FibGUobm9kZSkgPyAnY2hlY2tlZCcgOiAndmFsdWUnO1xuICB2YXIgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iobm9kZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHZhbHVlRmllbGQpO1xuXG4gIHZhciBjdXJyZW50VmFsdWUgPSAnJyArIG5vZGVbdmFsdWVGaWVsZF07XG5cbiAgLy8gaWYgc29tZW9uZSBoYXMgYWxyZWFkeSBkZWZpbmVkIGEgdmFsdWUgb3IgU2FmYXJpLCB0aGVuIGJhaWxcbiAgLy8gYW5kIGRvbid0IHRyYWNrIHZhbHVlIHdpbGwgY2F1c2Ugb3ZlciByZXBvcnRpbmcgb2YgY2hhbmdlcyxcbiAgLy8gYnV0IGl0J3MgYmV0dGVyIHRoZW4gYSBoYXJkIGZhaWx1cmVcbiAgLy8gKG5lZWRlZCBmb3IgY2VydGFpbiB0ZXN0cyB0aGF0IHNweU9uIGlucHV0IHZhbHVlcyBhbmQgU2FmYXJpKVxuICBpZiAobm9kZS5oYXNPd25Qcm9wZXJ0eSh2YWx1ZUZpZWxkKSB8fCB0eXBlb2YgZGVzY3JpcHRvci5nZXQgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGRlc2NyaXB0b3Iuc2V0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5vZGUsIHZhbHVlRmllbGQsIHtcbiAgICBlbnVtZXJhYmxlOiBkZXNjcmlwdG9yLmVudW1lcmFibGUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGRlc2NyaXB0b3IuZ2V0LmNhbGwodGhpcyk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgY3VycmVudFZhbHVlID0gJycgKyB2YWx1ZTtcbiAgICAgIGRlc2NyaXB0b3Iuc2V0LmNhbGwodGhpcywgdmFsdWUpO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIHRyYWNrZXIgPSB7XG4gICAgZ2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBjdXJyZW50VmFsdWU7XG4gICAgfSxcbiAgICBzZXRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBjdXJyZW50VmFsdWUgPSAnJyArIHZhbHVlO1xuICAgIH0sXG4gICAgc3RvcFRyYWNraW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICBkZXRhY2hUcmFja2VyKG5vZGUpO1xuICAgICAgZGVsZXRlIG5vZGVbdmFsdWVGaWVsZF07XG4gICAgfVxuICB9O1xuICByZXR1cm4gdHJhY2tlcjtcbn1cblxuZnVuY3Rpb24gdHJhY2sobm9kZSkge1xuICBpZiAoZ2V0VHJhY2tlcihub2RlKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFRPRE86IE9uY2UgaXQncyBqdXN0IEZpYmVyIHdlIGNhbiBtb3ZlIHRoaXMgdG8gbm9kZS5fd3JhcHBlclN0YXRlXG4gIG5vZGUuX3ZhbHVlVHJhY2tlciA9IHRyYWNrVmFsdWVPbk5vZGUobm9kZSk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVZhbHVlSWZDaGFuZ2VkKG5vZGUpIHtcbiAgaWYgKCFub2RlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHRyYWNrZXIgPSBnZXRUcmFja2VyKG5vZGUpO1xuICAvLyBpZiB0aGVyZSBpcyBubyB0cmFja2VyIGF0IHRoaXMgcG9pbnQgaXQncyB1bmxpa2VseVxuICAvLyB0aGF0IHRyeWluZyBhZ2FpbiB3aWxsIHN1Y2NlZWRcbiAgaWYgKCF0cmFja2VyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIgbGFzdFZhbHVlID0gdHJhY2tlci5nZXRWYWx1ZSgpO1xuICB2YXIgbmV4dFZhbHVlID0gZ2V0VmFsdWVGcm9tTm9kZShub2RlKTtcbiAgaWYgKG5leHRWYWx1ZSAhPT0gbGFzdFZhbHVlKSB7XG4gICAgdHJhY2tlci5zZXRWYWx1ZShuZXh0VmFsdWUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIGV2ZW50VHlwZXMkMSA9IHtcbiAgY2hhbmdlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6ICdvbkNoYW5nZScsXG4gICAgICBjYXB0dXJlZDogJ29uQ2hhbmdlQ2FwdHVyZSdcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogWyd0b3BCbHVyJywgJ3RvcENoYW5nZScsICd0b3BDbGljaycsICd0b3BGb2N1cycsICd0b3BJbnB1dCcsICd0b3BLZXlEb3duJywgJ3RvcEtleVVwJywgJ3RvcFNlbGVjdGlvbkNoYW5nZSddXG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUFuZEFjY3VtdWxhdGVDaGFuZ2VFdmVudChpbnN0LCBuYXRpdmVFdmVudCwgdGFyZ2V0KSB7XG4gIHZhciBldmVudCA9IFN5bnRoZXRpY0V2ZW50JDEuZ2V0UG9vbGVkKGV2ZW50VHlwZXMkMS5jaGFuZ2UsIGluc3QsIG5hdGl2ZUV2ZW50LCB0YXJnZXQpO1xuICBldmVudC50eXBlID0gJ2NoYW5nZSc7XG4gIC8vIEZsYWcgdGhpcyBldmVudCBsb29wIGFzIG5lZWRpbmcgc3RhdGUgcmVzdG9yZS5cbiAgZW5xdWV1ZVN0YXRlUmVzdG9yZSh0YXJnZXQpO1xuICBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgcmV0dXJuIGV2ZW50O1xufVxuLyoqXG4gKiBGb3IgSUUgc2hpbXNcbiAqL1xudmFyIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xudmFyIGFjdGl2ZUVsZW1lbnRJbnN0ID0gbnVsbDtcblxuLyoqXG4gKiBTRUNUSU9OOiBoYW5kbGUgYGNoYW5nZWAgZXZlbnRcbiAqL1xuZnVuY3Rpb24gc2hvdWxkVXNlQ2hhbmdlRXZlbnQoZWxlbSkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIG5vZGVOYW1lID09PSAnc2VsZWN0JyB8fCBub2RlTmFtZSA9PT0gJ2lucHV0JyAmJiBlbGVtLnR5cGUgPT09ICdmaWxlJztcbn1cblxuZnVuY3Rpb24gbWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudChuYXRpdmVFdmVudCkge1xuICB2YXIgZXZlbnQgPSBjcmVhdGVBbmRBY2N1bXVsYXRlQ2hhbmdlRXZlbnQoYWN0aXZlRWxlbWVudEluc3QsIG5hdGl2ZUV2ZW50LCBnZXRFdmVudFRhcmdldChuYXRpdmVFdmVudCkpO1xuXG4gIC8vIElmIGNoYW5nZSBhbmQgcHJvcGVydHljaGFuZ2UgYnViYmxlZCwgd2UnZCBqdXN0IGJpbmQgdG8gaXQgbGlrZSBhbGwgdGhlXG4gIC8vIG90aGVyIGV2ZW50cyBhbmQgaGF2ZSBpdCBnbyB0aHJvdWdoIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci4gU2luY2UgaXRcbiAgLy8gZG9lc24ndCwgd2UgbWFudWFsbHkgbGlzdGVuIGZvciB0aGUgZXZlbnRzIGFuZCBzbyB3ZSBoYXZlIHRvIGVucXVldWUgYW5kXG4gIC8vIHByb2Nlc3MgdGhlIGFic3RyYWN0IGV2ZW50IG1hbnVhbGx5LlxuICAvL1xuICAvLyBCYXRjaGluZyBpcyBuZWNlc3NhcnkgaGVyZSBpbiBvcmRlciB0byBlbnN1cmUgdGhhdCBhbGwgZXZlbnQgaGFuZGxlcnMgcnVuXG4gIC8vIGJlZm9yZSB0aGUgbmV4dCByZXJlbmRlciAoaW5jbHVkaW5nIGV2ZW50IGhhbmRsZXJzIGF0dGFjaGVkIHRvIGFuY2VzdG9yXG4gIC8vIGVsZW1lbnRzIGluc3RlYWQgb2YgZGlyZWN0bHkgb24gdGhlIGlucHV0KS4gV2l0aG91dCB0aGlzLCBjb250cm9sbGVkXG4gIC8vIGNvbXBvbmVudHMgZG9uJ3Qgd29yayBwcm9wZXJseSBpbiBjb25qdW5jdGlvbiB3aXRoIGV2ZW50IGJ1YmJsaW5nIGJlY2F1c2VcbiAgLy8gdGhlIGNvbXBvbmVudCBpcyByZXJlbmRlcmVkIGFuZCB0aGUgdmFsdWUgcmV2ZXJ0ZWQgYmVmb3JlIGFsbCB0aGUgZXZlbnRcbiAgLy8gaGFuZGxlcnMgY2FuIHJ1bi4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzA4LlxuICBiYXRjaGVkVXBkYXRlcyhydW5FdmVudEluQmF0Y2gsIGV2ZW50KTtcbn1cblxuZnVuY3Rpb24gcnVuRXZlbnRJbkJhdGNoKGV2ZW50KSB7XG4gIGVucXVldWVFdmVudHMoZXZlbnQpO1xuICBwcm9jZXNzRXZlbnRRdWV1ZShmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIGdldEluc3RJZlZhbHVlQ2hhbmdlZCh0YXJnZXRJbnN0KSB7XG4gIHZhciB0YXJnZXROb2RlID0gZ2V0Tm9kZUZyb21JbnN0YW5jZSQxKHRhcmdldEluc3QpO1xuICBpZiAodXBkYXRlVmFsdWVJZkNoYW5nZWQodGFyZ2V0Tm9kZSkpIHtcbiAgICByZXR1cm4gdGFyZ2V0SW5zdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9yQ2hhbmdlRXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0KSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BDaGFuZ2UnKSB7XG4gICAgcmV0dXJuIHRhcmdldEluc3Q7XG4gIH1cbn1cblxuLyoqXG4gKiBTRUNUSU9OOiBoYW5kbGUgYGlucHV0YCBldmVudFxuICovXG52YXIgaXNJbnB1dEV2ZW50U3VwcG9ydGVkID0gZmFsc2U7XG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIC8vIElFOSBjbGFpbXMgdG8gc3VwcG9ydCB0aGUgaW5wdXQgZXZlbnQgYnV0IGZhaWxzIHRvIHRyaWdnZXIgaXQgd2hlblxuICAvLyBkZWxldGluZyB0ZXh0LCBzbyB3ZSBpZ25vcmUgaXRzIGlucHV0IGV2ZW50cy5cbiAgaXNJbnB1dEV2ZW50U3VwcG9ydGVkID0gaXNFdmVudFN1cHBvcnRlZCgnaW5wdXQnKSAmJiAoIWRvY3VtZW50LmRvY3VtZW50TW9kZSB8fCBkb2N1bWVudC5kb2N1bWVudE1vZGUgPiA5KTtcbn1cblxuLyoqXG4gKiAoRm9yIElFIDw9OSkgU3RhcnRzIHRyYWNraW5nIHByb3BlcnR5Y2hhbmdlIGV2ZW50cyBvbiB0aGUgcGFzc2VkLWluIGVsZW1lbnRcbiAqIGFuZCBvdmVycmlkZSB0aGUgdmFsdWUgcHJvcGVydHkgc28gdGhhdCB3ZSBjYW4gZGlzdGluZ3Vpc2ggdXNlciBldmVudHMgZnJvbVxuICogdmFsdWUgY2hhbmdlcyBpbiBKUy5cbiAqL1xuZnVuY3Rpb24gc3RhcnRXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKHRhcmdldCwgdGFyZ2V0SW5zdCkge1xuICBhY3RpdmVFbGVtZW50ID0gdGFyZ2V0O1xuICBhY3RpdmVFbGVtZW50SW5zdCA9IHRhcmdldEluc3Q7XG4gIGFjdGl2ZUVsZW1lbnQuYXR0YWNoRXZlbnQoJ29ucHJvcGVydHljaGFuZ2UnLCBoYW5kbGVQcm9wZXJ0eUNoYW5nZSk7XG59XG5cbi8qKlxuICogKEZvciBJRSA8PTkpIFJlbW92ZXMgdGhlIGV2ZW50IGxpc3RlbmVycyBmcm9tIHRoZSBjdXJyZW50bHktdHJhY2tlZCBlbGVtZW50LFxuICogaWYgYW55IGV4aXN0cy5cbiAqL1xuZnVuY3Rpb24gc3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UoKSB7XG4gIGlmICghYWN0aXZlRWxlbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICBhY3RpdmVFbGVtZW50LmRldGFjaEV2ZW50KCdvbnByb3BlcnR5Y2hhbmdlJywgaGFuZGxlUHJvcGVydHlDaGFuZ2UpO1xuICBhY3RpdmVFbGVtZW50ID0gbnVsbDtcbiAgYWN0aXZlRWxlbWVudEluc3QgPSBudWxsO1xufVxuXG4vKipcbiAqIChGb3IgSUUgPD05KSBIYW5kbGVzIGEgcHJvcGVydHljaGFuZ2UgZXZlbnQsIHNlbmRpbmcgYSBgY2hhbmdlYCBldmVudCBpZlxuICogdGhlIHZhbHVlIG9mIHRoZSBhY3RpdmUgZWxlbWVudCBoYXMgY2hhbmdlZC5cbiAqL1xuZnVuY3Rpb24gaGFuZGxlUHJvcGVydHlDaGFuZ2UobmF0aXZlRXZlbnQpIHtcbiAgaWYgKG5hdGl2ZUV2ZW50LnByb3BlcnR5TmFtZSAhPT0gJ3ZhbHVlJykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKGFjdGl2ZUVsZW1lbnRJbnN0KSkge1xuICAgIG1hbnVhbERpc3BhdGNoQ2hhbmdlRXZlbnQobmF0aXZlRXZlbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUV2ZW50c0ZvcklucHV0RXZlbnRQb2x5ZmlsbCh0b3BMZXZlbFR5cGUsIHRhcmdldCwgdGFyZ2V0SW5zdCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wRm9jdXMnKSB7XG4gICAgLy8gSW4gSUU5LCBwcm9wZXJ0eWNoYW5nZSBmaXJlcyBmb3IgbW9zdCBpbnB1dCBldmVudHMgYnV0IGlzIGJ1Z2d5IGFuZFxuICAgIC8vIGRvZXNuJ3QgZmlyZSB3aGVuIHRleHQgaXMgZGVsZXRlZCwgYnV0IGNvbnZlbmllbnRseSwgc2VsZWN0aW9uY2hhbmdlXG4gICAgLy8gYXBwZWFycyB0byBmaXJlIGluIGFsbCBvZiB0aGUgcmVtYWluaW5nIGNhc2VzIHNvIHdlIGNhdGNoIHRob3NlIGFuZFxuICAgIC8vIGZvcndhcmQgdGhlIGV2ZW50IGlmIHRoZSB2YWx1ZSBoYXMgY2hhbmdlZFxuICAgIC8vIEluIGVpdGhlciBjYXNlLCB3ZSBkb24ndCB3YW50IHRvIGNhbGwgdGhlIGV2ZW50IGhhbmRsZXIgaWYgdGhlIHZhbHVlXG4gICAgLy8gaXMgY2hhbmdlZCBmcm9tIEpTIHNvIHdlIHJlZGVmaW5lIGEgc2V0dGVyIGZvciBgLnZhbHVlYCB0aGF0IHVwZGF0ZXNcbiAgICAvLyBvdXIgYWN0aXZlRWxlbWVudFZhbHVlIHZhcmlhYmxlLCBhbGxvd2luZyB1cyB0byBpZ25vcmUgdGhvc2UgY2hhbmdlc1xuICAgIC8vXG4gICAgLy8gc3RvcFdhdGNoaW5nKCkgc2hvdWxkIGJlIGEgbm9vcCBoZXJlIGJ1dCB3ZSBjYWxsIGl0IGp1c3QgaW4gY2FzZSB3ZVxuICAgIC8vIG1pc3NlZCBhIGJsdXIgZXZlbnQgc29tZWhvdy5cbiAgICBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpO1xuICAgIHN0YXJ0V2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSh0YXJnZXQsIHRhcmdldEluc3QpO1xuICB9IGVsc2UgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcEJsdXInKSB7XG4gICAgc3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UoKTtcbiAgfVxufVxuXG4vLyBGb3IgSUU4IGFuZCBJRTkuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRFdmVudFBvbHlmaWxsKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wU2VsZWN0aW9uQ2hhbmdlJyB8fCB0b3BMZXZlbFR5cGUgPT09ICd0b3BLZXlVcCcgfHwgdG9wTGV2ZWxUeXBlID09PSAndG9wS2V5RG93bicpIHtcbiAgICAvLyBPbiB0aGUgc2VsZWN0aW9uY2hhbmdlIGV2ZW50LCB0aGUgdGFyZ2V0IGlzIGp1c3QgZG9jdW1lbnQgd2hpY2ggaXNuJ3RcbiAgICAvLyBoZWxwZnVsIGZvciB1cyBzbyBqdXN0IGNoZWNrIGFjdGl2ZUVsZW1lbnQgaW5zdGVhZC5cbiAgICAvL1xuICAgIC8vIDk5JSBvZiB0aGUgdGltZSwga2V5ZG93biBhbmQga2V5dXAgYXJlbid0IG5lY2Vzc2FyeS4gSUU4IGZhaWxzIHRvIGZpcmVcbiAgICAvLyBwcm9wZXJ0eWNoYW5nZSBvbiB0aGUgZmlyc3QgaW5wdXQgZXZlbnQgYWZ0ZXIgc2V0dGluZyBgdmFsdWVgIGZyb20gYVxuICAgIC8vIHNjcmlwdCBhbmQgZmlyZXMgb25seSBrZXlkb3duLCBrZXlwcmVzcywga2V5dXAuIENhdGNoaW5nIGtleXVwIHVzdWFsbHlcbiAgICAvLyBnZXRzIGl0IGFuZCBjYXRjaGluZyBrZXlkb3duIGxldHMgdXMgZmlyZSBhbiBldmVudCBmb3IgdGhlIGZpcnN0XG4gICAgLy8ga2V5c3Ryb2tlIGlmIHVzZXIgZG9lcyBhIGtleSByZXBlYXQgKGl0J2xsIGJlIGEgbGl0dGxlIGRlbGF5ZWQ6IHJpZ2h0XG4gICAgLy8gYmVmb3JlIHRoZSBzZWNvbmQga2V5c3Ryb2tlKS4gT3RoZXIgaW5wdXQgbWV0aG9kcyAoZS5nLiwgcGFzdGUpIHNlZW0gdG9cbiAgICAvLyBmaXJlIHNlbGVjdGlvbmNoYW5nZSBub3JtYWxseS5cbiAgICByZXR1cm4gZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKGFjdGl2ZUVsZW1lbnRJbnN0KTtcbiAgfVxufVxuXG4vKipcbiAqIFNFQ1RJT046IGhhbmRsZSBgY2xpY2tgIGV2ZW50XG4gKi9cbmZ1bmN0aW9uIHNob3VsZFVzZUNsaWNrRXZlbnQoZWxlbSkge1xuICAvLyBVc2UgdGhlIGBjbGlja2AgZXZlbnQgdG8gZGV0ZWN0IGNoYW5nZXMgdG8gY2hlY2tib3ggYW5kIHJhZGlvIGlucHV0cy5cbiAgLy8gVGhpcyBhcHByb2FjaCB3b3JrcyBhY3Jvc3MgYWxsIGJyb3dzZXJzLCB3aGVyZWFzIGBjaGFuZ2VgIGRvZXMgbm90IGZpcmVcbiAgLy8gdW50aWwgYGJsdXJgIGluIElFOC5cbiAgdmFyIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZTtcbiAgcmV0dXJuIG5vZGVOYW1lICYmIG5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcgJiYgKGVsZW0udHlwZSA9PT0gJ2NoZWNrYm94JyB8fCBlbGVtLnR5cGUgPT09ICdyYWRpbycpO1xufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9yQ2xpY2tFdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcENsaWNrJykge1xuICAgIHJldHVybiBnZXRJbnN0SWZWYWx1ZUNoYW5nZWQodGFyZ2V0SW5zdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0VGFyZ2V0SW5zdEZvcklucHV0T3JDaGFuZ2VFdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcElucHV0JyB8fCB0b3BMZXZlbFR5cGUgPT09ICd0b3BDaGFuZ2UnKSB7XG4gICAgcmV0dXJuIGdldEluc3RJZlZhbHVlQ2hhbmdlZCh0YXJnZXRJbnN0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVDb250cm9sbGVkSW5wdXRCbHVyKGluc3QsIG5vZGUpIHtcbiAgLy8gVE9ETzogSW4gSUUsIGluc3QgaXMgb2NjYXNpb25hbGx5IG51bGwuIFdoeT9cbiAgaWYgKGluc3QgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEZpYmVyIGFuZCBSZWFjdERPTSBrZWVwIHdyYXBwZXIgc3RhdGUgaW4gc2VwYXJhdGUgcGxhY2VzXG4gIHZhciBzdGF0ZSA9IGluc3QuX3dyYXBwZXJTdGF0ZSB8fCBub2RlLl93cmFwcGVyU3RhdGU7XG5cbiAgaWYgKCFzdGF0ZSB8fCAhc3RhdGUuY29udHJvbGxlZCB8fCBub2RlLnR5cGUgIT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gSWYgY29udHJvbGxlZCwgYXNzaWduIHRoZSB2YWx1ZSBhdHRyaWJ1dGUgdG8gdGhlIGN1cnJlbnQgdmFsdWUgb24gYmx1clxuICB2YXIgdmFsdWUgPSAnJyArIG5vZGUudmFsdWU7XG4gIGlmIChub2RlLmdldEF0dHJpYnV0ZSgndmFsdWUnKSAhPT0gdmFsdWUpIHtcbiAgICBub2RlLnNldEF0dHJpYnV0ZSgndmFsdWUnLCB2YWx1ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIHBsdWdpbiBjcmVhdGVzIGFuIGBvbkNoYW5nZWAgZXZlbnQgdGhhdCBub3JtYWxpemVzIGNoYW5nZSBldmVudHNcbiAqIGFjcm9zcyBmb3JtIGVsZW1lbnRzLiBUaGlzIGV2ZW50IGZpcmVzIGF0IGEgdGltZSB3aGVuIGl0J3MgcG9zc2libGUgdG9cbiAqIGNoYW5nZSB0aGUgZWxlbWVudCdzIHZhbHVlIHdpdGhvdXQgc2VlaW5nIGEgZmxpY2tlci5cbiAqXG4gKiBTdXBwb3J0ZWQgZWxlbWVudHMgYXJlOlxuICogLSBpbnB1dCAoc2VlIGBpc1RleHRJbnB1dEVsZW1lbnRgKVxuICogLSB0ZXh0YXJlYVxuICogLSBzZWxlY3RcbiAqL1xudmFyIENoYW5nZUV2ZW50UGx1Z2luID0ge1xuICBldmVudFR5cGVzOiBldmVudFR5cGVzJDEsXG5cbiAgX2lzSW5wdXRFdmVudFN1cHBvcnRlZDogaXNJbnB1dEV2ZW50U3VwcG9ydGVkLFxuXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHZhciB0YXJnZXROb2RlID0gdGFyZ2V0SW5zdCA/IGdldE5vZGVGcm9tSW5zdGFuY2UkMSh0YXJnZXRJbnN0KSA6IHdpbmRvdztcblxuICAgIHZhciBnZXRUYXJnZXRJbnN0RnVuYywgaGFuZGxlRXZlbnRGdW5jO1xuICAgIGlmIChzaG91bGRVc2VDaGFuZ2VFdmVudCh0YXJnZXROb2RlKSkge1xuICAgICAgZ2V0VGFyZ2V0SW5zdEZ1bmMgPSBnZXRUYXJnZXRJbnN0Rm9yQ2hhbmdlRXZlbnQ7XG4gICAgfSBlbHNlIGlmIChpc1RleHRJbnB1dEVsZW1lbnQodGFyZ2V0Tm9kZSkpIHtcbiAgICAgIGlmIChpc0lucHV0RXZlbnRTdXBwb3J0ZWQpIHtcbiAgICAgICAgZ2V0VGFyZ2V0SW5zdEZ1bmMgPSBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRPckNoYW5nZUV2ZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2V0VGFyZ2V0SW5zdEZ1bmMgPSBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRFdmVudFBvbHlmaWxsO1xuICAgICAgICBoYW5kbGVFdmVudEZ1bmMgPSBoYW5kbGVFdmVudHNGb3JJbnB1dEV2ZW50UG9seWZpbGw7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzaG91bGRVc2VDbGlja0V2ZW50KHRhcmdldE5vZGUpKSB7XG4gICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JDbGlja0V2ZW50O1xuICAgIH1cblxuICAgIGlmIChnZXRUYXJnZXRJbnN0RnVuYykge1xuICAgICAgdmFyIGluc3QgPSBnZXRUYXJnZXRJbnN0RnVuYyh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QpO1xuICAgICAgaWYgKGluc3QpIHtcbiAgICAgICAgdmFyIGV2ZW50ID0gY3JlYXRlQW5kQWNjdW11bGF0ZUNoYW5nZUV2ZW50KGluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaGFuZGxlRXZlbnRGdW5jKSB7XG4gICAgICBoYW5kbGVFdmVudEZ1bmModG9wTGV2ZWxUeXBlLCB0YXJnZXROb2RlLCB0YXJnZXRJbnN0KTtcbiAgICB9XG5cbiAgICAvLyBXaGVuIGJsdXJyaW5nLCBzZXQgdGhlIHZhbHVlIGF0dHJpYnV0ZSBmb3IgbnVtYmVyIGlucHV0c1xuICAgIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BCbHVyJykge1xuICAgICAgaGFuZGxlQ29udHJvbGxlZElucHV0Qmx1cih0YXJnZXRJbnN0LCB0YXJnZXROb2RlKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogTW9kdWxlIHRoYXQgaXMgaW5qZWN0YWJsZSBpbnRvIGBFdmVudFBsdWdpbkh1YmAsIHRoYXQgc3BlY2lmaWVzIGFcbiAqIGRldGVybWluaXN0aWMgb3JkZXJpbmcgb2YgYEV2ZW50UGx1Z2luYHMuIEEgY29udmVuaWVudCB3YXkgdG8gcmVhc29uIGFib3V0XG4gKiBwbHVnaW5zLCB3aXRob3V0IGhhdmluZyB0byBwYWNrYWdlIGV2ZXJ5IG9uZSBvZiB0aGVtLiBUaGlzIGlzIGJldHRlciB0aGFuXG4gKiBoYXZpbmcgcGx1Z2lucyBiZSBvcmRlcmVkIGluIHRoZSBzYW1lIG9yZGVyIHRoYXQgdGhleSBhcmUgaW5qZWN0ZWQgYmVjYXVzZVxuICogdGhhdCBvcmRlcmluZyB3b3VsZCBiZSBpbmZsdWVuY2VkIGJ5IHRoZSBwYWNrYWdpbmcgb3JkZXIuXG4gKiBgUmVzcG9uZGVyRXZlbnRQbHVnaW5gIG11c3Qgb2NjdXIgYmVmb3JlIGBTaW1wbGVFdmVudFBsdWdpbmAgc28gdGhhdFxuICogcHJldmVudGluZyBkZWZhdWx0IG9uIGV2ZW50cyBpcyBjb252ZW5pZW50IGluIGBTaW1wbGVFdmVudFBsdWdpbmAgaGFuZGxlcnMuXG4gKi9cbnZhciBET01FdmVudFBsdWdpbk9yZGVyID0gWydSZXNwb25kZXJFdmVudFBsdWdpbicsICdTaW1wbGVFdmVudFBsdWdpbicsICdUYXBFdmVudFBsdWdpbicsICdFbnRlckxlYXZlRXZlbnRQbHVnaW4nLCAnQ2hhbmdlRXZlbnRQbHVnaW4nLCAnU2VsZWN0RXZlbnRQbHVnaW4nLCAnQmVmb3JlSW5wdXRFdmVudFBsdWdpbiddO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgVUlFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBVSUV2ZW50SW50ZXJmYWNlID0ge1xuICB2aWV3OiBudWxsLFxuICBkZXRhaWw6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNVSUV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNFdmVudCQxLmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNFdmVudCQxLmF1Z21lbnRDbGFzcyhTeW50aGV0aWNVSUV2ZW50LCBVSUV2ZW50SW50ZXJmYWNlKTtcblxuLyoqXG4gKiBUcmFuc2xhdGlvbiBmcm9tIG1vZGlmaWVyIGtleSB0byB0aGUgYXNzb2NpYXRlZCBwcm9wZXJ0eSBpbiB0aGUgZXZlbnQuXG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8ja2V5cy1Nb2RpZmllcnNcbiAqL1xuXG52YXIgbW9kaWZpZXJLZXlUb1Byb3AgPSB7XG4gIEFsdDogJ2FsdEtleScsXG4gIENvbnRyb2w6ICdjdHJsS2V5JyxcbiAgTWV0YTogJ21ldGFLZXknLFxuICBTaGlmdDogJ3NoaWZ0S2V5J1xufTtcblxuLy8gSUU4IGRvZXMgbm90IGltcGxlbWVudCBnZXRNb2RpZmllclN0YXRlIHNvIHdlIHNpbXBseSBtYXAgaXQgdG8gdGhlIG9ubHlcbi8vIG1vZGlmaWVyIGtleXMgZXhwb3NlZCBieSB0aGUgZXZlbnQgaXRzZWxmLCBkb2VzIG5vdCBzdXBwb3J0IExvY2sta2V5cy5cbi8vIEN1cnJlbnRseSwgYWxsIG1ham9yIGJyb3dzZXJzIGV4Y2VwdCBDaHJvbWUgc2VlbXMgdG8gc3VwcG9ydCBMb2NrLWtleXMuXG5mdW5jdGlvbiBtb2RpZmllclN0YXRlR2V0dGVyKGtleUFyZykge1xuICB2YXIgc3ludGhldGljRXZlbnQgPSB0aGlzO1xuICB2YXIgbmF0aXZlRXZlbnQgPSBzeW50aGV0aWNFdmVudC5uYXRpdmVFdmVudDtcbiAgaWYgKG5hdGl2ZUV2ZW50LmdldE1vZGlmaWVyU3RhdGUpIHtcbiAgICByZXR1cm4gbmF0aXZlRXZlbnQuZ2V0TW9kaWZpZXJTdGF0ZShrZXlBcmcpO1xuICB9XG4gIHZhciBrZXlQcm9wID0gbW9kaWZpZXJLZXlUb1Byb3Bba2V5QXJnXTtcbiAgcmV0dXJuIGtleVByb3AgPyAhIW5hdGl2ZUV2ZW50W2tleVByb3BdIDogZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldEV2ZW50TW9kaWZpZXJTdGF0ZShuYXRpdmVFdmVudCkge1xuICByZXR1cm4gbW9kaWZpZXJTdGF0ZUdldHRlcjtcbn1cblxuLyoqXG4gKiBAaW50ZXJmYWNlIE1vdXNlRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgTW91c2VFdmVudEludGVyZmFjZSA9IHtcbiAgc2NyZWVuWDogbnVsbCxcbiAgc2NyZWVuWTogbnVsbCxcbiAgY2xpZW50WDogbnVsbCxcbiAgY2xpZW50WTogbnVsbCxcbiAgcGFnZVg6IG51bGwsXG4gIHBhZ2VZOiBudWxsLFxuICBjdHJsS2V5OiBudWxsLFxuICBzaGlmdEtleTogbnVsbCxcbiAgYWx0S2V5OiBudWxsLFxuICBtZXRhS2V5OiBudWxsLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGUsXG4gIGJ1dHRvbjogbnVsbCxcbiAgYnV0dG9uczogbnVsbCxcbiAgcmVsYXRlZFRhcmdldDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgKGV2ZW50LmZyb21FbGVtZW50ID09PSBldmVudC5zcmNFbGVtZW50ID8gZXZlbnQudG9FbGVtZW50IDogZXZlbnQuZnJvbUVsZW1lbnQpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNNb3VzZUV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNVSUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNVSUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNNb3VzZUV2ZW50LCBNb3VzZUV2ZW50SW50ZXJmYWNlKTtcblxudmFyIGV2ZW50VHlwZXMkMiA9IHtcbiAgbW91c2VFbnRlcjoge1xuICAgIHJlZ2lzdHJhdGlvbk5hbWU6ICdvbk1vdXNlRW50ZXInLFxuICAgIGRlcGVuZGVuY2llczogWyd0b3BNb3VzZU91dCcsICd0b3BNb3VzZU92ZXInXVxuICB9LFxuICBtb3VzZUxlYXZlOiB7XG4gICAgcmVnaXN0cmF0aW9uTmFtZTogJ29uTW91c2VMZWF2ZScsXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcE1vdXNlT3V0JywgJ3RvcE1vdXNlT3ZlciddXG4gIH1cbn07XG5cbnZhciBFbnRlckxlYXZlRXZlbnRQbHVnaW4gPSB7XG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMkMixcblxuICAvKipcbiAgICogRm9yIGFsbW9zdCBldmVyeSBpbnRlcmFjdGlvbiB3ZSBjYXJlIGFib3V0LCB0aGVyZSB3aWxsIGJlIGJvdGggYSB0b3AtbGV2ZWxcbiAgICogYG1vdXNlb3ZlcmAgYW5kIGBtb3VzZW91dGAgZXZlbnQgdGhhdCBvY2N1cnMuIE9ubHkgdXNlIGBtb3VzZW91dGAgc28gdGhhdFxuICAgKiB3ZSBkbyBub3QgZXh0cmFjdCBkdXBsaWNhdGUgZXZlbnRzLiBIb3dldmVyLCBtb3ZpbmcgdGhlIG1vdXNlIGludG8gdGhlXG4gICAqIGJyb3dzZXIgZnJvbSBvdXRzaWRlIHdpbGwgbm90IGZpcmUgYSBgbW91c2VvdXRgIGV2ZW50LiBJbiB0aGlzIGNhc2UsIHdlIHVzZVxuICAgKiB0aGUgYG1vdXNlb3ZlcmAgdG9wLWxldmVsIGV2ZW50LlxuICAgKi9cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcE1vdXNlT3ZlcicgJiYgKG5hdGl2ZUV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgbmF0aXZlRXZlbnQuZnJvbUVsZW1lbnQpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRvcExldmVsVHlwZSAhPT0gJ3RvcE1vdXNlT3V0JyAmJiB0b3BMZXZlbFR5cGUgIT09ICd0b3BNb3VzZU92ZXInKSB7XG4gICAgICAvLyBNdXN0IG5vdCBiZSBhIG1vdXNlIGluIG9yIG1vdXNlIG91dCAtIGlnbm9yaW5nLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHdpbjtcbiAgICBpZiAobmF0aXZlRXZlbnRUYXJnZXQud2luZG93ID09PSBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgICAgLy8gYG5hdGl2ZUV2ZW50VGFyZ2V0YCBpcyBwcm9iYWJseSBhIHdpbmRvdyBvYmplY3QuXG4gICAgICB3aW4gPSBuYXRpdmVFdmVudFRhcmdldDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVE9ETzogRmlndXJlIG91dCB3aHkgYG93bmVyRG9jdW1lbnRgIGlzIHNvbWV0aW1lcyB1bmRlZmluZWQgaW4gSUU4LlxuICAgICAgdmFyIGRvYyA9IG5hdGl2ZUV2ZW50VGFyZ2V0Lm93bmVyRG9jdW1lbnQ7XG4gICAgICBpZiAoZG9jKSB7XG4gICAgICAgIHdpbiA9IGRvYy5kZWZhdWx0VmlldyB8fCBkb2MucGFyZW50V2luZG93O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2luID0gd2luZG93O1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBmcm9tO1xuICAgIHZhciB0bztcbiAgICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wTW91c2VPdXQnKSB7XG4gICAgICBmcm9tID0gdGFyZ2V0SW5zdDtcbiAgICAgIHZhciByZWxhdGVkID0gbmF0aXZlRXZlbnQucmVsYXRlZFRhcmdldCB8fCBuYXRpdmVFdmVudC50b0VsZW1lbnQ7XG4gICAgICB0byA9IHJlbGF0ZWQgPyBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShyZWxhdGVkKSA6IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE1vdmluZyB0byBhIG5vZGUgZnJvbSBvdXRzaWRlIHRoZSB3aW5kb3cuXG4gICAgICBmcm9tID0gbnVsbDtcbiAgICAgIHRvID0gdGFyZ2V0SW5zdDtcbiAgICB9XG5cbiAgICBpZiAoZnJvbSA9PT0gdG8pIHtcbiAgICAgIC8vIE5vdGhpbmcgcGVydGFpbnMgdG8gb3VyIG1hbmFnZWQgY29tcG9uZW50cy5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBmcm9tTm9kZSA9IGZyb20gPT0gbnVsbCA/IHdpbiA6IGdldE5vZGVGcm9tSW5zdGFuY2UkMShmcm9tKTtcbiAgICB2YXIgdG9Ob2RlID0gdG8gPT0gbnVsbCA/IHdpbiA6IGdldE5vZGVGcm9tSW5zdGFuY2UkMSh0byk7XG5cbiAgICB2YXIgbGVhdmUgPSBTeW50aGV0aWNNb3VzZUV2ZW50LmdldFBvb2xlZChldmVudFR5cGVzJDIubW91c2VMZWF2ZSwgZnJvbSwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICBsZWF2ZS50eXBlID0gJ21vdXNlbGVhdmUnO1xuICAgIGxlYXZlLnRhcmdldCA9IGZyb21Ob2RlO1xuICAgIGxlYXZlLnJlbGF0ZWRUYXJnZXQgPSB0b05vZGU7XG5cbiAgICB2YXIgZW50ZXIgPSBTeW50aGV0aWNNb3VzZUV2ZW50LmdldFBvb2xlZChldmVudFR5cGVzJDIubW91c2VFbnRlciwgdG8sIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgZW50ZXIudHlwZSA9ICdtb3VzZWVudGVyJztcbiAgICBlbnRlci50YXJnZXQgPSB0b05vZGU7XG4gICAgZW50ZXIucmVsYXRlZFRhcmdldCA9IGZyb21Ob2RlO1xuXG4gICAgYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzKGxlYXZlLCBlbnRlciwgZnJvbSwgdG8pO1xuXG4gICAgcmV0dXJuIFtsZWF2ZSwgZW50ZXJdO1xuICB9XG59O1xuXG4vKipcbiAqIGBSZWFjdEluc3RhbmNlTWFwYCBtYWludGFpbnMgYSBtYXBwaW5nIGZyb20gYSBwdWJsaWMgZmFjaW5nIHN0YXRlZnVsXG4gKiBpbnN0YW5jZSAoa2V5KSBhbmQgdGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uICh2YWx1ZSkuIFRoaXMgYWxsb3dzIHB1YmxpY1xuICogbWV0aG9kcyB0byBhY2NlcHQgdGhlIHVzZXIgZmFjaW5nIGluc3RhbmNlIGFzIGFuIGFyZ3VtZW50IGFuZCBtYXAgdGhlbSBiYWNrXG4gKiB0byBpbnRlcm5hbCBtZXRob2RzLlxuICpcbiAqIE5vdGUgdGhhdCB0aGlzIG1vZHVsZSBpcyBjdXJyZW50bHkgc2hhcmVkIGFuZCBhc3N1bWVkIHRvIGJlIHN0YXRlbGVzcy5cbiAqIElmIHRoaXMgYmVjb21lcyBhbiBhY3R1YWwgTWFwLCB0aGF0IHdpbGwgYnJlYWsuXG4gKi9cblxuLyoqXG4gKiBUaGlzIEFQSSBzaG91bGQgYmUgY2FsbGVkIGBkZWxldGVgIGJ1dCB3ZSdkIGhhdmUgdG8gbWFrZSBzdXJlIHRvIGFsd2F5c1xuICogdHJhbnNmb3JtIHRoZXNlIHRvIHN0cmluZ3MgZm9yIElFIHN1cHBvcnQuIFdoZW4gdGhpcyB0cmFuc2Zvcm0gaXMgZnVsbHlcbiAqIHN1cHBvcnRlZCB3ZSBjYW4gcmVuYW1lIGl0LlxuICovXG5cblxuZnVuY3Rpb24gZ2V0KGtleSkge1xuICByZXR1cm4ga2V5Ll9yZWFjdEludGVybmFsRmliZXI7XG59XG5cbmZ1bmN0aW9uIGhhcyhrZXkpIHtcbiAgcmV0dXJuIGtleS5fcmVhY3RJbnRlcm5hbEZpYmVyICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XG4gIGtleS5fcmVhY3RJbnRlcm5hbEZpYmVyID0gdmFsdWU7XG59XG5cbnZhciBSZWFjdEludGVybmFscyA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSBSZWFjdEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZShmaWJlcikge1xuICB2YXIgdHlwZSA9IGZpYmVyLnR5cGU7XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gRG9uJ3QgY2hhbmdlIHRoZXNlIHR3byB2YWx1ZXM6XG52YXIgTm9FZmZlY3QgPSAwOyAvLyAgICAgICAgICAgMGIwMDAwMDAwMFxudmFyIFBlcmZvcm1lZFdvcmsgPSAxOyAvLyAgICAgIDBiMDAwMDAwMDFcblxuLy8gWW91IGNhbiBjaGFuZ2UgdGhlIHJlc3QgKGFuZCBhZGQgbW9yZSkuXG52YXIgUGxhY2VtZW50ID0gMjsgLy8gICAgICAgICAgMGIwMDAwMDAxMFxudmFyIFVwZGF0ZSA9IDQ7IC8vICAgICAgICAgICAgIDBiMDAwMDAxMDBcbnZhciBQbGFjZW1lbnRBbmRVcGRhdGUgPSA2OyAvLyAwYjAwMDAwMTEwXG52YXIgRGVsZXRpb24gPSA4OyAvLyAgICAgICAgICAgMGIwMDAwMTAwMFxudmFyIENvbnRlbnRSZXNldCA9IDE2OyAvLyAgICAgIDBiMDAwMTAwMDBcbnZhciBDYWxsYmFjayA9IDMyOyAvLyAgICAgICAgICAwYjAwMTAwMDAwXG52YXIgRXJyID0gNjQ7IC8vICAgICAgICAgICAgICAgMGIwMTAwMDAwMFxudmFyIFJlZiA9IDEyODsgLy8gICAgICAgICAgICAgIDBiMTAwMDAwMDBcblxudmFyIE1PVU5USU5HID0gMTtcbnZhciBNT1VOVEVEID0gMjtcbnZhciBVTk1PVU5URUQgPSAzO1xuXG5mdW5jdGlvbiBpc0ZpYmVyTW91bnRlZEltcGwoZmliZXIpIHtcbiAgdmFyIG5vZGUgPSBmaWJlcjtcbiAgaWYgKCFmaWJlci5hbHRlcm5hdGUpIHtcbiAgICAvLyBJZiB0aGVyZSBpcyBubyBhbHRlcm5hdGUsIHRoaXMgbWlnaHQgYmUgYSBuZXcgdHJlZSB0aGF0IGlzbid0IGluc2VydGVkXG4gICAgLy8geWV0LiBJZiBpdCBpcywgdGhlbiBpdCB3aWxsIGhhdmUgYSBwZW5kaW5nIGluc2VydGlvbiBlZmZlY3Qgb24gaXQuXG4gICAgaWYgKChub2RlLmVmZmVjdFRhZyAmIFBsYWNlbWVudCkgIT09IE5vRWZmZWN0KSB7XG4gICAgICByZXR1cm4gTU9VTlRJTkc7XG4gICAgfVxuICAgIHdoaWxlIChub2RlWydyZXR1cm4nXSkge1xuICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgaWYgKChub2RlLmVmZmVjdFRhZyAmIFBsYWNlbWVudCkgIT09IE5vRWZmZWN0KSB7XG4gICAgICAgIHJldHVybiBNT1VOVElORztcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKG5vZGVbJ3JldHVybiddKSB7XG4gICAgICBub2RlID0gbm9kZVsncmV0dXJuJ107XG4gICAgfVxuICB9XG4gIGlmIChub2RlLnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICAvLyBUT0RPOiBDaGVjayBpZiB0aGlzIHdhcyBhIG5lc3RlZCBIb3N0Um9vdCB3aGVuIHVzZWQgd2l0aFxuICAgIC8vIHJlbmRlckNvbnRhaW5lckludG9TdWJ0cmVlLlxuICAgIHJldHVybiBNT1VOVEVEO1xuICB9XG4gIC8vIElmIHdlIGRpZG4ndCBoaXQgdGhlIHJvb3QsIHRoYXQgbWVhbnMgdGhhdCB3ZSdyZSBpbiBhbiBkaXNjb25uZWN0ZWQgdHJlZVxuICAvLyB0aGF0IGhhcyBiZWVuIHVubW91bnRlZC5cbiAgcmV0dXJuIFVOTU9VTlRFRDtcbn1cblxuZnVuY3Rpb24gaXNGaWJlck1vdW50ZWQoZmliZXIpIHtcbiAgcmV0dXJuIGlzRmliZXJNb3VudGVkSW1wbChmaWJlcikgPT09IE1PVU5URUQ7XG59XG5cbmZ1bmN0aW9uIGlzTW91bnRlZChjb21wb25lbnQpIHtcbiAge1xuICAgIHZhciBvd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgaWYgKG93bmVyICE9PSBudWxsICYmIG93bmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpIHtcbiAgICAgIHZhciBvd25lckZpYmVyID0gb3duZXI7XG4gICAgICB2YXIgaW5zdGFuY2UgPSBvd25lckZpYmVyLnN0YXRlTm9kZTtcbiAgICAgIHdhcm5pbmcoaW5zdGFuY2UuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyLCAnJXMgaXMgYWNjZXNzaW5nIGlzTW91bnRlZCBpbnNpZGUgaXRzIHJlbmRlcigpIGZ1bmN0aW9uLiAnICsgJ3JlbmRlcigpIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlLiBJdCBzaG91bGQgJyArICduZXZlciBhY2Nlc3Mgc29tZXRoaW5nIHRoYXQgcmVxdWlyZXMgc3RhbGUgZGF0YSBmcm9tIHRoZSBwcmV2aW91cyAnICsgJ3JlbmRlciwgc3VjaCBhcyByZWZzLiBNb3ZlIHRoaXMgbG9naWMgdG8gY29tcG9uZW50RGlkTW91bnQgYW5kICcgKyAnY29tcG9uZW50RGlkVXBkYXRlIGluc3RlYWQuJywgZ2V0Q29tcG9uZW50TmFtZShvd25lckZpYmVyKSB8fCAnQSBjb21wb25lbnQnKTtcbiAgICAgIGluc3RhbmNlLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGZpYmVyID0gZ2V0KGNvbXBvbmVudCk7XG4gIGlmICghZmliZXIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGlzRmliZXJNb3VudGVkSW1wbChmaWJlcikgPT09IE1PVU5URUQ7XG59XG5cbmZ1bmN0aW9uIGFzc2VydElzTW91bnRlZChmaWJlcikge1xuICAhKGlzRmliZXJNb3VudGVkSW1wbChmaWJlcikgPT09IE1PVU5URUQpID8gaW52YXJpYW50KGZhbHNlLCAnVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpIDogdm9pZCAwO1xufVxuXG5mdW5jdGlvbiBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aChmaWJlcikge1xuICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuICBpZiAoIWFsdGVybmF0ZSkge1xuICAgIC8vIElmIHRoZXJlIGlzIG5vIGFsdGVybmF0ZSwgdGhlbiB3ZSBvbmx5IG5lZWQgdG8gY2hlY2sgaWYgaXQgaXMgbW91bnRlZC5cbiAgICB2YXIgc3RhdGUgPSBpc0ZpYmVyTW91bnRlZEltcGwoZmliZXIpO1xuICAgICEoc3RhdGUgIT09IFVOTU9VTlRFRCkgPyBpbnZhcmlhbnQoZmFsc2UsICdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJykgOiB2b2lkIDA7XG4gICAgaWYgKHN0YXRlID09PSBNT1VOVElORykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBmaWJlcjtcbiAgfVxuICAvLyBJZiB3ZSBoYXZlIHR3byBwb3NzaWJsZSBicmFuY2hlcywgd2UnbGwgd2FsayBiYWNrd2FyZHMgdXAgdG8gdGhlIHJvb3RcbiAgLy8gdG8gc2VlIHdoYXQgcGF0aCB0aGUgcm9vdCBwb2ludHMgdG8uIE9uIHRoZSB3YXkgd2UgbWF5IGhpdCBvbmUgb2YgdGhlXG4gIC8vIHNwZWNpYWwgY2FzZXMgYW5kIHdlJ2xsIGRlYWwgd2l0aCB0aGVtLlxuICB2YXIgYSA9IGZpYmVyO1xuICB2YXIgYiA9IGFsdGVybmF0ZTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICB2YXIgcGFyZW50QSA9IGFbJ3JldHVybiddO1xuICAgIHZhciBwYXJlbnRCID0gcGFyZW50QSA/IHBhcmVudEEuYWx0ZXJuYXRlIDogbnVsbDtcbiAgICBpZiAoIXBhcmVudEEgfHwgIXBhcmVudEIpIHtcbiAgICAgIC8vIFdlJ3JlIGF0IHRoZSByb290LlxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gSWYgYm90aCBjb3BpZXMgb2YgdGhlIHBhcmVudCBmaWJlciBwb2ludCB0byB0aGUgc2FtZSBjaGlsZCwgd2UgY2FuXG4gICAgLy8gYXNzdW1lIHRoYXQgdGhlIGNoaWxkIGlzIGN1cnJlbnQuIFRoaXMgaGFwcGVucyB3aGVuIHdlIGJhaWxvdXQgb24gbG93XG4gICAgLy8gcHJpb3JpdHk6IHRoZSBiYWlsZWQgb3V0IGZpYmVyJ3MgY2hpbGQgcmV1c2VzIHRoZSBjdXJyZW50IGNoaWxkLlxuICAgIGlmIChwYXJlbnRBLmNoaWxkID09PSBwYXJlbnRCLmNoaWxkKSB7XG4gICAgICB2YXIgY2hpbGQgPSBwYXJlbnRBLmNoaWxkO1xuICAgICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICAgIGlmIChjaGlsZCA9PT0gYSkge1xuICAgICAgICAgIC8vIFdlJ3ZlIGRldGVybWluZWQgdGhhdCBBIGlzIHRoZSBjdXJyZW50IGJyYW5jaC5cbiAgICAgICAgICBhc3NlcnRJc01vdW50ZWQocGFyZW50QSk7XG4gICAgICAgICAgcmV0dXJuIGZpYmVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZCA9PT0gYikge1xuICAgICAgICAgIC8vIFdlJ3ZlIGRldGVybWluZWQgdGhhdCBCIGlzIHRoZSBjdXJyZW50IGJyYW5jaC5cbiAgICAgICAgICBhc3NlcnRJc01vdW50ZWQocGFyZW50QSk7XG4gICAgICAgICAgcmV0dXJuIGFsdGVybmF0ZTtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgICB9XG4gICAgICAvLyBXZSBzaG91bGQgbmV2ZXIgaGF2ZSBhbiBhbHRlcm5hdGUgZm9yIGFueSBtb3VudGluZyBub2RlLiBTbyB0aGUgb25seVxuICAgICAgLy8gd2F5IHRoaXMgY291bGQgcG9zc2libHkgaGFwcGVuIGlzIGlmIHRoaXMgd2FzIHVubW91bnRlZCwgaWYgYXQgYWxsLlxuICAgICAgaW52YXJpYW50KGZhbHNlLCAnVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpO1xuICAgIH1cblxuICAgIGlmIChhWydyZXR1cm4nXSAhPT0gYlsncmV0dXJuJ10pIHtcbiAgICAgIC8vIFRoZSByZXR1cm4gcG9pbnRlciBvZiBBIGFuZCB0aGUgcmV0dXJuIHBvaW50ZXIgb2YgQiBwb2ludCB0byBkaWZmZXJlbnRcbiAgICAgIC8vIGZpYmVycy4gV2UgYXNzdW1lIHRoYXQgcmV0dXJuIHBvaW50ZXJzIG5ldmVyIGNyaXNzLWNyb3NzLCBzbyBBIG11c3RcbiAgICAgIC8vIGJlbG9uZyB0byB0aGUgY2hpbGQgc2V0IG9mIEEucmV0dXJuLCBhbmQgQiBtdXN0IGJlbG9uZyB0byB0aGUgY2hpbGRcbiAgICAgIC8vIHNldCBvZiBCLnJldHVybi5cbiAgICAgIGEgPSBwYXJlbnRBO1xuICAgICAgYiA9IHBhcmVudEI7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZSByZXR1cm4gcG9pbnRlcnMgcG9pbnQgdG8gdGhlIHNhbWUgZmliZXIuIFdlJ2xsIGhhdmUgdG8gdXNlIHRoZVxuICAgICAgLy8gZGVmYXVsdCwgc2xvdyBwYXRoOiBzY2FuIHRoZSBjaGlsZCBzZXRzIG9mIGVhY2ggcGFyZW50IGFsdGVybmF0ZSB0byBzZWVcbiAgICAgIC8vIHdoaWNoIGNoaWxkIGJlbG9uZ3MgdG8gd2hpY2ggc2V0LlxuICAgICAgLy9cbiAgICAgIC8vIFNlYXJjaCBwYXJlbnQgQSdzIGNoaWxkIHNldFxuICAgICAgdmFyIGRpZEZpbmRDaGlsZCA9IGZhbHNlO1xuICAgICAgdmFyIF9jaGlsZCA9IHBhcmVudEEuY2hpbGQ7XG4gICAgICB3aGlsZSAoX2NoaWxkKSB7XG4gICAgICAgIGlmIChfY2hpbGQgPT09IGEpIHtcbiAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgIGEgPSBwYXJlbnRBO1xuICAgICAgICAgIGIgPSBwYXJlbnRCO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfY2hpbGQgPT09IGIpIHtcbiAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgIGIgPSBwYXJlbnRBO1xuICAgICAgICAgIGEgPSBwYXJlbnRCO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIF9jaGlsZCA9IF9jaGlsZC5zaWJsaW5nO1xuICAgICAgfVxuICAgICAgaWYgKCFkaWRGaW5kQ2hpbGQpIHtcbiAgICAgICAgLy8gU2VhcmNoIHBhcmVudCBCJ3MgY2hpbGQgc2V0XG4gICAgICAgIF9jaGlsZCA9IHBhcmVudEIuY2hpbGQ7XG4gICAgICAgIHdoaWxlIChfY2hpbGQpIHtcbiAgICAgICAgICBpZiAoX2NoaWxkID09PSBhKSB7XG4gICAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgICAgYSA9IHBhcmVudEI7XG4gICAgICAgICAgICBiID0gcGFyZW50QTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoX2NoaWxkID09PSBiKSB7XG4gICAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgICAgYiA9IHBhcmVudEI7XG4gICAgICAgICAgICBhID0gcGFyZW50QTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfY2hpbGQgPSBfY2hpbGQuc2libGluZztcbiAgICAgICAgfVxuICAgICAgICAhZGlkRmluZENoaWxkID8gaW52YXJpYW50KGZhbHNlLCAnQ2hpbGQgd2FzIG5vdCBmb3VuZCBpbiBlaXRoZXIgcGFyZW50IHNldC4gVGhpcyBpbmRpY2F0ZXMgYSBidWcgaW4gUmVhY3QgcmVsYXRlZCB0byB0aGUgcmV0dXJuIHBvaW50ZXIuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgfVxuICAgIH1cblxuICAgICEoYS5hbHRlcm5hdGUgPT09IGIpID8gaW52YXJpYW50KGZhbHNlLCAnUmV0dXJuIGZpYmVycyBzaG91bGQgYWx3YXlzIGJlIGVhY2ggb3RoZXJzXFwnIGFsdGVybmF0ZXMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gIH1cbiAgLy8gSWYgdGhlIHJvb3QgaXMgbm90IGEgaG9zdCBjb250YWluZXIsIHdlJ3JlIGluIGEgZGlzY29ubmVjdGVkIHRyZWUuIEkuZS5cbiAgLy8gdW5tb3VudGVkLlxuICAhKGEudGFnID09PSBIb3N0Um9vdCkgPyBpbnZhcmlhbnQoZmFsc2UsICdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJykgOiB2b2lkIDA7XG4gIGlmIChhLnN0YXRlTm9kZS5jdXJyZW50ID09PSBhKSB7XG4gICAgLy8gV2UndmUgZGV0ZXJtaW5lZCB0aGF0IEEgaXMgdGhlIGN1cnJlbnQgYnJhbmNoLlxuICAgIHJldHVybiBmaWJlcjtcbiAgfVxuICAvLyBPdGhlcndpc2UgQiBoYXMgdG8gYmUgY3VycmVudCBicmFuY2guXG4gIHJldHVybiBhbHRlcm5hdGU7XG59XG5cbmZ1bmN0aW9uIGZpbmRDdXJyZW50SG9zdEZpYmVyKHBhcmVudCkge1xuICB2YXIgY3VycmVudFBhcmVudCA9IGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoKHBhcmVudCk7XG4gIGlmICghY3VycmVudFBhcmVudCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gTmV4dCB3ZSdsbCBkcmlsbCBkb3duIHRoaXMgY29tcG9uZW50IHRvIGZpbmQgdGhlIGZpcnN0IEhvc3RDb21wb25lbnQvVGV4dC5cbiAgdmFyIG5vZGUgPSBjdXJyZW50UGFyZW50O1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCkge1xuICAgICAgbm9kZS5jaGlsZFsncmV0dXJuJ10gPSBub2RlO1xuICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKG5vZGUgPT09IGN1cnJlbnRQYXJlbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB3aGlsZSAoIW5vZGUuc2libGluZykge1xuICAgICAgaWYgKCFub2RlWydyZXR1cm4nXSB8fCBub2RlWydyZXR1cm4nXSA9PT0gY3VycmVudFBhcmVudCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICB9XG4gICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gIH1cbiAgLy8gRmxvdyBuZWVkcyB0aGUgcmV0dXJuIG51bGwgaGVyZSwgYnV0IEVTTGludCBjb21wbGFpbnMgYWJvdXQgaXQuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnJlYWNoYWJsZVxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzKHBhcmVudCkge1xuICB2YXIgY3VycmVudFBhcmVudCA9IGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoKHBhcmVudCk7XG4gIGlmICghY3VycmVudFBhcmVudCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gTmV4dCB3ZSdsbCBkcmlsbCBkb3duIHRoaXMgY29tcG9uZW50IHRvIGZpbmQgdGhlIGZpcnN0IEhvc3RDb21wb25lbnQvVGV4dC5cbiAgdmFyIG5vZGUgPSBjdXJyZW50UGFyZW50O1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCAmJiBub2RlLnRhZyAhPT0gSG9zdFBvcnRhbCkge1xuICAgICAgbm9kZS5jaGlsZFsncmV0dXJuJ10gPSBub2RlO1xuICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKG5vZGUgPT09IGN1cnJlbnRQYXJlbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB3aGlsZSAoIW5vZGUuc2libGluZykge1xuICAgICAgaWYgKCFub2RlWydyZXR1cm4nXSB8fCBub2RlWydyZXR1cm4nXSA9PT0gY3VycmVudFBhcmVudCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICB9XG4gICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gIH1cbiAgLy8gRmxvdyBuZWVkcyB0aGUgcmV0dXJuIG51bGwgaGVyZSwgYnV0IEVTTGludCBjb21wbGFpbnMgYWJvdXQgaXQuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnJlYWNoYWJsZVxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIENBTExCQUNLX0JPT0tLRUVQSU5HX1BPT0xfU0laRSA9IDEwO1xudmFyIGNhbGxiYWNrQm9va2tlZXBpbmdQb29sID0gW107XG5cbi8qKlxuICogRmluZCB0aGUgZGVlcGVzdCBSZWFjdCBjb21wb25lbnQgY29tcGxldGVseSBjb250YWluaW5nIHRoZSByb290IG9mIHRoZVxuICogcGFzc2VkLWluIGluc3RhbmNlIChmb3IgdXNlIHdoZW4gZW50aXJlIFJlYWN0IHRyZWVzIGFyZSBuZXN0ZWQgd2l0aGluIGVhY2hcbiAqIG90aGVyKS4gSWYgUmVhY3QgdHJlZXMgYXJlIG5vdCBuZXN0ZWQsIHJldHVybnMgbnVsbC5cbiAqL1xuZnVuY3Rpb24gZmluZFJvb3RDb250YWluZXJOb2RlKGluc3QpIHtcbiAgLy8gVE9ETzogSXQgbWF5IGJlIGEgZ29vZCBpZGVhIHRvIGNhY2hlIHRoaXMgdG8gcHJldmVudCB1bm5lY2Vzc2FyeSBET01cbiAgLy8gdHJhdmVyc2FsLCBidXQgY2FjaGluZyBpcyBkaWZmaWN1bHQgdG8gZG8gY29ycmVjdGx5IHdpdGhvdXQgdXNpbmcgYVxuICAvLyBtdXRhdGlvbiBvYnNlcnZlciB0byBsaXN0ZW4gZm9yIGFsbCBET00gY2hhbmdlcy5cbiAgd2hpbGUgKGluc3RbJ3JldHVybiddKSB7XG4gICAgaW5zdCA9IGluc3RbJ3JldHVybiddO1xuICB9XG4gIGlmIChpbnN0LnRhZyAhPT0gSG9zdFJvb3QpIHtcbiAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgd2UncmUgaW4gYSBkZXRhY2hlZCB0cmVlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBpbnN0LnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xufVxuXG4vLyBVc2VkIHRvIHN0b3JlIGFuY2VzdG9yIGhpZXJhcmNoeSBpbiB0b3AgbGV2ZWwgY2FsbGJhY2tcbmZ1bmN0aW9uIGdldFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50LCB0YXJnZXRJbnN0KSB7XG4gIGlmIChjYWxsYmFja0Jvb2trZWVwaW5nUG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBjYWxsYmFja0Jvb2trZWVwaW5nUG9vbC5wb3AoKTtcbiAgICBpbnN0YW5jZS50b3BMZXZlbFR5cGUgPSB0b3BMZXZlbFR5cGU7XG4gICAgaW5zdGFuY2UubmF0aXZlRXZlbnQgPSBuYXRpdmVFdmVudDtcbiAgICBpbnN0YW5jZS50YXJnZXRJbnN0ID0gdGFyZ2V0SW5zdDtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0b3BMZXZlbFR5cGU6IHRvcExldmVsVHlwZSxcbiAgICBuYXRpdmVFdmVudDogbmF0aXZlRXZlbnQsXG4gICAgdGFyZ2V0SW5zdDogdGFyZ2V0SW5zdCxcbiAgICBhbmNlc3RvcnM6IFtdXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlbGVhc2VUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcoaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UudG9wTGV2ZWxUeXBlID0gbnVsbDtcbiAgaW5zdGFuY2UubmF0aXZlRXZlbnQgPSBudWxsO1xuICBpbnN0YW5jZS50YXJnZXRJbnN0ID0gbnVsbDtcbiAgaW5zdGFuY2UuYW5jZXN0b3JzLmxlbmd0aCA9IDA7XG4gIGlmIChjYWxsYmFja0Jvb2trZWVwaW5nUG9vbC5sZW5ndGggPCBDQUxMQkFDS19CT09LS0VFUElOR19QT09MX1NJWkUpIHtcbiAgICBjYWxsYmFja0Jvb2trZWVwaW5nUG9vbC5wdXNoKGluc3RhbmNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVUb3BMZXZlbEltcGwoYm9va0tlZXBpbmcpIHtcbiAgdmFyIHRhcmdldEluc3QgPSBib29rS2VlcGluZy50YXJnZXRJbnN0O1xuXG4gIC8vIExvb3AgdGhyb3VnaCB0aGUgaGllcmFyY2h5LCBpbiBjYXNlIHRoZXJlJ3MgYW55IG5lc3RlZCBjb21wb25lbnRzLlxuICAvLyBJdCdzIGltcG9ydGFudCB0aGF0IHdlIGJ1aWxkIHRoZSBhcnJheSBvZiBhbmNlc3RvcnMgYmVmb3JlIGNhbGxpbmcgYW55XG4gIC8vIGV2ZW50IGhhbmRsZXJzLCBiZWNhdXNlIGV2ZW50IGhhbmRsZXJzIGNhbiBtb2RpZnkgdGhlIERPTSwgbGVhZGluZyB0b1xuICAvLyBpbmNvbnNpc3RlbmNpZXMgd2l0aCBSZWFjdE1vdW50J3Mgbm9kZSBjYWNoZS4gU2VlICMxMTA1LlxuICB2YXIgYW5jZXN0b3IgPSB0YXJnZXRJbnN0O1xuICBkbyB7XG4gICAgaWYgKCFhbmNlc3Rvcikge1xuICAgICAgYm9va0tlZXBpbmcuYW5jZXN0b3JzLnB1c2goYW5jZXN0b3IpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHZhciByb290ID0gZmluZFJvb3RDb250YWluZXJOb2RlKGFuY2VzdG9yKTtcbiAgICBpZiAoIXJvb3QpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBib29rS2VlcGluZy5hbmNlc3RvcnMucHVzaChhbmNlc3Rvcik7XG4gICAgYW5jZXN0b3IgPSBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShyb290KTtcbiAgfSB3aGlsZSAoYW5jZXN0b3IpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYm9va0tlZXBpbmcuYW5jZXN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGFyZ2V0SW5zdCA9IGJvb2tLZWVwaW5nLmFuY2VzdG9yc1tpXTtcbiAgICBfaGFuZGxlVG9wTGV2ZWwoYm9va0tlZXBpbmcudG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBib29rS2VlcGluZy5uYXRpdmVFdmVudCwgZ2V0RXZlbnRUYXJnZXQoYm9va0tlZXBpbmcubmF0aXZlRXZlbnQpKTtcbiAgfVxufVxuXG4vLyBUT0RPOiBjYW4gd2Ugc3RvcCBleHBvcnRpbmcgdGhlc2U/XG52YXIgX2VuYWJsZWQgPSB0cnVlO1xudmFyIF9oYW5kbGVUb3BMZXZlbCA9IHZvaWQgMDtcblxuZnVuY3Rpb24gc2V0SGFuZGxlVG9wTGV2ZWwoaGFuZGxlVG9wTGV2ZWwpIHtcbiAgX2hhbmRsZVRvcExldmVsID0gaGFuZGxlVG9wTGV2ZWw7XG59XG5cbmZ1bmN0aW9uIHNldEVuYWJsZWQoZW5hYmxlZCkge1xuICBfZW5hYmxlZCA9ICEhZW5hYmxlZDtcbn1cblxuZnVuY3Rpb24gaXNFbmFibGVkKCkge1xuICByZXR1cm4gX2VuYWJsZWQ7XG59XG5cbi8qKlxuICogVHJhcHMgdG9wLWxldmVsIGV2ZW50cyBieSB1c2luZyBldmVudCBidWJibGluZy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBCcm93c2VyRXZlbnRDb25zdGFudHNgLlxuICogQHBhcmFtIHtzdHJpbmd9IGhhbmRsZXJCYXNlTmFtZSBFdmVudCBuYW1lIChlLmcuIFwiY2xpY2tcIikuXG4gKiBAcGFyYW0ge29iamVjdH0gZWxlbWVudCBFbGVtZW50IG9uIHdoaWNoIHRvIGF0dGFjaCBsaXN0ZW5lci5cbiAqIEByZXR1cm4gez9vYmplY3R9IEFuIG9iamVjdCB3aXRoIGEgcmVtb3ZlIGZ1bmN0aW9uIHdoaWNoIHdpbGwgZm9yY2VmdWxseVxuICogICAgICAgICAgICAgICAgICByZW1vdmUgdGhlIGxpc3RlbmVyLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHRyYXBCdWJibGVkRXZlbnQodG9wTGV2ZWxUeXBlLCBoYW5kbGVyQmFzZU5hbWUsIGVsZW1lbnQpIHtcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIEV2ZW50TGlzdGVuZXIubGlzdGVuKGVsZW1lbnQsIGhhbmRsZXJCYXNlTmFtZSwgZGlzcGF0Y2hFdmVudC5iaW5kKG51bGwsIHRvcExldmVsVHlwZSkpO1xufVxuXG4vKipcbiAqIFRyYXBzIGEgdG9wLWxldmVsIGV2ZW50IGJ5IHVzaW5nIGV2ZW50IGNhcHR1cmluZy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBCcm93c2VyRXZlbnRDb25zdGFudHNgLlxuICogQHBhcmFtIHtzdHJpbmd9IGhhbmRsZXJCYXNlTmFtZSBFdmVudCBuYW1lIChlLmcuIFwiY2xpY2tcIikuXG4gKiBAcGFyYW0ge29iamVjdH0gZWxlbWVudCBFbGVtZW50IG9uIHdoaWNoIHRvIGF0dGFjaCBsaXN0ZW5lci5cbiAqIEByZXR1cm4gez9vYmplY3R9IEFuIG9iamVjdCB3aXRoIGEgcmVtb3ZlIGZ1bmN0aW9uIHdoaWNoIHdpbGwgZm9yY2VmdWxseVxuICogICAgICAgICAgICAgICAgICByZW1vdmUgdGhlIGxpc3RlbmVyLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHRyYXBDYXB0dXJlZEV2ZW50KHRvcExldmVsVHlwZSwgaGFuZGxlckJhc2VOYW1lLCBlbGVtZW50KSB7XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBFdmVudExpc3RlbmVyLmNhcHR1cmUoZWxlbWVudCwgaGFuZGxlckJhc2VOYW1lLCBkaXNwYXRjaEV2ZW50LmJpbmQobnVsbCwgdG9wTGV2ZWxUeXBlKSk7XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICBpZiAoIV9lbmFibGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG5hdGl2ZUV2ZW50VGFyZ2V0ID0gZ2V0RXZlbnRUYXJnZXQobmF0aXZlRXZlbnQpO1xuICB2YXIgdGFyZ2V0SW5zdCA9IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgaWYgKHRhcmdldEluc3QgIT09IG51bGwgJiYgdHlwZW9mIHRhcmdldEluc3QudGFnID09PSAnbnVtYmVyJyAmJiAhaXNGaWJlck1vdW50ZWQodGFyZ2V0SW5zdCkpIHtcbiAgICAvLyBJZiB3ZSBnZXQgYW4gZXZlbnQgKGV4OiBpbWcgb25sb2FkKSBiZWZvcmUgY29tbWl0dGluZyB0aGF0XG4gICAgLy8gY29tcG9uZW50J3MgbW91bnQsIGlnbm9yZSBpdCBmb3Igbm93ICh0aGF0IGlzLCB0cmVhdCBpdCBhcyBpZiBpdCB3YXMgYW5cbiAgICAvLyBldmVudCBvbiBhIG5vbi1SZWFjdCB0cmVlKS4gV2UgbWlnaHQgYWxzbyBjb25zaWRlciBxdWV1ZWluZyBldmVudHMgYW5kXG4gICAgLy8gZGlzcGF0Y2hpbmcgdGhlbSBhZnRlciB0aGUgbW91bnQuXG4gICAgdGFyZ2V0SW5zdCA9IG51bGw7XG4gIH1cblxuICB2YXIgYm9va0tlZXBpbmcgPSBnZXRUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCwgdGFyZ2V0SW5zdCk7XG5cbiAgdHJ5IHtcbiAgICAvLyBFdmVudCBxdWV1ZSBiZWluZyBwcm9jZXNzZWQgaW4gdGhlIHNhbWUgY3ljbGUgYWxsb3dzXG4gICAgLy8gYHByZXZlbnREZWZhdWx0YC5cbiAgICBiYXRjaGVkVXBkYXRlcyhoYW5kbGVUb3BMZXZlbEltcGwsIGJvb2tLZWVwaW5nKTtcbiAgfSBmaW5hbGx5IHtcbiAgICByZWxlYXNlVG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nKGJvb2tLZWVwaW5nKTtcbiAgfVxufVxuXG52YXIgUmVhY3RET01FdmVudExpc3RlbmVyID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGdldCBfZW5hYmxlZCAoKSB7IHJldHVybiBfZW5hYmxlZDsgfSxcblx0Z2V0IF9oYW5kbGVUb3BMZXZlbCAoKSB7IHJldHVybiBfaGFuZGxlVG9wTGV2ZWw7IH0sXG5cdHNldEhhbmRsZVRvcExldmVsOiBzZXRIYW5kbGVUb3BMZXZlbCxcblx0c2V0RW5hYmxlZDogc2V0RW5hYmxlZCxcblx0aXNFbmFibGVkOiBpc0VuYWJsZWQsXG5cdHRyYXBCdWJibGVkRXZlbnQ6IHRyYXBCdWJibGVkRXZlbnQsXG5cdHRyYXBDYXB0dXJlZEV2ZW50OiB0cmFwQ2FwdHVyZWRFdmVudCxcblx0ZGlzcGF0Y2hFdmVudDogZGlzcGF0Y2hFdmVudFxufSk7XG5cbi8qKlxuICogR2VuZXJhdGUgYSBtYXBwaW5nIG9mIHN0YW5kYXJkIHZlbmRvciBwcmVmaXhlcyB1c2luZyB0aGUgZGVmaW5lZCBzdHlsZSBwcm9wZXJ0eSBhbmQgZXZlbnQgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3R5bGVQcm9wXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gKiBAcmV0dXJucyB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBtYWtlUHJlZml4TWFwKHN0eWxlUHJvcCwgZXZlbnROYW1lKSB7XG4gIHZhciBwcmVmaXhlcyA9IHt9O1xuXG4gIHByZWZpeGVzW3N0eWxlUHJvcC50b0xvd2VyQ2FzZSgpXSA9IGV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpO1xuICBwcmVmaXhlc1snV2Via2l0JyArIHN0eWxlUHJvcF0gPSAnd2Via2l0JyArIGV2ZW50TmFtZTtcbiAgcHJlZml4ZXNbJ01veicgKyBzdHlsZVByb3BdID0gJ21veicgKyBldmVudE5hbWU7XG4gIHByZWZpeGVzWydtcycgKyBzdHlsZVByb3BdID0gJ01TJyArIGV2ZW50TmFtZTtcbiAgcHJlZml4ZXNbJ08nICsgc3R5bGVQcm9wXSA9ICdvJyArIGV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gIHJldHVybiBwcmVmaXhlcztcbn1cblxuLyoqXG4gKiBBIGxpc3Qgb2YgZXZlbnQgbmFtZXMgdG8gYSBjb25maWd1cmFibGUgbGlzdCBvZiB2ZW5kb3IgcHJlZml4ZXMuXG4gKi9cbnZhciB2ZW5kb3JQcmVmaXhlcyA9IHtcbiAgYW5pbWF0aW9uZW5kOiBtYWtlUHJlZml4TWFwKCdBbmltYXRpb24nLCAnQW5pbWF0aW9uRW5kJyksXG4gIGFuaW1hdGlvbml0ZXJhdGlvbjogbWFrZVByZWZpeE1hcCgnQW5pbWF0aW9uJywgJ0FuaW1hdGlvbkl0ZXJhdGlvbicpLFxuICBhbmltYXRpb25zdGFydDogbWFrZVByZWZpeE1hcCgnQW5pbWF0aW9uJywgJ0FuaW1hdGlvblN0YXJ0JyksXG4gIHRyYW5zaXRpb25lbmQ6IG1ha2VQcmVmaXhNYXAoJ1RyYW5zaXRpb24nLCAnVHJhbnNpdGlvbkVuZCcpXG59O1xuXG4vKipcbiAqIEV2ZW50IG5hbWVzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gZGV0ZWN0ZWQgYW5kIHByZWZpeGVkIChpZiBhcHBsaWNhYmxlKS5cbiAqL1xudmFyIHByZWZpeGVkRXZlbnROYW1lcyA9IHt9O1xuXG4vKipcbiAqIEVsZW1lbnQgdG8gY2hlY2sgZm9yIHByZWZpeGVzIG9uLlxuICovXG52YXIgc3R5bGUgPSB7fTtcblxuLyoqXG4gKiBCb290c3RyYXAgaWYgYSBET00gZXhpc3RzLlxuICovXG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jykuc3R5bGU7XG5cbiAgLy8gT24gc29tZSBwbGF0Zm9ybXMsIGluIHBhcnRpY3VsYXIgc29tZSByZWxlYXNlcyBvZiBBbmRyb2lkIDQueCxcbiAgLy8gdGhlIHVuLXByZWZpeGVkIFwiYW5pbWF0aW9uXCIgYW5kIFwidHJhbnNpdGlvblwiIHByb3BlcnRpZXMgYXJlIGRlZmluZWQgb24gdGhlXG4gIC8vIHN0eWxlIG9iamVjdCBidXQgdGhlIGV2ZW50cyB0aGF0IGZpcmUgd2lsbCBzdGlsbCBiZSBwcmVmaXhlZCwgc28gd2UgbmVlZFxuICAvLyB0byBjaGVjayBpZiB0aGUgdW4tcHJlZml4ZWQgZXZlbnRzIGFyZSB1c2FibGUsIGFuZCBpZiBub3QgcmVtb3ZlIHRoZW0gZnJvbSB0aGUgbWFwLlxuICBpZiAoISgnQW5pbWF0aW9uRXZlbnQnIGluIHdpbmRvdykpIHtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMuYW5pbWF0aW9uZW5kLmFuaW1hdGlvbjtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMuYW5pbWF0aW9uaXRlcmF0aW9uLmFuaW1hdGlvbjtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMuYW5pbWF0aW9uc3RhcnQuYW5pbWF0aW9uO1xuICB9XG5cbiAgLy8gU2FtZSBhcyBhYm92ZVxuICBpZiAoISgnVHJhbnNpdGlvbkV2ZW50JyBpbiB3aW5kb3cpKSB7XG4gICAgZGVsZXRlIHZlbmRvclByZWZpeGVzLnRyYW5zaXRpb25lbmQudHJhbnNpdGlvbjtcbiAgfVxufVxuXG4vKipcbiAqIEF0dGVtcHRzIHRvIGRldGVybWluZSB0aGUgY29ycmVjdCB2ZW5kb3IgcHJlZml4ZWQgZXZlbnQgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZShldmVudE5hbWUpIHtcbiAgaWYgKHByZWZpeGVkRXZlbnROYW1lc1tldmVudE5hbWVdKSB7XG4gICAgcmV0dXJuIHByZWZpeGVkRXZlbnROYW1lc1tldmVudE5hbWVdO1xuICB9IGVsc2UgaWYgKCF2ZW5kb3JQcmVmaXhlc1tldmVudE5hbWVdKSB7XG4gICAgcmV0dXJuIGV2ZW50TmFtZTtcbiAgfVxuXG4gIHZhciBwcmVmaXhNYXAgPSB2ZW5kb3JQcmVmaXhlc1tldmVudE5hbWVdO1xuXG4gIGZvciAodmFyIHN0eWxlUHJvcCBpbiBwcmVmaXhNYXApIHtcbiAgICBpZiAocHJlZml4TWFwLmhhc093blByb3BlcnR5KHN0eWxlUHJvcCkgJiYgc3R5bGVQcm9wIGluIHN0eWxlKSB7XG4gICAgICByZXR1cm4gcHJlZml4ZWRFdmVudE5hbWVzW2V2ZW50TmFtZV0gPSBwcmVmaXhNYXBbc3R5bGVQcm9wXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogVHlwZXMgb2YgcmF3IHNpZ25hbHMgZnJvbSB0aGUgYnJvd3NlciBjYXVnaHQgYXQgdGhlIHRvcCBsZXZlbC5cbiAqXG4gKiBGb3IgZXZlbnRzIGxpa2UgJ3N1Ym1pdCcgd2hpY2ggZG9uJ3QgY29uc2lzdGVudGx5IGJ1YmJsZSAod2hpY2ggd2VcbiAqIHRyYXAgYXQgYSBsb3dlciBub2RlIHRoYW4gYGRvY3VtZW50YCksIGJpbmRpbmcgYXQgYGRvY3VtZW50YCB3b3VsZFxuICogY2F1c2UgZHVwbGljYXRlIGV2ZW50cyBzbyB3ZSBkb24ndCBpbmNsdWRlIHRoZW0gaGVyZS5cbiAqL1xudmFyIHRvcExldmVsVHlwZXMkMSA9IHtcbiAgdG9wQWJvcnQ6ICdhYm9ydCcsXG4gIHRvcEFuaW1hdGlvbkVuZDogZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoJ2FuaW1hdGlvbmVuZCcpIHx8ICdhbmltYXRpb25lbmQnLFxuICB0b3BBbmltYXRpb25JdGVyYXRpb246IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKCdhbmltYXRpb25pdGVyYXRpb24nKSB8fCAnYW5pbWF0aW9uaXRlcmF0aW9uJyxcbiAgdG9wQW5pbWF0aW9uU3RhcnQ6IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKCdhbmltYXRpb25zdGFydCcpIHx8ICdhbmltYXRpb25zdGFydCcsXG4gIHRvcEJsdXI6ICdibHVyJyxcbiAgdG9wQ2FuY2VsOiAnY2FuY2VsJyxcbiAgdG9wQ2FuUGxheTogJ2NhbnBsYXknLFxuICB0b3BDYW5QbGF5VGhyb3VnaDogJ2NhbnBsYXl0aHJvdWdoJyxcbiAgdG9wQ2hhbmdlOiAnY2hhbmdlJyxcbiAgdG9wQ2xpY2s6ICdjbGljaycsXG4gIHRvcENsb3NlOiAnY2xvc2UnLFxuICB0b3BDb21wb3NpdGlvbkVuZDogJ2NvbXBvc2l0aW9uZW5kJyxcbiAgdG9wQ29tcG9zaXRpb25TdGFydDogJ2NvbXBvc2l0aW9uc3RhcnQnLFxuICB0b3BDb21wb3NpdGlvblVwZGF0ZTogJ2NvbXBvc2l0aW9udXBkYXRlJyxcbiAgdG9wQ29udGV4dE1lbnU6ICdjb250ZXh0bWVudScsXG4gIHRvcENvcHk6ICdjb3B5JyxcbiAgdG9wQ3V0OiAnY3V0JyxcbiAgdG9wRG91YmxlQ2xpY2s6ICdkYmxjbGljaycsXG4gIHRvcERyYWc6ICdkcmFnJyxcbiAgdG9wRHJhZ0VuZDogJ2RyYWdlbmQnLFxuICB0b3BEcmFnRW50ZXI6ICdkcmFnZW50ZXInLFxuICB0b3BEcmFnRXhpdDogJ2RyYWdleGl0JyxcbiAgdG9wRHJhZ0xlYXZlOiAnZHJhZ2xlYXZlJyxcbiAgdG9wRHJhZ092ZXI6ICdkcmFnb3ZlcicsXG4gIHRvcERyYWdTdGFydDogJ2RyYWdzdGFydCcsXG4gIHRvcERyb3A6ICdkcm9wJyxcbiAgdG9wRHVyYXRpb25DaGFuZ2U6ICdkdXJhdGlvbmNoYW5nZScsXG4gIHRvcEVtcHRpZWQ6ICdlbXB0aWVkJyxcbiAgdG9wRW5jcnlwdGVkOiAnZW5jcnlwdGVkJyxcbiAgdG9wRW5kZWQ6ICdlbmRlZCcsXG4gIHRvcEVycm9yOiAnZXJyb3InLFxuICB0b3BGb2N1czogJ2ZvY3VzJyxcbiAgdG9wSW5wdXQ6ICdpbnB1dCcsXG4gIHRvcEtleURvd246ICdrZXlkb3duJyxcbiAgdG9wS2V5UHJlc3M6ICdrZXlwcmVzcycsXG4gIHRvcEtleVVwOiAna2V5dXAnLFxuICB0b3BMb2FkZWREYXRhOiAnbG9hZGVkZGF0YScsXG4gIHRvcExvYWQ6ICdsb2FkJyxcbiAgdG9wTG9hZGVkTWV0YWRhdGE6ICdsb2FkZWRtZXRhZGF0YScsXG4gIHRvcExvYWRTdGFydDogJ2xvYWRzdGFydCcsXG4gIHRvcE1vdXNlRG93bjogJ21vdXNlZG93bicsXG4gIHRvcE1vdXNlTW92ZTogJ21vdXNlbW92ZScsXG4gIHRvcE1vdXNlT3V0OiAnbW91c2VvdXQnLFxuICB0b3BNb3VzZU92ZXI6ICdtb3VzZW92ZXInLFxuICB0b3BNb3VzZVVwOiAnbW91c2V1cCcsXG4gIHRvcFBhc3RlOiAncGFzdGUnLFxuICB0b3BQYXVzZTogJ3BhdXNlJyxcbiAgdG9wUGxheTogJ3BsYXknLFxuICB0b3BQbGF5aW5nOiAncGxheWluZycsXG4gIHRvcFByb2dyZXNzOiAncHJvZ3Jlc3MnLFxuICB0b3BSYXRlQ2hhbmdlOiAncmF0ZWNoYW5nZScsXG4gIHRvcFNjcm9sbDogJ3Njcm9sbCcsXG4gIHRvcFNlZWtlZDogJ3NlZWtlZCcsXG4gIHRvcFNlZWtpbmc6ICdzZWVraW5nJyxcbiAgdG9wU2VsZWN0aW9uQ2hhbmdlOiAnc2VsZWN0aW9uY2hhbmdlJyxcbiAgdG9wU3RhbGxlZDogJ3N0YWxsZWQnLFxuICB0b3BTdXNwZW5kOiAnc3VzcGVuZCcsXG4gIHRvcFRleHRJbnB1dDogJ3RleHRJbnB1dCcsXG4gIHRvcFRpbWVVcGRhdGU6ICd0aW1ldXBkYXRlJyxcbiAgdG9wVG9nZ2xlOiAndG9nZ2xlJyxcbiAgdG9wVG91Y2hDYW5jZWw6ICd0b3VjaGNhbmNlbCcsXG4gIHRvcFRvdWNoRW5kOiAndG91Y2hlbmQnLFxuICB0b3BUb3VjaE1vdmU6ICd0b3VjaG1vdmUnLFxuICB0b3BUb3VjaFN0YXJ0OiAndG91Y2hzdGFydCcsXG4gIHRvcFRyYW5zaXRpb25FbmQ6IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKCd0cmFuc2l0aW9uZW5kJykgfHwgJ3RyYW5zaXRpb25lbmQnLFxuICB0b3BWb2x1bWVDaGFuZ2U6ICd2b2x1bWVjaGFuZ2UnLFxuICB0b3BXYWl0aW5nOiAnd2FpdGluZycsXG4gIHRvcFdoZWVsOiAnd2hlZWwnXG59O1xuXG52YXIgQnJvd3NlckV2ZW50Q29uc3RhbnRzID0ge1xuICB0b3BMZXZlbFR5cGVzOiB0b3BMZXZlbFR5cGVzJDFcbn07XG5cbmZ1bmN0aW9uIHJ1bkV2ZW50UXVldWVJbkJhdGNoKGV2ZW50cykge1xuICBlbnF1ZXVlRXZlbnRzKGV2ZW50cyk7XG4gIHByb2Nlc3NFdmVudFF1ZXVlKGZhbHNlKTtcbn1cblxuLyoqXG4gKiBTdHJlYW1zIGEgZmlyZWQgdG9wLWxldmVsIGV2ZW50IHRvIGBFdmVudFBsdWdpbkh1YmAgd2hlcmUgcGx1Z2lucyBoYXZlIHRoZVxuICogb3Bwb3J0dW5pdHkgdG8gY3JlYXRlIGBSZWFjdEV2ZW50YHMgdG8gYmUgZGlzcGF0Y2hlZC5cbiAqL1xuZnVuY3Rpb24gaGFuZGxlVG9wTGV2ZWwodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgdmFyIGV2ZW50cyA9IGV4dHJhY3RFdmVudHModG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICBydW5FdmVudFF1ZXVlSW5CYXRjaChldmVudHMpO1xufVxuXG52YXIgdG9wTGV2ZWxUeXBlcyA9IEJyb3dzZXJFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzO1xuXG4vKipcbiAqIFN1bW1hcnkgb2YgYFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlcmAgZXZlbnQgaGFuZGxpbmc6XG4gKlxuICogIC0gVG9wLWxldmVsIGRlbGVnYXRpb24gaXMgdXNlZCB0byB0cmFwIG1vc3QgbmF0aXZlIGJyb3dzZXIgZXZlbnRzLiBUaGlzXG4gKiAgICBtYXkgb25seSBvY2N1ciBpbiB0aGUgbWFpbiB0aHJlYWQgYW5kIGlzIHRoZSByZXNwb25zaWJpbGl0eSBvZlxuICogICAgUmVhY3RET01FdmVudExpc3RlbmVyLCB3aGljaCBpcyBpbmplY3RlZCBhbmQgY2FuIHRoZXJlZm9yZSBzdXBwb3J0XG4gKiAgICBwbHVnZ2FibGUgZXZlbnQgc291cmNlcy4gVGhpcyBpcyB0aGUgb25seSB3b3JrIHRoYXQgb2NjdXJzIGluIHRoZSBtYWluXG4gKiAgICB0aHJlYWQuXG4gKlxuICogIC0gV2Ugbm9ybWFsaXplIGFuZCBkZS1kdXBsaWNhdGUgZXZlbnRzIHRvIGFjY291bnQgZm9yIGJyb3dzZXIgcXVpcmtzLiBUaGlzXG4gKiAgICBtYXkgYmUgZG9uZSBpbiB0aGUgd29ya2VyIHRocmVhZC5cbiAqXG4gKiAgLSBGb3J3YXJkIHRoZXNlIG5hdGl2ZSBldmVudHMgKHdpdGggdGhlIGFzc29jaWF0ZWQgdG9wLWxldmVsIHR5cGUgdXNlZCB0b1xuICogICAgdHJhcCBpdCkgdG8gYEV2ZW50UGx1Z2luSHViYCwgd2hpY2ggaW4gdHVybiB3aWxsIGFzayBwbHVnaW5zIGlmIHRoZXkgd2FudFxuICogICAgdG8gZXh0cmFjdCBhbnkgc3ludGhldGljIGV2ZW50cy5cbiAqXG4gKiAgLSBUaGUgYEV2ZW50UGx1Z2luSHViYCB3aWxsIHRoZW4gcHJvY2VzcyBlYWNoIGV2ZW50IGJ5IGFubm90YXRpbmcgdGhlbSB3aXRoXG4gKiAgICBcImRpc3BhdGNoZXNcIiwgYSBzZXF1ZW5jZSBvZiBsaXN0ZW5lcnMgYW5kIElEcyB0aGF0IGNhcmUgYWJvdXQgdGhhdCBldmVudC5cbiAqXG4gKiAgLSBUaGUgYEV2ZW50UGx1Z2luSHViYCB0aGVuIGRpc3BhdGNoZXMgdGhlIGV2ZW50cy5cbiAqXG4gKiBPdmVydmlldyBvZiBSZWFjdCBhbmQgdGhlIGV2ZW50IHN5c3RlbTpcbiAqXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuXG4gKiB8ICAgIERPTSAgICAgfCAgICAuXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuXG4gKiAgICAgICB8ICAgICAgICAgICAuXG4gKiAgICAgICB2ICAgICAgICAgICAuXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuXG4gKiB8IFJlYWN0RXZlbnQgfCAgICAuXG4gKiB8ICBMaXN0ZW5lciAgfCAgICAuXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLStcbiAqICAgICAgIHwgICAgICAgICAgIC4gICAgICAgICAgICAgICArLS0tLS0tLS0rfFNpbXBsZUV2ZW50fFxuICogICAgICAgfCAgICAgICAgICAgLiAgICAgICAgICAgICAgIHwgICAgICAgICB8UGx1Z2luICAgICB8XG4gKiArLS0tLS18LS0tLS0tKyAgICAuICAgICAgICAgICAgICAgdiAgICAgICAgICstLS0tLS0tLS0tLStcbiAqIHwgICAgIHwgICAgICB8ICAgIC4gICAgKy0tLS0tLS0tLS0tLS0tKyAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLStcbiAqIHwgICAgICstLS0tLS0tLS0tLS4tLS0+fEV2ZW50UGx1Z2luSHVifCAgICAgICAgICAgICAgICAgICAgfCAgICBFdmVudCAgIHxcbiAqIHwgICAgICAgICAgICB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfCAgICAgKy0tLS0tLS0tLS0tKyAgfCBQcm9wYWdhdG9yc3xcbiAqIHwgUmVhY3RFdmVudCB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfCAgICAgfFRhcEV2ZW50ICAgfCAgfC0tLS0tLS0tLS0tLXxcbiAqIHwgIEVtaXR0ZXIgICB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfDwtLS0rfFBsdWdpbiAgICAgfCAgfG90aGVyIHBsdWdpbnxcbiAqIHwgICAgICAgICAgICB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfCAgICAgKy0tLS0tLS0tLS0tKyAgfCAgdXRpbGl0aWVzIHxcbiAqIHwgICAgICstLS0tLS0tLS0tLS4tLS0+fCAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLStcbiAqIHwgICAgIHwgICAgICB8ICAgIC4gICAgKy0tLS0tLS0tLS0tLS0tK1xuICogKy0tLS0tfC0tLS0tLSsgICAgLiAgICAgICAgICAgICAgICBeICAgICAgICArLS0tLS0tLS0tLS0rXG4gKiAgICAgICB8ICAgICAgICAgICAuICAgICAgICAgICAgICAgIHwgICAgICAgIHxFbnRlci9MZWF2ZXxcbiAqICAgICAgICsgICAgICAgICAgIC4gICAgICAgICAgICAgICAgKy0tLS0tLS0rfFBsdWdpbiAgICAgfFxuICogKy0tLS0tLS0tLS0tLS0rICAgLiAgICAgICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0rXG4gKiB8IGFwcGxpY2F0aW9uIHwgICAuXG4gKiB8LS0tLS0tLS0tLS0tLXwgICAuXG4gKiB8ICAgICAgICAgICAgIHwgICAuXG4gKiB8ICAgICAgICAgICAgIHwgICAuXG4gKiArLS0tLS0tLS0tLS0tLSsgICAuXG4gKiAgICAgICAgICAgICAgICAgICAuXG4gKiAgICBSZWFjdCBDb3JlICAgICAuICBHZW5lcmFsIFB1cnBvc2UgRXZlbnQgUGx1Z2luIFN5c3RlbVxuICovXG5cbnZhciBhbHJlYWR5TGlzdGVuaW5nVG8gPSB7fTtcbnZhciByZWFjdFRvcExpc3RlbmVyc0NvdW50ZXIgPSAwO1xuXG4vKipcbiAqIFRvIGVuc3VyZSBubyBjb25mbGljdHMgd2l0aCBvdGhlciBwb3RlbnRpYWwgUmVhY3QgaW5zdGFuY2VzIG9uIHRoZSBwYWdlXG4gKi9cbnZhciB0b3BMaXN0ZW5lcnNJREtleSA9ICdfcmVhY3RMaXN0ZW5lcnNJRCcgKyAoJycgKyBNYXRoLnJhbmRvbSgpKS5zbGljZSgyKTtcblxuZnVuY3Rpb24gZ2V0TGlzdGVuaW5nRm9yRG9jdW1lbnQobW91bnRBdCkge1xuICAvLyBJbiBJRTgsIGBtb3VudEF0YCBpcyBhIGhvc3Qgb2JqZWN0IGFuZCBkb2Vzbid0IGhhdmUgYGhhc093blByb3BlcnR5YFxuICAvLyBkaXJlY3RseS5cbiAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW91bnRBdCwgdG9wTGlzdGVuZXJzSURLZXkpKSB7XG4gICAgbW91bnRBdFt0b3BMaXN0ZW5lcnNJREtleV0gPSByZWFjdFRvcExpc3RlbmVyc0NvdW50ZXIrKztcbiAgICBhbHJlYWR5TGlzdGVuaW5nVG9bbW91bnRBdFt0b3BMaXN0ZW5lcnNJREtleV1dID0ge307XG4gIH1cbiAgcmV0dXJuIGFscmVhZHlMaXN0ZW5pbmdUb1ttb3VudEF0W3RvcExpc3RlbmVyc0lES2V5XV07XG59XG5cbi8qKlxuICogV2UgbGlzdGVuIGZvciBidWJibGVkIHRvdWNoIGV2ZW50cyBvbiB0aGUgZG9jdW1lbnQgb2JqZWN0LlxuICpcbiAqIEZpcmVmb3ggdjguMDEgKGFuZCBwb3NzaWJseSBvdGhlcnMpIGV4aGliaXRlZCBzdHJhbmdlIGJlaGF2aW9yIHdoZW5cbiAqIG1vdW50aW5nIGBvbm1vdXNlbW92ZWAgZXZlbnRzIGF0IHNvbWUgbm9kZSB0aGF0IHdhcyBub3QgdGhlIGRvY3VtZW50XG4gKiBlbGVtZW50LiBUaGUgc3ltcHRvbXMgd2VyZSB0aGF0IGlmIHlvdXIgbW91c2UgaXMgbm90IG1vdmluZyBvdmVyIHNvbWV0aGluZ1xuICogY29udGFpbmVkIHdpdGhpbiB0aGF0IG1vdW50IHBvaW50IChmb3IgZXhhbXBsZSBvbiB0aGUgYmFja2dyb3VuZCkgdGhlXG4gKiB0b3AtbGV2ZWwgbGlzdGVuZXJzIGZvciBgb25tb3VzZW1vdmVgIHdvbid0IGJlIGNhbGxlZC4gSG93ZXZlciwgaWYgeW91XG4gKiByZWdpc3RlciB0aGUgYG1vdXNlbW92ZWAgb24gdGhlIGRvY3VtZW50IG9iamVjdCwgdGhlbiBpdCB3aWxsIG9mIGNvdXJzZVxuICogY2F0Y2ggYWxsIGBtb3VzZW1vdmVgcy4gVGhpcyBhbG9uZyB3aXRoIGlPUyBxdWlya3MsIGp1c3RpZmllcyByZXN0cmljdGluZ1xuICogdG9wLWxldmVsIGxpc3RlbmVycyB0byB0aGUgZG9jdW1lbnQgb2JqZWN0IG9ubHksIGF0IGxlYXN0IGZvciB0aGVzZVxuICogbW92ZW1lbnQgdHlwZXMgb2YgZXZlbnRzIGFuZCBwb3NzaWJseSBhbGwgZXZlbnRzLlxuICpcbiAqIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMTAvMDkvY2xpY2tfZXZlbnRfZGVsLmh0bWxcbiAqXG4gKiBBbHNvLCBga2V5dXBgL2BrZXlwcmVzc2AvYGtleWRvd25gIGRvIG5vdCBidWJibGUgdG8gdGhlIHdpbmRvdyBvbiBJRSwgYnV0XG4gKiB0aGV5IGJ1YmJsZSB0byBkb2N1bWVudC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXG4gKiBAcGFyYW0ge29iamVjdH0gY29udGVudERvY3VtZW50SGFuZGxlIERvY3VtZW50IHdoaWNoIG93bnMgdGhlIGNvbnRhaW5lclxuICovXG5mdW5jdGlvbiBsaXN0ZW5UbyhyZWdpc3RyYXRpb25OYW1lLCBjb250ZW50RG9jdW1lbnRIYW5kbGUpIHtcbiAgdmFyIG1vdW50QXQgPSBjb250ZW50RG9jdW1lbnRIYW5kbGU7XG4gIHZhciBpc0xpc3RlbmluZyA9IGdldExpc3RlbmluZ0ZvckRvY3VtZW50KG1vdW50QXQpO1xuICB2YXIgZGVwZW5kZW5jaWVzID0gcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llc1tyZWdpc3RyYXRpb25OYW1lXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGRlcGVuZGVuY2llcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXBlbmRlbmN5ID0gZGVwZW5kZW5jaWVzW2ldO1xuICAgIGlmICghKGlzTGlzdGVuaW5nLmhhc093blByb3BlcnR5KGRlcGVuZGVuY3kpICYmIGlzTGlzdGVuaW5nW2RlcGVuZGVuY3ldKSkge1xuICAgICAgaWYgKGRlcGVuZGVuY3kgPT09ICd0b3BTY3JvbGwnKSB7XG4gICAgICAgIHRyYXBDYXB0dXJlZEV2ZW50KCd0b3BTY3JvbGwnLCAnc2Nyb2xsJywgbW91bnRBdCk7XG4gICAgICB9IGVsc2UgaWYgKGRlcGVuZGVuY3kgPT09ICd0b3BGb2N1cycgfHwgZGVwZW5kZW5jeSA9PT0gJ3RvcEJsdXInKSB7XG4gICAgICAgIHRyYXBDYXB0dXJlZEV2ZW50KCd0b3BGb2N1cycsICdmb2N1cycsIG1vdW50QXQpO1xuICAgICAgICB0cmFwQ2FwdHVyZWRFdmVudCgndG9wQmx1cicsICdibHVyJywgbW91bnRBdCk7XG5cbiAgICAgICAgLy8gdG8gbWFrZSBzdXJlIGJsdXIgYW5kIGZvY3VzIGV2ZW50IGxpc3RlbmVycyBhcmUgb25seSBhdHRhY2hlZCBvbmNlXG4gICAgICAgIGlzTGlzdGVuaW5nLnRvcEJsdXIgPSB0cnVlO1xuICAgICAgICBpc0xpc3RlbmluZy50b3BGb2N1cyA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGRlcGVuZGVuY3kgPT09ICd0b3BDYW5jZWwnKSB7XG4gICAgICAgIGlmIChpc0V2ZW50U3VwcG9ydGVkKCdjYW5jZWwnLCB0cnVlKSkge1xuICAgICAgICAgIHRyYXBDYXB0dXJlZEV2ZW50KCd0b3BDYW5jZWwnLCAnY2FuY2VsJywgbW91bnRBdCk7XG4gICAgICAgIH1cbiAgICAgICAgaXNMaXN0ZW5pbmcudG9wQ2FuY2VsID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZGVwZW5kZW5jeSA9PT0gJ3RvcENsb3NlJykge1xuICAgICAgICBpZiAoaXNFdmVudFN1cHBvcnRlZCgnY2xvc2UnLCB0cnVlKSkge1xuICAgICAgICAgIHRyYXBDYXB0dXJlZEV2ZW50KCd0b3BDbG9zZScsICdjbG9zZScsIG1vdW50QXQpO1xuICAgICAgICB9XG4gICAgICAgIGlzTGlzdGVuaW5nLnRvcENsb3NlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodG9wTGV2ZWxUeXBlcy5oYXNPd25Qcm9wZXJ0eShkZXBlbmRlbmN5KSkge1xuICAgICAgICB0cmFwQnViYmxlZEV2ZW50KGRlcGVuZGVuY3ksIHRvcExldmVsVHlwZXNbZGVwZW5kZW5jeV0sIG1vdW50QXQpO1xuICAgICAgfVxuXG4gICAgICBpc0xpc3RlbmluZ1tkZXBlbmRlbmN5XSA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzTGlzdGVuaW5nVG9BbGxEZXBlbmRlbmNpZXMocmVnaXN0cmF0aW9uTmFtZSwgbW91bnRBdCkge1xuICB2YXIgaXNMaXN0ZW5pbmcgPSBnZXRMaXN0ZW5pbmdGb3JEb2N1bWVudChtb3VudEF0KTtcbiAgdmFyIGRlcGVuZGVuY2llcyA9IHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXNbcmVnaXN0cmF0aW9uTmFtZV07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGVwZW5kZW5jaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlcGVuZGVuY3kgPSBkZXBlbmRlbmNpZXNbaV07XG4gICAgaWYgKCEoaXNMaXN0ZW5pbmcuaGFzT3duUHJvcGVydHkoZGVwZW5kZW5jeSkgJiYgaXNMaXN0ZW5pbmdbZGVwZW5kZW5jeV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEdpdmVuIGFueSBub2RlIHJldHVybiB0aGUgZmlyc3QgbGVhZiBub2RlIHdpdGhvdXQgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gKiBAcmV0dXJuIHtET01FbGVtZW50fERPTVRleHROb2RlfVxuICovXG5mdW5jdGlvbiBnZXRMZWFmTm9kZShub2RlKSB7XG4gIHdoaWxlIChub2RlICYmIG5vZGUuZmlyc3RDaGlsZCkge1xuICAgIG5vZGUgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5cbi8qKlxuICogR2V0IHRoZSBuZXh0IHNpYmxpbmcgd2l0aGluIGEgY29udGFpbmVyLiBUaGlzIHdpbGwgd2FsayB1cCB0aGVcbiAqIERPTSBpZiBhIG5vZGUncyBzaWJsaW5ncyBoYXZlIGJlZW4gZXhoYXVzdGVkLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHJldHVybiB7P0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9XG4gKi9cbmZ1bmN0aW9uIGdldFNpYmxpbmdOb2RlKG5vZGUpIHtcbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBpZiAobm9kZS5uZXh0U2libGluZykge1xuICAgICAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmc7XG4gICAgfVxuICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgb2JqZWN0IGRlc2NyaWJpbmcgdGhlIG5vZGVzIHdoaWNoIGNvbnRhaW4gY2hhcmFjdGVycyBhdCBvZmZzZXQuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSByb290XG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcmV0dXJuIHs/b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KHJvb3QsIG9mZnNldCkge1xuICB2YXIgbm9kZSA9IGdldExlYWZOb2RlKHJvb3QpO1xuICB2YXIgbm9kZVN0YXJ0ID0gMDtcbiAgdmFyIG5vZGVFbmQgPSAwO1xuXG4gIHdoaWxlIChub2RlKSB7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IFRFWFRfTk9ERSkge1xuICAgICAgbm9kZUVuZCA9IG5vZGVTdGFydCArIG5vZGUudGV4dENvbnRlbnQubGVuZ3RoO1xuXG4gICAgICBpZiAobm9kZVN0YXJ0IDw9IG9mZnNldCAmJiBub2RlRW5kID49IG9mZnNldCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5vZGU6IG5vZGUsXG4gICAgICAgICAgb2Zmc2V0OiBvZmZzZXQgLSBub2RlU3RhcnRcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgbm9kZVN0YXJ0ID0gbm9kZUVuZDtcbiAgICB9XG5cbiAgICBub2RlID0gZ2V0TGVhZk5vZGUoZ2V0U2libGluZ05vZGUobm9kZSkpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBvdXRlck5vZGVcbiAqIEByZXR1cm4gez9vYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldE9mZnNldHMob3V0ZXJOb2RlKSB7XG4gIHZhciBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uICYmIHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcblxuICBpZiAoIXNlbGVjdGlvbiB8fCBzZWxlY3Rpb24ucmFuZ2VDb3VudCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGFuY2hvck5vZGUgPSBzZWxlY3Rpb24uYW5jaG9yTm9kZSxcbiAgICAgIGFuY2hvck9mZnNldCA9IHNlbGVjdGlvbi5hbmNob3JPZmZzZXQsXG4gICAgICBmb2N1c05vZGUkJDEgPSBzZWxlY3Rpb24uZm9jdXNOb2RlLFxuICAgICAgZm9jdXNPZmZzZXQgPSBzZWxlY3Rpb24uZm9jdXNPZmZzZXQ7XG5cbiAgLy8gSW4gRmlyZWZveCwgYW5jaG9yTm9kZSBhbmQgZm9jdXNOb2RlIGNhbiBiZSBcImFub255bW91cyBkaXZzXCIsIGUuZy4gdGhlXG4gIC8vIHVwL2Rvd24gYnV0dG9ucyBvbiBhbiA8aW5wdXQgdHlwZT1cIm51bWJlclwiPi4gQW5vbnltb3VzIGRpdnMgZG8gbm90IHNlZW0gdG9cbiAgLy8gZXhwb3NlIHByb3BlcnRpZXMsIHRyaWdnZXJpbmcgYSBcIlBlcm1pc3Npb24gZGVuaWVkIGVycm9yXCIgaWYgYW55IG9mIGl0c1xuICAvLyBwcm9wZXJ0aWVzIGFyZSBhY2Nlc3NlZC4gVGhlIG9ubHkgc2VlbWluZ2x5IHBvc3NpYmxlIHdheSB0byBhdm9pZCBlcnJvcmluZ1xuICAvLyBpcyB0byBhY2Nlc3MgYSBwcm9wZXJ0eSB0aGF0IHR5cGljYWxseSB3b3JrcyBmb3Igbm9uLWFub255bW91cyBkaXZzIGFuZFxuICAvLyBjYXRjaCBhbnkgZXJyb3IgdGhhdCBtYXkgb3RoZXJ3aXNlIGFyaXNlLiBTZWVcbiAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjA4NDI3XG5cbiAgdHJ5IHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtZXhwcmVzc2lvbnMgKi9cbiAgICBhbmNob3JOb2RlLm5vZGVUeXBlO1xuICAgIGZvY3VzTm9kZSQkMS5ub2RlVHlwZTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC1leHByZXNzaW9ucyAqL1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gZ2V0TW9kZXJuT2Zmc2V0c0Zyb21Qb2ludHMob3V0ZXJOb2RlLCBhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGZvY3VzTm9kZSQkMSwgZm9jdXNPZmZzZXQpO1xufVxuXG4vKipcbiAqIFJldHVybnMge3N0YXJ0LCBlbmR9IHdoZXJlIGBzdGFydGAgaXMgdGhlIGNoYXJhY3Rlci9jb2RlcG9pbnQgaW5kZXggb2ZcbiAqIChhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQpIHdpdGhpbiB0aGUgdGV4dENvbnRlbnQgb2YgYG91dGVyTm9kZWAsIGFuZFxuICogYGVuZGAgaXMgdGhlIGluZGV4IG9mIChmb2N1c05vZGUsIGZvY3VzT2Zmc2V0KS5cbiAqXG4gKiBSZXR1cm5zIG51bGwgaWYgeW91IHBhc3MgaW4gZ2FyYmFnZSBpbnB1dCBidXQgd2Ugc2hvdWxkIHByb2JhYmx5IGp1c3QgY3Jhc2guXG4gKlxuICogRXhwb3J0ZWQgb25seSBmb3IgdGVzdGluZy5cbiAqL1xuZnVuY3Rpb24gZ2V0TW9kZXJuT2Zmc2V0c0Zyb21Qb2ludHMob3V0ZXJOb2RlLCBhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGZvY3VzTm9kZSQkMSwgZm9jdXNPZmZzZXQpIHtcbiAgdmFyIGxlbmd0aCA9IDA7XG4gIHZhciBzdGFydCA9IC0xO1xuICB2YXIgZW5kID0gLTE7XG4gIHZhciBpbmRleFdpdGhpbkFuY2hvciA9IDA7XG4gIHZhciBpbmRleFdpdGhpbkZvY3VzID0gMDtcbiAgdmFyIG5vZGUgPSBvdXRlck5vZGU7XG4gIHZhciBwYXJlbnROb2RlID0gbnVsbDtcblxuICBvdXRlcjogd2hpbGUgKHRydWUpIHtcbiAgICB2YXIgbmV4dCA9IG51bGw7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKG5vZGUgPT09IGFuY2hvck5vZGUgJiYgKGFuY2hvck9mZnNldCA9PT0gMCB8fCBub2RlLm5vZGVUeXBlID09PSBURVhUX05PREUpKSB7XG4gICAgICAgIHN0YXJ0ID0gbGVuZ3RoICsgYW5jaG9yT2Zmc2V0O1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUgPT09IGZvY3VzTm9kZSQkMSAmJiAoZm9jdXNPZmZzZXQgPT09IDAgfHwgbm9kZS5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFKSkge1xuICAgICAgICBlbmQgPSBsZW5ndGggKyBmb2N1c09mZnNldDtcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IFRFWFRfTk9ERSkge1xuICAgICAgICBsZW5ndGggKz0gbm9kZS5ub2RlVmFsdWUubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICBpZiAoKG5leHQgPSBub2RlLmZpcnN0Q2hpbGQpID09PSBudWxsKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy8gTW92aW5nIGZyb20gYG5vZGVgIHRvIGl0cyBmaXJzdCBjaGlsZCBgbmV4dGAuXG4gICAgICBwYXJlbnROb2RlID0gbm9kZTtcbiAgICAgIG5vZGUgPSBuZXh0O1xuICAgIH1cblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAobm9kZSA9PT0gb3V0ZXJOb2RlKSB7XG4gICAgICAgIC8vIElmIGBvdXRlck5vZGVgIGhhcyBjaGlsZHJlbiwgdGhpcyBpcyBhbHdheXMgdGhlIHNlY29uZCB0aW1lIHZpc2l0aW5nXG4gICAgICAgIC8vIGl0LiBJZiBpdCBoYXMgbm8gY2hpbGRyZW4sIHRoaXMgaXMgc3RpbGwgdGhlIGZpcnN0IGxvb3AsIGFuZCB0aGUgb25seVxuICAgICAgICAvLyB2YWxpZCBzZWxlY3Rpb24gaXMgYW5jaG9yTm9kZSBhbmQgZm9jdXNOb2RlIGJvdGggZXF1YWwgdG8gdGhpcyBub2RlXG4gICAgICAgIC8vIGFuZCBib3RoIG9mZnNldHMgMCwgaW4gd2hpY2ggY2FzZSB3ZSB3aWxsIGhhdmUgaGFuZGxlZCBhYm92ZS5cbiAgICAgICAgYnJlYWsgb3V0ZXI7XG4gICAgICB9XG4gICAgICBpZiAocGFyZW50Tm9kZSA9PT0gYW5jaG9yTm9kZSAmJiArK2luZGV4V2l0aGluQW5jaG9yID09PSBhbmNob3JPZmZzZXQpIHtcbiAgICAgICAgc3RhcnQgPSBsZW5ndGg7XG4gICAgICB9XG4gICAgICBpZiAocGFyZW50Tm9kZSA9PT0gZm9jdXNOb2RlJCQxICYmICsraW5kZXhXaXRoaW5Gb2N1cyA9PT0gZm9jdXNPZmZzZXQpIHtcbiAgICAgICAgZW5kID0gbGVuZ3RoO1xuICAgICAgfVxuICAgICAgaWYgKChuZXh0ID0gbm9kZS5uZXh0U2libGluZykgIT09IG51bGwpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBub2RlID0gcGFyZW50Tm9kZTtcbiAgICAgIHBhcmVudE5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfVxuXG4gICAgLy8gTW92aW5nIGZyb20gYG5vZGVgIHRvIGl0cyBuZXh0IHNpYmxpbmcgYG5leHRgLlxuICAgIG5vZGUgPSBuZXh0O1xuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSAtMSB8fCBlbmQgPT09IC0xKSB7XG4gICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuLiAoV291bGQgaGFwcGVuIGlmIHRoZSBhbmNob3IvZm9jdXMgbm9kZXMgYXJlbid0XG4gICAgLy8gYWN0dWFsbHkgaW5zaWRlIHRoZSBwYXNzZWQtaW4gbm9kZS4pXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBzdGFydCxcbiAgICBlbmQ6IGVuZFxuICB9O1xufVxuXG4vKipcbiAqIEluIG1vZGVybiBub24tSUUgYnJvd3NlcnMsIHdlIGNhbiBzdXBwb3J0IGJvdGggZm9yd2FyZCBhbmQgYmFja3dhcmRcbiAqIHNlbGVjdGlvbnMuXG4gKlxuICogTm90ZTogSUUxMCsgc3VwcG9ydHMgdGhlIFNlbGVjdGlvbiBvYmplY3QsIGJ1dCBpdCBkb2VzIG5vdCBzdXBwb3J0XG4gKiB0aGUgYGV4dGVuZGAgbWV0aG9kLCB3aGljaCBtZWFucyB0aGF0IGV2ZW4gaW4gbW9kZXJuIElFLCBpdCdzIG5vdCBwb3NzaWJsZVxuICogdG8gcHJvZ3JhbW1hdGljYWxseSBjcmVhdGUgYSBiYWNrd2FyZCBzZWxlY3Rpb24uIFRodXMsIGZvciBhbGwgSUVcbiAqIHZlcnNpb25zLCB3ZSB1c2UgdGhlIG9sZCBJRSBBUEkgdG8gY3JlYXRlIG91ciBzZWxlY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtvYmplY3R9IG9mZnNldHNcbiAqL1xuZnVuY3Rpb24gc2V0T2Zmc2V0cyhub2RlLCBvZmZzZXRzKSB7XG4gIGlmICghd2luZG93LmdldFNlbGVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gIHZhciBsZW5ndGggPSBub2RlW2dldFRleHRDb250ZW50QWNjZXNzb3IoKV0ubGVuZ3RoO1xuICB2YXIgc3RhcnQgPSBNYXRoLm1pbihvZmZzZXRzLnN0YXJ0LCBsZW5ndGgpO1xuICB2YXIgZW5kID0gb2Zmc2V0cy5lbmQgPT09IHVuZGVmaW5lZCA/IHN0YXJ0IDogTWF0aC5taW4ob2Zmc2V0cy5lbmQsIGxlbmd0aCk7XG5cbiAgLy8gSUUgMTEgdXNlcyBtb2Rlcm4gc2VsZWN0aW9uLCBidXQgZG9lc24ndCBzdXBwb3J0IHRoZSBleHRlbmQgbWV0aG9kLlxuICAvLyBGbGlwIGJhY2t3YXJkIHNlbGVjdGlvbnMsIHNvIHdlIGNhbiBzZXQgd2l0aCBhIHNpbmdsZSByYW5nZS5cbiAgaWYgKCFzZWxlY3Rpb24uZXh0ZW5kICYmIHN0YXJ0ID4gZW5kKSB7XG4gICAgdmFyIHRlbXAgPSBlbmQ7XG4gICAgZW5kID0gc3RhcnQ7XG4gICAgc3RhcnQgPSB0ZW1wO1xuICB9XG5cbiAgdmFyIHN0YXJ0TWFya2VyID0gZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldChub2RlLCBzdGFydCk7XG4gIHZhciBlbmRNYXJrZXIgPSBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KG5vZGUsIGVuZCk7XG5cbiAgaWYgKHN0YXJ0TWFya2VyICYmIGVuZE1hcmtlcikge1xuICAgIGlmIChzZWxlY3Rpb24ucmFuZ2VDb3VudCA9PT0gMSAmJiBzZWxlY3Rpb24uYW5jaG9yTm9kZSA9PT0gc3RhcnRNYXJrZXIubm9kZSAmJiBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0ID09PSBzdGFydE1hcmtlci5vZmZzZXQgJiYgc2VsZWN0aW9uLmZvY3VzTm9kZSA9PT0gZW5kTWFya2VyLm5vZGUgJiYgc2VsZWN0aW9uLmZvY3VzT2Zmc2V0ID09PSBlbmRNYXJrZXIub2Zmc2V0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgcmFuZ2Uuc2V0U3RhcnQoc3RhcnRNYXJrZXIubm9kZSwgc3RhcnRNYXJrZXIub2Zmc2V0KTtcbiAgICBzZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG5cbiAgICBpZiAoc3RhcnQgPiBlbmQpIHtcbiAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XG4gICAgICBzZWxlY3Rpb24uZXh0ZW5kKGVuZE1hcmtlci5ub2RlLCBlbmRNYXJrZXIub2Zmc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmFuZ2Uuc2V0RW5kKGVuZE1hcmtlci5ub2RlLCBlbmRNYXJrZXIub2Zmc2V0KTtcbiAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzSW5Eb2N1bWVudChub2RlKSB7XG4gIHJldHVybiBjb250YWluc05vZGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBub2RlKTtcbn1cblxuLyoqXG4gKiBAUmVhY3RJbnB1dFNlbGVjdGlvbjogUmVhY3QgaW5wdXQgc2VsZWN0aW9uIG1vZHVsZS4gQmFzZWQgb24gU2VsZWN0aW9uLmpzLFxuICogYnV0IG1vZGlmaWVkIHRvIGJlIHN1aXRhYmxlIGZvciByZWFjdCBhbmQgaGFzIGEgY291cGxlIG9mIGJ1ZyBmaXhlcyAoZG9lc24ndFxuICogYXNzdW1lIGJ1dHRvbnMgaGF2ZSByYW5nZSBzZWxlY3Rpb25zIGFsbG93ZWQpLlxuICogSW5wdXQgc2VsZWN0aW9uIG1vZHVsZSBmb3IgUmVhY3QuXG4gKi9cblxuZnVuY3Rpb24gaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKGVsZW0pIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbSAmJiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIG5vZGVOYW1lICYmIChub2RlTmFtZSA9PT0gJ2lucHV0JyAmJiBlbGVtLnR5cGUgPT09ICd0ZXh0JyB8fCBub2RlTmFtZSA9PT0gJ3RleHRhcmVhJyB8fCBlbGVtLmNvbnRlbnRFZGl0YWJsZSA9PT0gJ3RydWUnKTtcbn1cblxuZnVuY3Rpb24gZ2V0U2VsZWN0aW9uSW5mb3JtYXRpb24oKSB7XG4gIHZhciBmb2N1c2VkRWxlbSA9IGdldEFjdGl2ZUVsZW1lbnQoKTtcbiAgcmV0dXJuIHtcbiAgICBmb2N1c2VkRWxlbTogZm9jdXNlZEVsZW0sXG4gICAgc2VsZWN0aW9uUmFuZ2U6IGhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhmb2N1c2VkRWxlbSkgPyBnZXRTZWxlY3Rpb24kMShmb2N1c2VkRWxlbSkgOiBudWxsXG4gIH07XG59XG5cbi8qKlxuICogQHJlc3RvcmVTZWxlY3Rpb246IElmIGFueSBzZWxlY3Rpb24gaW5mb3JtYXRpb24gd2FzIHBvdGVudGlhbGx5IGxvc3QsXG4gKiByZXN0b3JlIGl0LiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHBlcmZvcm1pbmcgb3BlcmF0aW9ucyB0aGF0IGNvdWxkIHJlbW92ZSBkb21cbiAqIG5vZGVzIGFuZCBwbGFjZSB0aGVtIGJhY2sgaW4sIHJlc3VsdGluZyBpbiBmb2N1cyBiZWluZyBsb3N0LlxuICovXG5mdW5jdGlvbiByZXN0b3JlU2VsZWN0aW9uKHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24pIHtcbiAgdmFyIGN1ckZvY3VzZWRFbGVtID0gZ2V0QWN0aXZlRWxlbWVudCgpO1xuICB2YXIgcHJpb3JGb2N1c2VkRWxlbSA9IHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24uZm9jdXNlZEVsZW07XG4gIHZhciBwcmlvclNlbGVjdGlvblJhbmdlID0gcHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbi5zZWxlY3Rpb25SYW5nZTtcbiAgaWYgKGN1ckZvY3VzZWRFbGVtICE9PSBwcmlvckZvY3VzZWRFbGVtICYmIGlzSW5Eb2N1bWVudChwcmlvckZvY3VzZWRFbGVtKSkge1xuICAgIGlmIChoYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMocHJpb3JGb2N1c2VkRWxlbSkpIHtcbiAgICAgIHNldFNlbGVjdGlvbihwcmlvckZvY3VzZWRFbGVtLCBwcmlvclNlbGVjdGlvblJhbmdlKTtcbiAgICB9XG5cbiAgICAvLyBGb2N1c2luZyBhIG5vZGUgY2FuIGNoYW5nZSB0aGUgc2Nyb2xsIHBvc2l0aW9uLCB3aGljaCBpcyB1bmRlc2lyYWJsZVxuICAgIHZhciBhbmNlc3RvcnMgPSBbXTtcbiAgICB2YXIgYW5jZXN0b3IgPSBwcmlvckZvY3VzZWRFbGVtO1xuICAgIHdoaWxlIChhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudE5vZGUpIHtcbiAgICAgIGlmIChhbmNlc3Rvci5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgIGFuY2VzdG9ycy5wdXNoKHtcbiAgICAgICAgICBlbGVtZW50OiBhbmNlc3RvcixcbiAgICAgICAgICBsZWZ0OiBhbmNlc3Rvci5zY3JvbGxMZWZ0LFxuICAgICAgICAgIHRvcDogYW5jZXN0b3Iuc2Nyb2xsVG9wXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvY3VzTm9kZShwcmlvckZvY3VzZWRFbGVtKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW5jZXN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaW5mbyA9IGFuY2VzdG9yc1tpXTtcbiAgICAgIGluZm8uZWxlbWVudC5zY3JvbGxMZWZ0ID0gaW5mby5sZWZ0O1xuICAgICAgaW5mby5lbGVtZW50LnNjcm9sbFRvcCA9IGluZm8udG9wO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBnZXRTZWxlY3Rpb246IEdldHMgdGhlIHNlbGVjdGlvbiBib3VuZHMgb2YgYSBmb2N1c2VkIHRleHRhcmVhLCBpbnB1dCBvclxuICogY29udGVudEVkaXRhYmxlIG5vZGUuXG4gKiAtQGlucHV0OiBMb29rIHVwIHNlbGVjdGlvbiBib3VuZHMgb2YgdGhpcyBpbnB1dFxuICogLUByZXR1cm4ge3N0YXJ0OiBzZWxlY3Rpb25TdGFydCwgZW5kOiBzZWxlY3Rpb25FbmR9XG4gKi9cbmZ1bmN0aW9uIGdldFNlbGVjdGlvbiQxKGlucHV0KSB7XG4gIHZhciBzZWxlY3Rpb24gPSB2b2lkIDA7XG5cbiAgaWYgKCdzZWxlY3Rpb25TdGFydCcgaW4gaW5wdXQpIHtcbiAgICAvLyBNb2Rlcm4gYnJvd3NlciB3aXRoIGlucHV0IG9yIHRleHRhcmVhLlxuICAgIHNlbGVjdGlvbiA9IHtcbiAgICAgIHN0YXJ0OiBpbnB1dC5zZWxlY3Rpb25TdGFydCxcbiAgICAgIGVuZDogaW5wdXQuc2VsZWN0aW9uRW5kXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBDb250ZW50IGVkaXRhYmxlIG9yIG9sZCBJRSB0ZXh0YXJlYS5cbiAgICBzZWxlY3Rpb24gPSBnZXRPZmZzZXRzKGlucHV0KTtcbiAgfVxuXG4gIHJldHVybiBzZWxlY3Rpb24gfHwgeyBzdGFydDogMCwgZW5kOiAwIH07XG59XG5cbi8qKlxuICogQHNldFNlbGVjdGlvbjogU2V0cyB0aGUgc2VsZWN0aW9uIGJvdW5kcyBvZiBhIHRleHRhcmVhIG9yIGlucHV0IGFuZCBmb2N1c2VzXG4gKiB0aGUgaW5wdXQuXG4gKiAtQGlucHV0ICAgICBTZXQgc2VsZWN0aW9uIGJvdW5kcyBvZiB0aGlzIGlucHV0IG9yIHRleHRhcmVhXG4gKiAtQG9mZnNldHMgICBPYmplY3Qgb2Ygc2FtZSBmb3JtIHRoYXQgaXMgcmV0dXJuZWQgZnJvbSBnZXQqXG4gKi9cbmZ1bmN0aW9uIHNldFNlbGVjdGlvbihpbnB1dCwgb2Zmc2V0cykge1xuICB2YXIgc3RhcnQgPSBvZmZzZXRzLnN0YXJ0LFxuICAgICAgZW5kID0gb2Zmc2V0cy5lbmQ7XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gc3RhcnQ7XG4gIH1cblxuICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBpbnB1dCkge1xuICAgIGlucHV0LnNlbGVjdGlvblN0YXJ0ID0gc3RhcnQ7XG4gICAgaW5wdXQuc2VsZWN0aW9uRW5kID0gTWF0aC5taW4oZW5kLCBpbnB1dC52YWx1ZS5sZW5ndGgpO1xuICB9IGVsc2Uge1xuICAgIHNldE9mZnNldHMoaW5wdXQsIG9mZnNldHMpO1xuICB9XG59XG5cbnZhciBza2lwU2VsZWN0aW9uQ2hhbmdlRXZlbnQgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRNb2RlIDw9IDExO1xuXG52YXIgZXZlbnRUeXBlcyQzID0ge1xuICBzZWxlY3Q6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogJ29uU2VsZWN0JyxcbiAgICAgIGNhcHR1cmVkOiAnb25TZWxlY3RDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcEJsdXInLCAndG9wQ29udGV4dE1lbnUnLCAndG9wRm9jdXMnLCAndG9wS2V5RG93bicsICd0b3BLZXlVcCcsICd0b3BNb3VzZURvd24nLCAndG9wTW91c2VVcCcsICd0b3BTZWxlY3Rpb25DaGFuZ2UnXVxuICB9XG59O1xuXG52YXIgYWN0aXZlRWxlbWVudCQxID0gbnVsbDtcbnZhciBhY3RpdmVFbGVtZW50SW5zdCQxID0gbnVsbDtcbnZhciBsYXN0U2VsZWN0aW9uID0gbnVsbDtcbnZhciBtb3VzZURvd24gPSBmYWxzZTtcblxuLyoqXG4gKiBHZXQgYW4gb2JqZWN0IHdoaWNoIGlzIGEgdW5pcXVlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAqXG4gKiBUaGUgcmV0dXJuIHZhbHVlIHdpbGwgbm90IGJlIGNvbnNpc3RlbnQgYWNyb3NzIG5vZGVzIG9yIGJyb3dzZXJzLCBidXRcbiAqIHR3byBpZGVudGljYWwgc2VsZWN0aW9ucyBvbiB0aGUgc2FtZSBub2RlIHdpbGwgcmV0dXJuIGlkZW50aWNhbCBvYmplY3RzLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRTZWxlY3Rpb24obm9kZSkge1xuICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBub2RlICYmIGhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhub2RlKSkge1xuICAgIHJldHVybiB7XG4gICAgICBzdGFydDogbm9kZS5zZWxlY3Rpb25TdGFydCxcbiAgICAgIGVuZDogbm9kZS5zZWxlY3Rpb25FbmRcbiAgICB9O1xuICB9IGVsc2UgaWYgKHdpbmRvdy5nZXRTZWxlY3Rpb24pIHtcbiAgICB2YXIgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgIHJldHVybiB7XG4gICAgICBhbmNob3JOb2RlOiBzZWxlY3Rpb24uYW5jaG9yTm9kZSxcbiAgICAgIGFuY2hvck9mZnNldDogc2VsZWN0aW9uLmFuY2hvck9mZnNldCxcbiAgICAgIGZvY3VzTm9kZTogc2VsZWN0aW9uLmZvY3VzTm9kZSxcbiAgICAgIGZvY3VzT2Zmc2V0OiBzZWxlY3Rpb24uZm9jdXNPZmZzZXRcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogUG9sbCBzZWxlY3Rpb24gdG8gc2VlIHdoZXRoZXIgaXQncyBjaGFuZ2VkLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHJldHVybiB7P1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBjb25zdHJ1Y3RTZWxlY3RFdmVudChuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgLy8gRW5zdXJlIHdlIGhhdmUgdGhlIHJpZ2h0IGVsZW1lbnQsIGFuZCB0aGF0IHRoZSB1c2VyIGlzIG5vdCBkcmFnZ2luZyBhXG4gIC8vIHNlbGVjdGlvbiAodGhpcyBtYXRjaGVzIG5hdGl2ZSBgc2VsZWN0YCBldmVudCBiZWhhdmlvcikuIEluIEhUTUw1LCBzZWxlY3RcbiAgLy8gZmlyZXMgb25seSBvbiBpbnB1dCBhbmQgdGV4dGFyZWEgdGh1cyBpZiB0aGVyZSdzIG5vIGZvY3VzZWQgZWxlbWVudCB3ZVxuICAvLyB3b24ndCBkaXNwYXRjaC5cbiAgaWYgKG1vdXNlRG93biB8fCBhY3RpdmVFbGVtZW50JDEgPT0gbnVsbCB8fCBhY3RpdmVFbGVtZW50JDEgIT09IGdldEFjdGl2ZUVsZW1lbnQoKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gT25seSBmaXJlIHdoZW4gc2VsZWN0aW9uIGhhcyBhY3R1YWxseSBjaGFuZ2VkLlxuICB2YXIgY3VycmVudFNlbGVjdGlvbiA9IGdldFNlbGVjdGlvbihhY3RpdmVFbGVtZW50JDEpO1xuICBpZiAoIWxhc3RTZWxlY3Rpb24gfHwgIXNoYWxsb3dFcXVhbChsYXN0U2VsZWN0aW9uLCBjdXJyZW50U2VsZWN0aW9uKSkge1xuICAgIGxhc3RTZWxlY3Rpb24gPSBjdXJyZW50U2VsZWN0aW9uO1xuXG4gICAgdmFyIHN5bnRoZXRpY0V2ZW50ID0gU3ludGhldGljRXZlbnQkMS5nZXRQb29sZWQoZXZlbnRUeXBlcyQzLnNlbGVjdCwgYWN0aXZlRWxlbWVudEluc3QkMSwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcblxuICAgIHN5bnRoZXRpY0V2ZW50LnR5cGUgPSAnc2VsZWN0JztcbiAgICBzeW50aGV0aWNFdmVudC50YXJnZXQgPSBhY3RpdmVFbGVtZW50JDE7XG5cbiAgICBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKHN5bnRoZXRpY0V2ZW50KTtcblxuICAgIHJldHVybiBzeW50aGV0aWNFdmVudDtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFRoaXMgcGx1Z2luIGNyZWF0ZXMgYW4gYG9uU2VsZWN0YCBldmVudCB0aGF0IG5vcm1hbGl6ZXMgc2VsZWN0IGV2ZW50c1xuICogYWNyb3NzIGZvcm0gZWxlbWVudHMuXG4gKlxuICogU3VwcG9ydGVkIGVsZW1lbnRzIGFyZTpcbiAqIC0gaW5wdXQgKHNlZSBgaXNUZXh0SW5wdXRFbGVtZW50YClcbiAqIC0gdGV4dGFyZWFcbiAqIC0gY29udGVudEVkaXRhYmxlXG4gKlxuICogVGhpcyBkaWZmZXJzIGZyb20gbmF0aXZlIGJyb3dzZXIgaW1wbGVtZW50YXRpb25zIGluIHRoZSBmb2xsb3dpbmcgd2F5czpcbiAqIC0gRmlyZXMgb24gY29udGVudEVkaXRhYmxlIGZpZWxkcyBhcyB3ZWxsIGFzIGlucHV0cy5cbiAqIC0gRmlyZXMgZm9yIGNvbGxhcHNlZCBzZWxlY3Rpb24uXG4gKiAtIEZpcmVzIGFmdGVyIHVzZXIgaW5wdXQuXG4gKi9cbnZhciBTZWxlY3RFdmVudFBsdWdpbiA9IHtcbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyQzLFxuXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHZhciBkb2MgPSBuYXRpdmVFdmVudFRhcmdldC53aW5kb3cgPT09IG5hdGl2ZUV2ZW50VGFyZ2V0ID8gbmF0aXZlRXZlbnRUYXJnZXQuZG9jdW1lbnQgOiBuYXRpdmVFdmVudFRhcmdldC5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfTk9ERSA/IG5hdGl2ZUV2ZW50VGFyZ2V0IDogbmF0aXZlRXZlbnRUYXJnZXQub3duZXJEb2N1bWVudDtcbiAgICAvLyBUcmFjayB3aGV0aGVyIGFsbCBsaXN0ZW5lcnMgZXhpc3RzIGZvciB0aGlzIHBsdWdpbi4gSWYgbm9uZSBleGlzdCwgd2UgZG9cbiAgICAvLyBub3QgZXh0cmFjdCBldmVudHMuIFNlZSAjMzYzOS5cbiAgICBpZiAoIWRvYyB8fCAhaXNMaXN0ZW5pbmdUb0FsbERlcGVuZGVuY2llcygnb25TZWxlY3QnLCBkb2MpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgdGFyZ2V0Tm9kZSA9IHRhcmdldEluc3QgPyBnZXROb2RlRnJvbUluc3RhbmNlJDEodGFyZ2V0SW5zdCkgOiB3aW5kb3c7XG5cbiAgICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgICAgLy8gVHJhY2sgdGhlIGlucHV0IG5vZGUgdGhhdCBoYXMgZm9jdXMuXG4gICAgICBjYXNlICd0b3BGb2N1cyc6XG4gICAgICAgIGlmIChpc1RleHRJbnB1dEVsZW1lbnQodGFyZ2V0Tm9kZSkgfHwgdGFyZ2V0Tm9kZS5jb250ZW50RWRpdGFibGUgPT09ICd0cnVlJykge1xuICAgICAgICAgIGFjdGl2ZUVsZW1lbnQkMSA9IHRhcmdldE5vZGU7XG4gICAgICAgICAgYWN0aXZlRWxlbWVudEluc3QkMSA9IHRhcmdldEluc3Q7XG4gICAgICAgICAgbGFzdFNlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BCbHVyJzpcbiAgICAgICAgYWN0aXZlRWxlbWVudCQxID0gbnVsbDtcbiAgICAgICAgYWN0aXZlRWxlbWVudEluc3QkMSA9IG51bGw7XG4gICAgICAgIGxhc3RTZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIERvbid0IGZpcmUgdGhlIGV2ZW50IHdoaWxlIHRoZSB1c2VyIGlzIGRyYWdnaW5nLiBUaGlzIG1hdGNoZXMgdGhlXG4gICAgICAvLyBzZW1hbnRpY3Mgb2YgdGhlIG5hdGl2ZSBzZWxlY3QgZXZlbnQuXG4gICAgICBjYXNlICd0b3BNb3VzZURvd24nOlxuICAgICAgICBtb3VzZURvd24gPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcENvbnRleHRNZW51JzpcbiAgICAgIGNhc2UgJ3RvcE1vdXNlVXAnOlxuICAgICAgICBtb3VzZURvd24gPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdFNlbGVjdEV2ZW50KG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgICAvLyBDaHJvbWUgYW5kIElFIGZpcmUgbm9uLXN0YW5kYXJkIGV2ZW50IHdoZW4gc2VsZWN0aW9uIGlzIGNoYW5nZWQgKGFuZFxuICAgICAgLy8gc29tZXRpbWVzIHdoZW4gaXQgaGFzbid0KS4gSUUncyBldmVudCBmaXJlcyBvdXQgb2Ygb3JkZXIgd2l0aCByZXNwZWN0XG4gICAgICAvLyB0byBrZXkgYW5kIGlucHV0IGV2ZW50cyBvbiBkZWxldGlvbiwgc28gd2UgZGlzY2FyZCBpdC5cbiAgICAgIC8vXG4gICAgICAvLyBGaXJlZm94IGRvZXNuJ3Qgc3VwcG9ydCBzZWxlY3Rpb25jaGFuZ2UsIHNvIGNoZWNrIHNlbGVjdGlvbiBzdGF0dXNcbiAgICAgIC8vIGFmdGVyIGVhY2gga2V5IGVudHJ5LiBUaGUgc2VsZWN0aW9uIGNoYW5nZXMgYWZ0ZXIga2V5ZG93biBhbmQgYmVmb3JlXG4gICAgICAvLyBrZXl1cCwgYnV0IHdlIGNoZWNrIG9uIGtleWRvd24gYXMgd2VsbCBpbiB0aGUgY2FzZSBvZiBob2xkaW5nIGRvd24gYVxuICAgICAgLy8ga2V5LCB3aGVuIG11bHRpcGxlIGtleWRvd24gZXZlbnRzIGFyZSBmaXJlZCBidXQgb25seSBvbmUga2V5dXAgaXMuXG4gICAgICAvLyBUaGlzIGlzIGFsc28gb3VyIGFwcHJvYWNoIGZvciBJRSBoYW5kbGluZywgZm9yIHRoZSByZWFzb24gYWJvdmUuXG4gICAgICBjYXNlICd0b3BTZWxlY3Rpb25DaGFuZ2UnOlxuICAgICAgICBpZiAoc2tpcFNlbGVjdGlvbkNoYW5nZUV2ZW50KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgIGNhc2UgJ3RvcEtleURvd24nOlxuICAgICAgY2FzZSAndG9wS2V5VXAnOlxuICAgICAgICByZXR1cm4gY29uc3RydWN0U2VsZWN0RXZlbnQobmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtYW5pbWF0aW9ucy8jQW5pbWF0aW9uRXZlbnQtaW50ZXJmYWNlXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BbmltYXRpb25FdmVudFxuICovXG52YXIgQW5pbWF0aW9uRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGFuaW1hdGlvbk5hbWU6IG51bGwsXG4gIGVsYXBzZWRUaW1lOiBudWxsLFxuICBwc2V1ZG9FbGVtZW50OiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljQW5pbWF0aW9uRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50JDEuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50JDEuYXVnbWVudENsYXNzKFN5bnRoZXRpY0FuaW1hdGlvbkV2ZW50LCBBbmltYXRpb25FdmVudEludGVyZmFjZSk7XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9jbGlwYm9hcmQtYXBpcy9cbiAqL1xudmFyIENsaXBib2FyZEV2ZW50SW50ZXJmYWNlID0ge1xuICBjbGlwYm9hcmREYXRhOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ2NsaXBib2FyZERhdGEnIGluIGV2ZW50ID8gZXZlbnQuY2xpcGJvYXJkRGF0YSA6IHdpbmRvdy5jbGlwYm9hcmREYXRhO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljQ2xpcGJvYXJkRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50JDEuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50JDEuYXVnbWVudENsYXNzKFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50LCBDbGlwYm9hcmRFdmVudEludGVyZmFjZSk7XG5cbi8qKlxuICogQGludGVyZmFjZSBGb2N1c0V2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIEZvY3VzRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHJlbGF0ZWRUYXJnZXQ6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0ZvY3VzRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY1VJRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY1VJRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0ZvY3VzRXZlbnQsIEZvY3VzRXZlbnRJbnRlcmZhY2UpO1xuXG4vKipcbiAqIGBjaGFyQ29kZWAgcmVwcmVzZW50cyB0aGUgYWN0dWFsIFwiY2hhcmFjdGVyIGNvZGVcIiBhbmQgaXMgc2FmZSB0byB1c2Ugd2l0aFxuICogYFN0cmluZy5mcm9tQ2hhckNvZGVgLiBBcyBzdWNoLCBvbmx5IGtleXMgdGhhdCBjb3JyZXNwb25kIHRvIHByaW50YWJsZVxuICogY2hhcmFjdGVycyBwcm9kdWNlIGEgdmFsaWQgYGNoYXJDb2RlYCwgdGhlIG9ubHkgZXhjZXB0aW9uIHRvIHRoaXMgaXMgRW50ZXIuXG4gKiBUaGUgVGFiLWtleSBpcyBjb25zaWRlcmVkIG5vbi1wcmludGFibGUgYW5kIGRvZXMgbm90IGhhdmUgYSBgY2hhckNvZGVgLFxuICogcHJlc3VtYWJseSBiZWNhdXNlIGl0IGRvZXMgbm90IHByb2R1Y2UgYSB0YWItY2hhcmFjdGVyIGluIGJyb3dzZXJzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge251bWJlcn0gTm9ybWFsaXplZCBgY2hhckNvZGVgIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBjaGFyQ29kZTtcbiAgdmFyIGtleUNvZGUgPSBuYXRpdmVFdmVudC5rZXlDb2RlO1xuXG4gIGlmICgnY2hhckNvZGUnIGluIG5hdGl2ZUV2ZW50KSB7XG4gICAgY2hhckNvZGUgPSBuYXRpdmVFdmVudC5jaGFyQ29kZTtcblxuICAgIC8vIEZGIGRvZXMgbm90IHNldCBgY2hhckNvZGVgIGZvciB0aGUgRW50ZXIta2V5LCBjaGVjayBhZ2FpbnN0IGBrZXlDb2RlYC5cbiAgICBpZiAoY2hhckNvZGUgPT09IDAgJiYga2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgIGNoYXJDb2RlID0gMTM7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIElFOCBkb2VzIG5vdCBpbXBsZW1lbnQgYGNoYXJDb2RlYCwgYnV0IGBrZXlDb2RlYCBoYXMgdGhlIGNvcnJlY3QgdmFsdWUuXG4gICAgY2hhckNvZGUgPSBrZXlDb2RlO1xuICB9XG5cbiAgLy8gU29tZSBub24tcHJpbnRhYmxlIGtleXMgYXJlIHJlcG9ydGVkIGluIGBjaGFyQ29kZWAvYGtleUNvZGVgLCBkaXNjYXJkIHRoZW0uXG4gIC8vIE11c3Qgbm90IGRpc2NhcmQgdGhlIChub24tKXByaW50YWJsZSBFbnRlci1rZXkuXG4gIGlmIChjaGFyQ29kZSA+PSAzMiB8fCBjaGFyQ29kZSA9PT0gMTMpIHtcbiAgICByZXR1cm4gY2hhckNvZGU7XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuLyoqXG4gKiBOb3JtYWxpemF0aW9uIG9mIGRlcHJlY2F0ZWQgSFRNTDUgYGtleWAgdmFsdWVzXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50I0tleV9uYW1lc1xuICovXG52YXIgbm9ybWFsaXplS2V5ID0ge1xuICBFc2M6ICdFc2NhcGUnLFxuICBTcGFjZWJhcjogJyAnLFxuICBMZWZ0OiAnQXJyb3dMZWZ0JyxcbiAgVXA6ICdBcnJvd1VwJyxcbiAgUmlnaHQ6ICdBcnJvd1JpZ2h0JyxcbiAgRG93bjogJ0Fycm93RG93bicsXG4gIERlbDogJ0RlbGV0ZScsXG4gIFdpbjogJ09TJyxcbiAgTWVudTogJ0NvbnRleHRNZW51JyxcbiAgQXBwczogJ0NvbnRleHRNZW51JyxcbiAgU2Nyb2xsOiAnU2Nyb2xsTG9jaycsXG4gIE1velByaW50YWJsZUtleTogJ1VuaWRlbnRpZmllZCdcbn07XG5cbi8qKlxuICogVHJhbnNsYXRpb24gZnJvbSBsZWdhY3kgYGtleUNvZGVgIHRvIEhUTUw1IGBrZXlgXG4gKiBPbmx5IHNwZWNpYWwga2V5cyBzdXBwb3J0ZWQsIGFsbCBvdGhlcnMgZGVwZW5kIG9uIGtleWJvYXJkIGxheW91dCBvciBicm93c2VyXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50I0tleV9uYW1lc1xuICovXG52YXIgdHJhbnNsYXRlVG9LZXkgPSB7XG4gICc4JzogJ0JhY2tzcGFjZScsXG4gICc5JzogJ1RhYicsXG4gICcxMic6ICdDbGVhcicsXG4gICcxMyc6ICdFbnRlcicsXG4gICcxNic6ICdTaGlmdCcsXG4gICcxNyc6ICdDb250cm9sJyxcbiAgJzE4JzogJ0FsdCcsXG4gICcxOSc6ICdQYXVzZScsXG4gICcyMCc6ICdDYXBzTG9jaycsXG4gICcyNyc6ICdFc2NhcGUnLFxuICAnMzInOiAnICcsXG4gICczMyc6ICdQYWdlVXAnLFxuICAnMzQnOiAnUGFnZURvd24nLFxuICAnMzUnOiAnRW5kJyxcbiAgJzM2JzogJ0hvbWUnLFxuICAnMzcnOiAnQXJyb3dMZWZ0JyxcbiAgJzM4JzogJ0Fycm93VXAnLFxuICAnMzknOiAnQXJyb3dSaWdodCcsXG4gICc0MCc6ICdBcnJvd0Rvd24nLFxuICAnNDUnOiAnSW5zZXJ0JyxcbiAgJzQ2JzogJ0RlbGV0ZScsXG4gICcxMTInOiAnRjEnLFxuICAnMTEzJzogJ0YyJyxcbiAgJzExNCc6ICdGMycsXG4gICcxMTUnOiAnRjQnLFxuICAnMTE2JzogJ0Y1JyxcbiAgJzExNyc6ICdGNicsXG4gICcxMTgnOiAnRjcnLFxuICAnMTE5JzogJ0Y4JyxcbiAgJzEyMCc6ICdGOScsXG4gICcxMjEnOiAnRjEwJyxcbiAgJzEyMic6ICdGMTEnLFxuICAnMTIzJzogJ0YxMicsXG4gICcxNDQnOiAnTnVtTG9jaycsXG4gICcxNDUnOiAnU2Nyb2xsTG9jaycsXG4gICcyMjQnOiAnTWV0YSdcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7c3RyaW5nfSBOb3JtYWxpemVkIGBrZXlgIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBnZXRFdmVudEtleShuYXRpdmVFdmVudCkge1xuICBpZiAobmF0aXZlRXZlbnQua2V5KSB7XG4gICAgLy8gTm9ybWFsaXplIGluY29uc2lzdGVudCB2YWx1ZXMgcmVwb3J0ZWQgYnkgYnJvd3NlcnMgZHVlIHRvXG4gICAgLy8gaW1wbGVtZW50YXRpb25zIG9mIGEgd29ya2luZyBkcmFmdCBzcGVjaWZpY2F0aW9uLlxuXG4gICAgLy8gRmlyZUZveCBpbXBsZW1lbnRzIGBrZXlgIGJ1dCByZXR1cm5zIGBNb3pQcmludGFibGVLZXlgIGZvciBhbGxcbiAgICAvLyBwcmludGFibGUgY2hhcmFjdGVycyAobm9ybWFsaXplZCB0byBgVW5pZGVudGlmaWVkYCksIGlnbm9yZSBpdC5cbiAgICB2YXIga2V5ID0gbm9ybWFsaXplS2V5W25hdGl2ZUV2ZW50LmtleV0gfHwgbmF0aXZlRXZlbnQua2V5O1xuICAgIGlmIChrZXkgIT09ICdVbmlkZW50aWZpZWQnKSB7XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH1cbiAgfVxuXG4gIC8vIEJyb3dzZXIgZG9lcyBub3QgaW1wbGVtZW50IGBrZXlgLCBwb2x5ZmlsbCBhcyBtdWNoIG9mIGl0IGFzIHdlIGNhbi5cbiAgaWYgKG5hdGl2ZUV2ZW50LnR5cGUgPT09ICdrZXlwcmVzcycpIHtcbiAgICB2YXIgY2hhckNvZGUgPSBnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KTtcblxuICAgIC8vIFRoZSBlbnRlci1rZXkgaXMgdGVjaG5pY2FsbHkgYm90aCBwcmludGFibGUgYW5kIG5vbi1wcmludGFibGUgYW5kIGNhblxuICAgIC8vIHRodXMgYmUgY2FwdHVyZWQgYnkgYGtleXByZXNzYCwgbm8gb3RoZXIgbm9uLXByaW50YWJsZSBrZXkgc2hvdWxkLlxuICAgIHJldHVybiBjaGFyQ29kZSA9PT0gMTMgPyAnRW50ZXInIDogU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSk7XG4gIH1cbiAgaWYgKG5hdGl2ZUV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBuYXRpdmVFdmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgLy8gV2hpbGUgdXNlciBrZXlib2FyZCBsYXlvdXQgZGV0ZXJtaW5lcyB0aGUgYWN0dWFsIG1lYW5pbmcgb2YgZWFjaFxuICAgIC8vIGBrZXlDb2RlYCB2YWx1ZSwgYWxtb3N0IGFsbCBmdW5jdGlvbiBrZXlzIGhhdmUgYSB1bml2ZXJzYWwgdmFsdWUuXG4gICAgcmV0dXJuIHRyYW5zbGF0ZVRvS2V5W25hdGl2ZUV2ZW50LmtleUNvZGVdIHx8ICdVbmlkZW50aWZpZWQnO1xuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBAaW50ZXJmYWNlIEtleWJvYXJkRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgS2V5Ym9hcmRFdmVudEludGVyZmFjZSA9IHtcbiAga2V5OiBnZXRFdmVudEtleSxcbiAgbG9jYXRpb246IG51bGwsXG4gIGN0cmxLZXk6IG51bGwsXG4gIHNoaWZ0S2V5OiBudWxsLFxuICBhbHRLZXk6IG51bGwsXG4gIG1ldGFLZXk6IG51bGwsXG4gIHJlcGVhdDogbnVsbCxcbiAgbG9jYWxlOiBudWxsLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGUsXG4gIC8vIExlZ2FjeSBJbnRlcmZhY2VcbiAgY2hhckNvZGU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIGBjaGFyQ29kZWAgaXMgdGhlIHJlc3VsdCBvZiBhIEtleVByZXNzIGV2ZW50IGFuZCByZXByZXNlbnRzIHRoZSB2YWx1ZSBvZlxuICAgIC8vIHRoZSBhY3R1YWwgcHJpbnRhYmxlIGNoYXJhY3Rlci5cblxuICAgIC8vIEtleVByZXNzIGlzIGRlcHJlY2F0ZWQsIGJ1dCBpdHMgcmVwbGFjZW1lbnQgaXMgbm90IHlldCBmaW5hbCBhbmQgbm90XG4gICAgLy8gaW1wbGVtZW50ZWQgaW4gYW55IG1ham9yIGJyb3dzZXIuIE9ubHkgS2V5UHJlc3MgaGFzIGNoYXJDb2RlLlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgICByZXR1cm4gZ2V0RXZlbnRDaGFyQ29kZShldmVudCk7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9LFxuICBrZXlDb2RlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBga2V5Q29kZWAgaXMgdGhlIHJlc3VsdCBvZiBhIEtleURvd24vVXAgZXZlbnQgYW5kIHJlcHJlc2VudHMgdGhlIHZhbHVlIG9mXG4gICAgLy8gcGh5c2ljYWwga2V5Ym9hcmQga2V5LlxuXG4gICAgLy8gVGhlIGFjdHVhbCBtZWFuaW5nIG9mIHRoZSB2YWx1ZSBkZXBlbmRzIG9uIHRoZSB1c2Vycycga2V5Ym9hcmQgbGF5b3V0XG4gICAgLy8gd2hpY2ggY2Fubm90IGJlIGRldGVjdGVkLiBBc3N1bWluZyB0aGF0IGl0IGlzIGEgVVMga2V5Ym9hcmQgbGF5b3V0XG4gICAgLy8gcHJvdmlkZXMgYSBzdXJwcmlzaW5nbHkgYWNjdXJhdGUgbWFwcGluZyBmb3IgVVMgYW5kIEV1cm9wZWFuIHVzZXJzLlxuICAgIC8vIER1ZSB0byB0aGlzLCBpdCBpcyBsZWZ0IHRvIHRoZSB1c2VyIHRvIGltcGxlbWVudCBhdCB0aGlzIHRpbWUuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBldmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgICByZXR1cm4gZXZlbnQua2V5Q29kZTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH0sXG4gIHdoaWNoOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBgd2hpY2hgIGlzIGFuIGFsaWFzIGZvciBlaXRoZXIgYGtleUNvZGVgIG9yIGBjaGFyQ29kZWAgZGVwZW5kaW5nIG9uIHRoZVxuICAgIC8vIHR5cGUgb2YgdGhlIGV2ZW50LlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgICByZXR1cm4gZ2V0RXZlbnRDaGFyQ29kZShldmVudCk7XG4gICAgfVxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5ZG93bicgfHwgZXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xuICAgICAgcmV0dXJuIGV2ZW50LmtleUNvZGU7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNLZXlib2FyZEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNVSUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNVSUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNLZXlib2FyZEV2ZW50LCBLZXlib2FyZEV2ZW50SW50ZXJmYWNlKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIERyYWdFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBEcmFnRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGRhdGFUcmFuc2ZlcjogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljTW91c2VFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljRHJhZ0V2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNNb3VzZUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNNb3VzZUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNEcmFnRXZlbnQsIERyYWdFdmVudEludGVyZmFjZSk7XG5cbi8qKlxuICogQGludGVyZmFjZSBUb3VjaEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL3RvdWNoLWV2ZW50cy9cbiAqL1xudmFyIFRvdWNoRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHRvdWNoZXM6IG51bGwsXG4gIHRhcmdldFRvdWNoZXM6IG51bGwsXG4gIGNoYW5nZWRUb3VjaGVzOiBudWxsLFxuICBhbHRLZXk6IG51bGwsXG4gIG1ldGFLZXk6IG51bGwsXG4gIGN0cmxLZXk6IG51bGwsXG4gIHNoaWZ0S2V5OiBudWxsLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGVcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY1RvdWNoRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY1VJRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY1VJRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY1RvdWNoRXZlbnQsIFRvdWNoRXZlbnRJbnRlcmZhY2UpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAwOS9XRC1jc3MzLXRyYW5zaXRpb25zLTIwMDkwMzIwLyN0cmFuc2l0aW9uLWV2ZW50cy1cbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1RyYW5zaXRpb25FdmVudFxuICovXG52YXIgVHJhbnNpdGlvbkV2ZW50SW50ZXJmYWNlID0ge1xuICBwcm9wZXJ0eU5hbWU6IG51bGwsXG4gIGVsYXBzZWRUaW1lOiBudWxsLFxuICBwc2V1ZG9FbGVtZW50OiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljVHJhbnNpdGlvbkV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNFdmVudCQxLmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNFdmVudCQxLmF1Z21lbnRDbGFzcyhTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQsIFRyYW5zaXRpb25FdmVudEludGVyZmFjZSk7XG5cbi8qKlxuICogQGludGVyZmFjZSBXaGVlbEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIFdoZWVsRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGRlbHRhWDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdkZWx0YVgnIGluIGV2ZW50ID8gZXZlbnQuZGVsdGFYIDogLy8gRmFsbGJhY2sgdG8gYHdoZWVsRGVsdGFYYCBmb3IgV2Via2l0IGFuZCBub3JtYWxpemUgKHJpZ2h0IGlzIHBvc2l0aXZlKS5cbiAgICAnd2hlZWxEZWx0YVgnIGluIGV2ZW50ID8gLWV2ZW50LndoZWVsRGVsdGFYIDogMDtcbiAgfSxcbiAgZGVsdGFZOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ2RlbHRhWScgaW4gZXZlbnQgPyBldmVudC5kZWx0YVkgOiAvLyBGYWxsYmFjayB0byBgd2hlZWxEZWx0YVlgIGZvciBXZWJraXQgYW5kIG5vcm1hbGl6ZSAoZG93biBpcyBwb3NpdGl2ZSkuXG4gICAgJ3doZWVsRGVsdGFZJyBpbiBldmVudCA/IC1ldmVudC53aGVlbERlbHRhWSA6IC8vIEZhbGxiYWNrIHRvIGB3aGVlbERlbHRhYCBmb3IgSUU8OSBhbmQgbm9ybWFsaXplIChkb3duIGlzIHBvc2l0aXZlKS5cbiAgICAnd2hlZWxEZWx0YScgaW4gZXZlbnQgPyAtZXZlbnQud2hlZWxEZWx0YSA6IDA7XG4gIH0sXG4gIGRlbHRhWjogbnVsbCxcblxuICAvLyBCcm93c2VycyB3aXRob3V0IFwiZGVsdGFNb2RlXCIgaXMgcmVwb3J0aW5nIGluIHJhdyB3aGVlbCBkZWx0YSB3aGVyZSBvbmVcbiAgLy8gbm90Y2ggb24gdGhlIHNjcm9sbCBpcyBhbHdheXMgKy8tIDEyMCwgcm91Z2hseSBlcXVpdmFsZW50IHRvIHBpeGVscy5cbiAgLy8gQSBnb29kIGFwcHJveGltYXRpb24gb2YgRE9NX0RFTFRBX0xJTkUgKDEpIGlzIDUlIG9mIHZpZXdwb3J0IHNpemUgb3JcbiAgLy8gfjQwIHBpeGVscywgZm9yIERPTV9ERUxUQV9TQ1JFRU4gKDIpIGl0IGlzIDg3LjUlIG9mIHZpZXdwb3J0IHNpemUuXG4gIGRlbHRhTW9kZTogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljTW91c2VFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljV2hlZWxFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljTW91c2VFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljTW91c2VFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljV2hlZWxFdmVudCwgV2hlZWxFdmVudEludGVyZmFjZSk7XG5cbi8qKlxuICogVHVybnNcbiAqIFsnYWJvcnQnLCAuLi5dXG4gKiBpbnRvXG4gKiBldmVudFR5cGVzID0ge1xuICogICAnYWJvcnQnOiB7XG4gKiAgICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAqICAgICAgIGJ1YmJsZWQ6ICdvbkFib3J0JyxcbiAqICAgICAgIGNhcHR1cmVkOiAnb25BYm9ydENhcHR1cmUnLFxuICogICAgIH0sXG4gKiAgICAgZGVwZW5kZW5jaWVzOiBbJ3RvcEFib3J0J10sXG4gKiAgIH0sXG4gKiAgIC4uLlxuICogfTtcbiAqIHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZyA9IHtcbiAqICAgJ3RvcEFib3J0JzogeyBzYW1lQ29uZmlnIH1cbiAqIH07XG4gKi9cbnZhciBldmVudFR5cGVzJDQgPSB7fTtcbnZhciB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWcgPSB7fTtcblsnYWJvcnQnLCAnYW5pbWF0aW9uRW5kJywgJ2FuaW1hdGlvbkl0ZXJhdGlvbicsICdhbmltYXRpb25TdGFydCcsICdibHVyJywgJ2NhbmNlbCcsICdjYW5QbGF5JywgJ2NhblBsYXlUaHJvdWdoJywgJ2NsaWNrJywgJ2Nsb3NlJywgJ2NvbnRleHRNZW51JywgJ2NvcHknLCAnY3V0JywgJ2RvdWJsZUNsaWNrJywgJ2RyYWcnLCAnZHJhZ0VuZCcsICdkcmFnRW50ZXInLCAnZHJhZ0V4aXQnLCAnZHJhZ0xlYXZlJywgJ2RyYWdPdmVyJywgJ2RyYWdTdGFydCcsICdkcm9wJywgJ2R1cmF0aW9uQ2hhbmdlJywgJ2VtcHRpZWQnLCAnZW5jcnlwdGVkJywgJ2VuZGVkJywgJ2Vycm9yJywgJ2ZvY3VzJywgJ2lucHV0JywgJ2ludmFsaWQnLCAna2V5RG93bicsICdrZXlQcmVzcycsICdrZXlVcCcsICdsb2FkJywgJ2xvYWRlZERhdGEnLCAnbG9hZGVkTWV0YWRhdGEnLCAnbG9hZFN0YXJ0JywgJ21vdXNlRG93bicsICdtb3VzZU1vdmUnLCAnbW91c2VPdXQnLCAnbW91c2VPdmVyJywgJ21vdXNlVXAnLCAncGFzdGUnLCAncGF1c2UnLCAncGxheScsICdwbGF5aW5nJywgJ3Byb2dyZXNzJywgJ3JhdGVDaGFuZ2UnLCAncmVzZXQnLCAnc2Nyb2xsJywgJ3NlZWtlZCcsICdzZWVraW5nJywgJ3N0YWxsZWQnLCAnc3VibWl0JywgJ3N1c3BlbmQnLCAndGltZVVwZGF0ZScsICd0b2dnbGUnLCAndG91Y2hDYW5jZWwnLCAndG91Y2hFbmQnLCAndG91Y2hNb3ZlJywgJ3RvdWNoU3RhcnQnLCAndHJhbnNpdGlvbkVuZCcsICd2b2x1bWVDaGFuZ2UnLCAnd2FpdGluZycsICd3aGVlbCddLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gIHZhciBjYXBpdGFsaXplZEV2ZW50ID0gZXZlbnRbMF0udG9VcHBlckNhc2UoKSArIGV2ZW50LnNsaWNlKDEpO1xuICB2YXIgb25FdmVudCA9ICdvbicgKyBjYXBpdGFsaXplZEV2ZW50O1xuICB2YXIgdG9wRXZlbnQgPSAndG9wJyArIGNhcGl0YWxpemVkRXZlbnQ7XG5cbiAgdmFyIHR5cGUgPSB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IG9uRXZlbnQsXG4gICAgICBjYXB0dXJlZDogb25FdmVudCArICdDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbdG9wRXZlbnRdXG4gIH07XG4gIGV2ZW50VHlwZXMkNFtldmVudF0gPSB0eXBlO1xuICB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWdbdG9wRXZlbnRdID0gdHlwZTtcbn0pO1xuXG4vLyBPbmx5IHVzZWQgaW4gREVWIGZvciBleGhhdXN0aXZlbmVzcyB2YWxpZGF0aW9uLlxudmFyIGtub3duSFRNTFRvcExldmVsVHlwZXMgPSBbJ3RvcEFib3J0JywgJ3RvcENhbmNlbCcsICd0b3BDYW5QbGF5JywgJ3RvcENhblBsYXlUaHJvdWdoJywgJ3RvcENsb3NlJywgJ3RvcER1cmF0aW9uQ2hhbmdlJywgJ3RvcEVtcHRpZWQnLCAndG9wRW5jcnlwdGVkJywgJ3RvcEVuZGVkJywgJ3RvcEVycm9yJywgJ3RvcElucHV0JywgJ3RvcEludmFsaWQnLCAndG9wTG9hZCcsICd0b3BMb2FkZWREYXRhJywgJ3RvcExvYWRlZE1ldGFkYXRhJywgJ3RvcExvYWRTdGFydCcsICd0b3BQYXVzZScsICd0b3BQbGF5JywgJ3RvcFBsYXlpbmcnLCAndG9wUHJvZ3Jlc3MnLCAndG9wUmF0ZUNoYW5nZScsICd0b3BSZXNldCcsICd0b3BTZWVrZWQnLCAndG9wU2Vla2luZycsICd0b3BTdGFsbGVkJywgJ3RvcFN1Ym1pdCcsICd0b3BTdXNwZW5kJywgJ3RvcFRpbWVVcGRhdGUnLCAndG9wVG9nZ2xlJywgJ3RvcFZvbHVtZUNoYW5nZScsICd0b3BXYWl0aW5nJ107XG5cbnZhciBTaW1wbGVFdmVudFBsdWdpbiA9IHtcbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyQ0LFxuXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHZhciBkaXNwYXRjaENvbmZpZyA9IHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZ1t0b3BMZXZlbFR5cGVdO1xuICAgIGlmICghZGlzcGF0Y2hDb25maWcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgRXZlbnRDb25zdHJ1Y3RvcjtcbiAgICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgICAgY2FzZSAndG9wS2V5UHJlc3MnOlxuICAgICAgICAvLyBGaXJlZm94IGNyZWF0ZXMgYSBrZXlwcmVzcyBldmVudCBmb3IgZnVuY3Rpb24ga2V5cyB0b28uIFRoaXMgcmVtb3Zlc1xuICAgICAgICAvLyB0aGUgdW53YW50ZWQga2V5cHJlc3MgZXZlbnRzLiBFbnRlciBpcyBob3dldmVyIGJvdGggcHJpbnRhYmxlIGFuZFxuICAgICAgICAvLyBub24tcHJpbnRhYmxlLiBPbmUgd291bGQgZXhwZWN0IFRhYiB0byBiZSBhcyB3ZWxsIChidXQgaXQgaXNuJ3QpLlxuICAgICAgICBpZiAoZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCkgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSAndG9wS2V5RG93bic6XG4gICAgICBjYXNlICd0b3BLZXlVcCc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNLZXlib2FyZEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcEJsdXInOlxuICAgICAgY2FzZSAndG9wRm9jdXMnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljRm9jdXNFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BDbGljayc6XG4gICAgICAgIC8vIEZpcmVmb3ggY3JlYXRlcyBhIGNsaWNrIGV2ZW50IG9uIHJpZ2h0IG1vdXNlIGNsaWNrcy4gVGhpcyByZW1vdmVzIHRoZVxuICAgICAgICAvLyB1bndhbnRlZCBjbGljayBldmVudHMuXG4gICAgICAgIGlmIChuYXRpdmVFdmVudC5idXR0b24gPT09IDIpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSAndG9wRG91YmxlQ2xpY2snOlxuICAgICAgY2FzZSAndG9wTW91c2VEb3duJzpcbiAgICAgIGNhc2UgJ3RvcE1vdXNlTW92ZSc6XG4gICAgICBjYXNlICd0b3BNb3VzZVVwJzpcbiAgICAgIC8vIFRPRE86IERpc2FibGVkIGVsZW1lbnRzIHNob3VsZCBub3QgcmVzcG9uZCB0byBtb3VzZSBldmVudHNcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgJ3RvcE1vdXNlT3V0JzpcbiAgICAgIGNhc2UgJ3RvcE1vdXNlT3Zlcic6XG4gICAgICBjYXNlICd0b3BDb250ZXh0TWVudSc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNNb3VzZUV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcERyYWcnOlxuICAgICAgY2FzZSAndG9wRHJhZ0VuZCc6XG4gICAgICBjYXNlICd0b3BEcmFnRW50ZXInOlxuICAgICAgY2FzZSAndG9wRHJhZ0V4aXQnOlxuICAgICAgY2FzZSAndG9wRHJhZ0xlYXZlJzpcbiAgICAgIGNhc2UgJ3RvcERyYWdPdmVyJzpcbiAgICAgIGNhc2UgJ3RvcERyYWdTdGFydCc6XG4gICAgICBjYXNlICd0b3BEcm9wJzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0RyYWdFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BUb3VjaENhbmNlbCc6XG4gICAgICBjYXNlICd0b3BUb3VjaEVuZCc6XG4gICAgICBjYXNlICd0b3BUb3VjaE1vdmUnOlxuICAgICAgY2FzZSAndG9wVG91Y2hTdGFydCc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNUb3VjaEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcEFuaW1hdGlvbkVuZCc6XG4gICAgICBjYXNlICd0b3BBbmltYXRpb25JdGVyYXRpb24nOlxuICAgICAgY2FzZSAndG9wQW5pbWF0aW9uU3RhcnQnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljQW5pbWF0aW9uRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wVHJhbnNpdGlvbkVuZCc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wU2Nyb2xsJzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY1VJRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wV2hlZWwnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljV2hlZWxFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BDb3B5JzpcbiAgICAgIGNhc2UgJ3RvcEN1dCc6XG4gICAgICBjYXNlICd0b3BQYXN0ZSc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNDbGlwYm9hcmRFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKGtub3duSFRNTFRvcExldmVsVHlwZXMuaW5kZXhPZih0b3BMZXZlbFR5cGUpID09PSAtMSkge1xuICAgICAgICAgICAgd2FybmluZyhmYWxzZSwgJ1NpbXBsZUV2ZW50UGx1Z2luOiBVbmhhbmRsZWQgZXZlbnQgdHlwZSwgYCVzYC4gVGhpcyB3YXJuaW5nICcgKyAnaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJywgdG9wTGV2ZWxUeXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSFRNTCBFdmVudHNcbiAgICAgICAgLy8gQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9pbmRleC5odG1sI2V2ZW50cy0wXG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNFdmVudCQxO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdmFyIGV2ZW50ID0gRXZlbnRDb25zdHJ1Y3Rvci5nZXRQb29sZWQoZGlzcGF0Y2hDb25maWcsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudCk7XG4gICAgcmV0dXJuIGV2ZW50O1xuICB9XG59O1xuXG5zZXRIYW5kbGVUb3BMZXZlbChoYW5kbGVUb3BMZXZlbCk7XG5cbi8qKlxuICogSW5qZWN0IG1vZHVsZXMgZm9yIHJlc29sdmluZyBET00gaGllcmFyY2h5IGFuZCBwbHVnaW4gb3JkZXJpbmcuXG4gKi9cbmluamVjdGlvbiQxLmluamVjdEV2ZW50UGx1Z2luT3JkZXIoRE9NRXZlbnRQbHVnaW5PcmRlcik7XG5pbmplY3Rpb24kMi5pbmplY3RDb21wb25lbnRUcmVlKFJlYWN0RE9NQ29tcG9uZW50VHJlZSk7XG5cbi8qKlxuICogU29tZSBpbXBvcnRhbnQgZXZlbnQgcGx1Z2lucyBpbmNsdWRlZCBieSBkZWZhdWx0ICh3aXRob3V0IGhhdmluZyB0byByZXF1aXJlXG4gKiB0aGVtKS5cbiAqL1xuaW5qZWN0aW9uJDEuaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lKHtcbiAgU2ltcGxlRXZlbnRQbHVnaW46IFNpbXBsZUV2ZW50UGx1Z2luLFxuICBFbnRlckxlYXZlRXZlbnRQbHVnaW46IEVudGVyTGVhdmVFdmVudFBsdWdpbixcbiAgQ2hhbmdlRXZlbnRQbHVnaW46IENoYW5nZUV2ZW50UGx1Z2luLFxuICBTZWxlY3RFdmVudFBsdWdpbjogU2VsZWN0RXZlbnRQbHVnaW4sXG4gIEJlZm9yZUlucHV0RXZlbnRQbHVnaW46IEJlZm9yZUlucHV0RXZlbnRQbHVnaW5cbn0pO1xuXG52YXIgZW5hYmxlQXN5bmNTdWJ0cmVlQVBJID0gdHJ1ZTtcbnZhciBlbmFibGVBc3luY1NjaGVkdWxpbmdCeURlZmF1bHRJblJlYWN0RE9NID0gZmFsc2U7XG4vLyBFeHBvcnRzIFJlYWN0RE9NLmNyZWF0ZVJvb3RcbnZhciBlbmFibGVDcmVhdGVSb290ID0gZmFsc2U7XG52YXIgZW5hYmxlVXNlclRpbWluZ0FQSSA9IHRydWU7XG5cbi8vIE11dGF0aW5nIG1vZGUgKFJlYWN0IERPTSwgUmVhY3QgQVJULCBSZWFjdCBOYXRpdmUpOlxudmFyIGVuYWJsZU11dGF0aW5nUmVjb25jaWxlciA9IHRydWU7XG4vLyBFeHBlcmltZW50YWwgbm9vcCBtb2RlIChjdXJyZW50bHkgdW51c2VkKTpcbnZhciBlbmFibGVOb29wUmVjb25jaWxlciA9IGZhbHNlO1xuLy8gRXhwZXJpbWVudGFsIHBlcnNpc3RlbnQgbW9kZSAoQ1MpOlxudmFyIGVuYWJsZVBlcnNpc3RlbnRSZWNvbmNpbGVyID0gZmFsc2U7XG5cbi8vIEhlbHBzIGlkZW50aWZ5IHNpZGUgZWZmZWN0cyBpbiBiZWdpbi1waGFzZSBsaWZlY3ljbGUgaG9va3MgYW5kIHNldFN0YXRlIHJlZHVjZXJzOlxudmFyIGRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0cyA9IGZhbHNlO1xuXG4vLyBPbmx5IHVzZWQgaW4gd3d3IGJ1aWxkcy5cblxudmFyIHZhbHVlU3RhY2sgPSBbXTtcblxue1xuICB2YXIgZmliZXJTdGFjayA9IFtdO1xufVxuXG52YXIgaW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY3JlYXRlQ3Vyc29yKGRlZmF1bHRWYWx1ZSkge1xuICByZXR1cm4ge1xuICAgIGN1cnJlbnQ6IGRlZmF1bHRWYWx1ZVxuICB9O1xufVxuXG5cblxuZnVuY3Rpb24gcG9wKGN1cnNvciwgZmliZXIpIHtcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdVbmV4cGVjdGVkIHBvcC4nKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAge1xuICAgIGlmIChmaWJlciAhPT0gZmliZXJTdGFja1tpbmRleF0pIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdVbmV4cGVjdGVkIEZpYmVyIHBvcHBlZC4nKTtcbiAgICB9XG4gIH1cblxuICBjdXJzb3IuY3VycmVudCA9IHZhbHVlU3RhY2tbaW5kZXhdO1xuXG4gIHZhbHVlU3RhY2tbaW5kZXhdID0gbnVsbDtcblxuICB7XG4gICAgZmliZXJTdGFja1tpbmRleF0gPSBudWxsO1xuICB9XG5cbiAgaW5kZXgtLTtcbn1cblxuZnVuY3Rpb24gcHVzaChjdXJzb3IsIHZhbHVlLCBmaWJlcikge1xuICBpbmRleCsrO1xuXG4gIHZhbHVlU3RhY2tbaW5kZXhdID0gY3Vyc29yLmN1cnJlbnQ7XG5cbiAge1xuICAgIGZpYmVyU3RhY2tbaW5kZXhdID0gZmliZXI7XG4gIH1cblxuICBjdXJzb3IuY3VycmVudCA9IHZhbHVlO1xufVxuXG5mdW5jdGlvbiByZXNldCQxKCkge1xuICB3aGlsZSAoaW5kZXggPiAtMSkge1xuICAgIHZhbHVlU3RhY2tbaW5kZXhdID0gbnVsbDtcblxuICAgIHtcbiAgICAgIGZpYmVyU3RhY2tbaW5kZXhdID0gbnVsbDtcbiAgICB9XG5cbiAgICBpbmRleC0tO1xuICB9XG59XG5cbnZhciBkZXNjcmliZUNvbXBvbmVudEZyYW1lID0gZnVuY3Rpb24gKG5hbWUsIHNvdXJjZSwgb3duZXJOYW1lKSB7XG4gIHJldHVybiAnXFxuICAgIGluICcgKyAobmFtZSB8fCAnVW5rbm93bicpICsgKHNvdXJjZSA/ICcgKGF0ICcgKyBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpICsgJzonICsgc291cmNlLmxpbmVOdW1iZXIgKyAnKScgOiBvd25lck5hbWUgPyAnIChjcmVhdGVkIGJ5ICcgKyBvd25lck5hbWUgKyAnKScgOiAnJyk7XG59O1xuXG5mdW5jdGlvbiBkZXNjcmliZUZpYmVyKGZpYmVyKSB7XG4gIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgY2FzZSBJbmRldGVybWluYXRlQ29tcG9uZW50OlxuICAgIGNhc2UgRnVuY3Rpb25hbENvbXBvbmVudDpcbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHZhciBvd25lciA9IGZpYmVyLl9kZWJ1Z093bmVyO1xuICAgICAgdmFyIHNvdXJjZSA9IGZpYmVyLl9kZWJ1Z1NvdXJjZTtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmaWJlcik7XG4gICAgICB2YXIgb3duZXJOYW1lID0gbnVsbDtcbiAgICAgIGlmIChvd25lcikge1xuICAgICAgICBvd25lck5hbWUgPSBnZXRDb21wb25lbnROYW1lKG93bmVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZXNjcmliZUNvbXBvbmVudEZyYW1lKG5hbWUsIHNvdXJjZSwgb3duZXJOYW1lKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcnO1xuICB9XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gY2FuIG9ubHkgYmUgY2FsbGVkIHdpdGggYSB3b3JrLWluLXByb2dyZXNzIGZpYmVyIGFuZFxuLy8gb25seSBkdXJpbmcgYmVnaW4gb3IgY29tcGxldGUgcGhhc2UuIERvIG5vdCBjYWxsIGl0IHVuZGVyIGFueSBvdGhlclxuLy8gY2lyY3Vtc3RhbmNlcy5cbmZ1bmN0aW9uIGdldFN0YWNrQWRkZW5kdW1CeVdvcmtJblByb2dyZXNzRmliZXIod29ya0luUHJvZ3Jlc3MpIHtcbiAgdmFyIGluZm8gPSAnJztcbiAgdmFyIG5vZGUgPSB3b3JrSW5Qcm9ncmVzcztcbiAgZG8ge1xuICAgIGluZm8gKz0gZGVzY3JpYmVGaWJlcihub2RlKTtcbiAgICAvLyBPdGhlcndpc2UgdGhpcyByZXR1cm4gcG9pbnRlciBtaWdodCBwb2ludCB0byB0aGUgd3JvbmcgdHJlZTpcbiAgICBub2RlID0gbm9kZVsncmV0dXJuJ107XG4gIH0gd2hpbGUgKG5vZGUpO1xuICByZXR1cm4gaW5mbztcbn1cblxuZnVuY3Rpb24gZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lKCkge1xuICB7XG4gICAgdmFyIGZpYmVyID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5jdXJyZW50O1xuICAgIGlmIChmaWJlciA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBvd25lciA9IGZpYmVyLl9kZWJ1Z093bmVyO1xuICAgIGlmIChvd25lciAhPT0gbnVsbCAmJiB0eXBlb2Ygb3duZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZShvd25lcik7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtKCkge1xuICB7XG4gICAgdmFyIGZpYmVyID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5jdXJyZW50O1xuICAgIGlmIChmaWJlciA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIFNhZmUgYmVjYXVzZSBpZiBjdXJyZW50IGZpYmVyIGV4aXN0cywgd2UgYXJlIHJlY29uY2lsaW5nLFxuICAgIC8vIGFuZCBpdCBpcyBndWFyYW50ZWVkIHRvIGJlIHRoZSB3b3JrLWluLXByb2dyZXNzIHZlcnNpb24uXG4gICAgcmV0dXJuIGdldFN0YWNrQWRkZW5kdW1CeVdvcmtJblByb2dyZXNzRmliZXIoZmliZXIpO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiByZXNldEN1cnJlbnRGaWJlcigpIHtcbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2sgPSBudWxsO1xuICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmN1cnJlbnQgPSBudWxsO1xuICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnBoYXNlID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gc2V0Q3VycmVudEZpYmVyKGZpYmVyKSB7XG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrID0gZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bTtcbiAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5jdXJyZW50ID0gZmliZXI7XG4gIFJlYWN0RGVidWdDdXJyZW50RmliZXIucGhhc2UgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBzZXRDdXJyZW50UGhhc2UocGhhc2UpIHtcbiAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5waGFzZSA9IHBoYXNlO1xufVxuXG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlciA9IHtcbiAgY3VycmVudDogbnVsbCxcbiAgcGhhc2U6IG51bGwsXG4gIHJlc2V0Q3VycmVudEZpYmVyOiByZXNldEN1cnJlbnRGaWJlcixcbiAgc2V0Q3VycmVudEZpYmVyOiBzZXRDdXJyZW50RmliZXIsXG4gIHNldEN1cnJlbnRQaGFzZTogc2V0Q3VycmVudFBoYXNlLFxuICBnZXRDdXJyZW50RmliZXJPd25lck5hbWU6IGdldEN1cnJlbnRGaWJlck93bmVyTmFtZSxcbiAgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bTogZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bVxufTtcblxuLy8gUHJlZml4IG1lYXN1cmVtZW50cyBzbyB0aGF0IGl0J3MgcG9zc2libGUgdG8gZmlsdGVyIHRoZW0uXG4vLyBMb25nZXIgcHJlZml4ZXMgYXJlIGhhcmQgdG8gcmVhZCBpbiBEZXZUb29scy5cbnZhciByZWFjdEVtb2ppID0gJ1xcdTI2OUInO1xudmFyIHdhcm5pbmdFbW9qaSA9ICdcXHUyNkQ0JztcbnZhciBzdXBwb3J0c1VzZXJUaW1pbmcgPSB0eXBlb2YgcGVyZm9ybWFuY2UgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5tYXJrID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5jbGVhck1hcmtzID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5tZWFzdXJlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5jbGVhck1lYXN1cmVzID09PSAnZnVuY3Rpb24nO1xuXG4vLyBLZWVwIHRyYWNrIG9mIGN1cnJlbnQgZmliZXIgc28gdGhhdCB3ZSBrbm93IHRoZSBwYXRoIHRvIHVud2luZCBvbiBwYXVzZS5cbi8vIFRPRE86IHRoaXMgbG9va3MgdGhlIHNhbWUgYXMgbmV4dFVuaXRPZldvcmsgaW4gc2NoZWR1bGVyLiBDYW4gd2UgdW5pZnkgdGhlbT9cbnZhciBjdXJyZW50RmliZXIgPSBudWxsO1xuLy8gSWYgd2UncmUgaW4gdGhlIG1pZGRsZSBvZiB1c2VyIGNvZGUsIHdoaWNoIGZpYmVyIGFuZCBtZXRob2QgaXMgaXQ/XG4vLyBSZXVzaW5nIGBjdXJyZW50RmliZXJgIHdvdWxkIGJlIGNvbmZ1c2luZyBmb3IgdGhpcyBiZWNhdXNlIHVzZXIgY29kZSBmaWJlclxuLy8gY2FuIGNoYW5nZSBkdXJpbmcgY29tbWl0IHBoYXNlIHRvbywgYnV0IHdlIGRvbid0IG5lZWQgdG8gdW53aW5kIGl0IChzaW5jZVxuLy8gbGlmZWN5Y2xlcyBpbiB0aGUgY29tbWl0IHBoYXNlIGRvbid0IHJlc2VtYmxlIGEgdHJlZSkuXG52YXIgY3VycmVudFBoYXNlID0gbnVsbDtcbnZhciBjdXJyZW50UGhhc2VGaWJlciA9IG51bGw7XG4vLyBEaWQgbGlmZWN5Y2xlIGhvb2sgc2NoZWR1bGUgYW4gdXBkYXRlPyBUaGlzIGlzIG9mdGVuIGEgcGVyZm9ybWFuY2UgcHJvYmxlbSxcbi8vIHNvIHdlIHdpbGwga2VlcCB0cmFjayBvZiBpdCwgYW5kIGluY2x1ZGUgaXQgaW4gdGhlIHJlcG9ydC5cbi8vIFRyYWNrIGNvbW1pdHMgY2F1c2VkIGJ5IGNhc2NhZGluZyB1cGRhdGVzLlxudmFyIGlzQ29tbWl0dGluZyA9IGZhbHNlO1xudmFyIGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudENvbW1pdCA9IGZhbHNlO1xudmFyIGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudFBoYXNlID0gZmFsc2U7XG52YXIgY29tbWl0Q291bnRJbkN1cnJlbnRXb3JrTG9vcCA9IDA7XG52YXIgZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQgPSAwO1xudmFyIGlzV2FpdGluZ0ZvckNhbGxiYWNrID0gZmFsc2U7XG4vLyBEdXJpbmcgY29tbWl0cywgd2Ugb25seSBzaG93IGEgbWVhc3VyZW1lbnQgb25jZSBwZXIgbWV0aG9kIG5hbWVcbi8vIHRvIGF2b2lkIHN0cmV0Y2ggdGhlIGNvbW1pdCBwaGFzZSB3aXRoIG1lYXN1cmVtZW50IG92ZXJoZWFkLlxudmFyIGxhYmVsc0luQ3VycmVudENvbW1pdCA9IG5ldyBTZXQoKTtcblxudmFyIGZvcm1hdE1hcmtOYW1lID0gZnVuY3Rpb24gKG1hcmtOYW1lKSB7XG4gIHJldHVybiByZWFjdEVtb2ppICsgJyAnICsgbWFya05hbWU7XG59O1xuXG52YXIgZm9ybWF0TGFiZWwgPSBmdW5jdGlvbiAobGFiZWwsIHdhcm5pbmckJDEpIHtcbiAgdmFyIHByZWZpeCA9IHdhcm5pbmckJDEgPyB3YXJuaW5nRW1vamkgKyAnICcgOiByZWFjdEVtb2ppICsgJyAnO1xuICB2YXIgc3VmZml4ID0gd2FybmluZyQkMSA/ICcgV2FybmluZzogJyArIHdhcm5pbmckJDEgOiAnJztcbiAgcmV0dXJuICcnICsgcHJlZml4ICsgbGFiZWwgKyBzdWZmaXg7XG59O1xuXG52YXIgYmVnaW5NYXJrID0gZnVuY3Rpb24gKG1hcmtOYW1lKSB7XG4gIHBlcmZvcm1hbmNlLm1hcmsoZm9ybWF0TWFya05hbWUobWFya05hbWUpKTtcbn07XG5cbnZhciBjbGVhck1hcmsgPSBmdW5jdGlvbiAobWFya05hbWUpIHtcbiAgcGVyZm9ybWFuY2UuY2xlYXJNYXJrcyhmb3JtYXRNYXJrTmFtZShtYXJrTmFtZSkpO1xufTtcblxudmFyIGVuZE1hcmsgPSBmdW5jdGlvbiAobGFiZWwsIG1hcmtOYW1lLCB3YXJuaW5nJCQxKSB7XG4gIHZhciBmb3JtYXR0ZWRNYXJrTmFtZSA9IGZvcm1hdE1hcmtOYW1lKG1hcmtOYW1lKTtcbiAgdmFyIGZvcm1hdHRlZExhYmVsID0gZm9ybWF0TGFiZWwobGFiZWwsIHdhcm5pbmckJDEpO1xuICB0cnkge1xuICAgIHBlcmZvcm1hbmNlLm1lYXN1cmUoZm9ybWF0dGVkTGFiZWwsIGZvcm1hdHRlZE1hcmtOYW1lKTtcbiAgfSBjYXRjaCAoZXJyKSB7fVxuICAvLyBJZiBwcmV2aW91cyBtYXJrIHdhcyBtaXNzaW5nIGZvciBzb21lIHJlYXNvbiwgdGhpcyB3aWxsIHRocm93LlxuICAvLyBUaGlzIGNvdWxkIG9ubHkgaGFwcGVuIGlmIFJlYWN0IGNyYXNoZWQgaW4gYW4gdW5leHBlY3RlZCBwbGFjZSBlYXJsaWVyLlxuICAvLyBEb24ndCBwaWxlIG9uIHdpdGggbW9yZSBlcnJvcnMuXG5cbiAgLy8gQ2xlYXIgbWFya3MgaW1tZWRpYXRlbHkgdG8gYXZvaWQgZ3Jvd2luZyBidWZmZXIuXG4gIHBlcmZvcm1hbmNlLmNsZWFyTWFya3MoZm9ybWF0dGVkTWFya05hbWUpO1xuICBwZXJmb3JtYW5jZS5jbGVhck1lYXN1cmVzKGZvcm1hdHRlZExhYmVsKTtcbn07XG5cbnZhciBnZXRGaWJlck1hcmtOYW1lID0gZnVuY3Rpb24gKGxhYmVsLCBkZWJ1Z0lEKSB7XG4gIHJldHVybiBsYWJlbCArICcgKCMnICsgZGVidWdJRCArICcpJztcbn07XG5cbnZhciBnZXRGaWJlckxhYmVsID0gZnVuY3Rpb24gKGNvbXBvbmVudE5hbWUsIGlzTW91bnRlZCwgcGhhc2UpIHtcbiAgaWYgKHBoYXNlID09PSBudWxsKSB7XG4gICAgLy8gVGhlc2UgYXJlIGNvbXBvc2l0ZSBjb21wb25lbnQgdG90YWwgdGltZSBtZWFzdXJlbWVudHMuXG4gICAgcmV0dXJuIGNvbXBvbmVudE5hbWUgKyAnIFsnICsgKGlzTW91bnRlZCA/ICd1cGRhdGUnIDogJ21vdW50JykgKyAnXSc7XG4gIH0gZWxzZSB7XG4gICAgLy8gQ29tcG9zaXRlIGNvbXBvbmVudCBtZXRob2RzLlxuICAgIHJldHVybiBjb21wb25lbnROYW1lICsgJy4nICsgcGhhc2U7XG4gIH1cbn07XG5cbnZhciBiZWdpbkZpYmVyTWFyayA9IGZ1bmN0aW9uIChmaWJlciwgcGhhc2UpIHtcbiAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKGZpYmVyKSB8fCAnVW5rbm93bic7XG4gIHZhciBkZWJ1Z0lEID0gZmliZXIuX2RlYnVnSUQ7XG4gIHZhciBpc01vdW50ZWQgPSBmaWJlci5hbHRlcm5hdGUgIT09IG51bGw7XG4gIHZhciBsYWJlbCA9IGdldEZpYmVyTGFiZWwoY29tcG9uZW50TmFtZSwgaXNNb3VudGVkLCBwaGFzZSk7XG5cbiAgaWYgKGlzQ29tbWl0dGluZyAmJiBsYWJlbHNJbkN1cnJlbnRDb21taXQuaGFzKGxhYmVsKSkge1xuICAgIC8vIER1cmluZyB0aGUgY29tbWl0IHBoYXNlLCB3ZSBkb24ndCBzaG93IGR1cGxpY2F0ZSBsYWJlbHMgYmVjYXVzZVxuICAgIC8vIHRoZXJlIGlzIGEgZml4ZWQgb3ZlcmhlYWQgZm9yIGV2ZXJ5IG1lYXN1cmVtZW50LCBhbmQgd2UgZG9uJ3RcbiAgICAvLyB3YW50IHRvIHN0cmV0Y2ggdGhlIGNvbW1pdCBwaGFzZSBiZXlvbmQgbmVjZXNzYXJ5LlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBsYWJlbHNJbkN1cnJlbnRDb21taXQuYWRkKGxhYmVsKTtcblxuICB2YXIgbWFya05hbWUgPSBnZXRGaWJlck1hcmtOYW1lKGxhYmVsLCBkZWJ1Z0lEKTtcbiAgYmVnaW5NYXJrKG1hcmtOYW1lKTtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG52YXIgY2xlYXJGaWJlck1hcmsgPSBmdW5jdGlvbiAoZmliZXIsIHBoYXNlKSB7XG4gIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmaWJlcikgfHwgJ1Vua25vd24nO1xuICB2YXIgZGVidWdJRCA9IGZpYmVyLl9kZWJ1Z0lEO1xuICB2YXIgaXNNb3VudGVkID0gZmliZXIuYWx0ZXJuYXRlICE9PSBudWxsO1xuICB2YXIgbGFiZWwgPSBnZXRGaWJlckxhYmVsKGNvbXBvbmVudE5hbWUsIGlzTW91bnRlZCwgcGhhc2UpO1xuICB2YXIgbWFya05hbWUgPSBnZXRGaWJlck1hcmtOYW1lKGxhYmVsLCBkZWJ1Z0lEKTtcbiAgY2xlYXJNYXJrKG1hcmtOYW1lKTtcbn07XG5cbnZhciBlbmRGaWJlck1hcmsgPSBmdW5jdGlvbiAoZmliZXIsIHBoYXNlLCB3YXJuaW5nJCQxKSB7XG4gIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmaWJlcikgfHwgJ1Vua25vd24nO1xuICB2YXIgZGVidWdJRCA9IGZpYmVyLl9kZWJ1Z0lEO1xuICB2YXIgaXNNb3VudGVkID0gZmliZXIuYWx0ZXJuYXRlICE9PSBudWxsO1xuICB2YXIgbGFiZWwgPSBnZXRGaWJlckxhYmVsKGNvbXBvbmVudE5hbWUsIGlzTW91bnRlZCwgcGhhc2UpO1xuICB2YXIgbWFya05hbWUgPSBnZXRGaWJlck1hcmtOYW1lKGxhYmVsLCBkZWJ1Z0lEKTtcbiAgZW5kTWFyayhsYWJlbCwgbWFya05hbWUsIHdhcm5pbmckJDEpO1xufTtcblxudmFyIHNob3VsZElnbm9yZUZpYmVyID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gIC8vIEhvc3QgY29tcG9uZW50cyBzaG91bGQgYmUgc2tpcHBlZCBpbiB0aGUgdGltZWxpbmUuXG4gIC8vIFdlIGNvdWxkIGNoZWNrIHR5cGVvZiBmaWJlci50eXBlLCBidXQgZG9lcyB0aGlzIHdvcmsgd2l0aCBSTj9cbiAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICBjYXNlIEhvc3RSb290OlxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICBjYXNlIEhvc3RUZXh0OlxuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICBjYXNlIFJldHVybkNvbXBvbmVudDpcbiAgICBjYXNlIEZyYWdtZW50OlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxudmFyIGNsZWFyUGVuZGluZ1BoYXNlTWVhc3VyZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChjdXJyZW50UGhhc2UgIT09IG51bGwgJiYgY3VycmVudFBoYXNlRmliZXIgIT09IG51bGwpIHtcbiAgICBjbGVhckZpYmVyTWFyayhjdXJyZW50UGhhc2VGaWJlciwgY3VycmVudFBoYXNlKTtcbiAgfVxuICBjdXJyZW50UGhhc2VGaWJlciA9IG51bGw7XG4gIGN1cnJlbnRQaGFzZSA9IG51bGw7XG4gIGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudFBoYXNlID0gZmFsc2U7XG59O1xuXG52YXIgcGF1c2VUaW1lcnMgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFN0b3BzIGFsbCBjdXJyZW50bHkgYWN0aXZlIG1lYXN1cmVtZW50cyBzbyB0aGF0IHRoZXkgY2FuIGJlIHJlc3VtZWRcbiAgLy8gaWYgd2UgY29udGludWUgaW4gYSBsYXRlciBkZWZlcnJlZCBsb29wIGZyb20gdGhlIHNhbWUgdW5pdCBvZiB3b3JrLlxuICB2YXIgZmliZXIgPSBjdXJyZW50RmliZXI7XG4gIHdoaWxlIChmaWJlcikge1xuICAgIGlmIChmaWJlci5fZGVidWdJc0N1cnJlbnRseVRpbWluZykge1xuICAgICAgZW5kRmliZXJNYXJrKGZpYmVyLCBudWxsLCBudWxsKTtcbiAgICB9XG4gICAgZmliZXIgPSBmaWJlclsncmV0dXJuJ107XG4gIH1cbn07XG5cbnZhciByZXN1bWVUaW1lcnNSZWN1cnNpdmVseSA9IGZ1bmN0aW9uIChmaWJlcikge1xuICBpZiAoZmliZXJbJ3JldHVybiddICE9PSBudWxsKSB7XG4gICAgcmVzdW1lVGltZXJzUmVjdXJzaXZlbHkoZmliZXJbJ3JldHVybiddKTtcbiAgfVxuICBpZiAoZmliZXIuX2RlYnVnSXNDdXJyZW50bHlUaW1pbmcpIHtcbiAgICBiZWdpbkZpYmVyTWFyayhmaWJlciwgbnVsbCk7XG4gIH1cbn07XG5cbnZhciByZXN1bWVUaW1lcnMgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFJlc3VtZXMgYWxsIG1lYXN1cmVtZW50cyB0aGF0IHdlcmUgYWN0aXZlIGR1cmluZyB0aGUgbGFzdCBkZWZlcnJlZCBsb29wLlxuICBpZiAoY3VycmVudEZpYmVyICE9PSBudWxsKSB7XG4gICAgcmVzdW1lVGltZXJzUmVjdXJzaXZlbHkoY3VycmVudEZpYmVyKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gcmVjb3JkRWZmZWN0KCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0Kys7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVjb3JkU2NoZWR1bGVVcGRhdGUoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKGlzQ29tbWl0dGluZykge1xuICAgICAgaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50Q29tbWl0ID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnRQaGFzZSAhPT0gbnVsbCAmJiBjdXJyZW50UGhhc2UgIT09ICdjb21wb25lbnRXaWxsTW91bnQnICYmIGN1cnJlbnRQaGFzZSAhPT0gJ2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnKSB7XG4gICAgICBoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRQaGFzZSA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0UmVxdWVzdENhbGxiYWNrVGltZXIoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKHN1cHBvcnRzVXNlclRpbWluZyAmJiAhaXNXYWl0aW5nRm9yQ2FsbGJhY2spIHtcbiAgICAgIGlzV2FpdGluZ0ZvckNhbGxiYWNrID0gdHJ1ZTtcbiAgICAgIGJlZ2luTWFyaygnKFdhaXRpbmcgZm9yIGFzeW5jIGNhbGxiYWNrLi4uKScpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wUmVxdWVzdENhbGxiYWNrVGltZXIoZGlkRXhwaXJlKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKHN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgaXNXYWl0aW5nRm9yQ2FsbGJhY2sgPSBmYWxzZTtcbiAgICAgIHZhciB3YXJuaW5nJCQxID0gZGlkRXhwaXJlID8gJ1JlYWN0IHdhcyBibG9ja2VkIGJ5IG1haW4gdGhyZWFkJyA6IG51bGw7XG4gICAgICBlbmRNYXJrKCcoV2FpdGluZyBmb3IgYXN5bmMgY2FsbGJhY2suLi4pJywgJyhXYWl0aW5nIGZvciBhc3luYyBjYWxsYmFjay4uLiknLCB3YXJuaW5nJCQxKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRXb3JrVGltZXIoZmliZXIpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZyB8fCBzaG91bGRJZ25vcmVGaWJlcihmaWJlcikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gSWYgd2UgcGF1c2UsIHRoaXMgaXMgdGhlIGZpYmVyIHRvIHVud2luZCBmcm9tLlxuICAgIGN1cnJlbnRGaWJlciA9IGZpYmVyO1xuICAgIGlmICghYmVnaW5GaWJlck1hcmsoZmliZXIsIG51bGwpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZpYmVyLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYW5jZWxXb3JrVGltZXIoZmliZXIpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZyB8fCBzaG91bGRJZ25vcmVGaWJlcihmaWJlcikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gUmVtZW1iZXIgd2Ugc2hvdWxkbid0IGNvbXBsZXRlIG1lYXN1cmVtZW50IGZvciB0aGlzIGZpYmVyLlxuICAgIC8vIE90aGVyd2lzZSBmbGFtZWNoYXJ0IHdpbGwgYmUgZGVlcCBldmVuIGZvciBzbWFsbCB1cGRhdGVzLlxuICAgIGZpYmVyLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nID0gZmFsc2U7XG4gICAgY2xlYXJGaWJlck1hcmsoZmliZXIsIG51bGwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3BXb3JrVGltZXIoZmliZXIpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZyB8fCBzaG91bGRJZ25vcmVGaWJlcihmaWJlcikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gSWYgd2UgcGF1c2UsIGl0cyBwYXJlbnQgaXMgdGhlIGZpYmVyIHRvIHVud2luZCBmcm9tLlxuICAgIGN1cnJlbnRGaWJlciA9IGZpYmVyWydyZXR1cm4nXTtcbiAgICBpZiAoIWZpYmVyLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZpYmVyLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nID0gZmFsc2U7XG4gICAgZW5kRmliZXJNYXJrKGZpYmVyLCBudWxsLCBudWxsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wRmFpbGVkV29ya1RpbWVyKGZpYmVyKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcgfHwgc2hvdWxkSWdub3JlRmliZXIoZmliZXIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIElmIHdlIHBhdXNlLCBpdHMgcGFyZW50IGlzIHRoZSBmaWJlciB0byB1bndpbmQgZnJvbS5cbiAgICBjdXJyZW50RmliZXIgPSBmaWJlclsncmV0dXJuJ107XG4gICAgaWYgKCFmaWJlci5fZGVidWdJc0N1cnJlbnRseVRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmaWJlci5fZGVidWdJc0N1cnJlbnRseVRpbWluZyA9IGZhbHNlO1xuICAgIHZhciB3YXJuaW5nJCQxID0gJ0FuIGVycm9yIHdhcyB0aHJvd24gaW5zaWRlIHRoaXMgZXJyb3IgYm91bmRhcnknO1xuICAgIGVuZEZpYmVyTWFyayhmaWJlciwgbnVsbCwgd2FybmluZyQkMSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRQaGFzZVRpbWVyKGZpYmVyLCBwaGFzZSkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNsZWFyUGVuZGluZ1BoYXNlTWVhc3VyZW1lbnQoKTtcbiAgICBpZiAoIWJlZ2luRmliZXJNYXJrKGZpYmVyLCBwaGFzZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY3VycmVudFBoYXNlRmliZXIgPSBmaWJlcjtcbiAgICBjdXJyZW50UGhhc2UgPSBwaGFzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wUGhhc2VUaW1lcigpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY3VycmVudFBoYXNlICE9PSBudWxsICYmIGN1cnJlbnRQaGFzZUZpYmVyICE9PSBudWxsKSB7XG4gICAgICB2YXIgd2FybmluZyQkMSA9IGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudFBoYXNlID8gJ1NjaGVkdWxlZCBhIGNhc2NhZGluZyB1cGRhdGUnIDogbnVsbDtcbiAgICAgIGVuZEZpYmVyTWFyayhjdXJyZW50UGhhc2VGaWJlciwgY3VycmVudFBoYXNlLCB3YXJuaW5nJCQxKTtcbiAgICB9XG4gICAgY3VycmVudFBoYXNlID0gbnVsbDtcbiAgICBjdXJyZW50UGhhc2VGaWJlciA9IG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRXb3JrTG9vcFRpbWVyKG5leHRVbml0T2ZXb3JrKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgY3VycmVudEZpYmVyID0gbmV4dFVuaXRPZldvcms7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29tbWl0Q291bnRJbkN1cnJlbnRXb3JrTG9vcCA9IDA7XG4gICAgLy8gVGhpcyBpcyB0b3AgbGV2ZWwgY2FsbC5cbiAgICAvLyBBbnkgb3RoZXIgbWVhc3VyZW1lbnRzIGFyZSBwZXJmb3JtZWQgd2l0aGluLlxuICAgIGJlZ2luTWFyaygnKFJlYWN0IFRyZWUgUmVjb25jaWxpYXRpb24pJyk7XG4gICAgLy8gUmVzdW1lIGFueSBtZWFzdXJlbWVudHMgdGhhdCB3ZXJlIGluIHByb2dyZXNzIGR1cmluZyB0aGUgbGFzdCBsb29wLlxuICAgIHJlc3VtZVRpbWVycygpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3BXb3JrTG9vcFRpbWVyKGludGVycnVwdGVkQnkpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgd2FybmluZyQkMSA9IG51bGw7XG4gICAgaWYgKGludGVycnVwdGVkQnkgIT09IG51bGwpIHtcbiAgICAgIGlmIChpbnRlcnJ1cHRlZEJ5LnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICAgICAgd2FybmluZyQkMSA9ICdBIHRvcC1sZXZlbCB1cGRhdGUgaW50ZXJydXB0ZWQgdGhlIHByZXZpb3VzIHJlbmRlcic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoaW50ZXJydXB0ZWRCeSkgfHwgJ1Vua25vd24nO1xuICAgICAgICB3YXJuaW5nJCQxID0gJ0FuIHVwZGF0ZSB0byAnICsgY29tcG9uZW50TmFtZSArICcgaW50ZXJydXB0ZWQgdGhlIHByZXZpb3VzIHJlbmRlcic7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjb21taXRDb3VudEluQ3VycmVudFdvcmtMb29wID4gMSkge1xuICAgICAgd2FybmluZyQkMSA9ICdUaGVyZSB3ZXJlIGNhc2NhZGluZyB1cGRhdGVzJztcbiAgICB9XG4gICAgY29tbWl0Q291bnRJbkN1cnJlbnRXb3JrTG9vcCA9IDA7XG4gICAgLy8gUGF1c2UgYW55IG1lYXN1cmVtZW50cyB1bnRpbCB0aGUgbmV4dCBsb29wLlxuICAgIHBhdXNlVGltZXJzKCk7XG4gICAgZW5kTWFyaygnKFJlYWN0IFRyZWUgUmVjb25jaWxpYXRpb24pJywgJyhSZWFjdCBUcmVlIFJlY29uY2lsaWF0aW9uKScsIHdhcm5pbmckJDEpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0Q29tbWl0VGltZXIoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaXNDb21taXR0aW5nID0gdHJ1ZTtcbiAgICBoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRDb21taXQgPSBmYWxzZTtcbiAgICBsYWJlbHNJbkN1cnJlbnRDb21taXQuY2xlYXIoKTtcbiAgICBiZWdpbk1hcmsoJyhDb21taXR0aW5nIENoYW5nZXMpJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcENvbW1pdFRpbWVyKCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHdhcm5pbmckJDEgPSBudWxsO1xuICAgIGlmIChoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRDb21taXQpIHtcbiAgICAgIHdhcm5pbmckJDEgPSAnTGlmZWN5Y2xlIGhvb2sgc2NoZWR1bGVkIGEgY2FzY2FkaW5nIHVwZGF0ZSc7XG4gICAgfSBlbHNlIGlmIChjb21taXRDb3VudEluQ3VycmVudFdvcmtMb29wID4gMCkge1xuICAgICAgd2FybmluZyQkMSA9ICdDYXVzZWQgYnkgYSBjYXNjYWRpbmcgdXBkYXRlIGluIGVhcmxpZXIgY29tbWl0JztcbiAgICB9XG4gICAgaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50Q29tbWl0ID0gZmFsc2U7XG4gICAgY29tbWl0Q291bnRJbkN1cnJlbnRXb3JrTG9vcCsrO1xuICAgIGlzQ29tbWl0dGluZyA9IGZhbHNlO1xuICAgIGxhYmVsc0luQ3VycmVudENvbW1pdC5jbGVhcigpO1xuXG4gICAgZW5kTWFyaygnKENvbW1pdHRpbmcgQ2hhbmdlcyknLCAnKENvbW1pdHRpbmcgQ2hhbmdlcyknLCB3YXJuaW5nJCQxKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFydENvbW1pdEhvc3RFZmZlY3RzVGltZXIoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQgPSAwO1xuICAgIGJlZ2luTWFyaygnKENvbW1pdHRpbmcgSG9zdCBFZmZlY3RzKScpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3BDb21taXRIb3N0RWZmZWN0c1RpbWVyKCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBjb3VudCA9IGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0O1xuICAgIGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0ID0gMDtcbiAgICBlbmRNYXJrKCcoQ29tbWl0dGluZyBIb3N0IEVmZmVjdHM6ICcgKyBjb3VudCArICcgVG90YWwpJywgJyhDb21taXR0aW5nIEhvc3QgRWZmZWN0cyknLCBudWxsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFydENvbW1pdExpZmVDeWNsZXNUaW1lcigpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlZmZlY3RDb3VudEluQ3VycmVudENvbW1pdCA9IDA7XG4gICAgYmVnaW5NYXJrKCcoQ2FsbGluZyBMaWZlY3ljbGUgTWV0aG9kcyknKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wQ29tbWl0TGlmZUN5Y2xlc1RpbWVyKCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBjb3VudCA9IGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0O1xuICAgIGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0ID0gMDtcbiAgICBlbmRNYXJrKCcoQ2FsbGluZyBMaWZlY3ljbGUgTWV0aG9kczogJyArIGNvdW50ICsgJyBUb3RhbCknLCAnKENhbGxpbmcgTGlmZWN5Y2xlIE1ldGhvZHMpJywgbnVsbCk7XG4gIH1cbn1cblxue1xuICB2YXIgd2FybmVkQWJvdXRNaXNzaW5nR2V0Q2hpbGRDb250ZXh0ID0ge307XG59XG5cbi8vIEEgY3Vyc29yIHRvIHRoZSBjdXJyZW50IG1lcmdlZCBjb250ZXh0IG9iamVjdCBvbiB0aGUgc3RhY2suXG52YXIgY29udGV4dFN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKGVtcHR5T2JqZWN0KTtcbi8vIEEgY3Vyc29yIHRvIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGNvbnRleHQgaGFzIGNoYW5nZWQuXG52YXIgZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvcihmYWxzZSk7XG4vLyBLZWVwIHRyYWNrIG9mIHRoZSBwcmV2aW91cyBjb250ZXh0IG9iamVjdCB0aGF0IHdhcyBvbiB0aGUgc3RhY2suXG4vLyBXZSB1c2UgdGhpcyB0byBnZXQgYWNjZXNzIHRvIHRoZSBwYXJlbnQgY29udGV4dCBhZnRlciB3ZSBoYXZlIGFscmVhZHlcbi8vIHB1c2hlZCB0aGUgbmV4dCBjb250ZXh0IHByb3ZpZGVyLCBhbmQgbm93IG5lZWQgdG8gbWVyZ2UgdGhlaXIgY29udGV4dHMuXG52YXIgcHJldmlvdXNDb250ZXh0ID0gZW1wdHlPYmplY3Q7XG5cbmZ1bmN0aW9uIGdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcykge1xuICB2YXIgaGFzT3duQ29udGV4dCA9IGlzQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgaWYgKGhhc093bkNvbnRleHQpIHtcbiAgICAvLyBJZiB0aGUgZmliZXIgaXMgYSBjb250ZXh0IHByb3ZpZGVyIGl0c2VsZiwgd2hlbiB3ZSByZWFkIGl0cyBjb250ZXh0XG4gICAgLy8gd2UgaGF2ZSBhbHJlYWR5IHB1c2hlZCBpdHMgb3duIGNoaWxkIGNvbnRleHQgb24gdGhlIHN0YWNrLiBBIGNvbnRleHRcbiAgICAvLyBwcm92aWRlciBzaG91bGQgbm90IFwic2VlXCIgaXRzIG93biBjaGlsZCBjb250ZXh0LiBUaGVyZWZvcmUgd2UgcmVhZCB0aGVcbiAgICAvLyBwcmV2aW91cyAocGFyZW50KSBjb250ZXh0IGluc3RlYWQgZm9yIGEgY29udGV4dCBwcm92aWRlci5cbiAgICByZXR1cm4gcHJldmlvdXNDb250ZXh0O1xuICB9XG4gIHJldHVybiBjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudDtcbn1cblxuZnVuY3Rpb24gY2FjaGVDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQsIG1hc2tlZENvbnRleHQpIHtcbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZFVubWFza2VkQ2hpbGRDb250ZXh0ID0gdW5tYXNrZWRDb250ZXh0O1xuICBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1hc2tlZENoaWxkQ29udGV4dCA9IG1hc2tlZENvbnRleHQ7XG59XG5cbmZ1bmN0aW9uIGdldE1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHVubWFza2VkQ29udGV4dCkge1xuICB2YXIgdHlwZSA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gIHZhciBjb250ZXh0VHlwZXMgPSB0eXBlLmNvbnRleHRUeXBlcztcbiAgaWYgKCFjb250ZXh0VHlwZXMpIHtcbiAgICByZXR1cm4gZW1wdHlPYmplY3Q7XG4gIH1cblxuICAvLyBBdm9pZCByZWNyZWF0aW5nIG1hc2tlZCBjb250ZXh0IHVubGVzcyB1bm1hc2tlZCBjb250ZXh0IGhhcyBjaGFuZ2VkLlxuICAvLyBGYWlsaW5nIHRvIGRvIHRoaXMgd2lsbCByZXN1bHQgaW4gdW5uZWNlc3NhcnkgY2FsbHMgdG8gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcy5cbiAgLy8gVGhpcyBtYXkgdHJpZ2dlciBpbmZpbml0ZSBsb29wcyBpZiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIGNhbGxzIHNldFN0YXRlLlxuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gIGlmIChpbnN0YW5jZSAmJiBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZFVubWFza2VkQ2hpbGRDb250ZXh0ID09PSB1bm1hc2tlZENvbnRleHQpIHtcbiAgICByZXR1cm4gaW5zdGFuY2UuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNYXNrZWRDaGlsZENvbnRleHQ7XG4gIH1cblxuICB2YXIgY29udGV4dCA9IHt9O1xuICBmb3IgKHZhciBrZXkgaW4gY29udGV4dFR5cGVzKSB7XG4gICAgY29udGV4dFtrZXldID0gdW5tYXNrZWRDb250ZXh0W2tleV07XG4gIH1cblxuICB7XG4gICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzKSB8fCAnVW5rbm93bic7XG4gICAgY2hlY2tQcm9wVHlwZXMoY29udGV4dFR5cGVzLCBjb250ZXh0LCAnY29udGV4dCcsIG5hbWUsIFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSk7XG4gIH1cblxuICAvLyBDYWNoZSB1bm1hc2tlZCBjb250ZXh0IHNvIHdlIGNhbiBhdm9pZCByZWNyZWF0aW5nIG1hc2tlZCBjb250ZXh0IHVubGVzcyBuZWNlc3NhcnkuXG4gIC8vIENvbnRleHQgaXMgY3JlYXRlZCBiZWZvcmUgdGhlIGNsYXNzIGNvbXBvbmVudCBpcyBpbnN0YW50aWF0ZWQgc28gY2hlY2sgZm9yIGluc3RhbmNlLlxuICBpZiAoaW5zdGFuY2UpIHtcbiAgICBjYWNoZUNvbnRleHQod29ya0luUHJvZ3Jlc3MsIHVubWFza2VkQ29udGV4dCwgY29udGV4dCk7XG4gIH1cblxuICByZXR1cm4gY29udGV4dDtcbn1cblxuZnVuY3Rpb24gaGFzQ29udGV4dENoYW5nZWQoKSB7XG4gIHJldHVybiBkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLmN1cnJlbnQ7XG59XG5cbmZ1bmN0aW9uIGlzQ29udGV4dENvbnN1bWVyKGZpYmVyKSB7XG4gIHJldHVybiBmaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50ICYmIGZpYmVyLnR5cGUuY29udGV4dFR5cGVzICE9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzQ29udGV4dFByb3ZpZGVyKGZpYmVyKSB7XG4gIHJldHVybiBmaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50ICYmIGZpYmVyLnR5cGUuY2hpbGRDb250ZXh0VHlwZXMgIT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gcG9wQ29udGV4dFByb3ZpZGVyKGZpYmVyKSB7XG4gIGlmICghaXNDb250ZXh0UHJvdmlkZXIoZmliZXIpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcG9wKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgZmliZXIpO1xufVxuXG5mdW5jdGlvbiBwb3BUb3BMZXZlbENvbnRleHRPYmplY3QoZmliZXIpIHtcbiAgcG9wKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgZmliZXIpO1xufVxuXG5mdW5jdGlvbiBwdXNoVG9wTGV2ZWxDb250ZXh0T2JqZWN0KGZpYmVyLCBjb250ZXh0LCBkaWRDaGFuZ2UpIHtcbiAgIShjb250ZXh0U3RhY2tDdXJzb3IuY3Vyc29yID09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnVW5leHBlY3RlZCBjb250ZXh0IGZvdW5kIG9uIHN0YWNrLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBjb250ZXh0LCBmaWJlcik7XG4gIHB1c2goZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZGlkQ2hhbmdlLCBmaWJlcik7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NDaGlsZENvbnRleHQoZmliZXIsIHBhcmVudENvbnRleHQpIHtcbiAgdmFyIGluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuICB2YXIgY2hpbGRDb250ZXh0VHlwZXMgPSBmaWJlci50eXBlLmNoaWxkQ29udGV4dFR5cGVzO1xuXG4gIC8vIFRPRE8gKGJ2YXVnaG4pIFJlcGxhY2UgdGhpcyBiZWhhdmlvciB3aXRoIGFuIGludmFyaWFudCgpIGluIHRoZSBmdXR1cmUuXG4gIC8vIEl0IGhhcyBvbmx5IGJlZW4gYWRkZWQgaW4gRmliZXIgdG8gbWF0Y2ggdGhlICh1bmludGVudGlvbmFsKSBiZWhhdmlvciBpbiBTdGFjay5cbiAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQgIT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoZmliZXIpIHx8ICdVbmtub3duJztcblxuICAgICAgaWYgKCF3YXJuZWRBYm91dE1pc3NpbmdHZXRDaGlsZENvbnRleHRbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgd2FybmVkQWJvdXRNaXNzaW5nR2V0Q2hpbGRDb250ZXh0W2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJyVzLmNoaWxkQ29udGV4dFR5cGVzIGlzIHNwZWNpZmllZCBidXQgdGhlcmUgaXMgbm8gZ2V0Q2hpbGRDb250ZXh0KCkgbWV0aG9kICcgKyAnb24gdGhlIGluc3RhbmNlLiBZb3UgY2FuIGVpdGhlciBkZWZpbmUgZ2V0Q2hpbGRDb250ZXh0KCkgb24gJXMgb3IgcmVtb3ZlICcgKyAnY2hpbGRDb250ZXh0VHlwZXMgZnJvbSBpdC4nLCBjb21wb25lbnROYW1lLCBjb21wb25lbnROYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcmVudENvbnRleHQ7XG4gIH1cblxuICB2YXIgY2hpbGRDb250ZXh0ID0gdm9pZCAwO1xuICB7XG4gICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50UGhhc2UoJ2dldENoaWxkQ29udGV4dCcpO1xuICB9XG4gIHN0YXJ0UGhhc2VUaW1lcihmaWJlciwgJ2dldENoaWxkQ29udGV4dCcpO1xuICBjaGlsZENvbnRleHQgPSBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQoKTtcbiAgc3RvcFBoYXNlVGltZXIoKTtcbiAge1xuICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIuc2V0Q3VycmVudFBoYXNlKG51bGwpO1xuICB9XG4gIGZvciAodmFyIGNvbnRleHRLZXkgaW4gY2hpbGRDb250ZXh0KSB7XG4gICAgIShjb250ZXh0S2V5IGluIGNoaWxkQ29udGV4dFR5cGVzKSA/IGludmFyaWFudChmYWxzZSwgJyVzLmdldENoaWxkQ29udGV4dCgpOiBrZXkgXCIlc1wiIGlzIG5vdCBkZWZpbmVkIGluIGNoaWxkQ29udGV4dFR5cGVzLicsIGdldENvbXBvbmVudE5hbWUoZmliZXIpIHx8ICdVbmtub3duJywgY29udGV4dEtleSkgOiB2b2lkIDA7XG4gIH1cbiAge1xuICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmaWJlcikgfHwgJ1Vua25vd24nO1xuICAgIGNoZWNrUHJvcFR5cGVzKGNoaWxkQ29udGV4dFR5cGVzLCBjaGlsZENvbnRleHQsICdjaGlsZCBjb250ZXh0JywgbmFtZSxcbiAgICAvLyBJbiBwcmFjdGljZSwgdGhlcmUgaXMgb25lIGNhc2UgaW4gd2hpY2ggd2Ugd29uJ3QgZ2V0IGEgc3RhY2suIEl0J3Mgd2hlblxuICAgIC8vIHNvbWVib2R5IGNhbGxzIHVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKCkgYW5kIHdlIHByb2Nlc3NcbiAgICAvLyBjb250ZXh0IGZyb20gdGhlIHBhcmVudCBjb21wb25lbnQgaW5zdGFuY2UuIFRoZSBzdGFjayB3aWxsIGJlIG1pc3NpbmdcbiAgICAvLyBiZWNhdXNlIGl0J3Mgb3V0c2lkZSBvZiB0aGUgcmVjb25jaWxpYXRpb24sIGFuZCBzbyB0aGUgcG9pbnRlciBoYXMgbm90XG4gICAgLy8gYmVlbiBzZXQuIFRoaXMgaXMgcmFyZSBhbmQgZG9lc24ndCBtYXR0ZXIuIFdlJ2xsIGFsc28gcmVtb3ZlIHRoYXQgQVBJLlxuICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSk7XG4gIH1cblxuICByZXR1cm4gX2Fzc2lnbih7fSwgcGFyZW50Q29udGV4dCwgY2hpbGRDb250ZXh0KTtcbn1cblxuZnVuY3Rpb24gcHVzaENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcykge1xuICBpZiAoIWlzQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgLy8gV2UgcHVzaCB0aGUgY29udGV4dCBhcyBlYXJseSBhcyBwb3NzaWJsZSB0byBlbnN1cmUgc3RhY2sgaW50ZWdyaXR5LlxuICAvLyBJZiB0aGUgaW5zdGFuY2UgZG9lcyBub3QgZXhpc3QgeWV0LCB3ZSB3aWxsIHB1c2ggbnVsbCBhdCBmaXJzdCxcbiAgLy8gYW5kIHJlcGxhY2UgaXQgb24gdGhlIHN0YWNrIGxhdGVyIHdoZW4gaW52YWxpZGF0aW5nIHRoZSBjb250ZXh0LlxuICB2YXIgbWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQgPSBpbnN0YW5jZSAmJiBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dCB8fCBlbXB0eU9iamVjdDtcblxuICAvLyBSZW1lbWJlciB0aGUgcGFyZW50IGNvbnRleHQgc28gd2UgY2FuIG1lcmdlIHdpdGggaXQgbGF0ZXIuXG4gIC8vIEluaGVyaXQgdGhlIHBhcmVudCdzIGRpZC1wZXJmb3JtLXdvcmsgdmFsdWUgdG8gYXZvaWQgaW5hZHZlcnRlbnRseSBibG9ja2luZyB1cGRhdGVzLlxuICBwcmV2aW91c0NvbnRleHQgPSBjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudDtcbiAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IsIG1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7XG4gIHB1c2goZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvci5jdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGludmFsaWRhdGVDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIGRpZENoYW5nZSkge1xuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICFpbnN0YW5jZSA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHRvIGhhdmUgYW4gaW5zdGFuY2UgYnkgdGhpcyBwb2ludC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcblxuICBpZiAoZGlkQ2hhbmdlKSB7XG4gICAgLy8gTWVyZ2UgcGFyZW50IGFuZCBvd24gY29udGV4dC5cbiAgICAvLyBTa2lwIHRoaXMgaWYgd2UncmUgbm90IHVwZGF0aW5nIGR1ZSB0byBzQ1UuXG4gICAgLy8gVGhpcyBhdm9pZHMgdW5uZWNlc3NhcmlseSByZWNvbXB1dGluZyBtZW1vaXplZCB2YWx1ZXMuXG4gICAgdmFyIG1lcmdlZENvbnRleHQgPSBwcm9jZXNzQ2hpbGRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBwcmV2aW91c0NvbnRleHQpO1xuICAgIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0ID0gbWVyZ2VkQ29udGV4dDtcblxuICAgIC8vIFJlcGxhY2UgdGhlIG9sZCAob3IgZW1wdHkpIGNvbnRleHQgd2l0aCB0aGUgbmV3IG9uZS5cbiAgICAvLyBJdCBpcyBpbXBvcnRhbnQgdG8gdW53aW5kIHRoZSBjb250ZXh0IGluIHRoZSByZXZlcnNlIG9yZGVyLlxuICAgIHBvcChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIC8vIE5vdyBwdXNoIHRoZSBuZXcgY29udGV4dCBhbmQgbWFyayB0aGF0IGl0IGhhcyBjaGFuZ2VkLlxuICAgIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBtZXJnZWRDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgcHVzaChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCBkaWRDaGFuZ2UsIHdvcmtJblByb2dyZXNzKTtcbiAgfSBlbHNlIHtcbiAgICBwb3AoZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIHB1c2goZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZGlkQ2hhbmdlLCB3b3JrSW5Qcm9ncmVzcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzZXRDb250ZXh0KCkge1xuICBwcmV2aW91c0NvbnRleHQgPSBlbXB0eU9iamVjdDtcbiAgY29udGV4dFN0YWNrQ3Vyc29yLmN1cnJlbnQgPSBlbXB0eU9iamVjdDtcbiAgZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvci5jdXJyZW50ID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGZpbmRDdXJyZW50VW5tYXNrZWRDb250ZXh0KGZpYmVyKSB7XG4gIC8vIEN1cnJlbnRseSB0aGlzIGlzIG9ubHkgdXNlZCB3aXRoIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyOyBub3Qgc3VyZSBpZiBpdFxuICAvLyBtYWtlcyBzZW5zZSBlbHNld2hlcmVcbiAgIShpc0ZpYmVyTW91bnRlZChmaWJlcikgJiYgZmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCkgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBzdWJ0cmVlIHBhcmVudCB0byBiZSBhIG1vdW50ZWQgY2xhc3MgY29tcG9uZW50LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gIHZhciBub2RlID0gZmliZXI7XG4gIHdoaWxlIChub2RlLnRhZyAhPT0gSG9zdFJvb3QpIHtcbiAgICBpZiAoaXNDb250ZXh0UHJvdmlkZXIobm9kZSkpIHtcbiAgICAgIHJldHVybiBub2RlLnN0YXRlTm9kZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dDtcbiAgICB9XG4gICAgdmFyIHBhcmVudCA9IG5vZGVbJ3JldHVybiddO1xuICAgICFwYXJlbnQgPyBpbnZhcmlhbnQoZmFsc2UsICdGb3VuZCB1bmV4cGVjdGVkIGRldGFjaGVkIHN1YnRyZWUgcGFyZW50LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgIG5vZGUgPSBwYXJlbnQ7XG4gIH1cbiAgcmV0dXJuIG5vZGUuc3RhdGVOb2RlLmNvbnRleHQ7XG59XG5cbnZhciBOb1dvcmsgPSAwOyAvLyBUT0RPOiBVc2UgYW4gb3BhcXVlIHR5cGUgb25jZSBFU0xpbnQgZXQgYWwgc3VwcG9ydCB0aGUgc3ludGF4XG5cbnZhciBTeW5jID0gMTtcbnZhciBOZXZlciA9IDIxNDc0ODM2NDc7IC8vIE1heCBpbnQzMjogTWF0aC5wb3coMiwgMzEpIC0gMVxuXG52YXIgVU5JVF9TSVpFID0gMTA7XG52YXIgTUFHSUNfTlVNQkVSX09GRlNFVCA9IDI7XG5cbi8vIDEgdW5pdCBvZiBleHBpcmF0aW9uIHRpbWUgcmVwcmVzZW50cyAxMG1zLlxuZnVuY3Rpb24gbXNUb0V4cGlyYXRpb25UaW1lKG1zKSB7XG4gIC8vIEFsd2F5cyBhZGQgYW4gb2Zmc2V0IHNvIHRoYXQgd2UgZG9uJ3QgY2xhc2ggd2l0aCB0aGUgbWFnaWMgbnVtYmVyIGZvciBOb1dvcmsuXG4gIHJldHVybiAobXMgLyBVTklUX1NJWkUgfCAwKSArIE1BR0lDX05VTUJFUl9PRkZTRVQ7XG59XG5cbmZ1bmN0aW9uIGV4cGlyYXRpb25UaW1lVG9NcyhleHBpcmF0aW9uVGltZSkge1xuICByZXR1cm4gKGV4cGlyYXRpb25UaW1lIC0gTUFHSUNfTlVNQkVSX09GRlNFVCkgKiBVTklUX1NJWkU7XG59XG5cbmZ1bmN0aW9uIGNlaWxpbmcobnVtLCBwcmVjaXNpb24pIHtcbiAgcmV0dXJuICgobnVtIC8gcHJlY2lzaW9uIHwgMCkgKyAxKSAqIHByZWNpc2lvbjtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUV4cGlyYXRpb25CdWNrZXQoY3VycmVudFRpbWUsIGV4cGlyYXRpb25Jbk1zLCBidWNrZXRTaXplTXMpIHtcbiAgcmV0dXJuIGNlaWxpbmcoY3VycmVudFRpbWUgKyBleHBpcmF0aW9uSW5NcyAvIFVOSVRfU0laRSwgYnVja2V0U2l6ZU1zIC8gVU5JVF9TSVpFKTtcbn1cblxudmFyIE5vQ29udGV4dCA9IDA7XG52YXIgQXN5bmNVcGRhdGVzID0gMTtcblxue1xuICB2YXIgaGFzQmFkTWFwUG9seWZpbGwgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICB2YXIgbm9uRXh0ZW5zaWJsZU9iamVjdCA9IE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSk7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tbmV3ICovXG4gICAgXG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1uZXcgKi9cbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIFRPRE86IENvbnNpZGVyIHdhcm5pbmcgYWJvdXQgYmFkIHBvbHlmaWxsc1xuICAgIGhhc0JhZE1hcFBvbHlmaWxsID0gdHJ1ZTtcbiAgfVxufVxuXG4vLyBBIEZpYmVyIGlzIHdvcmsgb24gYSBDb21wb25lbnQgdGhhdCBuZWVkcyB0byBiZSBkb25lIG9yIHdhcyBkb25lLiBUaGVyZSBjYW5cbi8vIGJlIG1vcmUgdGhhbiBvbmUgcGVyIGNvbXBvbmVudC5cblxuXG57XG4gIHZhciBkZWJ1Z0NvdW50ZXIgPSAxO1xufVxuXG5mdW5jdGlvbiBGaWJlck5vZGUodGFnLCBrZXksIGludGVybmFsQ29udGV4dFRhZykge1xuICAvLyBJbnN0YW5jZVxuICB0aGlzLnRhZyA9IHRhZztcbiAgdGhpcy5rZXkgPSBrZXk7XG4gIHRoaXMudHlwZSA9IG51bGw7XG4gIHRoaXMuc3RhdGVOb2RlID0gbnVsbDtcblxuICAvLyBGaWJlclxuICB0aGlzWydyZXR1cm4nXSA9IG51bGw7XG4gIHRoaXMuY2hpbGQgPSBudWxsO1xuICB0aGlzLnNpYmxpbmcgPSBudWxsO1xuICB0aGlzLmluZGV4ID0gMDtcblxuICB0aGlzLnJlZiA9IG51bGw7XG5cbiAgdGhpcy5wZW5kaW5nUHJvcHMgPSBudWxsO1xuICB0aGlzLm1lbW9pemVkUHJvcHMgPSBudWxsO1xuICB0aGlzLnVwZGF0ZVF1ZXVlID0gbnVsbDtcbiAgdGhpcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcblxuICB0aGlzLmludGVybmFsQ29udGV4dFRhZyA9IGludGVybmFsQ29udGV4dFRhZztcblxuICAvLyBFZmZlY3RzXG4gIHRoaXMuZWZmZWN0VGFnID0gTm9FZmZlY3Q7XG4gIHRoaXMubmV4dEVmZmVjdCA9IG51bGw7XG5cbiAgdGhpcy5maXJzdEVmZmVjdCA9IG51bGw7XG4gIHRoaXMubGFzdEVmZmVjdCA9IG51bGw7XG5cbiAgdGhpcy5leHBpcmF0aW9uVGltZSA9IE5vV29yaztcblxuICB0aGlzLmFsdGVybmF0ZSA9IG51bGw7XG5cbiAge1xuICAgIHRoaXMuX2RlYnVnSUQgPSBkZWJ1Z0NvdW50ZXIrKztcbiAgICB0aGlzLl9kZWJ1Z1NvdXJjZSA9IG51bGw7XG4gICAgdGhpcy5fZGVidWdPd25lciA9IG51bGw7XG4gICAgdGhpcy5fZGVidWdJc0N1cnJlbnRseVRpbWluZyA9IGZhbHNlO1xuICAgIGlmICghaGFzQmFkTWFwUG9seWZpbGwgJiYgdHlwZW9mIE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHRoaXMpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBUaGlzIGlzIGEgY29uc3RydWN0b3IgZnVuY3Rpb24sIHJhdGhlciB0aGFuIGEgUE9KTyBjb25zdHJ1Y3Rvciwgc3RpbGxcbi8vIHBsZWFzZSBlbnN1cmUgd2UgZG8gdGhlIGZvbGxvd2luZzpcbi8vIDEpIE5vYm9keSBzaG91bGQgYWRkIGFueSBpbnN0YW5jZSBtZXRob2RzIG9uIHRoaXMuIEluc3RhbmNlIG1ldGhvZHMgY2FuIGJlXG4vLyAgICBtb3JlIGRpZmZpY3VsdCB0byBwcmVkaWN0IHdoZW4gdGhleSBnZXQgb3B0aW1pemVkIGFuZCB0aGV5IGFyZSBhbG1vc3Rcbi8vICAgIG5ldmVyIGlubGluZWQgcHJvcGVybHkgaW4gc3RhdGljIGNvbXBpbGVycy5cbi8vIDIpIE5vYm9keSBzaG91bGQgcmVseSBvbiBgaW5zdGFuY2VvZiBGaWJlcmAgZm9yIHR5cGUgdGVzdGluZy4gV2Ugc2hvdWxkXG4vLyAgICBhbHdheXMga25vdyB3aGVuIGl0IGlzIGEgZmliZXIuXG4vLyAzKSBXZSBtaWdodCB3YW50IHRvIGV4cGVyaW1lbnQgd2l0aCB1c2luZyBudW1lcmljIGtleXMgc2luY2UgdGhleSBhcmUgZWFzaWVyXG4vLyAgICB0byBvcHRpbWl6ZSBpbiBhIG5vbi1KSVQgZW52aXJvbm1lbnQuXG4vLyA0KSBXZSBjYW4gZWFzaWx5IGdvIGZyb20gYSBjb25zdHJ1Y3RvciB0byBhIGNyZWF0ZUZpYmVyIG9iamVjdCBsaXRlcmFsIGlmIHRoYXRcbi8vICAgIGlzIGZhc3Rlci5cbi8vIDUpIEl0IHNob3VsZCBiZSBlYXN5IHRvIHBvcnQgdGhpcyB0byBhIEMgc3RydWN0IGFuZCBrZWVwIGEgQyBpbXBsZW1lbnRhdGlvblxuLy8gICAgY29tcGF0aWJsZS5cbnZhciBjcmVhdGVGaWJlciA9IGZ1bmN0aW9uICh0YWcsIGtleSwgaW50ZXJuYWxDb250ZXh0VGFnKSB7XG4gIC8vICRGbG93Rml4TWU6IHRoZSBzaGFwZXMgYXJlIGV4YWN0IGhlcmUgYnV0IEZsb3cgZG9lc24ndCBsaWtlIGNvbnN0cnVjdG9yc1xuICByZXR1cm4gbmV3IEZpYmVyTm9kZSh0YWcsIGtleSwgaW50ZXJuYWxDb250ZXh0VGFnKTtcbn07XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcbiAgcmV0dXJuICEhKENvbXBvbmVudC5wcm90b3R5cGUgJiYgQ29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuLy8gVGhpcyBpcyB1c2VkIHRvIGNyZWF0ZSBhbiBhbHRlcm5hdGUgZmliZXIgdG8gZG8gd29yayBvbi5cbmZ1bmN0aW9uIGNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnQsIHBlbmRpbmdQcm9wcywgZXhwaXJhdGlvblRpbWUpIHtcbiAgdmFyIHdvcmtJblByb2dyZXNzID0gY3VycmVudC5hbHRlcm5hdGU7XG4gIGlmICh3b3JrSW5Qcm9ncmVzcyA9PT0gbnVsbCkge1xuICAgIC8vIFdlIHVzZSBhIGRvdWJsZSBidWZmZXJpbmcgcG9vbGluZyB0ZWNobmlxdWUgYmVjYXVzZSB3ZSBrbm93IHRoYXQgd2UnbGxcbiAgICAvLyBvbmx5IGV2ZXIgbmVlZCBhdCBtb3N0IHR3byB2ZXJzaW9ucyBvZiBhIHRyZWUuIFdlIHBvb2wgdGhlIFwib3RoZXJcIiB1bnVzZWRcbiAgICAvLyBub2RlIHRoYXQgd2UncmUgZnJlZSB0byByZXVzZS4gVGhpcyBpcyBsYXppbHkgY3JlYXRlZCB0byBhdm9pZCBhbGxvY2F0aW5nXG4gICAgLy8gZXh0cmEgb2JqZWN0cyBmb3IgdGhpbmdzIHRoYXQgYXJlIG5ldmVyIHVwZGF0ZWQuIEl0IGFsc28gYWxsb3cgdXMgdG9cbiAgICAvLyByZWNsYWltIHRoZSBleHRyYSBtZW1vcnkgaWYgbmVlZGVkLlxuICAgIHdvcmtJblByb2dyZXNzID0gY3JlYXRlRmliZXIoY3VycmVudC50YWcsIGN1cnJlbnQua2V5LCBjdXJyZW50LmludGVybmFsQ29udGV4dFRhZyk7XG4gICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IGN1cnJlbnQudHlwZTtcbiAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjdXJyZW50LnN0YXRlTm9kZTtcblxuICAgIHtcbiAgICAgIC8vIERFVi1vbmx5IGZpZWxkc1xuICAgICAgd29ya0luUHJvZ3Jlc3MuX2RlYnVnSUQgPSBjdXJyZW50Ll9kZWJ1Z0lEO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuX2RlYnVnU291cmNlID0gY3VycmVudC5fZGVidWdTb3VyY2U7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdPd25lciA9IGN1cnJlbnQuX2RlYnVnT3duZXI7XG4gICAgfVxuXG4gICAgd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlID0gY3VycmVudDtcbiAgICBjdXJyZW50LmFsdGVybmF0ZSA9IHdvcmtJblByb2dyZXNzO1xuICB9IGVsc2Uge1xuICAgIC8vIFdlIGFscmVhZHkgaGF2ZSBhbiBhbHRlcm5hdGUuXG4gICAgLy8gUmVzZXQgdGhlIGVmZmVjdCB0YWcuXG4gICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnID0gTm9FZmZlY3Q7XG5cbiAgICAvLyBUaGUgZWZmZWN0IGxpc3QgaXMgbm8gbG9uZ2VyIHZhbGlkLlxuICAgIHdvcmtJblByb2dyZXNzLm5leHRFZmZlY3QgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLmZpcnN0RWZmZWN0ID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5sYXN0RWZmZWN0ID0gbnVsbDtcbiAgfVxuXG4gIHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyA9IHBlbmRpbmdQcm9wcztcblxuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGN1cnJlbnQuY2hpbGQ7XG4gIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gY3VycmVudC51cGRhdGVRdWV1ZTtcblxuICAvLyBUaGVzZSB3aWxsIGJlIG92ZXJyaWRkZW4gZHVyaW5nIHRoZSBwYXJlbnQncyByZWNvbmNpbGlhdGlvblxuICB3b3JrSW5Qcm9ncmVzcy5zaWJsaW5nID0gY3VycmVudC5zaWJsaW5nO1xuICB3b3JrSW5Qcm9ncmVzcy5pbmRleCA9IGN1cnJlbnQuaW5kZXg7XG4gIHdvcmtJblByb2dyZXNzLnJlZiA9IGN1cnJlbnQucmVmO1xuXG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbn1cblxuZnVuY3Rpb24gY3JlYXRlSG9zdFJvb3RGaWJlcigpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoSG9zdFJvb3QsIG51bGwsIE5vQ29udGV4dCk7XG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tRWxlbWVudChlbGVtZW50LCBpbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKSB7XG4gIHZhciBvd25lciA9IG51bGw7XG4gIHtcbiAgICBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICB9XG5cbiAgdmFyIGZpYmVyID0gdm9pZCAwO1xuICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZSxcbiAgICAgIGtleSA9IGVsZW1lbnQua2V5O1xuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGZpYmVyID0gc2hvdWxkQ29uc3RydWN0KHR5cGUpID8gY3JlYXRlRmliZXIoQ2xhc3NDb21wb25lbnQsIGtleSwgaW50ZXJuYWxDb250ZXh0VGFnKSA6IGNyZWF0ZUZpYmVyKEluZGV0ZXJtaW5hdGVDb21wb25lbnQsIGtleSwgaW50ZXJuYWxDb250ZXh0VGFnKTtcbiAgICBmaWJlci50eXBlID0gdHlwZTtcbiAgICBmaWJlci5wZW5kaW5nUHJvcHMgPSBlbGVtZW50LnByb3BzO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIGZpYmVyID0gY3JlYXRlRmliZXIoSG9zdENvbXBvbmVudCwga2V5LCBpbnRlcm5hbENvbnRleHRUYWcpO1xuICAgIGZpYmVyLnR5cGUgPSB0eXBlO1xuICAgIGZpYmVyLnBlbmRpbmdQcm9wcyA9IGVsZW1lbnQucHJvcHM7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgdHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgIC8vIEN1cnJlbnRseSBhc3N1bWVkIHRvIGJlIGEgY29udGludWF0aW9uIGFuZCB0aGVyZWZvcmUgaXMgYSBmaWJlciBhbHJlYWR5LlxuICAgIC8vIFRPRE86IFRoZSB5aWVsZCBzeXN0ZW0gaXMgY3VycmVudGx5IGJyb2tlbiBmb3IgdXBkYXRlcyBpbiBzb21lIGNhc2VzLlxuICAgIC8vIFRoZSByZWlmaWVkIHlpZWxkIHN0b3JlcyBhIGZpYmVyLCBidXQgd2UgZG9uJ3Qga25vdyB3aGljaCBmaWJlciB0aGF0IGlzO1xuICAgIC8vIHRoZSBjdXJyZW50IG9yIGEgd29ya0luUHJvZ3Jlc3M/IFdoZW4gdGhlIGNvbnRpbnVhdGlvbiBnZXRzIHJlbmRlcmVkIGhlcmVcbiAgICAvLyB3ZSBkb24ndCBrbm93IGlmIHdlIGNhbiByZXVzZSB0aGF0IGZpYmVyIG9yIGlmIHdlIG5lZWQgdG8gY2xvbmUgaXQuXG4gICAgLy8gVGhlcmUgaXMgcHJvYmFibHkgYSBjbGV2ZXIgd2F5IHRvIHJlc3RydWN0dXJlIHRoaXMuXG4gICAgZmliZXIgPSB0eXBlO1xuICAgIGZpYmVyLnBlbmRpbmdQcm9wcyA9IGVsZW1lbnQucHJvcHM7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGluZm8gPSAnJztcbiAgICB7XG4gICAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiO1xuICAgICAgfVxuICAgICAgdmFyIG93bmVyTmFtZSA9IG93bmVyID8gZ2V0Q29tcG9uZW50TmFtZShvd25lcikgOiBudWxsO1xuICAgICAgaWYgKG93bmVyTmFtZSkge1xuICAgICAgICBpbmZvICs9ICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG93bmVyTmFtZSArICdgLic7XG4gICAgICB9XG4gICAgfVxuICAgIGludmFyaWFudChmYWxzZSwgJ0VsZW1lbnQgdHlwZSBpcyBpbnZhbGlkOiBleHBlY3RlZCBhIHN0cmluZyAoZm9yIGJ1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXMnLCB0eXBlID09IG51bGwgPyB0eXBlIDogdHlwZW9mIHR5cGUsIGluZm8pO1xuICB9XG5cbiAge1xuICAgIGZpYmVyLl9kZWJ1Z1NvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTtcbiAgICBmaWJlci5fZGVidWdPd25lciA9IGVsZW1lbnQuX293bmVyO1xuICB9XG5cbiAgZmliZXIuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcblxuICByZXR1cm4gZmliZXI7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KGVsZW1lbnRzLCBpbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lLCBrZXkpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoRnJhZ21lbnQsIGtleSwgaW50ZXJuYWxDb250ZXh0VGFnKTtcbiAgZmliZXIucGVuZGluZ1Byb3BzID0gZWxlbWVudHM7XG4gIGZpYmVyLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tVGV4dChjb250ZW50LCBpbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKEhvc3RUZXh0LCBudWxsLCBpbnRlcm5hbENvbnRleHRUYWcpO1xuICBmaWJlci5wZW5kaW5nUHJvcHMgPSBjb250ZW50O1xuICBmaWJlci5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICByZXR1cm4gZmliZXI7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbUhvc3RJbnN0YW5jZUZvckRlbGV0aW9uKCkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihIb3N0Q29tcG9uZW50LCBudWxsLCBOb0NvbnRleHQpO1xuICBmaWJlci50eXBlID0gJ0RFTEVURUQnO1xuICByZXR1cm4gZmliZXI7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbUNhbGwoY2FsbCwgaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihDYWxsQ29tcG9uZW50LCBjYWxsLmtleSwgaW50ZXJuYWxDb250ZXh0VGFnKTtcbiAgZmliZXIudHlwZSA9IGNhbGwuaGFuZGxlcjtcbiAgZmliZXIucGVuZGluZ1Byb3BzID0gY2FsbDtcbiAgZmliZXIuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgcmV0dXJuIGZpYmVyO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21SZXR1cm4ocmV0dXJuTm9kZSwgaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihSZXR1cm5Db21wb25lbnQsIG51bGwsIGludGVybmFsQ29udGV4dFRhZyk7XG4gIGZpYmVyLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tUG9ydGFsKHBvcnRhbCwgaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihIb3N0UG9ydGFsLCBwb3J0YWwua2V5LCBpbnRlcm5hbENvbnRleHRUYWcpO1xuICBmaWJlci5wZW5kaW5nUHJvcHMgPSBwb3J0YWwuY2hpbGRyZW4gfHwgW107XG4gIGZpYmVyLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gIGZpYmVyLnN0YXRlTm9kZSA9IHtcbiAgICBjb250YWluZXJJbmZvOiBwb3J0YWwuY29udGFpbmVySW5mbyxcbiAgICBwZW5kaW5nQ2hpbGRyZW46IG51bGwsIC8vIFVzZWQgYnkgcGVyc2lzdGVudCB1cGRhdGVzXG4gICAgaW1wbGVtZW50YXRpb246IHBvcnRhbC5pbXBsZW1lbnRhdGlvblxuICB9O1xuICByZXR1cm4gZmliZXI7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyUm9vdChjb250YWluZXJJbmZvLCBoeWRyYXRlKSB7XG4gIC8vIEN5Y2xpYyBjb25zdHJ1Y3Rpb24uIFRoaXMgY2hlYXRzIHRoZSB0eXBlIHN5c3RlbSByaWdodCBub3cgYmVjYXVzZVxuICAvLyBzdGF0ZU5vZGUgaXMgYW55LlxuICB2YXIgdW5pbml0aWFsaXplZEZpYmVyID0gY3JlYXRlSG9zdFJvb3RGaWJlcigpO1xuICB2YXIgcm9vdCA9IHtcbiAgICBjdXJyZW50OiB1bmluaXRpYWxpemVkRmliZXIsXG4gICAgY29udGFpbmVySW5mbzogY29udGFpbmVySW5mbyxcbiAgICBwZW5kaW5nQ2hpbGRyZW46IG51bGwsXG4gICAgcmVtYWluaW5nRXhwaXJhdGlvblRpbWU6IE5vV29yayxcbiAgICBpc1JlYWR5Rm9yQ29tbWl0OiBmYWxzZSxcbiAgICBmaW5pc2hlZFdvcms6IG51bGwsXG4gICAgY29udGV4dDogbnVsbCxcbiAgICBwZW5kaW5nQ29udGV4dDogbnVsbCxcbiAgICBoeWRyYXRlOiBoeWRyYXRlLFxuICAgIG5leHRTY2hlZHVsZWRSb290OiBudWxsXG4gIH07XG4gIHVuaW5pdGlhbGl6ZWRGaWJlci5zdGF0ZU5vZGUgPSByb290O1xuICByZXR1cm4gcm9vdDtcbn1cblxudmFyIG9uQ29tbWl0RmliZXJSb290ID0gbnVsbDtcbnZhciBvbkNvbW1pdEZpYmVyVW5tb3VudCA9IG51bGw7XG52YXIgaGFzTG9nZ2VkRXJyb3IgPSBmYWxzZTtcblxuZnVuY3Rpb24gY2F0Y2hFcnJvcnMoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZuKGFyZyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAodHJ1ZSAmJiAhaGFzTG9nZ2VkRXJyb3IpIHtcbiAgICAgICAgaGFzTG9nZ2VkRXJyb3IgPSB0cnVlO1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnUmVhY3QgRGV2VG9vbHMgZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzJywgZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluamVjdEludGVybmFscyhpbnRlcm5hbHMpIHtcbiAgaWYgKHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gTm8gRGV2VG9vbHNcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGhvb2sgPSBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG4gIGlmIChob29rLmlzRGlzYWJsZWQpIHtcbiAgICAvLyBUaGlzIGlzbid0IGEgcmVhbCBwcm9wZXJ0eSBvbiB0aGUgaG9vaywgYnV0IGl0IGNhbiBiZSBzZXQgdG8gb3B0IG91dFxuICAgIC8vIG9mIERldlRvb2xzIGludGVncmF0aW9uIGFuZCBhc3NvY2lhdGVkIHdhcm5pbmdzIGFuZCBsb2dzLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMzg3N1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICghaG9vay5zdXBwb3J0c0ZpYmVyKSB7XG4gICAge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1RoZSBpbnN0YWxsZWQgdmVyc2lvbiBvZiBSZWFjdCBEZXZUb29scyBpcyB0b28gb2xkIGFuZCB3aWxsIG5vdCB3b3JrICcgKyAnd2l0aCB0aGUgY3VycmVudCB2ZXJzaW9uIG9mIFJlYWN0LiBQbGVhc2UgdXBkYXRlIFJlYWN0IERldlRvb2xzLiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtZGV2dG9vbHMnKTtcbiAgICB9XG4gICAgLy8gRGV2VG9vbHMgZXhpc3RzLCBldmVuIHRob3VnaCBpdCBkb2Vzbid0IHN1cHBvcnQgRmliZXIuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdHJ5IHtcbiAgICB2YXIgcmVuZGVyZXJJRCA9IGhvb2suaW5qZWN0KGludGVybmFscyk7XG4gICAgLy8gV2UgaGF2ZSBzdWNjZXNzZnVsbHkgaW5qZWN0ZWQsIHNvIG5vdyBpdCBpcyBzYWZlIHRvIHNldCB1cCBob29rcy5cbiAgICBvbkNvbW1pdEZpYmVyUm9vdCA9IGNhdGNoRXJyb3JzKGZ1bmN0aW9uIChyb290KSB7XG4gICAgICByZXR1cm4gaG9vay5vbkNvbW1pdEZpYmVyUm9vdChyZW5kZXJlcklELCByb290KTtcbiAgICB9KTtcbiAgICBvbkNvbW1pdEZpYmVyVW5tb3VudCA9IGNhdGNoRXJyb3JzKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgcmV0dXJuIGhvb2sub25Db21taXRGaWJlclVubW91bnQocmVuZGVyZXJJRCwgZmliZXIpO1xuICAgIH0pO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBDYXRjaCBhbGwgZXJyb3JzIGJlY2F1c2UgaXQgaXMgdW5zYWZlIHRvIHRocm93IGR1cmluZyBpbml0aWFsaXphdGlvbi5cbiAgICB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnUmVhY3QgRGV2VG9vbHMgZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzLicsIGVycik7XG4gICAgfVxuICB9XG4gIC8vIERldlRvb2xzIGV4aXN0c1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gb25Db21taXRSb290KHJvb3QpIHtcbiAgaWYgKHR5cGVvZiBvbkNvbW1pdEZpYmVyUm9vdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG9uQ29tbWl0RmliZXJSb290KHJvb3QpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9uQ29tbWl0VW5tb3VudChmaWJlcikge1xuICBpZiAodHlwZW9mIG9uQ29tbWl0RmliZXJVbm1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgb25Db21taXRGaWJlclVubW91bnQoZmliZXIpO1xuICB9XG59XG5cbntcbiAgdmFyIGRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGUgPSBmYWxzZTtcbn1cblxuLy8gQ2FsbGJhY2tzIGFyZSBub3QgdmFsaWRhdGVkIHVudGlsIGludm9jYXRpb25cblxuXG4vLyBTaW5nbHkgbGlua2VkLWxpc3Qgb2YgdXBkYXRlcy4gV2hlbiBhbiB1cGRhdGUgaXMgc2NoZWR1bGVkLCBpdCBpcyBhZGRlZCB0b1xuLy8gdGhlIHF1ZXVlIG9mIHRoZSBjdXJyZW50IGZpYmVyIGFuZCB0aGUgd29yay1pbi1wcm9ncmVzcyBmaWJlci4gVGhlIHR3byBxdWV1ZXNcbi8vIGFyZSBzZXBhcmF0ZSBidXQgdGhleSBzaGFyZSBhIHBlcnNpc3RlbnQgc3RydWN0dXJlLlxuLy9cbi8vIER1cmluZyByZWNvbmNpbGlhdGlvbiwgdXBkYXRlcyBhcmUgcmVtb3ZlZCBmcm9tIHRoZSB3b3JrLWluLXByb2dyZXNzIGZpYmVyLFxuLy8gYnV0IHRoZXkgcmVtYWluIG9uIHRoZSBjdXJyZW50IGZpYmVyLiBUaGF0IGVuc3VyZXMgdGhhdCBpZiBhIHdvcmstaW4tcHJvZ3Jlc3Ncbi8vIGlzIGFib3J0ZWQsIHRoZSBhYm9ydGVkIHVwZGF0ZXMgYXJlIHJlY292ZXJlZCBieSBjbG9uaW5nIGZyb20gY3VycmVudC5cbi8vXG4vLyBUaGUgd29yay1pbi1wcm9ncmVzcyBxdWV1ZSBpcyBhbHdheXMgYSBzdWJzZXQgb2YgdGhlIGN1cnJlbnQgcXVldWUuXG4vL1xuLy8gV2hlbiB0aGUgdHJlZSBpcyBjb21taXR0ZWQsIHRoZSB3b3JrLWluLXByb2dyZXNzIGJlY29tZXMgdGhlIGN1cnJlbnQuXG5cblxuZnVuY3Rpb24gY3JlYXRlVXBkYXRlUXVldWUoYmFzZVN0YXRlKSB7XG4gIHZhciBxdWV1ZSA9IHtcbiAgICBiYXNlU3RhdGU6IGJhc2VTdGF0ZSxcbiAgICBleHBpcmF0aW9uVGltZTogTm9Xb3JrLFxuICAgIGZpcnN0OiBudWxsLFxuICAgIGxhc3Q6IG51bGwsXG4gICAgY2FsbGJhY2tMaXN0OiBudWxsLFxuICAgIGhhc0ZvcmNlVXBkYXRlOiBmYWxzZSxcbiAgICBpc0luaXRpYWxpemVkOiBmYWxzZVxuICB9O1xuICB7XG4gICAgcXVldWUuaXNQcm9jZXNzaW5nID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHF1ZXVlO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRVcGRhdGVJbnRvUXVldWUocXVldWUsIHVwZGF0ZSkge1xuICAvLyBBcHBlbmQgdGhlIHVwZGF0ZSB0byB0aGUgZW5kIG9mIHRoZSBsaXN0LlxuICBpZiAocXVldWUubGFzdCA9PT0gbnVsbCkge1xuICAgIC8vIFF1ZXVlIGlzIGVtcHR5XG4gICAgcXVldWUuZmlyc3QgPSBxdWV1ZS5sYXN0ID0gdXBkYXRlO1xuICB9IGVsc2Uge1xuICAgIHF1ZXVlLmxhc3QubmV4dCA9IHVwZGF0ZTtcbiAgICBxdWV1ZS5sYXN0ID0gdXBkYXRlO1xuICB9XG4gIGlmIChxdWV1ZS5leHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IHF1ZXVlLmV4cGlyYXRpb25UaW1lID4gdXBkYXRlLmV4cGlyYXRpb25UaW1lKSB7XG4gICAgcXVldWUuZXhwaXJhdGlvblRpbWUgPSB1cGRhdGUuZXhwaXJhdGlvblRpbWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5zZXJ0VXBkYXRlSW50b0ZpYmVyKGZpYmVyLCB1cGRhdGUpIHtcbiAgLy8gV2UnbGwgaGF2ZSBhdCBsZWFzdCBvbmUgYW5kIGF0IG1vc3QgdHdvIGRpc3RpbmN0IHVwZGF0ZSBxdWV1ZXMuXG4gIHZhciBhbHRlcm5hdGVGaWJlciA9IGZpYmVyLmFsdGVybmF0ZTtcbiAgdmFyIHF1ZXVlMSA9IGZpYmVyLnVwZGF0ZVF1ZXVlO1xuICBpZiAocXVldWUxID09PSBudWxsKSB7XG4gICAgLy8gVE9ETzogV2UgZG9uJ3Qga25vdyB3aGF0IHRoZSBiYXNlIHN0YXRlIHdpbGwgYmUgdW50aWwgd2UgYmVnaW4gd29yay5cbiAgICAvLyBJdCBkZXBlbmRzIG9uIHdoaWNoIGZpYmVyIGlzIHRoZSBuZXh0IGN1cnJlbnQuIEluaXRpYWxpemUgd2l0aCBhbiBlbXB0eVxuICAgIC8vIGJhc2Ugc3RhdGUsIHRoZW4gc2V0IHRvIHRoZSBtZW1vaXplZFN0YXRlIHdoZW4gcmVuZGVyaW5nLiBOb3Qgc3VwZXJcbiAgICAvLyBoYXBweSB3aXRoIHRoaXMgYXBwcm9hY2guXG4gICAgcXVldWUxID0gZmliZXIudXBkYXRlUXVldWUgPSBjcmVhdGVVcGRhdGVRdWV1ZShudWxsKTtcbiAgfVxuXG4gIHZhciBxdWV1ZTIgPSB2b2lkIDA7XG4gIGlmIChhbHRlcm5hdGVGaWJlciAhPT0gbnVsbCkge1xuICAgIHF1ZXVlMiA9IGFsdGVybmF0ZUZpYmVyLnVwZGF0ZVF1ZXVlO1xuICAgIGlmIChxdWV1ZTIgPT09IG51bGwpIHtcbiAgICAgIHF1ZXVlMiA9IGFsdGVybmF0ZUZpYmVyLnVwZGF0ZVF1ZXVlID0gY3JlYXRlVXBkYXRlUXVldWUobnVsbCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHF1ZXVlMiA9IG51bGw7XG4gIH1cbiAgcXVldWUyID0gcXVldWUyICE9PSBxdWV1ZTEgPyBxdWV1ZTIgOiBudWxsO1xuXG4gIC8vIFdhcm4gaWYgYW4gdXBkYXRlIGlzIHNjaGVkdWxlZCBmcm9tIGluc2lkZSBhbiB1cGRhdGVyIGZ1bmN0aW9uLlxuICB7XG4gICAgaWYgKChxdWV1ZTEuaXNQcm9jZXNzaW5nIHx8IHF1ZXVlMiAhPT0gbnVsbCAmJiBxdWV1ZTIuaXNQcm9jZXNzaW5nKSAmJiAhZGlkV2FyblVwZGF0ZUluc2lkZVVwZGF0ZSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ0FuIHVwZGF0ZSAoc2V0U3RhdGUsIHJlcGxhY2VTdGF0ZSwgb3IgZm9yY2VVcGRhdGUpIHdhcyBzY2hlZHVsZWQgJyArICdmcm9tIGluc2lkZSBhbiB1cGRhdGUgZnVuY3Rpb24uIFVwZGF0ZSBmdW5jdGlvbnMgc2hvdWxkIGJlIHB1cmUsICcgKyAnd2l0aCB6ZXJvIHNpZGUtZWZmZWN0cy4gQ29uc2lkZXIgdXNpbmcgY29tcG9uZW50RGlkVXBkYXRlIG9yIGEgJyArICdjYWxsYmFjay4nKTtcbiAgICAgIGRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGUgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8vIElmIHRoZXJlJ3Mgb25seSBvbmUgcXVldWUsIGFkZCB0aGUgdXBkYXRlIHRvIHRoYXQgcXVldWUgYW5kIGV4aXQuXG4gIGlmIChxdWV1ZTIgPT09IG51bGwpIHtcbiAgICBpbnNlcnRVcGRhdGVJbnRvUXVldWUocXVldWUxLCB1cGRhdGUpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIElmIGVpdGhlciBxdWV1ZSBpcyBlbXB0eSwgd2UgbmVlZCB0byBhZGQgdG8gYm90aCBxdWV1ZXMuXG4gIGlmIChxdWV1ZTEubGFzdCA9PT0gbnVsbCB8fCBxdWV1ZTIubGFzdCA9PT0gbnVsbCkge1xuICAgIGluc2VydFVwZGF0ZUludG9RdWV1ZShxdWV1ZTEsIHVwZGF0ZSk7XG4gICAgaW5zZXJ0VXBkYXRlSW50b1F1ZXVlKHF1ZXVlMiwgdXBkYXRlKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBJZiBib3RoIGxpc3RzIGFyZSBub3QgZW1wdHksIHRoZSBsYXN0IHVwZGF0ZSBpcyB0aGUgc2FtZSBmb3IgYm90aCBsaXN0c1xuICAvLyBiZWNhdXNlIG9mIHN0cnVjdHVyYWwgc2hhcmluZy4gU28sIHdlIHNob3VsZCBvbmx5IGFwcGVuZCB0byBvbmUgb2ZcbiAgLy8gdGhlIGxpc3RzLlxuICBpbnNlcnRVcGRhdGVJbnRvUXVldWUocXVldWUxLCB1cGRhdGUpO1xuICAvLyBCdXQgd2Ugc3RpbGwgbmVlZCB0byB1cGRhdGUgdGhlIGBsYXN0YCBwb2ludGVyIG9mIHF1ZXVlMi5cbiAgcXVldWUyLmxhc3QgPSB1cGRhdGU7XG59XG5cbmZ1bmN0aW9uIGdldFVwZGF0ZUV4cGlyYXRpb25UaW1lKGZpYmVyKSB7XG4gIGlmIChmaWJlci50YWcgIT09IENsYXNzQ29tcG9uZW50ICYmIGZpYmVyLnRhZyAhPT0gSG9zdFJvb3QpIHtcbiAgICByZXR1cm4gTm9Xb3JrO1xuICB9XG4gIHZhciB1cGRhdGVRdWV1ZSA9IGZpYmVyLnVwZGF0ZVF1ZXVlO1xuICBpZiAodXBkYXRlUXVldWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gTm9Xb3JrO1xuICB9XG4gIHJldHVybiB1cGRhdGVRdWV1ZS5leHBpcmF0aW9uVGltZTtcbn1cblxuZnVuY3Rpb24gZ2V0U3RhdGVGcm9tVXBkYXRlKHVwZGF0ZSwgaW5zdGFuY2UsIHByZXZTdGF0ZSwgcHJvcHMpIHtcbiAgdmFyIHBhcnRpYWxTdGF0ZSA9IHVwZGF0ZS5wYXJ0aWFsU3RhdGU7XG4gIGlmICh0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIHVwZGF0ZUZuID0gcGFydGlhbFN0YXRlO1xuXG4gICAgLy8gSW52b2tlIHNldFN0YXRlIGNhbGxiYWNrIGFuIGV4dHJhIHRpbWUgdG8gaGVscCBkZXRlY3Qgc2lkZS1lZmZlY3RzLlxuICAgIGlmIChkZWJ1Z1JlbmRlclBoYXNlU2lkZUVmZmVjdHMpIHtcbiAgICAgIHVwZGF0ZUZuLmNhbGwoaW5zdGFuY2UsIHByZXZTdGF0ZSwgcHJvcHMpO1xuICAgIH1cblxuICAgIHJldHVybiB1cGRhdGVGbi5jYWxsKGluc3RhbmNlLCBwcmV2U3RhdGUsIHByb3BzKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcGFydGlhbFN0YXRlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NVcGRhdGVRdWV1ZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcXVldWUsIGluc3RhbmNlLCBwcm9wcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgY3VycmVudC51cGRhdGVRdWV1ZSA9PT0gcXVldWUpIHtcbiAgICAvLyBXZSBuZWVkIHRvIGNyZWF0ZSBhIHdvcmstaW4tcHJvZ3Jlc3MgcXVldWUsIGJ5IGNsb25pbmcgdGhlIGN1cnJlbnQgcXVldWUuXG4gICAgdmFyIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgIHF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSB7XG4gICAgICBiYXNlU3RhdGU6IGN1cnJlbnRRdWV1ZS5iYXNlU3RhdGUsXG4gICAgICBleHBpcmF0aW9uVGltZTogY3VycmVudFF1ZXVlLmV4cGlyYXRpb25UaW1lLFxuICAgICAgZmlyc3Q6IGN1cnJlbnRRdWV1ZS5maXJzdCxcbiAgICAgIGxhc3Q6IGN1cnJlbnRRdWV1ZS5sYXN0LFxuICAgICAgaXNJbml0aWFsaXplZDogY3VycmVudFF1ZXVlLmlzSW5pdGlhbGl6ZWQsXG4gICAgICAvLyBUaGVzZSBmaWVsZHMgYXJlIG5vIGxvbmdlciB2YWxpZCBiZWNhdXNlIHRoZXkgd2VyZSBhbHJlYWR5IGNvbW1pdHRlZC5cbiAgICAgIC8vIFJlc2V0IHRoZW0uXG4gICAgICBjYWxsYmFja0xpc3Q6IG51bGwsXG4gICAgICBoYXNGb3JjZVVwZGF0ZTogZmFsc2VcbiAgICB9O1xuICB9XG5cbiAge1xuICAgIC8vIFNldCB0aGlzIGZsYWcgc28gd2UgY2FuIHdhcm4gaWYgc2V0U3RhdGUgaXMgY2FsbGVkIGluc2lkZSB0aGUgdXBkYXRlXG4gICAgLy8gZnVuY3Rpb24gb2YgYW5vdGhlciBzZXRTdGF0ZS5cbiAgICBxdWV1ZS5pc1Byb2Nlc3NpbmcgPSB0cnVlO1xuICB9XG5cbiAgLy8gUmVzZXQgdGhlIHJlbWFpbmluZyBleHBpcmF0aW9uIHRpbWUuIElmIHdlIHNraXAgb3ZlciBhbnkgdXBkYXRlcywgd2UnbGxcbiAgLy8gaW5jcmVhc2UgdGhpcyBhY2NvcmRpbmdseS5cbiAgcXVldWUuZXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG5cbiAgLy8gVE9ETzogV2UgZG9uJ3Qga25vdyB3aGF0IHRoZSBiYXNlIHN0YXRlIHdpbGwgYmUgdW50aWwgd2UgYmVnaW4gd29yay5cbiAgLy8gSXQgZGVwZW5kcyBvbiB3aGljaCBmaWJlciBpcyB0aGUgbmV4dCBjdXJyZW50LiBJbml0aWFsaXplIHdpdGggYW4gZW1wdHlcbiAgLy8gYmFzZSBzdGF0ZSwgdGhlbiBzZXQgdG8gdGhlIG1lbW9pemVkU3RhdGUgd2hlbiByZW5kZXJpbmcuIE5vdCBzdXBlclxuICAvLyBoYXBweSB3aXRoIHRoaXMgYXBwcm9hY2guXG4gIHZhciBzdGF0ZSA9IHZvaWQgMDtcbiAgaWYgKHF1ZXVlLmlzSW5pdGlhbGl6ZWQpIHtcbiAgICBzdGF0ZSA9IHF1ZXVlLmJhc2VTdGF0ZTtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZSA9IHF1ZXVlLmJhc2VTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgcXVldWUuaXNJbml0aWFsaXplZCA9IHRydWU7XG4gIH1cbiAgdmFyIGRvbnRNdXRhdGVQcmV2U3RhdGUgPSB0cnVlO1xuICB2YXIgdXBkYXRlID0gcXVldWUuZmlyc3Q7XG4gIHZhciBkaWRTa2lwID0gZmFsc2U7XG4gIHdoaWxlICh1cGRhdGUgIT09IG51bGwpIHtcbiAgICB2YXIgdXBkYXRlRXhwaXJhdGlvblRpbWUgPSB1cGRhdGUuZXhwaXJhdGlvblRpbWU7XG4gICAgaWYgKHVwZGF0ZUV4cGlyYXRpb25UaW1lID4gcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgIC8vIFRoaXMgdXBkYXRlIGRvZXMgbm90IGhhdmUgc3VmZmljaWVudCBwcmlvcml0eS4gU2tpcCBpdC5cbiAgICAgIHZhciByZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IHF1ZXVlLmV4cGlyYXRpb25UaW1lO1xuICAgICAgaWYgKHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgcmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPiB1cGRhdGVFeHBpcmF0aW9uVGltZSkge1xuICAgICAgICAvLyBVcGRhdGUgdGhlIHJlbWFpbmluZyBleHBpcmF0aW9uIHRpbWUuXG4gICAgICAgIHF1ZXVlLmV4cGlyYXRpb25UaW1lID0gdXBkYXRlRXhwaXJhdGlvblRpbWU7XG4gICAgICB9XG4gICAgICBpZiAoIWRpZFNraXApIHtcbiAgICAgICAgZGlkU2tpcCA9IHRydWU7XG4gICAgICAgIHF1ZXVlLmJhc2VTdGF0ZSA9IHN0YXRlO1xuICAgICAgfVxuICAgICAgLy8gQ29udGludWUgdG8gdGhlIG5leHQgdXBkYXRlLlxuICAgICAgdXBkYXRlID0gdXBkYXRlLm5leHQ7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIHVwZGF0ZSBkb2VzIGhhdmUgc3VmZmljaWVudCBwcmlvcml0eS5cblxuICAgIC8vIElmIG5vIHByZXZpb3VzIHVwZGF0ZXMgd2VyZSBza2lwcGVkLCBkcm9wIHRoaXMgdXBkYXRlIGZyb20gdGhlIHF1ZXVlIGJ5XG4gICAgLy8gYWR2YW5jaW5nIHRoZSBoZWFkIG9mIHRoZSBsaXN0LlxuICAgIGlmICghZGlkU2tpcCkge1xuICAgICAgcXVldWUuZmlyc3QgPSB1cGRhdGUubmV4dDtcbiAgICAgIGlmIChxdWV1ZS5maXJzdCA9PT0gbnVsbCkge1xuICAgICAgICBxdWV1ZS5sYXN0ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBQcm9jZXNzIHRoZSB1cGRhdGVcbiAgICB2YXIgX3BhcnRpYWxTdGF0ZSA9IHZvaWQgMDtcbiAgICBpZiAodXBkYXRlLmlzUmVwbGFjZSkge1xuICAgICAgc3RhdGUgPSBnZXRTdGF0ZUZyb21VcGRhdGUodXBkYXRlLCBpbnN0YW5jZSwgc3RhdGUsIHByb3BzKTtcbiAgICAgIGRvbnRNdXRhdGVQcmV2U3RhdGUgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBfcGFydGlhbFN0YXRlID0gZ2V0U3RhdGVGcm9tVXBkYXRlKHVwZGF0ZSwgaW5zdGFuY2UsIHN0YXRlLCBwcm9wcyk7XG4gICAgICBpZiAoX3BhcnRpYWxTdGF0ZSkge1xuICAgICAgICBpZiAoZG9udE11dGF0ZVByZXZTdGF0ZSkge1xuICAgICAgICAgIC8vICRGbG93Rml4TWU6IElkayBob3cgdG8gdHlwZSB0aGlzIHByb3Blcmx5LlxuICAgICAgICAgIHN0YXRlID0gX2Fzc2lnbih7fSwgc3RhdGUsIF9wYXJ0aWFsU3RhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRlID0gX2Fzc2lnbihzdGF0ZSwgX3BhcnRpYWxTdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZG9udE11dGF0ZVByZXZTdGF0ZSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodXBkYXRlLmlzRm9yY2VkKSB7XG4gICAgICBxdWV1ZS5oYXNGb3JjZVVwZGF0ZSA9IHRydWU7XG4gICAgfVxuICAgIGlmICh1cGRhdGUuY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgIC8vIEFwcGVuZCB0byBsaXN0IG9mIGNhbGxiYWNrcy5cbiAgICAgIHZhciBfY2FsbGJhY2tMaXN0ID0gcXVldWUuY2FsbGJhY2tMaXN0O1xuICAgICAgaWYgKF9jYWxsYmFja0xpc3QgPT09IG51bGwpIHtcbiAgICAgICAgX2NhbGxiYWNrTGlzdCA9IHF1ZXVlLmNhbGxiYWNrTGlzdCA9IFtdO1xuICAgICAgfVxuICAgICAgX2NhbGxiYWNrTGlzdC5wdXNoKHVwZGF0ZSk7XG4gICAgfVxuICAgIHVwZGF0ZSA9IHVwZGF0ZS5uZXh0O1xuICB9XG5cbiAgaWYgKHF1ZXVlLmNhbGxiYWNrTGlzdCAhPT0gbnVsbCkge1xuICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBDYWxsYmFjaztcbiAgfSBlbHNlIGlmIChxdWV1ZS5maXJzdCA9PT0gbnVsbCAmJiAhcXVldWUuaGFzRm9yY2VVcGRhdGUpIHtcbiAgICAvLyBUaGUgcXVldWUgaXMgZW1wdHkuIFdlIGNhbiByZXNldCBpdC5cbiAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IG51bGw7XG4gIH1cblxuICBpZiAoIWRpZFNraXApIHtcbiAgICBkaWRTa2lwID0gdHJ1ZTtcbiAgICBxdWV1ZS5iYXNlU3RhdGUgPSBzdGF0ZTtcbiAgfVxuXG4gIHtcbiAgICAvLyBObyBsb25nZXIgcHJvY2Vzc2luZy5cbiAgICBxdWV1ZS5pc1Byb2Nlc3NpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZTtcbn1cblxuZnVuY3Rpb24gY29tbWl0Q2FsbGJhY2tzKHF1ZXVlLCBjb250ZXh0KSB7XG4gIHZhciBjYWxsYmFja0xpc3QgPSBxdWV1ZS5jYWxsYmFja0xpc3Q7XG4gIGlmIChjYWxsYmFja0xpc3QgPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gU2V0IHRoZSBsaXN0IHRvIG51bGwgdG8gbWFrZSBzdXJlIHRoZXkgZG9uJ3QgZ2V0IGNhbGxlZCBtb3JlIHRoYW4gb25jZS5cbiAgcXVldWUuY2FsbGJhY2tMaXN0ID0gbnVsbDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja0xpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdXBkYXRlID0gY2FsbGJhY2tMaXN0W2ldO1xuICAgIHZhciBfY2FsbGJhY2sgPSB1cGRhdGUuY2FsbGJhY2s7XG4gICAgLy8gVGhpcyB1cGRhdGUgbWlnaHQgYmUgcHJvY2Vzc2VkIGFnYWluLiBDbGVhciB0aGUgY2FsbGJhY2sgc28gaXQncyBvbmx5XG4gICAgLy8gY2FsbGVkIG9uY2UuXG4gICAgdXBkYXRlLmNhbGxiYWNrID0gbnVsbDtcbiAgICAhKHR5cGVvZiBfY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpID8gaW52YXJpYW50KGZhbHNlLCAnSW52YWxpZCBhcmd1bWVudCBwYXNzZWQgYXMgY2FsbGJhY2suIEV4cGVjdGVkIGEgZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzJywgX2NhbGxiYWNrKSA6IHZvaWQgMDtcbiAgICBfY2FsbGJhY2suY2FsbChjb250ZXh0KTtcbiAgfVxufVxuXG52YXIgZmFrZUludGVybmFsSW5zdGFuY2UgPSB7fTtcbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxue1xuICB2YXIgZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50ID0ge307XG5cbiAgdmFyIHdhcm5PbkludmFsaWRDYWxsYmFjayA9IGZ1bmN0aW9uIChjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5pbmcoY2FsbGJhY2sgPT09IG51bGwgfHwgdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nLCAnJXMoLi4uKTogRXhwZWN0ZWQgdGhlIGxhc3Qgb3B0aW9uYWwgYGNhbGxiYWNrYCBhcmd1bWVudCB0byBiZSBhICcgKyAnZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLicsIGNhbGxlck5hbWUsIGNhbGxiYWNrKTtcbiAgfTtcblxuICAvLyBUaGlzIGlzIHNvIGdyb3NzIGJ1dCBpdCdzIGF0IGxlYXN0IG5vbi1jcml0aWNhbCBhbmQgY2FuIGJlIHJlbW92ZWQgaWZcbiAgLy8gaXQgY2F1c2VzIHByb2JsZW1zLiBUaGlzIGlzIG1lYW50IHRvIGdpdmUgYSBuaWNlciBlcnJvciBtZXNzYWdlIGZvclxuICAvLyBSZWFjdERPTTE1LnVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKHJlYWN0RE9NMTZDb21wb25lbnQsXG4gIC8vIC4uLikpIHdoaWNoIG90aGVyd2lzZSB0aHJvd3MgYSBcIl9wcm9jZXNzQ2hpbGRDb250ZXh0IGlzIG5vdCBhIGZ1bmN0aW9uXCJcbiAgLy8gZXhjZXB0aW9uLlxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZmFrZUludGVybmFsSW5zdGFuY2UsICdfcHJvY2Vzc0NoaWxkQ29udGV4dCcsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnX3Byb2Nlc3NDaGlsZENvbnRleHQgaXMgbm90IGF2YWlsYWJsZSBpbiBSZWFjdCAxNisuIFRoaXMgbGlrZWx5IG1lYW5zIHlvdSBoYXZlIG11bHRpcGxlIGNvcGllcyBvZiBSZWFjdCBhbmQgYXJlIGF0dGVtcHRpbmcgdG8gbmVzdCBhIFJlYWN0IDE1IHRyZWUgaW5zaWRlIGEgUmVhY3QgMTYgdHJlZSB1c2luZyB1bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lciwgd2hpY2ggaXNuXFwndCBzdXBwb3J0ZWQuIFRyeSB0byBtYWtlIHN1cmUgeW91IGhhdmUgb25seSBvbmUgY29weSBvZiBSZWFjdCAoYW5kIGlkZWFsbHksIHN3aXRjaCB0byBSZWFjdERPTS5jcmVhdGVQb3J0YWwpLicpO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5mcmVlemUoZmFrZUludGVybmFsSW5zdGFuY2UpO1xufVxuXG52YXIgUmVhY3RGaWJlckNsYXNzQ29tcG9uZW50ID0gZnVuY3Rpb24gKHNjaGVkdWxlV29yaywgY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlciwgbWVtb2l6ZVByb3BzLCBtZW1vaXplU3RhdGUpIHtcbiAgLy8gQ2xhc3MgY29tcG9uZW50IHN0YXRlIHVwZGF0ZXJcbiAgdmFyIHVwZGF0ZXIgPSB7XG4gICAgaXNNb3VudGVkOiBpc01vdW50ZWQsXG4gICAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAoaW5zdGFuY2UsIHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBmaWJlciA9IGdldChpbnN0YW5jZSk7XG4gICAgICBjYWxsYmFjayA9IGNhbGxiYWNrID09PSB1bmRlZmluZWQgPyBudWxsIDogY2FsbGJhY2s7XG4gICAgICB7XG4gICAgICAgIHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjaywgJ3NldFN0YXRlJyk7XG4gICAgICB9XG4gICAgICB2YXIgZXhwaXJhdGlvblRpbWUgPSBjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyKGZpYmVyKTtcbiAgICAgIHZhciB1cGRhdGUgPSB7XG4gICAgICAgIGV4cGlyYXRpb25UaW1lOiBleHBpcmF0aW9uVGltZSxcbiAgICAgICAgcGFydGlhbFN0YXRlOiBwYXJ0aWFsU3RhdGUsXG4gICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgICAgaXNSZXBsYWNlOiBmYWxzZSxcbiAgICAgICAgaXNGb3JjZWQ6IGZhbHNlLFxuICAgICAgICBuZXh0Q2FsbGJhY2s6IG51bGwsXG4gICAgICAgIG5leHQ6IG51bGxcbiAgICAgIH07XG4gICAgICBpbnNlcnRVcGRhdGVJbnRvRmliZXIoZmliZXIsIHVwZGF0ZSk7XG4gICAgICBzY2hlZHVsZVdvcmsoZmliZXIsIGV4cGlyYXRpb25UaW1lKTtcbiAgICB9LFxuICAgIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChpbnN0YW5jZSwgc3RhdGUsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgZmliZXIgPSBnZXQoaW5zdGFuY2UpO1xuICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNhbGxiYWNrO1xuICAgICAge1xuICAgICAgICB3YXJuT25JbnZhbGlkQ2FsbGJhY2soY2FsbGJhY2ssICdyZXBsYWNlU3RhdGUnKTtcbiAgICAgIH1cbiAgICAgIHZhciBleHBpcmF0aW9uVGltZSA9IGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIoZmliZXIpO1xuICAgICAgdmFyIHVwZGF0ZSA9IHtcbiAgICAgICAgZXhwaXJhdGlvblRpbWU6IGV4cGlyYXRpb25UaW1lLFxuICAgICAgICBwYXJ0aWFsU3RhdGU6IHN0YXRlLFxuICAgICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICAgIGlzUmVwbGFjZTogdHJ1ZSxcbiAgICAgICAgaXNGb3JjZWQ6IGZhbHNlLFxuICAgICAgICBuZXh0Q2FsbGJhY2s6IG51bGwsXG4gICAgICAgIG5leHQ6IG51bGxcbiAgICAgIH07XG4gICAgICBpbnNlcnRVcGRhdGVJbnRvRmliZXIoZmliZXIsIHVwZGF0ZSk7XG4gICAgICBzY2hlZHVsZVdvcmsoZmliZXIsIGV4cGlyYXRpb25UaW1lKTtcbiAgICB9LFxuICAgIGVucXVldWVGb3JjZVVwZGF0ZTogZnVuY3Rpb24gKGluc3RhbmNlLCBjYWxsYmFjaykge1xuICAgICAgdmFyIGZpYmVyID0gZ2V0KGluc3RhbmNlKTtcbiAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjYWxsYmFjaztcbiAgICAgIHtcbiAgICAgICAgd2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrLCAnZm9yY2VVcGRhdGUnKTtcbiAgICAgIH1cbiAgICAgIHZhciBleHBpcmF0aW9uVGltZSA9IGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIoZmliZXIpO1xuICAgICAgdmFyIHVwZGF0ZSA9IHtcbiAgICAgICAgZXhwaXJhdGlvblRpbWU6IGV4cGlyYXRpb25UaW1lLFxuICAgICAgICBwYXJ0aWFsU3RhdGU6IG51bGwsXG4gICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgICAgaXNSZXBsYWNlOiBmYWxzZSxcbiAgICAgICAgaXNGb3JjZWQ6IHRydWUsXG4gICAgICAgIG5leHRDYWxsYmFjazogbnVsbCxcbiAgICAgICAgbmV4dDogbnVsbFxuICAgICAgfTtcbiAgICAgIGluc2VydFVwZGF0ZUludG9GaWJlcihmaWJlciwgdXBkYXRlKTtcbiAgICAgIHNjaGVkdWxlV29yayhmaWJlciwgZXhwaXJhdGlvblRpbWUpO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBjaGVja1Nob3VsZENvbXBvbmVudFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgb2xkUHJvcHMsIG5ld1Byb3BzLCBvbGRTdGF0ZSwgbmV3U3RhdGUsIG5ld0NvbnRleHQpIHtcbiAgICBpZiAob2xkUHJvcHMgPT09IG51bGwgfHwgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgIT09IG51bGwgJiYgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUuaGFzRm9yY2VVcGRhdGUpIHtcbiAgICAgIC8vIElmIHRoZSB3b3JrSW5Qcm9ncmVzcyBhbHJlYWR5IGhhcyBhbiBVcGRhdGUgZWZmZWN0LCByZXR1cm4gdHJ1ZVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgc3RhcnRQaGFzZVRpbWVyKHdvcmtJblByb2dyZXNzLCAnc2hvdWxkQ29tcG9uZW50VXBkYXRlJyk7XG4gICAgICB2YXIgc2hvdWxkVXBkYXRlID0gaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5ld1Byb3BzLCBuZXdTdGF0ZSwgbmV3Q29udGV4dCk7XG4gICAgICBzdG9wUGhhc2VUaW1lcigpO1xuXG4gICAgICAvLyBTaW11bGF0ZSBhbiBhc3luYyBiYWlsb3V0L2ludGVycnVwdGlvbiBieSBpbnZva2luZyBsaWZlY3ljbGUgdHdpY2UuXG4gICAgICBpZiAoZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzKSB7XG4gICAgICAgIGluc3RhbmNlLnNob3VsZENvbXBvbmVudFVwZGF0ZShuZXdQcm9wcywgbmV3U3RhdGUsIG5ld0NvbnRleHQpO1xuICAgICAgfVxuXG4gICAgICB7XG4gICAgICAgIHdhcm5pbmcoc2hvdWxkVXBkYXRlICE9PSB1bmRlZmluZWQsICclcy5zaG91bGRDb21wb25lbnRVcGRhdGUoKTogUmV0dXJuZWQgdW5kZWZpbmVkIGluc3RlYWQgb2YgYSAnICsgJ2Jvb2xlYW4gdmFsdWUuIE1ha2Ugc3VyZSB0byByZXR1cm4gdHJ1ZSBvciBmYWxzZS4nLCBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzKSB8fCAnVW5rbm93bicpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2hvdWxkVXBkYXRlO1xuICAgIH1cblxuICAgIGlmICh0eXBlLnByb3RvdHlwZSAmJiB0eXBlLnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCkge1xuICAgICAgcmV0dXJuICFzaGFsbG93RXF1YWwob2xkUHJvcHMsIG5ld1Byb3BzKSB8fCAhc2hhbGxvd0VxdWFsKG9sZFN0YXRlLCBuZXdTdGF0ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0NsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgdmFyIHR5cGUgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB2YXIgcmVuZGVyUHJlc2VudCA9IGluc3RhbmNlLnJlbmRlcjtcblxuICAgICAgaWYgKCFyZW5kZXJQcmVzZW50KSB7XG4gICAgICAgIGlmICh0eXBlLnByb3RvdHlwZSAmJiB0eXBlb2YgdHlwZS5wcm90b3R5cGUucmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgd2FybmluZyhmYWxzZSwgJyVzKC4uLik6IE5vIGByZW5kZXJgIG1ldGhvZCBmb3VuZCBvbiB0aGUgcmV0dXJuZWQgY29tcG9uZW50ICcgKyAnaW5zdGFuY2U6IGRpZCB5b3UgYWNjaWRlbnRhbGx5IHJldHVybiBhbiBvYmplY3QgZnJvbSB0aGUgY29uc3RydWN0b3I/JywgbmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2FybmluZyhmYWxzZSwgJyVzKC4uLik6IE5vIGByZW5kZXJgIG1ldGhvZCBmb3VuZCBvbiB0aGUgcmV0dXJuZWQgY29tcG9uZW50ICcgKyAnaW5zdGFuY2U6IHlvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gZGVmaW5lIGByZW5kZXJgLicsIG5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBub0dldEluaXRpYWxTdGF0ZU9uRVM2ID0gIWluc3RhbmNlLmdldEluaXRpYWxTdGF0ZSB8fCBpbnN0YW5jZS5nZXRJbml0aWFsU3RhdGUuaXNSZWFjdENsYXNzQXBwcm92ZWQgfHwgaW5zdGFuY2Uuc3RhdGU7XG4gICAgICB3YXJuaW5nKG5vR2V0SW5pdGlhbFN0YXRlT25FUzYsICdnZXRJbml0aWFsU3RhdGUgd2FzIGRlZmluZWQgb24gJXMsIGEgcGxhaW4gSmF2YVNjcmlwdCBjbGFzcy4gJyArICdUaGlzIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBjbGFzc2VzIGNyZWF0ZWQgdXNpbmcgUmVhY3QuY3JlYXRlQ2xhc3MuICcgKyAnRGlkIHlvdSBtZWFuIHRvIGRlZmluZSBhIHN0YXRlIHByb3BlcnR5IGluc3RlYWQ/JywgbmFtZSk7XG4gICAgICB2YXIgbm9HZXREZWZhdWx0UHJvcHNPbkVTNiA9ICFpbnN0YW5jZS5nZXREZWZhdWx0UHJvcHMgfHwgaW5zdGFuY2UuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkO1xuICAgICAgd2FybmluZyhub0dldERlZmF1bHRQcm9wc09uRVM2LCAnZ2V0RGVmYXVsdFByb3BzIHdhcyBkZWZpbmVkIG9uICVzLCBhIHBsYWluIEphdmFTY3JpcHQgY2xhc3MuICcgKyAnVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgY2xhc3NlcyBjcmVhdGVkIHVzaW5nIFJlYWN0LmNyZWF0ZUNsYXNzLiAnICsgJ1VzZSBhIHN0YXRpYyBwcm9wZXJ0eSB0byBkZWZpbmUgZGVmYXVsdFByb3BzIGluc3RlYWQuJywgbmFtZSk7XG4gICAgICB2YXIgbm9JbnN0YW5jZVByb3BUeXBlcyA9ICFpbnN0YW5jZS5wcm9wVHlwZXM7XG4gICAgICB3YXJuaW5nKG5vSW5zdGFuY2VQcm9wVHlwZXMsICdwcm9wVHlwZXMgd2FzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMuIFVzZSBhIHN0YXRpYyAnICsgJ3Byb3BlcnR5IHRvIGRlZmluZSBwcm9wVHlwZXMgaW5zdGVhZC4nLCBuYW1lKTtcbiAgICAgIHZhciBub0luc3RhbmNlQ29udGV4dFR5cGVzID0gIWluc3RhbmNlLmNvbnRleHRUeXBlcztcbiAgICAgIHdhcm5pbmcobm9JbnN0YW5jZUNvbnRleHRUeXBlcywgJ2NvbnRleHRUeXBlcyB3YXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcy4gVXNlIGEgc3RhdGljICcgKyAncHJvcGVydHkgdG8gZGVmaW5lIGNvbnRleHRUeXBlcyBpbnN0ZWFkLicsIG5hbWUpO1xuICAgICAgdmFyIG5vQ29tcG9uZW50U2hvdWxkVXBkYXRlID0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFNob3VsZFVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJztcbiAgICAgIHdhcm5pbmcobm9Db21wb25lbnRTaG91bGRVcGRhdGUsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50U2hvdWxkVXBkYXRlKCkuIERpZCB5b3UgbWVhbiBzaG91bGRDb21wb25lbnRVcGRhdGUoKT8gJyArICdUaGUgbmFtZSBpcyBwaHJhc2VkIGFzIGEgcXVlc3Rpb24gYmVjYXVzZSB0aGUgZnVuY3Rpb24gaXMgJyArICdleHBlY3RlZCB0byByZXR1cm4gYSB2YWx1ZS4nLCBuYW1lKTtcbiAgICAgIGlmICh0eXBlLnByb3RvdHlwZSAmJiB0eXBlLnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCAmJiB0eXBlb2YgaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCBzaG91bGRDb21wb25lbnRVcGRhdGUoKS4gJyArICdzaG91bGRDb21wb25lbnRVcGRhdGUgc2hvdWxkIG5vdCBiZSB1c2VkIHdoZW4gZXh0ZW5kaW5nIFJlYWN0LlB1cmVDb21wb25lbnQuICcgKyAnUGxlYXNlIGV4dGVuZCBSZWFjdC5Db21wb25lbnQgaWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIGlzIHVzZWQuJywgZ2V0Q29tcG9uZW50TmFtZSh3b3JrSW5Qcm9ncmVzcykgfHwgJ0EgcHVyZSBjb21wb25lbnQnKTtcbiAgICAgIH1cbiAgICAgIHZhciBub0NvbXBvbmVudERpZFVubW91bnQgPSB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVW5tb3VudCAhPT0gJ2Z1bmN0aW9uJztcbiAgICAgIHdhcm5pbmcobm9Db21wb25lbnREaWRVbm1vdW50LCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudERpZFVubW91bnQoKS4gQnV0IHRoZXJlIGlzIG5vIHN1Y2ggbGlmZWN5Y2xlIG1ldGhvZC4gJyArICdEaWQgeW91IG1lYW4gY29tcG9uZW50V2lsbFVubW91bnQoKT8nLCBuYW1lKTtcbiAgICAgIHZhciBub0NvbXBvbmVudERpZFJlY2VpdmVQcm9wcyA9IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRSZWNlaXZlUHJvcHMgIT09ICdmdW5jdGlvbic7XG4gICAgICB3YXJuaW5nKG5vQ29tcG9uZW50RGlkUmVjZWl2ZVByb3BzLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudERpZFJlY2VpdmVQcm9wcygpLiBCdXQgdGhlcmUgaXMgbm8gc3VjaCBsaWZlY3ljbGUgbWV0aG9kLiAnICsgJ0lmIHlvdSBtZWFudCB0byB1cGRhdGUgdGhlIHN0YXRlIGluIHJlc3BvbnNlIHRvIGNoYW5naW5nIHByb3BzLCAnICsgJ3VzZSBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCkuIElmIHlvdSBtZWFudCB0byBmZXRjaCBkYXRhIG9yICcgKyAncnVuIHNpZGUtZWZmZWN0cyBvciBtdXRhdGlvbnMgYWZ0ZXIgUmVhY3QgaGFzIHVwZGF0ZWQgdGhlIFVJLCB1c2UgY29tcG9uZW50RGlkVXBkYXRlKCkuJywgbmFtZSk7XG4gICAgICB2YXIgbm9Db21wb25lbnRXaWxsUmVjaWV2ZVByb3BzID0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMgIT09ICdmdW5jdGlvbic7XG4gICAgICB3YXJuaW5nKG5vQ29tcG9uZW50V2lsbFJlY2lldmVQcm9wcywgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzKCkuIERpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk/JywgbmFtZSk7XG4gICAgICB2YXIgaGFzTXV0YXRlZFByb3BzID0gaW5zdGFuY2UucHJvcHMgIT09IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICAgIHdhcm5pbmcoaW5zdGFuY2UucHJvcHMgPT09IHVuZGVmaW5lZCB8fCAhaGFzTXV0YXRlZFByb3BzLCAnJXMoLi4uKTogV2hlbiBjYWxsaW5nIHN1cGVyKCkgaW4gYCVzYCwgbWFrZSBzdXJlIHRvIHBhc3MgJyArIFwidXAgdGhlIHNhbWUgcHJvcHMgdGhhdCB5b3VyIGNvbXBvbmVudCdzIGNvbnN0cnVjdG9yIHdhcyBwYXNzZWQuXCIsIG5hbWUsIG5hbWUpO1xuICAgICAgdmFyIG5vSW5zdGFuY2VEZWZhdWx0UHJvcHMgPSAhaW5zdGFuY2UuZGVmYXVsdFByb3BzO1xuICAgICAgd2FybmluZyhub0luc3RhbmNlRGVmYXVsdFByb3BzLCAnU2V0dGluZyBkZWZhdWx0UHJvcHMgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMgaXMgbm90IHN1cHBvcnRlZCBhbmQgd2lsbCBiZSBpZ25vcmVkLicgKyAnIEluc3RlYWQsIGRlZmluZSBkZWZhdWx0UHJvcHMgYXMgYSBzdGF0aWMgcHJvcGVydHkgb24gJXMuJywgbmFtZSwgbmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIHN0YXRlID0gaW5zdGFuY2Uuc3RhdGU7XG4gICAgaWYgKHN0YXRlICYmICh0eXBlb2Ygc3RhdGUgIT09ICdvYmplY3QnIHx8IGlzQXJyYXkoc3RhdGUpKSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJyVzLnN0YXRlOiBtdXN0IGJlIHNldCB0byBhbiBvYmplY3Qgb3IgbnVsbCcsIGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MpKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdhcm5pbmcodHlwZW9mIHdvcmtJblByb2dyZXNzLnR5cGUuY2hpbGRDb250ZXh0VHlwZXMgPT09ICdvYmplY3QnLCAnJXMuZ2V0Q2hpbGRDb250ZXh0KCk6IGNoaWxkQ29udGV4dFR5cGVzIG11c3QgYmUgZGVmaW5lZCBpbiBvcmRlciB0byAnICsgJ3VzZSBnZXRDaGlsZENvbnRleHQoKS4nLCBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzKSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRJbnB1dFBvaW50ZXJzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSkge1xuICAgIGluc3RhbmNlLnByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgICBpbnN0YW5jZS5zdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIH1cblxuICBmdW5jdGlvbiBhZG9wdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKSB7XG4gICAgaW5zdGFuY2UudXBkYXRlciA9IHVwZGF0ZXI7XG4gICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gaW5zdGFuY2U7XG4gICAgLy8gVGhlIGluc3RhbmNlIG5lZWRzIGFjY2VzcyB0byB0aGUgZmliZXIgc28gdGhhdCBpdCBjYW4gc2NoZWR1bGUgdXBkYXRlc1xuICAgIHNldChpbnN0YW5jZSwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIHtcbiAgICAgIGluc3RhbmNlLl9yZWFjdEludGVybmFsSW5zdGFuY2UgPSBmYWtlSW50ZXJuYWxJbnN0YW5jZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb25zdHJ1Y3RDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBwcm9wcykge1xuICAgIHZhciBjdG9yID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICB2YXIgdW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICB2YXIgbmVlZHNDb250ZXh0ID0gaXNDb250ZXh0Q29uc3VtZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgIHZhciBjb250ZXh0ID0gbmVlZHNDb250ZXh0ID8gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KSA6IGVtcHR5T2JqZWN0O1xuICAgIHZhciBpbnN0YW5jZSA9IG5ldyBjdG9yKHByb3BzLCBjb250ZXh0KTtcbiAgICBhZG9wdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTtcblxuICAgIC8vIENhY2hlIHVubWFza2VkIGNvbnRleHQgc28gd2UgY2FuIGF2b2lkIHJlY3JlYXRpbmcgbWFza2VkIGNvbnRleHQgdW5sZXNzIG5lY2Vzc2FyeS5cbiAgICAvLyBSZWFjdEZpYmVyQ29udGV4dCB1c3VhbGx5IHVwZGF0ZXMgdGhpcyBjYWNoZSBidXQgY2FuJ3QgZm9yIG5ld2x5LWNyZWF0ZWQgaW5zdGFuY2VzLlxuICAgIGlmIChuZWVkc0NvbnRleHQpIHtcbiAgICAgIGNhY2hlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0LCBjb250ZXh0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH1cblxuICBmdW5jdGlvbiBjYWxsQ29tcG9uZW50V2lsbE1vdW50KHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSkge1xuICAgIHN0YXJ0UGhhc2VUaW1lcih3b3JrSW5Qcm9ncmVzcywgJ2NvbXBvbmVudFdpbGxNb3VudCcpO1xuICAgIHZhciBvbGRTdGF0ZSA9IGluc3RhbmNlLnN0YXRlO1xuICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCgpO1xuICAgIHN0b3BQaGFzZVRpbWVyKCk7XG5cbiAgICAvLyBTaW11bGF0ZSBhbiBhc3luYyBiYWlsb3V0L2ludGVycnVwdGlvbiBieSBpbnZva2luZyBsaWZlY3ljbGUgdHdpY2UuXG4gICAgaWYgKGRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0cykge1xuICAgICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50KCk7XG4gICAgfVxuXG4gICAgaWYgKG9sZFN0YXRlICE9PSBpbnN0YW5jZS5zdGF0ZSkge1xuICAgICAge1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnJXMuY29tcG9uZW50V2lsbE1vdW50KCk6IEFzc2lnbmluZyBkaXJlY3RseSB0byB0aGlzLnN0YXRlIGlzICcgKyBcImRlcHJlY2F0ZWQgKGV4Y2VwdCBpbnNpZGUgYSBjb21wb25lbnQncyBcIiArICdjb25zdHJ1Y3RvcikuIFVzZSBzZXRTdGF0ZSBpbnN0ZWFkLicsIGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MpKTtcbiAgICAgIH1cbiAgICAgIHVwZGF0ZXIuZW5xdWV1ZVJlcGxhY2VTdGF0ZShpbnN0YW5jZSwgaW5zdGFuY2Uuc3RhdGUsIG51bGwpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbGxDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSwgbmV3UHJvcHMsIG5ld0NvbnRleHQpIHtcbiAgICBzdGFydFBoYXNlVGltZXIod29ya0luUHJvZ3Jlc3MsICdjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJyk7XG4gICAgdmFyIG9sZFN0YXRlID0gaW5zdGFuY2Uuc3RhdGU7XG4gICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXdQcm9wcywgbmV3Q29udGV4dCk7XG4gICAgc3RvcFBoYXNlVGltZXIoKTtcblxuICAgIC8vIFNpbXVsYXRlIGFuIGFzeW5jIGJhaWxvdXQvaW50ZXJydXB0aW9uIGJ5IGludm9raW5nIGxpZmVjeWNsZSB0d2ljZS5cbiAgICBpZiAoZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzKSB7XG4gICAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5ld1Byb3BzLCBuZXdDb250ZXh0KTtcbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2Uuc3RhdGUgIT09IG9sZFN0YXRlKSB7XG4gICAgICB7XG4gICAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh3b3JrSW5Qcm9ncmVzcykgfHwgJ0NvbXBvbmVudCc7XG4gICAgICAgIGlmICghZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50W2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgICAgd2FybmluZyhmYWxzZSwgJyVzLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKTogQXNzaWduaW5nIGRpcmVjdGx5IHRvICcgKyBcInRoaXMuc3RhdGUgaXMgZGVwcmVjYXRlZCAoZXhjZXB0IGluc2lkZSBhIGNvbXBvbmVudCdzIFwiICsgJ2NvbnN0cnVjdG9yKS4gVXNlIHNldFN0YXRlIGluc3RlYWQuJywgY29tcG9uZW50TmFtZSk7XG4gICAgICAgICAgZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50W2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdXBkYXRlci5lbnF1ZXVlUmVwbGFjZVN0YXRlKGluc3RhbmNlLCBpbnN0YW5jZS5zdGF0ZSwgbnVsbCk7XG4gICAgfVxuICB9XG5cbiAgLy8gSW52b2tlcyB0aGUgbW91bnQgbGlmZS1jeWNsZXMgb24gYSBwcmV2aW91c2x5IG5ldmVyIHJlbmRlcmVkIGluc3RhbmNlLlxuICBmdW5jdGlvbiBtb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgdmFyIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGU7XG5cbiAgICB7XG4gICAgICBjaGVja0NsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICB2YXIgc3RhdGUgPSBpbnN0YW5jZS5zdGF0ZSB8fCBudWxsO1xuXG4gICAgdmFyIHByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgICFwcm9wcyA/IGludmFyaWFudChmYWxzZSwgJ1RoZXJlIG11c3QgYmUgcGVuZGluZyBwcm9wcyBmb3IgYW4gaW5pdGlhbCBtb3VudC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcblxuICAgIHZhciB1bm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgaW5zdGFuY2UucHJvcHMgPSBwcm9wcztcbiAgICBpbnN0YW5jZS5zdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBzdGF0ZTtcbiAgICBpbnN0YW5jZS5yZWZzID0gZW1wdHlPYmplY3Q7XG4gICAgaW5zdGFuY2UuY29udGV4dCA9IGdldE1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHVubWFza2VkQ29udGV4dCk7XG5cbiAgICBpZiAoZW5hYmxlQXN5bmNTdWJ0cmVlQVBJICYmIHdvcmtJblByb2dyZXNzLnR5cGUgIT0gbnVsbCAmJiB3b3JrSW5Qcm9ncmVzcy50eXBlLnByb3RvdHlwZSAhPSBudWxsICYmIHdvcmtJblByb2dyZXNzLnR5cGUucHJvdG90eXBlLnVuc3RhYmxlX2lzQXN5bmNSZWFjdENvbXBvbmVudCA9PT0gdHJ1ZSkge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuaW50ZXJuYWxDb250ZXh0VGFnIHw9IEFzeW5jVXBkYXRlcztcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbENvbXBvbmVudFdpbGxNb3VudCh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UpO1xuICAgICAgLy8gSWYgd2UgaGFkIGFkZGl0aW9uYWwgc3RhdGUgdXBkYXRlcyBkdXJpbmcgdGhpcyBsaWZlLWN5Y2xlLCBsZXQnc1xuICAgICAgLy8gcHJvY2VzcyB0aGVtIG5vdy5cbiAgICAgIHZhciB1cGRhdGVRdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICAgICAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgIGluc3RhbmNlLnN0YXRlID0gcHJvY2Vzc1VwZGF0ZVF1ZXVlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB1cGRhdGVRdWV1ZSwgaW5zdGFuY2UsIHByb3BzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGU7XG4gICAgfVxuICB9XG5cbiAgLy8gQ2FsbGVkIG9uIGEgcHJlZXhpc3RpbmcgY2xhc3MgaW5zdGFuY2UuIFJldHVybnMgZmFsc2UgaWYgYSByZXN1bWVkIHJlbmRlclxuICAvLyBjb3VsZCBiZSByZXVzZWQuXG4gIC8vIGZ1bmN0aW9uIHJlc3VtZU1vdW50Q2xhc3NJbnN0YW5jZShcbiAgLy8gICB3b3JrSW5Qcm9ncmVzczogRmliZXIsXG4gIC8vICAgcHJpb3JpdHlMZXZlbDogUHJpb3JpdHlMZXZlbCxcbiAgLy8gKTogYm9vbGVhbiB7XG4gIC8vICAgY29uc3QgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gIC8vICAgcmVzZXRJbnB1dFBvaW50ZXJzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSk7XG5cbiAgLy8gICBsZXQgbmV3U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAvLyAgIGxldCBuZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgLy8gICBpZiAoIW5ld1Byb3BzKSB7XG4gIC8vICAgICAvLyBJZiB0aGVyZSBpc24ndCBhbnkgbmV3IHByb3BzLCB0aGVuIHdlJ2xsIHJldXNlIHRoZSBtZW1vaXplZCBwcm9wcy5cbiAgLy8gICAgIC8vIFRoaXMgY291bGQgYmUgZnJvbSBhbHJlYWR5IGNvbXBsZXRlZCB3b3JrLlxuICAvLyAgICAgbmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICAvLyAgICAgaW52YXJpYW50KFxuICAvLyAgICAgICBuZXdQcm9wcyAhPSBudWxsLFxuICAvLyAgICAgICAnVGhlcmUgc2hvdWxkIGFsd2F5cyBiZSBwZW5kaW5nIG9yIG1lbW9pemVkIHByb3BzLiBUaGlzIGVycm9yIGlzICcgK1xuICAvLyAgICAgICAgICdsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLFxuICAvLyAgICAgKTtcbiAgLy8gICB9XG4gIC8vICAgY29uc3QgbmV3VW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgLy8gICBjb25zdCBuZXdDb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgbmV3VW5tYXNrZWRDb250ZXh0KTtcblxuICAvLyAgIGNvbnN0IG9sZENvbnRleHQgPSBpbnN0YW5jZS5jb250ZXh0O1xuICAvLyAgIGNvbnN0IG9sZFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcblxuICAvLyAgIGlmIChcbiAgLy8gICAgIHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nICYmXG4gIC8vICAgICAob2xkUHJvcHMgIT09IG5ld1Byb3BzIHx8IG9sZENvbnRleHQgIT09IG5ld0NvbnRleHQpXG4gIC8vICAgKSB7XG4gIC8vICAgICBjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhcbiAgLy8gICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gIC8vICAgICAgIGluc3RhbmNlLFxuICAvLyAgICAgICBuZXdQcm9wcyxcbiAgLy8gICAgICAgbmV3Q29udGV4dCxcbiAgLy8gICAgICk7XG4gIC8vICAgfVxuXG4gIC8vICAgLy8gUHJvY2VzcyB0aGUgdXBkYXRlIHF1ZXVlIGJlZm9yZSBjYWxsaW5nIHNob3VsZENvbXBvbmVudFVwZGF0ZVxuICAvLyAgIGNvbnN0IHVwZGF0ZVF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gIC8vICAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gIC8vICAgICBuZXdTdGF0ZSA9IHByb2Nlc3NVcGRhdGVRdWV1ZShcbiAgLy8gICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gIC8vICAgICAgIHVwZGF0ZVF1ZXVlLFxuICAvLyAgICAgICBpbnN0YW5jZSxcbiAgLy8gICAgICAgbmV3U3RhdGUsXG4gIC8vICAgICAgIG5ld1Byb3BzLFxuICAvLyAgICAgICBwcmlvcml0eUxldmVsLFxuICAvLyAgICAgKTtcbiAgLy8gICB9XG5cbiAgLy8gICAvLyBUT0RPOiBTaG91bGQgd2UgZGVhbCB3aXRoIGEgc2V0U3RhdGUgdGhhdCBoYXBwZW5lZCBhZnRlciB0aGUgbGFzdFxuICAvLyAgIC8vIGNvbXBvbmVudFdpbGxNb3VudCBhbmQgYmVmb3JlIHRoaXMgY29tcG9uZW50V2lsbE1vdW50PyBQcm9iYWJseVxuICAvLyAgIC8vIHVuc3VwcG9ydGVkIGFueXdheS5cblxuICAvLyAgIGlmIChcbiAgLy8gICAgICFjaGVja1Nob3VsZENvbXBvbmVudFVwZGF0ZShcbiAgLy8gICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gIC8vICAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMsXG4gIC8vICAgICAgIG5ld1Byb3BzLFxuICAvLyAgICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlLFxuICAvLyAgICAgICBuZXdTdGF0ZSxcbiAgLy8gICAgICAgbmV3Q29udGV4dCxcbiAgLy8gICAgIClcbiAgLy8gICApIHtcbiAgLy8gICAgIC8vIFVwZGF0ZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UncyBzdGF0ZSwgcHJvcHMsIGFuZCBjb250ZXh0IHBvaW50ZXJzIGV2ZW5cbiAgLy8gICAgIC8vIHRob3VnaCB3ZSdyZSBiYWlsaW5nIG91dC5cbiAgLy8gICAgIGluc3RhbmNlLnByb3BzID0gbmV3UHJvcHM7XG4gIC8vICAgICBpbnN0YW5jZS5zdGF0ZSA9IG5ld1N0YXRlO1xuICAvLyAgICAgaW5zdGFuY2UuY29udGV4dCA9IG5ld0NvbnRleHQ7XG4gIC8vICAgICByZXR1cm4gZmFsc2U7XG4gIC8vICAgfVxuXG4gIC8vICAgLy8gVXBkYXRlIHRoZSBpbnB1dCBwb2ludGVycyBub3cgc28gdGhhdCB0aGV5IGFyZSBjb3JyZWN0IHdoZW4gd2UgY2FsbFxuICAvLyAgIC8vIGNvbXBvbmVudFdpbGxNb3VudFxuICAvLyAgIGluc3RhbmNlLnByb3BzID0gbmV3UHJvcHM7XG4gIC8vICAgaW5zdGFuY2Uuc3RhdGUgPSBuZXdTdGF0ZTtcbiAgLy8gICBpbnN0YW5jZS5jb250ZXh0ID0gbmV3Q29udGV4dDtcblxuICAvLyAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vICAgICBjYWxsQ29tcG9uZW50V2lsbE1vdW50KHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSk7XG4gIC8vICAgICAvLyBjb21wb25lbnRXaWxsTW91bnQgbWF5IGhhdmUgY2FsbGVkIHNldFN0YXRlLiBQcm9jZXNzIHRoZSB1cGRhdGUgcXVldWUuXG4gIC8vICAgICBjb25zdCBuZXdVcGRhdGVRdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICAvLyAgICAgaWYgKG5ld1VwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gIC8vICAgICAgIG5ld1N0YXRlID0gcHJvY2Vzc1VwZGF0ZVF1ZXVlKFxuICAvLyAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAvLyAgICAgICAgIG5ld1VwZGF0ZVF1ZXVlLFxuICAvLyAgICAgICAgIGluc3RhbmNlLFxuICAvLyAgICAgICAgIG5ld1N0YXRlLFxuICAvLyAgICAgICAgIG5ld1Byb3BzLFxuICAvLyAgICAgICAgIHByaW9yaXR5TGV2ZWwsXG4gIC8vICAgICAgICk7XG4gIC8vICAgICB9XG4gIC8vICAgfVxuXG4gIC8vICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFVwZGF0ZTtcbiAgLy8gICB9XG5cbiAgLy8gICBpbnN0YW5jZS5zdGF0ZSA9IG5ld1N0YXRlO1xuXG4gIC8vICAgcmV0dXJuIHRydWU7XG4gIC8vIH1cblxuICAvLyBJbnZva2VzIHRoZSB1cGRhdGUgbGlmZS1jeWNsZXMgYW5kIHJldHVybnMgZmFsc2UgaWYgaXQgc2hvdWxkbid0IHJlcmVuZGVyLlxuICBmdW5jdGlvbiB1cGRhdGVDbGFzc0luc3RhbmNlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICByZXNldElucHV0UG9pbnRlcnMod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTtcblxuICAgIHZhciBvbGRQcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gICAgdmFyIG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgIGlmICghbmV3UHJvcHMpIHtcbiAgICAgIC8vIElmIHRoZXJlIGFyZW4ndCBhbnkgbmV3IHByb3BzLCB0aGVuIHdlJ2xsIHJldXNlIHRoZSBtZW1vaXplZCBwcm9wcy5cbiAgICAgIC8vIFRoaXMgY291bGQgYmUgZnJvbSBhbHJlYWR5IGNvbXBsZXRlZCB3b3JrLlxuICAgICAgbmV3UHJvcHMgPSBvbGRQcm9wcztcbiAgICAgICEobmV3UHJvcHMgIT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdUaGVyZSBzaG91bGQgYWx3YXlzIGJlIHBlbmRpbmcgb3IgbWVtb2l6ZWQgcHJvcHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgfVxuICAgIHZhciBvbGRDb250ZXh0ID0gaW5zdGFuY2UuY29udGV4dDtcbiAgICB2YXIgbmV3VW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICB2YXIgbmV3Q29udGV4dCA9IGdldE1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIG5ld1VubWFza2VkQ29udGV4dCk7XG5cbiAgICAvLyBOb3RlOiBEdXJpbmcgdGhlc2UgbGlmZS1jeWNsZXMsIGluc3RhbmNlLnByb3BzL2luc3RhbmNlLnN0YXRlIGFyZSB3aGF0XG4gICAgLy8gZXZlciB0aGUgcHJldmlvdXNseSBhdHRlbXB0ZWQgdG8gcmVuZGVyIC0gbm90IHRoZSBcImN1cnJlbnRcIi4gSG93ZXZlcixcbiAgICAvLyBkdXJpbmcgY29tcG9uZW50RGlkVXBkYXRlIHdlIHBhc3MgdGhlIFwiY3VycmVudFwiIHByb3BzLlxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nICYmIChvbGRQcm9wcyAhPT0gbmV3UHJvcHMgfHwgb2xkQ29udGV4dCAhPT0gbmV3Q29udGV4dCkpIHtcbiAgICAgIGNhbGxDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSwgbmV3UHJvcHMsIG5ld0NvbnRleHQpO1xuICAgIH1cblxuICAgIC8vIENvbXB1dGUgdGhlIG5leHQgc3RhdGUgdXNpbmcgdGhlIG1lbW9pemVkIHN0YXRlIGFuZCB0aGUgdXBkYXRlIHF1ZXVlLlxuICAgIHZhciBvbGRTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgLy8gVE9ETzogUHJldmlvdXMgc3RhdGUgY2FuIGJlIG51bGwuXG4gICAgdmFyIG5ld1N0YXRlID0gdm9pZCAwO1xuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgbmV3U3RhdGUgPSBwcm9jZXNzVXBkYXRlUXVldWUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlLCBpbnN0YW5jZSwgbmV3UHJvcHMsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3U3RhdGUgPSBvbGRTdGF0ZTtcbiAgICB9XG5cbiAgICBpZiAob2xkUHJvcHMgPT09IG5ld1Byb3BzICYmIG9sZFN0YXRlID09PSBuZXdTdGF0ZSAmJiAhaGFzQ29udGV4dENoYW5nZWQoKSAmJiAhKHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlICE9PSBudWxsICYmIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlLmhhc0ZvcmNlVXBkYXRlKSkge1xuICAgICAgLy8gSWYgYW4gdXBkYXRlIHdhcyBhbHJlYWR5IGluIHByb2dyZXNzLCB3ZSBzaG91bGQgc2NoZWR1bGUgYW4gVXBkYXRlXG4gICAgICAvLyBlZmZlY3QgZXZlbiB0aG91Z2ggd2UncmUgYmFpbGluZyBvdXQsIHNvIHRoYXQgY1dVL2NEVSBhcmUgY2FsbGVkLlxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKG9sZFByb3BzICE9PSBjdXJyZW50Lm1lbW9pemVkUHJvcHMgfHwgb2xkU3RhdGUgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSkge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgc2hvdWxkVXBkYXRlID0gY2hlY2tTaG91bGRDb21wb25lbnRVcGRhdGUod29ya0luUHJvZ3Jlc3MsIG9sZFByb3BzLCBuZXdQcm9wcywgb2xkU3RhdGUsIG5ld1N0YXRlLCBuZXdDb250ZXh0KTtcblxuICAgIGlmIChzaG91bGRVcGRhdGUpIHtcbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBzdGFydFBoYXNlVGltZXIod29ya0luUHJvZ3Jlc3MsICdjb21wb25lbnRXaWxsVXBkYXRlJyk7XG4gICAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUobmV3UHJvcHMsIG5ld1N0YXRlLCBuZXdDb250ZXh0KTtcbiAgICAgICAgc3RvcFBoYXNlVGltZXIoKTtcblxuICAgICAgICAvLyBTaW11bGF0ZSBhbiBhc3luYyBiYWlsb3V0L2ludGVycnVwdGlvbiBieSBpbnZva2luZyBsaWZlY3ljbGUgdHdpY2UuXG4gICAgICAgIGlmIChkZWJ1Z1JlbmRlclBoYXNlU2lkZUVmZmVjdHMpIHtcbiAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlKG5ld1Byb3BzLCBuZXdTdGF0ZSwgbmV3Q29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIGFuIHVwZGF0ZSB3YXMgYWxyZWFkeSBpbiBwcm9ncmVzcywgd2Ugc2hvdWxkIHNjaGVkdWxlIGFuIFVwZGF0ZVxuICAgICAgLy8gZWZmZWN0IGV2ZW4gdGhvdWdoIHdlJ3JlIGJhaWxpbmcgb3V0LCBzbyB0aGF0IGNXVS9jRFUgYXJlIGNhbGxlZC5cbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGlmIChvbGRQcm9wcyAhPT0gY3VycmVudC5tZW1vaXplZFByb3BzIHx8IG9sZFN0YXRlICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUpIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gVXBkYXRlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHNob3VsZENvbXBvbmVudFVwZGF0ZSByZXR1cm5lZCBmYWxzZSwgd2Ugc2hvdWxkIHN0aWxsIHVwZGF0ZSB0aGVcbiAgICAgIC8vIG1lbW9pemVkIHByb3BzL3N0YXRlIHRvIGluZGljYXRlIHRoYXQgdGhpcyB3b3JrIGNhbiBiZSByZXVzZWQuXG4gICAgICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIG5ld1Byb3BzKTtcbiAgICAgIG1lbW9pemVTdGF0ZSh3b3JrSW5Qcm9ncmVzcywgbmV3U3RhdGUpO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UncyBzdGF0ZSwgcHJvcHMsIGFuZCBjb250ZXh0IHBvaW50ZXJzIGV2ZW5cbiAgICAvLyBpZiBzaG91bGRDb21wb25lbnRVcGRhdGUgcmV0dXJucyBmYWxzZS5cbiAgICBpbnN0YW5jZS5wcm9wcyA9IG5ld1Byb3BzO1xuICAgIGluc3RhbmNlLnN0YXRlID0gbmV3U3RhdGU7XG4gICAgaW5zdGFuY2UuY29udGV4dCA9IG5ld0NvbnRleHQ7XG5cbiAgICByZXR1cm4gc2hvdWxkVXBkYXRlO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBhZG9wdENsYXNzSW5zdGFuY2U6IGFkb3B0Q2xhc3NJbnN0YW5jZSxcbiAgICBjb25zdHJ1Y3RDbGFzc0luc3RhbmNlOiBjb25zdHJ1Y3RDbGFzc0luc3RhbmNlLFxuICAgIG1vdW50Q2xhc3NJbnN0YW5jZTogbW91bnRDbGFzc0luc3RhbmNlLFxuICAgIC8vIHJlc3VtZU1vdW50Q2xhc3NJbnN0YW5jZSxcbiAgICB1cGRhdGVDbGFzc0luc3RhbmNlOiB1cGRhdGVDbGFzc0luc3RhbmNlXG4gIH07XG59O1xuXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxudmFyIGhhc1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sWydmb3InXTtcblxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbFsnZm9yJ10oJ3JlYWN0LmVsZW1lbnQnKSA6IDB4ZWFjNztcbnZhciBSRUFDVF9DQUxMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5jYWxsJykgOiAweGVhYzg7XG52YXIgUkVBQ1RfUkVUVVJOX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5yZXR1cm4nKSA6IDB4ZWFjOTtcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbFsnZm9yJ10oJ3JlYWN0LnBvcnRhbCcpIDogMHhlYWNhO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5mcmFnbWVudCcpIDogMHhlYWNiO1xuXG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7XG5cbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgbWF5YmVJdGVyYXRvciA9IE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF07XG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQxID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtO1xuXG5cbntcbiAgdmFyIGRpZFdhcm5BYm91dE1hcHMgPSBmYWxzZTtcbiAgLyoqXG4gICAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3JcbiAgICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gICAqIHVwZGF0ZXMuXG4gICAqL1xuICB2YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG4gIHZhciBvd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmcgPSB7fTtcblxuICB2YXIgd2FybkZvck1pc3NpbmdLZXkgPSBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQgPT09IG51bGwgfHwgdHlwZW9mIGNoaWxkICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWNoaWxkLl9zdG9yZSB8fCBjaGlsZC5fc3RvcmUudmFsaWRhdGVkIHx8IGNoaWxkLmtleSAhPSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgICEodHlwZW9mIGNoaWxkLl9zdG9yZSA9PT0gJ29iamVjdCcpID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3QgQ29tcG9uZW50IGluIHdhcm5Gb3JNaXNzaW5nS2V5IHNob3VsZCBoYXZlIGEgX3N0b3JlLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgIGNoaWxkLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuXG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSAnRWFjaCBjaGlsZCBpbiBhbiBhcnJheSBvciBpdGVyYXRvciBzaG91bGQgaGF2ZSBhIHVuaXF1ZSAnICsgJ1wia2V5XCIgcHJvcC4gU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1rZXlzIGZvciAnICsgJ21vcmUgaW5mb3JtYXRpb24uJyArIChnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDEoKSB8fCAnJyk7XG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10gPSB0cnVlO1xuXG4gICAgd2FybmluZyhmYWxzZSwgJ0VhY2ggY2hpbGQgaW4gYW4gYXJyYXkgb3IgaXRlcmF0b3Igc2hvdWxkIGhhdmUgYSB1bmlxdWUgJyArICdcImtleVwiIHByb3AuIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmcta2V5cyBmb3IgJyArICdtb3JlIGluZm9ybWF0aW9uLiVzJywgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQxKCkpO1xuICB9O1xufVxuXG52YXIgaXNBcnJheSQxID0gQXJyYXkuaXNBcnJheTtcblxuZnVuY3Rpb24gY29lcmNlUmVmKGN1cnJlbnQsIGVsZW1lbnQpIHtcbiAgdmFyIG1peGVkUmVmID0gZWxlbWVudC5yZWY7XG4gIGlmIChtaXhlZFJlZiAhPT0gbnVsbCAmJiB0eXBlb2YgbWl4ZWRSZWYgIT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoZWxlbWVudC5fb3duZXIpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIGluc3QgPSB2b2lkIDA7XG4gICAgICBpZiAob3duZXIpIHtcbiAgICAgICAgdmFyIG93bmVyRmliZXIgPSBvd25lcjtcbiAgICAgICAgIShvd25lckZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpID8gaW52YXJpYW50KGZhbHNlLCAnU3RhdGVsZXNzIGZ1bmN0aW9uIGNvbXBvbmVudHMgY2Fubm90IGhhdmUgcmVmcy4nKSA6IHZvaWQgMDtcbiAgICAgICAgaW5zdCA9IG93bmVyRmliZXIuc3RhdGVOb2RlO1xuICAgICAgfVxuICAgICAgIWluc3QgPyBpbnZhcmlhbnQoZmFsc2UsICdNaXNzaW5nIG93bmVyIGZvciBzdHJpbmcgcmVmICVzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicsIG1peGVkUmVmKSA6IHZvaWQgMDtcbiAgICAgIHZhciBzdHJpbmdSZWYgPSAnJyArIG1peGVkUmVmO1xuICAgICAgLy8gQ2hlY2sgaWYgcHJldmlvdXMgc3RyaW5nIHJlZiBtYXRjaGVzIG5ldyBzdHJpbmcgcmVmXG4gICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiBjdXJyZW50LnJlZiAhPT0gbnVsbCAmJiBjdXJyZW50LnJlZi5fc3RyaW5nUmVmID09PSBzdHJpbmdSZWYpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQucmVmO1xuICAgICAgfVxuICAgICAgdmFyIHJlZiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgcmVmcyA9IGluc3QucmVmcyA9PT0gZW1wdHlPYmplY3QgPyBpbnN0LnJlZnMgPSB7fSA6IGluc3QucmVmcztcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgZGVsZXRlIHJlZnNbc3RyaW5nUmVmXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWZzW3N0cmluZ1JlZl0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJlZi5fc3RyaW5nUmVmID0gc3RyaW5nUmVmO1xuICAgICAgcmV0dXJuIHJlZjtcbiAgICB9IGVsc2Uge1xuICAgICAgISh0eXBlb2YgbWl4ZWRSZWYgPT09ICdzdHJpbmcnKSA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHJlZiB0byBiZSBhIGZ1bmN0aW9uIG9yIGEgc3RyaW5nLicpIDogdm9pZCAwO1xuICAgICAgIWVsZW1lbnQuX293bmVyID8gaW52YXJpYW50KGZhbHNlLCAnRWxlbWVudCByZWYgd2FzIHNwZWNpZmllZCBhcyBhIHN0cmluZyAoJXMpIGJ1dCBubyBvd25lciB3YXMgc2V0LiBZb3UgbWF5IGhhdmUgbXVsdGlwbGUgY29waWVzIG9mIFJlYWN0IGxvYWRlZC4gKGRldGFpbHM6IGh0dHBzOi8vZmIubWUvcmVhY3QtcmVmcy1tdXN0LWhhdmUtb3duZXIpLicsIG1peGVkUmVmKSA6IHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1peGVkUmVmO1xufVxuXG5mdW5jdGlvbiB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKSB7XG4gIGlmIChyZXR1cm5GaWJlci50eXBlICE9PSAndGV4dGFyZWEnKSB7XG4gICAgdmFyIGFkZGVuZHVtID0gJyc7XG4gICAge1xuICAgICAgYWRkZW5kdW0gPSAnIElmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgJyArICdpbnN0ZWFkLicgKyAoZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQxKCkgfHwgJycpO1xuICAgIH1cbiAgICBpbnZhcmlhbnQoZmFsc2UsICdPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6ICVzKS4lcycsIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuZXdDaGlsZCkgPT09ICdbb2JqZWN0IE9iamVjdF0nID8gJ29iamVjdCB3aXRoIGtleXMgeycgKyBPYmplY3Qua2V5cyhuZXdDaGlsZCkuam9pbignLCAnKSArICd9JyA6IG5ld0NoaWxkLCBhZGRlbmR1bSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2Fybk9uRnVuY3Rpb25UeXBlKCkge1xuICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9ICdGdW5jdGlvbnMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkLiBUaGlzIG1heSBoYXBwZW4gaWYgJyArICd5b3UgcmV0dXJuIGEgQ29tcG9uZW50IGluc3RlYWQgb2YgPENvbXBvbmVudCAvPiBmcm9tIHJlbmRlci4gJyArICdPciBtYXliZSB5b3UgbWVhbnQgdG8gY2FsbCB0aGlzIGZ1bmN0aW9uIHJhdGhlciB0aGFuIHJldHVybiBpdC4nICsgKGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMSgpIHx8ICcnKTtcblxuICBpZiAob3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIG93bmVySGFzRnVuY3Rpb25UeXBlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7XG5cbiAgd2FybmluZyhmYWxzZSwgJ0Z1bmN0aW9ucyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQuIFRoaXMgbWF5IGhhcHBlbiBpZiAnICsgJ3lvdSByZXR1cm4gYSBDb21wb25lbnQgaW5zdGVhZCBvZiA8Q29tcG9uZW50IC8+IGZyb20gcmVuZGVyLiAnICsgJ09yIG1heWJlIHlvdSBtZWFudCB0byBjYWxsIHRoaXMgZnVuY3Rpb24gcmF0aGVyIHRoYW4gcmV0dXJuIGl0LiVzJywgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQxKCkgfHwgJycpO1xufVxuXG4vLyBUaGlzIHdyYXBwZXIgZnVuY3Rpb24gZXhpc3RzIGJlY2F1c2UgSSBleHBlY3QgdG8gY2xvbmUgdGhlIGNvZGUgaW4gZWFjaCBwYXRoXG4vLyB0byBiZSBhYmxlIHRvIG9wdGltaXplIGVhY2ggcGF0aCBpbmRpdmlkdWFsbHkgYnkgYnJhbmNoaW5nIGVhcmx5LiBUaGlzIG5lZWRzXG4vLyBhIGNvbXBpbGVyIG9yIHdlIGNhbiBkbyBpdCBtYW51YWxseS4gSGVscGVycyB0aGF0IGRvbid0IG5lZWQgdGhpcyBicmFuY2hpbmdcbi8vIGxpdmUgb3V0c2lkZSBvZiB0aGlzIGZ1bmN0aW9uLlxuZnVuY3Rpb24gQ2hpbGRSZWNvbmNpbGVyKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgZnVuY3Rpb24gZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkVG9EZWxldGUpIHtcbiAgICBpZiAoIXNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIC8vIE5vb3AuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIERlbGV0aW9ucyBhcmUgYWRkZWQgaW4gcmV2ZXJzZWQgb3JkZXIgc28gd2UgYWRkIGl0IHRvIHRoZSBmcm9udC5cbiAgICAvLyBBdCB0aGlzIHBvaW50LCB0aGUgcmV0dXJuIGZpYmVyJ3MgZWZmZWN0IGxpc3QgaXMgZW1wdHkgZXhjZXB0IGZvclxuICAgIC8vIGRlbGV0aW9ucywgc28gd2UgY2FuIGp1c3QgYXBwZW5kIHRoZSBkZWxldGlvbiB0byB0aGUgbGlzdC4gVGhlIHJlbWFpbmluZ1xuICAgIC8vIGVmZmVjdHMgYXJlbid0IGFkZGVkIHVudGlsIHRoZSBjb21wbGV0ZSBwaGFzZS4gT25jZSB3ZSBpbXBsZW1lbnRcbiAgICAvLyByZXN1bWluZywgdGhpcyBtYXkgbm90IGJlIHRydWUuXG4gICAgdmFyIGxhc3QgPSByZXR1cm5GaWJlci5sYXN0RWZmZWN0O1xuICAgIGlmIChsYXN0ICE9PSBudWxsKSB7XG4gICAgICBsYXN0Lm5leHRFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID0gcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gICAgfVxuICAgIGNoaWxkVG9EZWxldGUubmV4dEVmZmVjdCA9IG51bGw7XG4gICAgY2hpbGRUb0RlbGV0ZS5lZmZlY3RUYWcgPSBEZWxldGlvbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCkge1xuICAgIGlmICghc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgLy8gTm9vcC5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIFRPRE86IEZvciB0aGUgc2hvdWxkQ2xvbmUgY2FzZSwgdGhpcyBjb3VsZCBiZSBtaWNyby1vcHRpbWl6ZWQgYSBiaXQgYnlcbiAgICAvLyBhc3N1bWluZyB0aGF0IGFmdGVyIHRoZSBmaXJzdCBjaGlsZCB3ZSd2ZSBhbHJlYWR5IGFkZGVkIGV2ZXJ5dGhpbmcuXG4gICAgdmFyIGNoaWxkVG9EZWxldGUgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoY2hpbGRUb0RlbGV0ZSAhPT0gbnVsbCkge1xuICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkVG9EZWxldGUpO1xuICAgICAgY2hpbGRUb0RlbGV0ZSA9IGNoaWxkVG9EZWxldGUuc2libGluZztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBtYXBSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpIHtcbiAgICAvLyBBZGQgdGhlIHJlbWFpbmluZyBjaGlsZHJlbiB0byBhIHRlbXBvcmFyeSBtYXAgc28gdGhhdCB3ZSBjYW4gZmluZCB0aGVtIGJ5XG4gICAgLy8ga2V5cyBxdWlja2x5LiBJbXBsaWNpdCAobnVsbCkga2V5cyBnZXQgYWRkZWQgdG8gdGhpcyBzZXQgd2l0aCB0aGVpciBpbmRleFxuICAgIHZhciBleGlzdGluZ0NoaWxkcmVuID0gbmV3IE1hcCgpO1xuXG4gICAgdmFyIGV4aXN0aW5nQ2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoZXhpc3RpbmdDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGV4aXN0aW5nQ2hpbGQua2V5ICE9PSBudWxsKSB7XG4gICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uc2V0KGV4aXN0aW5nQ2hpbGQua2V5LCBleGlzdGluZ0NoaWxkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uc2V0KGV4aXN0aW5nQ2hpbGQuaW5kZXgsIGV4aXN0aW5nQ2hpbGQpO1xuICAgICAgfVxuICAgICAgZXhpc3RpbmdDaGlsZCA9IGV4aXN0aW5nQ2hpbGQuc2libGluZztcbiAgICB9XG4gICAgcmV0dXJuIGV4aXN0aW5nQ2hpbGRyZW47XG4gIH1cblxuICBmdW5jdGlvbiB1c2VGaWJlcihmaWJlciwgcGVuZGluZ1Byb3BzLCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFdlIGN1cnJlbnRseSBzZXQgc2libGluZyB0byBudWxsIGFuZCBpbmRleCB0byAwIGhlcmUgYmVjYXVzZSBpdCBpcyBlYXN5XG4gICAgLy8gdG8gZm9yZ2V0IHRvIGRvIGJlZm9yZSByZXR1cm5pbmcgaXQuIEUuZy4gZm9yIHRoZSBzaW5nbGUgY2hpbGQgY2FzZS5cbiAgICB2YXIgY2xvbmUgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhmaWJlciwgcGVuZGluZ1Byb3BzLCBleHBpcmF0aW9uVGltZSk7XG4gICAgY2xvbmUuaW5kZXggPSAwO1xuICAgIGNsb25lLnNpYmxpbmcgPSBudWxsO1xuICAgIHJldHVybiBjbG9uZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBsYWNlQ2hpbGQobmV3RmliZXIsIGxhc3RQbGFjZWRJbmRleCwgbmV3SW5kZXgpIHtcbiAgICBuZXdGaWJlci5pbmRleCA9IG5ld0luZGV4O1xuICAgIGlmICghc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgLy8gTm9vcC5cbiAgICAgIHJldHVybiBsYXN0UGxhY2VkSW5kZXg7XG4gICAgfVxuICAgIHZhciBjdXJyZW50ID0gbmV3RmliZXIuYWx0ZXJuYXRlO1xuICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICB2YXIgb2xkSW5kZXggPSBjdXJyZW50LmluZGV4O1xuICAgICAgaWYgKG9sZEluZGV4IDwgbGFzdFBsYWNlZEluZGV4KSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBtb3ZlLlxuICAgICAgICBuZXdGaWJlci5lZmZlY3RUYWcgPSBQbGFjZW1lbnQ7XG4gICAgICAgIHJldHVybiBsYXN0UGxhY2VkSW5kZXg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIGl0ZW0gY2FuIHN0YXkgaW4gcGxhY2UuXG4gICAgICAgIHJldHVybiBvbGRJbmRleDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyBpcyBhbiBpbnNlcnRpb24uXG4gICAgICBuZXdGaWJlci5lZmZlY3RUYWcgPSBQbGFjZW1lbnQ7XG4gICAgICByZXR1cm4gbGFzdFBsYWNlZEluZGV4O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBsYWNlU2luZ2xlQ2hpbGQobmV3RmliZXIpIHtcbiAgICAvLyBUaGlzIGlzIHNpbXBsZXIgZm9yIHRoZSBzaW5nbGUgY2hpbGQgY2FzZS4gV2Ugb25seSBuZWVkIHRvIGRvIGFcbiAgICAvLyBwbGFjZW1lbnQgZm9yIGluc2VydGluZyBuZXcgY2hpbGRyZW4uXG4gICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMgJiYgbmV3RmliZXIuYWx0ZXJuYXRlID09PSBudWxsKSB7XG4gICAgICBuZXdGaWJlci5lZmZlY3RUYWcgPSBQbGFjZW1lbnQ7XG4gICAgfVxuICAgIHJldHVybiBuZXdGaWJlcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVRleHROb2RlKHJldHVybkZpYmVyLCBjdXJyZW50LCB0ZXh0Q29udGVudCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50LnRhZyAhPT0gSG9zdFRleHQpIHtcbiAgICAgIC8vIEluc2VydFxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21UZXh0KHRleHRDb250ZW50LCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNyZWF0ZWRbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVXBkYXRlXG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50LCB0ZXh0Q29udGVudCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRWxlbWVudChyZXR1cm5GaWJlciwgY3VycmVudCwgZWxlbWVudCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiBjdXJyZW50LnR5cGUgPT09IGVsZW1lbnQudHlwZSkge1xuICAgICAgLy8gTW92ZSBiYXNlZCBvbiBpbmRleFxuICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudCwgZWxlbWVudC5wcm9wcywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgZXhpc3RpbmcucmVmID0gY29lcmNlUmVmKGN1cnJlbnQsIGVsZW1lbnQpO1xuICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICB7XG4gICAgICAgIGV4aXN0aW5nLl9kZWJ1Z1NvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTtcbiAgICAgICAgZXhpc3RpbmcuX2RlYnVnT3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSW5zZXJ0XG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoZWxlbWVudCwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBjcmVhdGVkLnJlZiA9IGNvZXJjZVJlZihjdXJyZW50LCBlbGVtZW50KTtcbiAgICAgIGNyZWF0ZWRbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDYWxsKHJldHVybkZpYmVyLCBjdXJyZW50LCBjYWxsLCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFRPRE86IFNob3VsZCB0aGlzIGFsc28gY29tcGFyZSBoYW5kbGVyIHRvIGRldGVybWluZSB3aGV0aGVyIHRvIHJldXNlP1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQudGFnICE9PSBDYWxsQ29tcG9uZW50KSB7XG4gICAgICAvLyBJbnNlcnRcbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tQ2FsbChjYWxsLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNyZWF0ZWRbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTW92ZSBiYXNlZCBvbiBpbmRleFxuICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudCwgY2FsbCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlUmV0dXJuKHJldHVybkZpYmVyLCBjdXJyZW50LCByZXR1cm5Ob2RlLCBleHBpcmF0aW9uVGltZSkge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQudGFnICE9PSBSZXR1cm5Db21wb25lbnQpIHtcbiAgICAgIC8vIEluc2VydFxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21SZXR1cm4ocmV0dXJuTm9kZSwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBjcmVhdGVkLnR5cGUgPSByZXR1cm5Ob2RlLnZhbHVlO1xuICAgICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBNb3ZlIGJhc2VkIG9uIGluZGV4XG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50LCBudWxsLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBleGlzdGluZy50eXBlID0gcmV0dXJuTm9kZS52YWx1ZTtcbiAgICAgIGV4aXN0aW5nWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVBvcnRhbChyZXR1cm5GaWJlciwgY3VycmVudCwgcG9ydGFsLCBleHBpcmF0aW9uVGltZSkge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQudGFnICE9PSBIb3N0UG9ydGFsIHx8IGN1cnJlbnQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8gIT09IHBvcnRhbC5jb250YWluZXJJbmZvIHx8IGN1cnJlbnQuc3RhdGVOb2RlLmltcGxlbWVudGF0aW9uICE9PSBwb3J0YWwuaW1wbGVtZW50YXRpb24pIHtcbiAgICAgIC8vIEluc2VydFxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21Qb3J0YWwocG9ydGFsLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNyZWF0ZWRbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVXBkYXRlXG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50LCBwb3J0YWwuY2hpbGRyZW4gfHwgW10sIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGV4aXN0aW5nWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUZyYWdtZW50KHJldHVybkZpYmVyLCBjdXJyZW50LCBmcmFnbWVudCwgZXhwaXJhdGlvblRpbWUsIGtleSkge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQudGFnICE9PSBGcmFnbWVudCkge1xuICAgICAgLy8gSW5zZXJ0XG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KGZyYWdtZW50LCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lLCBrZXkpO1xuICAgICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVcGRhdGVcbiAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGN1cnJlbnQsIGZyYWdtZW50LCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBleGlzdGluZ1sncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDaGlsZChyZXR1cm5GaWJlciwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG5ld0NoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgLy8gVGV4dCBub2RlcyBkb24ndCBoYXZlIGtleXMuIElmIHRoZSBwcmV2aW91cyBub2RlIGlzIGltcGxpY2l0bHkga2V5ZWRcbiAgICAgIC8vIHdlIGNhbiBjb250aW51ZSB0byByZXBsYWNlIGl0IHdpdGhvdXQgYWJvcnRpbmcgZXZlbiBpZiBpdCBpcyBub3QgYSB0ZXh0XG4gICAgICAvLyBub2RlLlxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21UZXh0KCcnICsgbmV3Q2hpbGQsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICAgICAgICAgIHZhciBfY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KG5ld0NoaWxkLnByb3BzLmNoaWxkcmVuLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lLCBuZXdDaGlsZC5rZXkpO1xuICAgICAgICAgICAgICBfY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jcmVhdGVkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIF9jcmVhdGVkMiA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQobmV3Q2hpbGQsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgICAgICBfY3JlYXRlZDIucmVmID0gY29lcmNlUmVmKG51bGwsIG5ld0NoaWxkKTtcbiAgICAgICAgICAgICAgX2NyZWF0ZWQyWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgICAgICAgICByZXR1cm4gX2NyZWF0ZWQyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX0NBTExfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX2NyZWF0ZWQzID0gY3JlYXRlRmliZXJGcm9tQ2FsbChuZXdDaGlsZCwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgICBfY3JlYXRlZDNbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgICByZXR1cm4gX2NyZWF0ZWQzO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX1JFVFVSTl9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfY3JlYXRlZDQgPSBjcmVhdGVGaWJlckZyb21SZXR1cm4obmV3Q2hpbGQsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgICAgX2NyZWF0ZWQ0LnR5cGUgPSBuZXdDaGlsZC52YWx1ZTtcbiAgICAgICAgICAgIF9jcmVhdGVkNFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICAgIHJldHVybiBfY3JlYXRlZDQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9jcmVhdGVkNSA9IGNyZWF0ZUZpYmVyRnJvbVBvcnRhbChuZXdDaGlsZCwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgICBfY3JlYXRlZDVbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgICByZXR1cm4gX2NyZWF0ZWQ1O1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzQXJyYXkkMShuZXdDaGlsZCkgfHwgZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcbiAgICAgICAgdmFyIF9jcmVhdGVkNiA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KG5ld0NoaWxkLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lLCBudWxsKTtcbiAgICAgICAgX2NyZWF0ZWQ2WydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgICByZXR1cm4gX2NyZWF0ZWQ2O1xuICAgICAgfVxuXG4gICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdhcm5PbkZ1bmN0aW9uVHlwZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlU2xvdChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFVwZGF0ZSB0aGUgZmliZXIgaWYgdGhlIGtleXMgbWF0Y2gsIG90aGVyd2lzZSByZXR1cm4gbnVsbC5cblxuICAgIHZhciBrZXkgPSBvbGRGaWJlciAhPT0gbnVsbCA/IG9sZEZpYmVyLmtleSA6IG51bGw7XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV3Q2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICAvLyBUZXh0IG5vZGVzIGRvbid0IGhhdmUga2V5cy4gSWYgdGhlIHByZXZpb3VzIG5vZGUgaXMgaW1wbGljaXRseSBrZXllZFxuICAgICAgLy8gd2UgY2FuIGNvbnRpbnVlIHRvIHJlcGxhY2UgaXQgd2l0aG91dCBhYm9ydGluZyBldmVuIGlmIGl0IGlzIG5vdCBhIHRleHRcbiAgICAgIC8vIG5vZGUuXG4gICAgICBpZiAoa2V5ICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVwZGF0ZVRleHROb2RlKHJldHVybkZpYmVyLCBvbGRGaWJlciwgJycgKyBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICAgICAgICBpZiAobmV3Q2hpbGQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLnByb3BzLmNoaWxkcmVuLCBleHBpcmF0aW9uVGltZSwga2V5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlRWxlbWVudChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBSRUFDVF9DQUxMX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKG5ld0NoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgIHJldHVybiB1cGRhdGVDYWxsKHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX1JFVFVSTl9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vIFJldHVybnMgZG9uJ3QgaGF2ZSBrZXlzLiBJZiB0aGUgcHJldmlvdXMgbm9kZSBpcyBpbXBsaWNpdGx5IGtleWVkXG4gICAgICAgICAgICAvLyB3ZSBjYW4gY29udGludWUgdG8gcmVwbGFjZSBpdCB3aXRob3V0IGFib3J0aW5nIGV2ZW4gaWYgaXQgaXMgbm90IGFcbiAgICAgICAgICAgIC8vIHlpZWxkLlxuICAgICAgICAgICAgaWYgKGtleSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlUmV0dXJuKHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlUG9ydGFsKHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzQXJyYXkkMShuZXdDaGlsZCkgfHwgZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcbiAgICAgICAgaWYgKGtleSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHVwZGF0ZUZyYWdtZW50KHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lLCBudWxsKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuT25GdW5jdGlvblR5cGUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUZyb21NYXAoZXhpc3RpbmdDaGlsZHJlbiwgcmV0dXJuRmliZXIsIG5ld0lkeCwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG5ld0NoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgLy8gVGV4dCBub2RlcyBkb24ndCBoYXZlIGtleXMsIHNvIHdlIG5laXRoZXIgaGF2ZSB0byBjaGVjayB0aGUgb2xkIG5vclxuICAgICAgLy8gbmV3IG5vZGUgZm9yIHRoZSBrZXkuIElmIGJvdGggYXJlIHRleHQgbm9kZXMsIHRoZXkgbWF0Y2guXG4gICAgICB2YXIgbWF0Y2hlZEZpYmVyID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3SWR4KSB8fCBudWxsO1xuICAgICAgcmV0dXJuIHVwZGF0ZVRleHROb2RlKHJldHVybkZpYmVyLCBtYXRjaGVkRmliZXIsICcnICsgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnb2JqZWN0JyAmJiBuZXdDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgc3dpdGNoIChuZXdDaGlsZC4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX21hdGNoZWRGaWJlciA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0NoaWxkLmtleSA9PT0gbnVsbCA/IG5ld0lkeCA6IG5ld0NoaWxkLmtleSkgfHwgbnVsbDtcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICAgICAgICAgIHJldHVybiB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlciwgX21hdGNoZWRGaWJlciwgbmV3Q2hpbGQucHJvcHMuY2hpbGRyZW4sIGV4cGlyYXRpb25UaW1lLCBuZXdDaGlsZC5rZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZUVsZW1lbnQocmV0dXJuRmliZXIsIF9tYXRjaGVkRmliZXIsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfQ0FMTF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfbWF0Y2hlZEZpYmVyMiA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0NoaWxkLmtleSA9PT0gbnVsbCA/IG5ld0lkeCA6IG5ld0NoaWxkLmtleSkgfHwgbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVDYWxsKHJldHVybkZpYmVyLCBfbWF0Y2hlZEZpYmVyMiwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBSRUFDVF9SRVRVUk5fVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICAvLyBSZXR1cm5zIGRvbid0IGhhdmUga2V5cywgc28gd2UgbmVpdGhlciBoYXZlIHRvIGNoZWNrIHRoZSBvbGQgbm9yXG4gICAgICAgICAgICAvLyBuZXcgbm9kZSBmb3IgdGhlIGtleS4gSWYgYm90aCBhcmUgcmV0dXJucywgdGhleSBtYXRjaC5cbiAgICAgICAgICAgIHZhciBfbWF0Y2hlZEZpYmVyMyA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0lkeCkgfHwgbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVSZXR1cm4ocmV0dXJuRmliZXIsIF9tYXRjaGVkRmliZXIzLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfbWF0Y2hlZEZpYmVyNCA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0NoaWxkLmtleSA9PT0gbnVsbCA/IG5ld0lkeCA6IG5ld0NoaWxkLmtleSkgfHwgbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVQb3J0YWwocmV0dXJuRmliZXIsIF9tYXRjaGVkRmliZXI0LCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzQXJyYXkkMShuZXdDaGlsZCkgfHwgZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcbiAgICAgICAgdmFyIF9tYXRjaGVkRmliZXI1ID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3SWR4KSB8fCBudWxsO1xuICAgICAgICByZXR1cm4gdXBkYXRlRnJhZ21lbnQocmV0dXJuRmliZXIsIF9tYXRjaGVkRmliZXI1LCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUsIG51bGwpO1xuICAgICAgfVxuXG4gICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdhcm5PbkZ1bmN0aW9uVHlwZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFdhcm5zIGlmIHRoZXJlIGlzIGEgZHVwbGljYXRlIG9yIG1pc3Npbmcga2V5XG4gICAqL1xuICBmdW5jdGlvbiB3YXJuT25JbnZhbGlkS2V5KGNoaWxkLCBrbm93bktleXMpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIGNoaWxkICE9PSAnb2JqZWN0JyB8fCBjaGlsZCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4ga25vd25LZXlzO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChjaGlsZC4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgY2FzZSBSRUFDVF9DQUxMX1RZUEU6XG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgd2FybkZvck1pc3NpbmdLZXkoY2hpbGQpO1xuICAgICAgICAgIHZhciBrZXkgPSBjaGlsZC5rZXk7XG4gICAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGtub3duS2V5cyA9PT0gbnVsbCkge1xuICAgICAgICAgICAga25vd25LZXlzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAga25vd25LZXlzLmFkZChrZXkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgha25vd25LZXlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICBrbm93bktleXMuYWRkKGtleSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgd2FybmluZyhmYWxzZSwgJ0VuY291bnRlcmVkIHR3byBjaGlsZHJlbiB3aXRoIHRoZSBzYW1lIGtleSwgYCVzYC4gJyArICdLZXlzIHNob3VsZCBiZSB1bmlxdWUgc28gdGhhdCBjb21wb25lbnRzIG1haW50YWluIHRoZWlyIGlkZW50aXR5ICcgKyAnYWNyb3NzIHVwZGF0ZXMuIE5vbi11bmlxdWUga2V5cyBtYXkgY2F1c2UgY2hpbGRyZW4gdG8gYmUgJyArICdkdXBsaWNhdGVkIGFuZC9vciBvbWl0dGVkIOKAlCB0aGUgYmVoYXZpb3IgaXMgdW5zdXBwb3J0ZWQgYW5kICcgKyAnY291bGQgY2hhbmdlIGluIGEgZnV0dXJlIHZlcnNpb24uJXMnLCBrZXksIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMSgpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGtub3duS2V5cztcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuQXJyYXkocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZHJlbiwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBUaGlzIGFsZ29yaXRobSBjYW4ndCBvcHRpbWl6ZSBieSBzZWFyY2hpbmcgZnJvbSBib3RocyBlbmRzIHNpbmNlIHdlXG4gICAgLy8gZG9uJ3QgaGF2ZSBiYWNrcG9pbnRlcnMgb24gZmliZXJzLiBJJ20gdHJ5aW5nIHRvIHNlZSBob3cgZmFyIHdlIGNhbiBnZXRcbiAgICAvLyB3aXRoIHRoYXQgbW9kZWwuIElmIGl0IGVuZHMgdXAgbm90IGJlaW5nIHdvcnRoIHRoZSB0cmFkZW9mZnMsIHdlIGNhblxuICAgIC8vIGFkZCBpdCBsYXRlci5cblxuICAgIC8vIEV2ZW4gd2l0aCBhIHR3byBlbmRlZCBvcHRpbWl6YXRpb24sIHdlJ2Qgd2FudCB0byBvcHRpbWl6ZSBmb3IgdGhlIGNhc2VcbiAgICAvLyB3aGVyZSB0aGVyZSBhcmUgZmV3IGNoYW5nZXMgYW5kIGJydXRlIGZvcmNlIHRoZSBjb21wYXJpc29uIGluc3RlYWQgb2ZcbiAgICAvLyBnb2luZyBmb3IgdGhlIE1hcC4gSXQnZCBsaWtlIHRvIGV4cGxvcmUgaGl0dGluZyB0aGF0IHBhdGggZmlyc3QgaW5cbiAgICAvLyBmb3J3YXJkLW9ubHkgbW9kZSBhbmQgb25seSBnbyBmb3IgdGhlIE1hcCBvbmNlIHdlIG5vdGljZSB0aGF0IHdlIG5lZWRcbiAgICAvLyBsb3RzIG9mIGxvb2sgYWhlYWQuIFRoaXMgZG9lc24ndCBoYW5kbGUgcmV2ZXJzYWwgYXMgd2VsbCBhcyB0d28gZW5kZWRcbiAgICAvLyBzZWFyY2ggYnV0IHRoYXQncyB1bnVzdWFsLiBCZXNpZGVzLCBmb3IgdGhlIHR3byBlbmRlZCBvcHRpbWl6YXRpb24gdG9cbiAgICAvLyB3b3JrIG9uIEl0ZXJhYmxlcywgd2UnZCBuZWVkIHRvIGNvcHkgdGhlIHdob2xlIHNldC5cblxuICAgIC8vIEluIHRoaXMgZmlyc3QgaXRlcmF0aW9uLCB3ZSdsbCBqdXN0IGxpdmUgd2l0aCBoaXR0aW5nIHRoZSBiYWQgY2FzZVxuICAgIC8vIChhZGRpbmcgZXZlcnl0aGluZyB0byBhIE1hcCkgaW4gZm9yIGV2ZXJ5IGluc2VydC9tb3ZlLlxuXG4gICAgLy8gSWYgeW91IGNoYW5nZSB0aGlzIGNvZGUsIGFsc28gdXBkYXRlIHJlY29uY2lsZUNoaWxkcmVuSXRlcmF0b3IoKSB3aGljaFxuICAgIC8vIHVzZXMgdGhlIHNhbWUgYWxnb3JpdGhtLlxuXG4gICAge1xuICAgICAgLy8gRmlyc3QsIHZhbGlkYXRlIGtleXMuXG4gICAgICB2YXIga25vd25LZXlzID0gbnVsbDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gbmV3Q2hpbGRyZW5baV07XG4gICAgICAgIGtub3duS2V5cyA9IHdhcm5PbkludmFsaWRLZXkoY2hpbGQsIGtub3duS2V5cyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBudWxsO1xuICAgIHZhciBwcmV2aW91c05ld0ZpYmVyID0gbnVsbDtcblxuICAgIHZhciBvbGRGaWJlciA9IGN1cnJlbnRGaXJzdENoaWxkO1xuICAgIHZhciBsYXN0UGxhY2VkSW5kZXggPSAwO1xuICAgIHZhciBuZXdJZHggPSAwO1xuICAgIHZhciBuZXh0T2xkRmliZXIgPSBudWxsO1xuICAgIGZvciAoOyBvbGRGaWJlciAhPT0gbnVsbCAmJiBuZXdJZHggPCBuZXdDaGlsZHJlbi5sZW5ndGg7IG5ld0lkeCsrKSB7XG4gICAgICBpZiAob2xkRmliZXIuaW5kZXggPiBuZXdJZHgpIHtcbiAgICAgICAgbmV4dE9sZEZpYmVyID0gb2xkRmliZXI7XG4gICAgICAgIG9sZEZpYmVyID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRPbGRGaWJlciA9IG9sZEZpYmVyLnNpYmxpbmc7XG4gICAgICB9XG4gICAgICB2YXIgbmV3RmliZXIgPSB1cGRhdGVTbG90KHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGRyZW5bbmV3SWR4XSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgaWYgKG5ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgYnJlYWtzIG9uIGVtcHR5IHNsb3RzIGxpa2UgbnVsbCBjaGlsZHJlbi4gVGhhdCdzXG4gICAgICAgIC8vIHVuZm9ydHVuYXRlIGJlY2F1c2UgaXQgdHJpZ2dlcnMgdGhlIHNsb3cgcGF0aCBhbGwgdGhlIHRpbWUuIFdlIG5lZWRcbiAgICAgICAgLy8gYSBiZXR0ZXIgd2F5IHRvIGNvbW11bmljYXRlIHdoZXRoZXIgdGhpcyB3YXMgYSBtaXNzIG9yIG51bGwsXG4gICAgICAgIC8vIGJvb2xlYW4sIHVuZGVmaW5lZCwgZXRjLlxuICAgICAgICBpZiAob2xkRmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICBvbGRGaWJlciA9IG5leHRPbGRGaWJlcjtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAgIGlmIChvbGRGaWJlciAmJiBuZXdGaWJlci5hbHRlcm5hdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBXZSBtYXRjaGVkIHRoZSBzbG90LCBidXQgd2UgZGlkbid0IHJldXNlIHRoZSBleGlzdGluZyBmaWJlciwgc28gd2VcbiAgICAgICAgICAvLyBuZWVkIHRvIGRlbGV0ZSB0aGUgZXhpc3RpbmcgY2hpbGQuXG4gICAgICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChuZXdGaWJlciwgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogTW92ZSBvdXQgb2YgdGhlIGxvb3AuIFRoaXMgb25seSBoYXBwZW5zIGZvciB0aGUgZmlyc3QgcnVuLlxuICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gbmV3RmliZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUT0RPOiBEZWZlciBzaWJsaW5ncyBpZiB3ZSdyZSBub3QgYXQgdGhlIHJpZ2h0IGluZGV4IGZvciB0aGlzIHNsb3QuXG4gICAgICAgIC8vIEkuZS4gaWYgd2UgaGFkIG51bGwgdmFsdWVzIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIGRlZmVyIHRoaXNcbiAgICAgICAgLy8gZm9yIGVhY2ggbnVsbCB2YWx1ZS4gSG93ZXZlciwgd2UgYWxzbyBkb24ndCB3YW50IHRvIGNhbGwgdXBkYXRlU2xvdFxuICAgICAgICAvLyB3aXRoIHRoZSBwcmV2aW91cyBvbmUuXG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IG5ld0ZpYmVyO1xuICAgICAgfVxuICAgICAgcHJldmlvdXNOZXdGaWJlciA9IG5ld0ZpYmVyO1xuICAgICAgb2xkRmliZXIgPSBuZXh0T2xkRmliZXI7XG4gICAgfVxuXG4gICAgaWYgKG5ld0lkeCA9PT0gbmV3Q2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAvLyBXZSd2ZSByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIG5ldyBjaGlsZHJlbi4gV2UgY2FuIGRlbGV0ZSB0aGUgcmVzdC5cbiAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG4gICAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgICB9XG5cbiAgICBpZiAob2xkRmliZXIgPT09IG51bGwpIHtcbiAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYW55IG1vcmUgZXhpc3RpbmcgY2hpbGRyZW4gd2UgY2FuIGNob29zZSBhIGZhc3QgcGF0aFxuICAgICAgLy8gc2luY2UgdGhlIHJlc3Qgd2lsbCBhbGwgYmUgaW5zZXJ0aW9ucy5cbiAgICAgIGZvciAoOyBuZXdJZHggPCBuZXdDaGlsZHJlbi5sZW5ndGg7IG5ld0lkeCsrKSB7XG4gICAgICAgIHZhciBfbmV3RmliZXIgPSBjcmVhdGVDaGlsZChyZXR1cm5GaWJlciwgbmV3Q2hpbGRyZW5bbmV3SWR4XSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICBpZiAoIV9uZXdGaWJlcikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQoX25ld0ZpYmVyLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG4gICAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gVE9ETzogTW92ZSBvdXQgb2YgdGhlIGxvb3AuIFRoaXMgb25seSBoYXBwZW5zIGZvciB0aGUgZmlyc3QgcnVuLlxuICAgICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBfbmV3RmliZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gX25ld0ZpYmVyO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBfbmV3RmliZXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgICB9XG5cbiAgICAvLyBBZGQgYWxsIGNoaWxkcmVuIHRvIGEga2V5IG1hcCBmb3IgcXVpY2sgbG9va3Vwcy5cbiAgICB2YXIgZXhpc3RpbmdDaGlsZHJlbiA9IG1hcFJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG5cbiAgICAvLyBLZWVwIHNjYW5uaW5nIGFuZCB1c2UgdGhlIG1hcCB0byByZXN0b3JlIGRlbGV0ZWQgaXRlbXMgYXMgbW92ZXMuXG4gICAgZm9yICg7IG5ld0lkeCA8IG5ld0NoaWxkcmVuLmxlbmd0aDsgbmV3SWR4KyspIHtcbiAgICAgIHZhciBfbmV3RmliZXIyID0gdXBkYXRlRnJvbU1hcChleGlzdGluZ0NoaWxkcmVuLCByZXR1cm5GaWJlciwgbmV3SWR4LCBuZXdDaGlsZHJlbltuZXdJZHhdLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBpZiAoX25ld0ZpYmVyMikge1xuICAgICAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgICAgIGlmIChfbmV3RmliZXIyLmFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gVGhlIG5ldyBmaWJlciBpcyBhIHdvcmsgaW4gcHJvZ3Jlc3MsIGJ1dCBpZiB0aGVyZSBleGlzdHMgYVxuICAgICAgICAgICAgLy8gY3VycmVudCwgdGhhdCBtZWFucyB0aGF0IHdlIHJldXNlZCB0aGUgZmliZXIuIFdlIG5lZWQgdG8gZGVsZXRlXG4gICAgICAgICAgICAvLyBpdCBmcm9tIHRoZSBjaGlsZCBsaXN0IHNvIHRoYXQgd2UgZG9uJ3QgYWRkIGl0IHRvIHRoZSBkZWxldGlvblxuICAgICAgICAgICAgLy8gbGlzdC5cbiAgICAgICAgICAgIGV4aXN0aW5nQ2hpbGRyZW5bJ2RlbGV0ZSddKF9uZXdGaWJlcjIua2V5ID09PSBudWxsID8gbmV3SWR4IDogX25ld0ZpYmVyMi5rZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKF9uZXdGaWJlcjIsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcbiAgICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gX25ld0ZpYmVyMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBfbmV3RmliZXIyO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBfbmV3RmliZXIyO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAvLyBBbnkgZXhpc3RpbmcgY2hpbGRyZW4gdGhhdCB3ZXJlbid0IGNvbnN1bWVkIGFib3ZlIHdlcmUgZGVsZXRlZC4gV2UgbmVlZFxuICAgICAgLy8gdG8gYWRkIHRoZW0gdG8gdGhlIGRlbGV0aW9uIGxpc3QuXG4gICAgICBleGlzdGluZ0NoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHJldHVybiBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVDaGlsZHJlbkl0ZXJhdG9yKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGRyZW5JdGVyYWJsZSwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBzYW1lIGltcGxlbWVudGF0aW9uIGFzIHJlY29uY2lsZUNoaWxkcmVuQXJyYXkoKSxcbiAgICAvLyBidXQgdXNpbmcgdGhlIGl0ZXJhdG9yIGluc3RlYWQuXG5cbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obmV3Q2hpbGRyZW5JdGVyYWJsZSk7XG4gICAgISh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykgPyBpbnZhcmlhbnQoZmFsc2UsICdBbiBvYmplY3QgaXMgbm90IGFuIGl0ZXJhYmxlLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gICAge1xuICAgICAgLy8gV2FybiBhYm91dCB1c2luZyBNYXBzIGFzIGNoaWxkcmVuXG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkcmVuSXRlcmFibGUuZW50cmllcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgcG9zc2libGVNYXAgPSBuZXdDaGlsZHJlbkl0ZXJhYmxlO1xuICAgICAgICBpZiAocG9zc2libGVNYXAuZW50cmllcyA9PT0gaXRlcmF0b3JGbikge1xuICAgICAgICAgIHdhcm5pbmcoZGlkV2FybkFib3V0TWFwcywgJ1VzaW5nIE1hcHMgYXMgY2hpbGRyZW4gaXMgdW5zdXBwb3J0ZWQgYW5kIHdpbGwgbGlrZWx5IHlpZWxkICcgKyAndW5leHBlY3RlZCByZXN1bHRzLiBDb252ZXJ0IGl0IHRvIGEgc2VxdWVuY2UvaXRlcmFibGUgb2Yga2V5ZWQgJyArICdSZWFjdEVsZW1lbnRzIGluc3RlYWQuJXMnLCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDEoKSk7XG4gICAgICAgICAgZGlkV2FybkFib3V0TWFwcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gRmlyc3QsIHZhbGlkYXRlIGtleXMuXG4gICAgICAvLyBXZSdsbCBnZXQgYSBkaWZmZXJlbnQgaXRlcmF0b3IgbGF0ZXIgZm9yIHRoZSBtYWluIHBhc3MuXG4gICAgICB2YXIgX25ld0NoaWxkcmVuID0gaXRlcmF0b3JGbi5jYWxsKG5ld0NoaWxkcmVuSXRlcmFibGUpO1xuICAgICAgaWYgKF9uZXdDaGlsZHJlbikge1xuICAgICAgICB2YXIga25vd25LZXlzID0gbnVsbDtcbiAgICAgICAgdmFyIF9zdGVwID0gX25ld0NoaWxkcmVuLm5leHQoKTtcbiAgICAgICAgZm9yICg7ICFfc3RlcC5kb25lOyBfc3RlcCA9IF9uZXdDaGlsZHJlbi5uZXh0KCkpIHtcbiAgICAgICAgICB2YXIgY2hpbGQgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICBrbm93bktleXMgPSB3YXJuT25JbnZhbGlkS2V5KGNoaWxkLCBrbm93bktleXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG5ld0NoaWxkcmVuID0gaXRlcmF0b3JGbi5jYWxsKG5ld0NoaWxkcmVuSXRlcmFibGUpO1xuICAgICEobmV3Q2hpbGRyZW4gIT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdBbiBpdGVyYWJsZSBvYmplY3QgcHJvdmlkZWQgbm8gaXRlcmF0b3IuJykgOiB2b2lkIDA7XG5cbiAgICB2YXIgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IG51bGw7XG4gICAgdmFyIHByZXZpb3VzTmV3RmliZXIgPSBudWxsO1xuXG4gICAgdmFyIG9sZEZpYmVyID0gY3VycmVudEZpcnN0Q2hpbGQ7XG4gICAgdmFyIGxhc3RQbGFjZWRJbmRleCA9IDA7XG4gICAgdmFyIG5ld0lkeCA9IDA7XG4gICAgdmFyIG5leHRPbGRGaWJlciA9IG51bGw7XG5cbiAgICB2YXIgc3RlcCA9IG5ld0NoaWxkcmVuLm5leHQoKTtcbiAgICBmb3IgKDsgb2xkRmliZXIgIT09IG51bGwgJiYgIXN0ZXAuZG9uZTsgbmV3SWR4KyssIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCkpIHtcbiAgICAgIGlmIChvbGRGaWJlci5pbmRleCA+IG5ld0lkeCkge1xuICAgICAgICBuZXh0T2xkRmliZXIgPSBvbGRGaWJlcjtcbiAgICAgICAgb2xkRmliZXIgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dE9sZEZpYmVyID0gb2xkRmliZXIuc2libGluZztcbiAgICAgIH1cbiAgICAgIHZhciBuZXdGaWJlciA9IHVwZGF0ZVNsb3QocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBzdGVwLnZhbHVlLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBpZiAobmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBicmVha3Mgb24gZW1wdHkgc2xvdHMgbGlrZSBudWxsIGNoaWxkcmVuLiBUaGF0J3NcbiAgICAgICAgLy8gdW5mb3J0dW5hdGUgYmVjYXVzZSBpdCB0cmlnZ2VycyB0aGUgc2xvdyBwYXRoIGFsbCB0aGUgdGltZS4gV2UgbmVlZFxuICAgICAgICAvLyBhIGJldHRlciB3YXkgdG8gY29tbXVuaWNhdGUgd2hldGhlciB0aGlzIHdhcyBhIG1pc3Mgb3IgbnVsbCxcbiAgICAgICAgLy8gYm9vbGVhbiwgdW5kZWZpbmVkLCBldGMuXG4gICAgICAgIGlmICghb2xkRmliZXIpIHtcbiAgICAgICAgICBvbGRGaWJlciA9IG5leHRPbGRGaWJlcjtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAgIGlmIChvbGRGaWJlciAmJiBuZXdGaWJlci5hbHRlcm5hdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBXZSBtYXRjaGVkIHRoZSBzbG90LCBidXQgd2UgZGlkbid0IHJldXNlIHRoZSBleGlzdGluZyBmaWJlciwgc28gd2VcbiAgICAgICAgICAvLyBuZWVkIHRvIGRlbGV0ZSB0aGUgZXhpc3RpbmcgY2hpbGQuXG4gICAgICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChuZXdGaWJlciwgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogTW92ZSBvdXQgb2YgdGhlIGxvb3AuIFRoaXMgb25seSBoYXBwZW5zIGZvciB0aGUgZmlyc3QgcnVuLlxuICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gbmV3RmliZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUT0RPOiBEZWZlciBzaWJsaW5ncyBpZiB3ZSdyZSBub3QgYXQgdGhlIHJpZ2h0IGluZGV4IGZvciB0aGlzIHNsb3QuXG4gICAgICAgIC8vIEkuZS4gaWYgd2UgaGFkIG51bGwgdmFsdWVzIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIGRlZmVyIHRoaXNcbiAgICAgICAgLy8gZm9yIGVhY2ggbnVsbCB2YWx1ZS4gSG93ZXZlciwgd2UgYWxzbyBkb24ndCB3YW50IHRvIGNhbGwgdXBkYXRlU2xvdFxuICAgICAgICAvLyB3aXRoIHRoZSBwcmV2aW91cyBvbmUuXG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IG5ld0ZpYmVyO1xuICAgICAgfVxuICAgICAgcHJldmlvdXNOZXdGaWJlciA9IG5ld0ZpYmVyO1xuICAgICAgb2xkRmliZXIgPSBuZXh0T2xkRmliZXI7XG4gICAgfVxuXG4gICAgaWYgKHN0ZXAuZG9uZSkge1xuICAgICAgLy8gV2UndmUgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBuZXcgY2hpbGRyZW4uIFdlIGNhbiBkZWxldGUgdGhlIHJlc3QuXG4gICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgb2xkRmliZXIpO1xuICAgICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gICAgfVxuXG4gICAgaWYgKG9sZEZpYmVyID09PSBudWxsKSB7XG4gICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGFueSBtb3JlIGV4aXN0aW5nIGNoaWxkcmVuIHdlIGNhbiBjaG9vc2UgYSBmYXN0IHBhdGhcbiAgICAgIC8vIHNpbmNlIHRoZSByZXN0IHdpbGwgYWxsIGJlIGluc2VydGlvbnMuXG4gICAgICBmb3IgKDsgIXN0ZXAuZG9uZTsgbmV3SWR4KyssIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCkpIHtcbiAgICAgICAgdmFyIF9uZXdGaWJlcjMgPSBjcmVhdGVDaGlsZChyZXR1cm5GaWJlciwgc3RlcC52YWx1ZSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICBpZiAoX25ld0ZpYmVyMyA9PT0gbnVsbCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQoX25ld0ZpYmVyMywgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuICAgICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFRPRE86IE1vdmUgb3V0IG9mIHRoZSBsb29wLiBUaGlzIG9ubHkgaGFwcGVucyBmb3IgdGhlIGZpcnN0IHJ1bi5cbiAgICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gX25ld0ZpYmVyMztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBfbmV3RmliZXIzO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBfbmV3RmliZXIzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gICAgfVxuXG4gICAgLy8gQWRkIGFsbCBjaGlsZHJlbiB0byBhIGtleSBtYXAgZm9yIHF1aWNrIGxvb2t1cHMuXG4gICAgdmFyIGV4aXN0aW5nQ2hpbGRyZW4gPSBtYXBSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgb2xkRmliZXIpO1xuXG4gICAgLy8gS2VlcCBzY2FubmluZyBhbmQgdXNlIHRoZSBtYXAgdG8gcmVzdG9yZSBkZWxldGVkIGl0ZW1zIGFzIG1vdmVzLlxuICAgIGZvciAoOyAhc3RlcC5kb25lOyBuZXdJZHgrKywgc3RlcCA9IG5ld0NoaWxkcmVuLm5leHQoKSkge1xuICAgICAgdmFyIF9uZXdGaWJlcjQgPSB1cGRhdGVGcm9tTWFwKGV4aXN0aW5nQ2hpbGRyZW4sIHJldHVybkZpYmVyLCBuZXdJZHgsIHN0ZXAudmFsdWUsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGlmIChfbmV3RmliZXI0ICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAgICAgaWYgKF9uZXdGaWJlcjQuYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBUaGUgbmV3IGZpYmVyIGlzIGEgd29yayBpbiBwcm9ncmVzcywgYnV0IGlmIHRoZXJlIGV4aXN0cyBhXG4gICAgICAgICAgICAvLyBjdXJyZW50LCB0aGF0IG1lYW5zIHRoYXQgd2UgcmV1c2VkIHRoZSBmaWJlci4gV2UgbmVlZCB0byBkZWxldGVcbiAgICAgICAgICAgIC8vIGl0IGZyb20gdGhlIGNoaWxkIGxpc3Qgc28gdGhhdCB3ZSBkb24ndCBhZGQgaXQgdG8gdGhlIGRlbGV0aW9uXG4gICAgICAgICAgICAvLyBsaXN0LlxuICAgICAgICAgICAgZXhpc3RpbmdDaGlsZHJlblsnZGVsZXRlJ10oX25ld0ZpYmVyNC5rZXkgPT09IG51bGwgPyBuZXdJZHggOiBfbmV3RmliZXI0LmtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQoX25ld0ZpYmVyNCwgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuICAgICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBfbmV3RmliZXI0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IF9uZXdGaWJlcjQ7XG4gICAgICAgIH1cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IF9uZXdGaWJlcjQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIC8vIEFueSBleGlzdGluZyBjaGlsZHJlbiB0aGF0IHdlcmVuJ3QgY29uc3VtZWQgYWJvdmUgd2VyZSBkZWxldGVkLiBXZSBuZWVkXG4gICAgICAvLyB0byBhZGQgdGhlbSB0byB0aGUgZGVsZXRpb24gbGlzdC5cbiAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZVNpbmdsZVRleHROb2RlKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgdGV4dENvbnRlbnQsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gVGhlcmUncyBubyBuZWVkIHRvIGNoZWNrIGZvciBrZXlzIG9uIHRleHQgbm9kZXMgc2luY2Ugd2UgZG9uJ3QgaGF2ZSBhXG4gICAgLy8gd2F5IHRvIGRlZmluZSB0aGVtLlxuICAgIGlmIChjdXJyZW50Rmlyc3RDaGlsZCAhPT0gbnVsbCAmJiBjdXJyZW50Rmlyc3RDaGlsZC50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICAvLyBXZSBhbHJlYWR5IGhhdmUgYW4gZXhpc3Rpbmcgbm9kZSBzbyBsZXQncyBqdXN0IHVwZGF0ZSBpdCBhbmQgZGVsZXRlXG4gICAgICAvLyB0aGUgcmVzdC5cbiAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZC5zaWJsaW5nKTtcbiAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGN1cnJlbnRGaXJzdENoaWxkLCB0ZXh0Q29udGVudCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICAgIC8vIFRoZSBleGlzdGluZyBmaXJzdCBjaGlsZCBpcyBub3QgYSB0ZXh0IG5vZGUgc28gd2UgbmVlZCB0byBjcmVhdGUgb25lXG4gICAgLy8gYW5kIGRlbGV0ZSB0aGUgZXhpc3Rpbmcgb25lcy5cbiAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpO1xuICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tVGV4dCh0ZXh0Q29udGVudCwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSk7XG4gICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICByZXR1cm4gY3JlYXRlZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZVNpbmdsZUVsZW1lbnQocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBlbGVtZW50LCBleHBpcmF0aW9uVGltZSkge1xuICAgIHZhciBrZXkgPSBlbGVtZW50LmtleTtcbiAgICB2YXIgY2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIC8vIFRPRE86IElmIGtleSA9PT0gbnVsbCBhbmQgY2hpbGQua2V5ID09PSBudWxsLCB0aGVuIHRoaXMgb25seSBhcHBsaWVzIHRvXG4gICAgICAvLyB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgbGlzdC5cbiAgICAgIGlmIChjaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICBpZiAoY2hpbGQudGFnID09PSBGcmFnbWVudCA/IGVsZW1lbnQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSA6IGNoaWxkLnR5cGUgPT09IGVsZW1lbnQudHlwZSkge1xuICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZC5zaWJsaW5nKTtcbiAgICAgICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjaGlsZCwgZWxlbWVudC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFID8gZWxlbWVudC5wcm9wcy5jaGlsZHJlbiA6IGVsZW1lbnQucHJvcHMsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICBleGlzdGluZy5yZWYgPSBjb2VyY2VSZWYoY2hpbGQsIGVsZW1lbnQpO1xuICAgICAgICAgIGV4aXN0aW5nWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGV4aXN0aW5nLl9kZWJ1Z1NvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTtcbiAgICAgICAgICAgIGV4aXN0aW5nLl9kZWJ1Z093bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfVxuICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgIH1cblxuICAgIGlmIChlbGVtZW50LnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZWxlbWVudC5wcm9wcy5jaGlsZHJlbiwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSwgZWxlbWVudC5rZXkpO1xuICAgICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX2NyZWF0ZWQ3ID0gY3JlYXRlRmliZXJGcm9tRWxlbWVudChlbGVtZW50LCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIF9jcmVhdGVkNy5yZWYgPSBjb2VyY2VSZWYoY3VycmVudEZpcnN0Q2hpbGQsIGVsZW1lbnQpO1xuICAgICAgX2NyZWF0ZWQ3WydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIF9jcmVhdGVkNztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVTaW5nbGVDYWxsKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgY2FsbCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICB2YXIga2V5ID0gY2FsbC5rZXk7XG4gICAgdmFyIGNoaWxkID0gY3VycmVudEZpcnN0Q2hpbGQ7XG4gICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAvLyBUT0RPOiBJZiBrZXkgPT09IG51bGwgYW5kIGNoaWxkLmtleSA9PT0gbnVsbCwgdGhlbiB0aGlzIG9ubHkgYXBwbGllcyB0b1xuICAgICAgLy8gdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIGxpc3QuXG4gICAgICBpZiAoY2hpbGQua2V5ID09PSBrZXkpIHtcbiAgICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gQ2FsbENvbXBvbmVudCkge1xuICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZC5zaWJsaW5nKTtcbiAgICAgICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjaGlsZCwgY2FsbCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgIGV4aXN0aW5nWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfVxuICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgIH1cblxuICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tQ2FsbChjYWxsLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICBjcmVhdGVkWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgIHJldHVybiBjcmVhdGVkO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlU2luZ2xlUmV0dXJuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgcmV0dXJuTm9kZSwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBUaGVyZSdzIG5vIG5lZWQgdG8gY2hlY2sgZm9yIGtleXMgb24geWllbGRzIHNpbmNlIHRoZXkncmUgc3RhdGVsZXNzLlxuICAgIHZhciBjaGlsZCA9IGN1cnJlbnRGaXJzdENoaWxkO1xuICAgIGlmIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gUmV0dXJuQ29tcG9uZW50KSB7XG4gICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZC5zaWJsaW5nKTtcbiAgICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY2hpbGQsIG51bGwsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgZXhpc3RpbmcudHlwZSA9IHJldHVybk5vZGUudmFsdWU7XG4gICAgICAgIGV4aXN0aW5nWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tUmV0dXJuKHJldHVybk5vZGUsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpO1xuICAgIGNyZWF0ZWQudHlwZSA9IHJldHVybk5vZGUudmFsdWU7XG4gICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICByZXR1cm4gY3JlYXRlZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZVNpbmdsZVBvcnRhbChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIHBvcnRhbCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICB2YXIga2V5ID0gcG9ydGFsLmtleTtcbiAgICB2YXIgY2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIC8vIFRPRE86IElmIGtleSA9PT0gbnVsbCBhbmQgY2hpbGQua2V5ID09PSBudWxsLCB0aGVuIHRoaXMgb25seSBhcHBsaWVzIHRvXG4gICAgICAvLyB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgbGlzdC5cbiAgICAgIGlmIChjaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICBpZiAoY2hpbGQudGFnID09PSBIb3N0UG9ydGFsICYmIGNoaWxkLnN0YXRlTm9kZS5jb250YWluZXJJbmZvID09PSBwb3J0YWwuY29udGFpbmVySW5mbyAmJiBjaGlsZC5zdGF0ZU5vZGUuaW1wbGVtZW50YXRpb24gPT09IHBvcnRhbC5pbXBsZW1lbnRhdGlvbikge1xuICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZC5zaWJsaW5nKTtcbiAgICAgICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjaGlsZCwgcG9ydGFsLmNoaWxkcmVuIHx8IFtdLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICB9XG4gICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgfVxuXG4gICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21Qb3J0YWwocG9ydGFsLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICBjcmVhdGVkWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgIHJldHVybiBjcmVhdGVkO1xuICB9XG5cbiAgLy8gVGhpcyBBUEkgd2lsbCB0YWcgdGhlIGNoaWxkcmVuIHdpdGggdGhlIHNpZGUtZWZmZWN0IG9mIHRoZSByZWNvbmNpbGlhdGlvblxuICAvLyBpdHNlbGYuIFRoZXkgd2lsbCBiZSBhZGRlZCB0byB0aGUgc2lkZS1lZmZlY3QgbGlzdCBhcyB3ZSBwYXNzIHRocm91Z2ggdGhlXG4gIC8vIGNoaWxkcmVuIGFuZCB0aGUgcGFyZW50LlxuICBmdW5jdGlvbiByZWNvbmNpbGVDaGlsZEZpYmVycyhyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgbm90IHJlY3Vyc2l2ZS5cbiAgICAvLyBJZiB0aGUgdG9wIGxldmVsIGl0ZW0gaXMgYW4gYXJyYXksIHdlIHRyZWF0IGl0IGFzIGEgc2V0IG9mIGNoaWxkcmVuLFxuICAgIC8vIG5vdCBhcyBhIGZyYWdtZW50LiBOZXN0ZWQgYXJyYXlzIG9uIHRoZSBvdGhlciBoYW5kIHdpbGwgYmUgdHJlYXRlZCBhc1xuICAgIC8vIGZyYWdtZW50IG5vZGVzLiBSZWN1cnNpb24gaGFwcGVucyBhdCB0aGUgbm9ybWFsIGZsb3cuXG5cbiAgICAvLyBIYW5kbGUgdG9wIGxldmVsIHVua2V5ZWQgZnJhZ21lbnRzIGFzIGlmIHRoZXkgd2VyZSBhcnJheXMuXG4gICAgLy8gVGhpcyBsZWFkcyB0byBhbiBhbWJpZ3VpdHkgYmV0d2VlbiA8PntbLi4uXX08Lz4gYW5kIDw+Li4uPC8+LlxuICAgIC8vIFdlIHRyZWF0IHRoZSBhbWJpZ3VvdXMgY2FzZXMgYWJvdmUgdGhlIHNhbWUuXG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ29iamVjdCcgJiYgbmV3Q2hpbGQgIT09IG51bGwgJiYgbmV3Q2hpbGQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSAmJiBuZXdDaGlsZC5rZXkgPT09IG51bGwpIHtcbiAgICAgIG5ld0NoaWxkID0gbmV3Q2hpbGQucHJvcHMuY2hpbGRyZW47XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIG9iamVjdCB0eXBlc1xuICAgIHZhciBpc09iamVjdCA9IHR5cGVvZiBuZXdDaGlsZCA9PT0gJ29iamVjdCcgJiYgbmV3Q2hpbGQgIT09IG51bGw7XG5cbiAgICBpZiAoaXNPYmplY3QpIHtcbiAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIHBsYWNlU2luZ2xlQ2hpbGQocmVjb25jaWxlU2luZ2xlRWxlbWVudChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSkpO1xuXG4gICAgICAgIGNhc2UgUkVBQ1RfQ0FMTF9UWVBFOlxuICAgICAgICAgIHJldHVybiBwbGFjZVNpbmdsZUNoaWxkKHJlY29uY2lsZVNpbmdsZUNhbGwocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpKTtcbiAgICAgICAgY2FzZSBSRUFDVF9SRVRVUk5fVFlQRTpcbiAgICAgICAgICByZXR1cm4gcGxhY2VTaW5nbGVDaGlsZChyZWNvbmNpbGVTaW5nbGVSZXR1cm4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpKTtcbiAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICByZXR1cm4gcGxhY2VTaW5nbGVDaGlsZChyZWNvbmNpbGVTaW5nbGVQb3J0YWwocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV3Q2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gcGxhY2VTaW5nbGVDaGlsZChyZWNvbmNpbGVTaW5nbGVUZXh0Tm9kZShyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsICcnICsgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKSk7XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkkMShuZXdDaGlsZCkpIHtcbiAgICAgIHJldHVybiByZWNvbmNpbGVDaGlsZHJlbkFycmF5KHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG5cbiAgICBpZiAoZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcbiAgICAgIHJldHVybiByZWNvbmNpbGVDaGlsZHJlbkl0ZXJhdG9yKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG5cbiAgICBpZiAoaXNPYmplY3QpIHtcbiAgICAgIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2Fybk9uRnVuY3Rpb25UeXBlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBJZiB0aGUgbmV3IGNoaWxkIGlzIHVuZGVmaW5lZCwgYW5kIHRoZSByZXR1cm4gZmliZXIgaXMgYSBjb21wb3NpdGVcbiAgICAgIC8vIGNvbXBvbmVudCwgdGhyb3cgYW4gZXJyb3IuIElmIEZpYmVyIHJldHVybiB0eXBlcyBhcmUgZGlzYWJsZWQsXG4gICAgICAvLyB3ZSBhbHJlYWR5IHRocmV3IGFib3ZlLlxuICAgICAgc3dpdGNoIChyZXR1cm5GaWJlci50YWcpIHtcbiAgICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IHJldHVybkZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLnJlbmRlci5faXNNb2NrRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBhbGxvdyBhdXRvLW1vY2tzIHRvIHByb2NlZWQgYXMgaWYgdGhleSdyZSByZXR1cm5pbmcgbnVsbC5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgLy8gSW50ZW50aW9uYWxseSBmYWxsIHRocm91Z2ggdG8gdGhlIG5leHQgY2FzZSwgd2hpY2ggaGFuZGxlcyBib3RoXG4gICAgICAgIC8vIGZ1bmN0aW9ucyBhbmQgY2xhc3Nlc1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVkIG5vLWZhbGx0aHJvdWdoXG4gICAgICAgIGNhc2UgRnVuY3Rpb25hbENvbXBvbmVudDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgQ29tcG9uZW50ID0gcmV0dXJuRmliZXIudHlwZTtcbiAgICAgICAgICAgIGludmFyaWFudChmYWxzZSwgJyVzKC4uLik6IE5vdGhpbmcgd2FzIHJldHVybmVkIGZyb20gcmVuZGVyLiBUaGlzIHVzdWFsbHkgbWVhbnMgYSByZXR1cm4gc3RhdGVtZW50IGlzIG1pc3NpbmcuIE9yLCB0byByZW5kZXIgbm90aGluZywgcmV0dXJuIG51bGwuJywgQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnKTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmVtYWluaW5nIGNhc2VzIGFyZSBhbGwgdHJlYXRlZCBhcyBlbXB0eS5cbiAgICByZXR1cm4gZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKTtcbiAgfVxuXG4gIHJldHVybiByZWNvbmNpbGVDaGlsZEZpYmVycztcbn1cblxudmFyIHJlY29uY2lsZUNoaWxkRmliZXJzID0gQ2hpbGRSZWNvbmNpbGVyKHRydWUpO1xudmFyIG1vdW50Q2hpbGRGaWJlcnMgPSBDaGlsZFJlY29uY2lsZXIoZmFsc2UpO1xuXG5mdW5jdGlvbiBjbG9uZUNoaWxkRmliZXJzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gICEoY3VycmVudCA9PT0gbnVsbCB8fCB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9PT0gY3VycmVudC5jaGlsZCkgPyBpbnZhcmlhbnQoZmFsc2UsICdSZXN1bWluZyB3b3JrIG5vdCB5ZXQgaW1wbGVtZW50ZWQuJykgOiB2b2lkIDA7XG5cbiAgaWYgKHdvcmtJblByb2dyZXNzLmNoaWxkID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGN1cnJlbnRDaGlsZCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB2YXIgbmV3Q2hpbGQgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhjdXJyZW50Q2hpbGQsIGN1cnJlbnRDaGlsZC5wZW5kaW5nUHJvcHMsIGN1cnJlbnRDaGlsZC5leHBpcmF0aW9uVGltZSk7XG4gIHdvcmtJblByb2dyZXNzLmNoaWxkID0gbmV3Q2hpbGQ7XG5cbiAgbmV3Q2hpbGRbJ3JldHVybiddID0gd29ya0luUHJvZ3Jlc3M7XG4gIHdoaWxlIChjdXJyZW50Q2hpbGQuc2libGluZyAhPT0gbnVsbCkge1xuICAgIGN1cnJlbnRDaGlsZCA9IGN1cnJlbnRDaGlsZC5zaWJsaW5nO1xuICAgIG5ld0NoaWxkID0gbmV3Q2hpbGQuc2libGluZyA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnRDaGlsZCwgY3VycmVudENoaWxkLnBlbmRpbmdQcm9wcywgY3VycmVudENoaWxkLmV4cGlyYXRpb25UaW1lKTtcbiAgICBuZXdDaGlsZFsncmV0dXJuJ10gPSB3b3JrSW5Qcm9ncmVzcztcbiAgfVxuICBuZXdDaGlsZC5zaWJsaW5nID0gbnVsbDtcbn1cblxue1xuICB2YXIgd2FybmVkQWJvdXRTdGF0ZWxlc3NSZWZzID0ge307XG59XG5cbnZhciBSZWFjdEZpYmVyQmVnaW5Xb3JrID0gZnVuY3Rpb24gKGNvbmZpZywgaG9zdENvbnRleHQsIGh5ZHJhdGlvbkNvbnRleHQsIHNjaGVkdWxlV29yaywgY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcikge1xuICB2YXIgc2hvdWxkU2V0VGV4dENvbnRlbnQgPSBjb25maWcuc2hvdWxkU2V0VGV4dENvbnRlbnQsXG4gICAgICB1c2VTeW5jU2NoZWR1bGluZyA9IGNvbmZpZy51c2VTeW5jU2NoZWR1bGluZyxcbiAgICAgIHNob3VsZERlcHJpb3JpdGl6ZVN1YnRyZWUgPSBjb25maWcuc2hvdWxkRGVwcmlvcml0aXplU3VidHJlZTtcbiAgdmFyIHB1c2hIb3N0Q29udGV4dCA9IGhvc3RDb250ZXh0LnB1c2hIb3N0Q29udGV4dCxcbiAgICAgIHB1c2hIb3N0Q29udGFpbmVyID0gaG9zdENvbnRleHQucHVzaEhvc3RDb250YWluZXI7XG4gIHZhciBlbnRlckh5ZHJhdGlvblN0YXRlID0gaHlkcmF0aW9uQ29udGV4dC5lbnRlckh5ZHJhdGlvblN0YXRlLFxuICAgICAgcmVzZXRIeWRyYXRpb25TdGF0ZSA9IGh5ZHJhdGlvbkNvbnRleHQucmVzZXRIeWRyYXRpb25TdGF0ZSxcbiAgICAgIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gaHlkcmF0aW9uQ29udGV4dC50cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZTtcblxuICB2YXIgX1JlYWN0RmliZXJDbGFzc0NvbXBvID0gUmVhY3RGaWJlckNsYXNzQ29tcG9uZW50KHNjaGVkdWxlV29yaywgY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlciwgbWVtb2l6ZVByb3BzLCBtZW1vaXplU3RhdGUpLFxuICAgICAgYWRvcHRDbGFzc0luc3RhbmNlID0gX1JlYWN0RmliZXJDbGFzc0NvbXBvLmFkb3B0Q2xhc3NJbnN0YW5jZSxcbiAgICAgIGNvbnN0cnVjdENsYXNzSW5zdGFuY2UgPSBfUmVhY3RGaWJlckNsYXNzQ29tcG8uY29uc3RydWN0Q2xhc3NJbnN0YW5jZSxcbiAgICAgIG1vdW50Q2xhc3NJbnN0YW5jZSA9IF9SZWFjdEZpYmVyQ2xhc3NDb21wby5tb3VudENsYXNzSW5zdGFuY2UsXG4gICAgICB1cGRhdGVDbGFzc0luc3RhbmNlID0gX1JlYWN0RmliZXJDbGFzc0NvbXBvLnVwZGF0ZUNsYXNzSW5zdGFuY2U7XG5cbiAgLy8gVE9ETzogUmVtb3ZlIHRoaXMgYW5kIHVzZSByZWNvbmNpbGVDaGlsZHJlbkF0RXhwaXJhdGlvblRpbWUgZGlyZWN0bHkuXG5cblxuICBmdW5jdGlvbiByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKSB7XG4gICAgcmVjb25jaWxlQ2hpbGRyZW5BdEV4cGlyYXRpb25UaW1lKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuQXRFeHBpcmF0aW9uVGltZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAvLyBJZiB0aGlzIGlzIGEgZnJlc2ggbmV3IGNvbXBvbmVudCB0aGF0IGhhc24ndCBiZWVuIHJlbmRlcmVkIHlldCwgd2VcbiAgICAgIC8vIHdvbid0IHVwZGF0ZSBpdHMgY2hpbGQgc2V0IGJ5IGFwcGx5aW5nIG1pbmltYWwgc2lkZS1lZmZlY3RzLiBJbnN0ZWFkLFxuICAgICAgLy8gd2Ugd2lsbCBhZGQgdGhlbSBhbGwgdG8gdGhlIGNoaWxkIGJlZm9yZSBpdCBnZXRzIHJlbmRlcmVkLiBUaGF0IG1lYW5zXG4gICAgICAvLyB3ZSBjYW4gb3B0aW1pemUgdGhpcyByZWNvbmNpbGlhdGlvbiBwYXNzIGJ5IG5vdCB0cmFja2luZyBzaWRlLWVmZmVjdHMuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG1vdW50Q2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIG51bGwsIG5leHRDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB0aGUgY3VycmVudCBjaGlsZCBpcyB0aGUgc2FtZSBhcyB0aGUgd29yayBpbiBwcm9ncmVzcywgaXQgbWVhbnMgdGhhdFxuICAgICAgLy8gd2UgaGF2ZW4ndCB5ZXQgc3RhcnRlZCBhbnkgd29yayBvbiB0aGVzZSBjaGlsZHJlbi4gVGhlcmVmb3JlLCB3ZSB1c2VcbiAgICAgIC8vIHRoZSBjbG9uZSBhbGdvcml0aG0gdG8gY3JlYXRlIGEgY29weSBvZiBhbGwgdGhlIGN1cnJlbnQgY2hpbGRyZW4uXG5cbiAgICAgIC8vIElmIHdlIGhhZCBhbnkgcHJvZ3Jlc3NlZCB3b3JrIGFscmVhZHksIHRoYXQgaXMgaW52YWxpZCBhdCB0aGlzIHBvaW50IHNvXG4gICAgICAvLyBsZXQncyB0aHJvdyBpdCBvdXQuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBjdXJyZW50LmNoaWxkLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVGcmFnbWVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIHZhciBuZXh0Q2hpbGRyZW4gPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgaWYgKGhhc0NvbnRleHRDaGFuZ2VkKCkpIHtcbiAgICAgIC8vIE5vcm1hbGx5IHdlIGNhbiBiYWlsIG91dCBvbiBwcm9wcyBlcXVhbGl0eSBidXQgaWYgY29udGV4dCBoYXMgY2hhbmdlZFxuICAgICAgLy8gd2UgZG9uJ3QgZG8gdGhlIGJhaWxvdXQgYW5kIHdlIGhhdmUgdG8gcmV1c2UgZXhpc3RpbmcgcHJvcHMgaW5zdGVhZC5cbiAgICAgIGlmIChuZXh0Q2hpbGRyZW4gPT09IG51bGwpIHtcbiAgICAgICAgbmV4dENoaWxkcmVuID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5leHRDaGlsZHJlbiA9PT0gbnVsbCB8fCB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID09PSBuZXh0Q2hpbGRyZW4pIHtcbiAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbik7XG4gICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pO1xuICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgICB2YXIgcmVmID0gd29ya0luUHJvZ3Jlc3MucmVmO1xuICAgIGlmIChyZWYgIT09IG51bGwgJiYgKCFjdXJyZW50IHx8IGN1cnJlbnQucmVmICE9PSByZWYpKSB7XG4gICAgICAvLyBTY2hlZHVsZSBhIFJlZiBlZmZlY3RcbiAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBSZWY7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRnVuY3Rpb25hbENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIHZhciBmbiA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcblxuICAgIHZhciBtZW1vaXplZFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgICBpZiAoaGFzQ29udGV4dENoYW5nZWQoKSkge1xuICAgICAgLy8gTm9ybWFsbHkgd2UgY2FuIGJhaWwgb3V0IG9uIHByb3BzIGVxdWFsaXR5IGJ1dCBpZiBjb250ZXh0IGhhcyBjaGFuZ2VkXG4gICAgICAvLyB3ZSBkb24ndCBkbyB0aGUgYmFpbG91dCBhbmQgd2UgaGF2ZSB0byByZXVzZSBleGlzdGluZyBwcm9wcyBpbnN0ZWFkLlxuICAgICAgaWYgKG5leHRQcm9wcyA9PT0gbnVsbCkge1xuICAgICAgICBuZXh0UHJvcHMgPSBtZW1vaXplZFByb3BzO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobmV4dFByb3BzID09PSBudWxsIHx8IG1lbW9pemVkUHJvcHMgPT09IG5leHRQcm9wcykge1xuICAgICAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB9XG4gICAgICAvLyBUT0RPOiBjb25zaWRlciBicmluZ2luZyBmbi5zaG91bGRDb21wb25lbnRVcGRhdGUoKSBiYWNrLlxuICAgICAgLy8gSXQgdXNlZCB0byBiZSBoZXJlLlxuICAgIH1cblxuICAgIHZhciB1bm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgIHZhciBjb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KTtcblxuICAgIHZhciBuZXh0Q2hpbGRyZW47XG5cbiAgICB7XG4gICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnNldEN1cnJlbnRQaGFzZSgncmVuZGVyJyk7XG4gICAgICBuZXh0Q2hpbGRyZW4gPSBmbihuZXh0UHJvcHMsIGNvbnRleHQpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50UGhhc2UobnVsbCk7XG4gICAgfVxuICAgIC8vIFJlYWN0IERldlRvb2xzIHJlYWRzIHRoaXMgZmxhZy5cbiAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gUGVyZm9ybWVkV29yaztcbiAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKTtcbiAgICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcyk7XG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlQ2xhc3NDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gUHVzaCBjb250ZXh0IHByb3ZpZGVycyBlYXJseSB0byBwcmV2ZW50IGNvbnRleHQgc3RhY2sgbWlzbWF0Y2hlcy5cbiAgICAvLyBEdXJpbmcgbW91bnRpbmcgd2UgZG9uJ3Qga25vdyB0aGUgY2hpbGQgY29udGV4dCB5ZXQgYXMgdGhlIGluc3RhbmNlIGRvZXNuJ3QgZXhpc3QuXG4gICAgLy8gV2Ugd2lsbCBpbnZhbGlkYXRlIHRoZSBjaGlsZCBjb250ZXh0IGluIGZpbmlzaENsYXNzQ29tcG9uZW50KCkgcmlnaHQgYWZ0ZXIgcmVuZGVyaW5nLlxuICAgIHZhciBoYXNDb250ZXh0ID0gcHVzaENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICB2YXIgc2hvdWxkVXBkYXRlID0gdm9pZCAwO1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICBpZiAoIXdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSkge1xuICAgICAgICAvLyBJbiB0aGUgaW5pdGlhbCBwYXNzIHdlIG1pZ2h0IG5lZWQgdG8gY29uc3RydWN0IHRoZSBpbnN0YW5jZS5cbiAgICAgICAgY29uc3RydWN0Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzKTtcbiAgICAgICAgbW91bnRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICAgIHNob3VsZFVwZGF0ZSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdSZXN1bWluZyB3b3JrIG5vdCB5ZXQgaW1wbGVtZW50ZWQuJyk7XG4gICAgICAgIC8vIEluIGEgcmVzdW1lLCB3ZSdsbCBhbHJlYWR5IGhhdmUgYW4gaW5zdGFuY2Ugd2UgY2FuIHJldXNlLlxuICAgICAgICAvLyBzaG91bGRVcGRhdGUgPSByZXN1bWVNb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2hvdWxkVXBkYXRlID0gdXBkYXRlQ2xhc3NJbnN0YW5jZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIH1cbiAgICByZXR1cm4gZmluaXNoQ2xhc3NDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHNob3VsZFVwZGF0ZSwgaGFzQ29udGV4dCk7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5pc2hDbGFzc0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgc2hvdWxkVXBkYXRlLCBoYXNDb250ZXh0KSB7XG4gICAgLy8gUmVmcyBzaG91bGQgdXBkYXRlIGV2ZW4gaWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIHJldHVybnMgZmFsc2VcbiAgICBtYXJrUmVmKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcblxuICAgIGlmICghc2hvdWxkVXBkYXRlKSB7XG4gICAgICAvLyBDb250ZXh0IHByb3ZpZGVycyBzaG91bGQgZGVmZXIgdG8gc0NVIGZvciByZW5kZXJpbmdcbiAgICAgIGlmIChoYXNDb250ZXh0KSB7XG4gICAgICAgIGludmFsaWRhdGVDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcblxuICAgIC8vIFJlcmVuZGVyXG4gICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IHdvcmtJblByb2dyZXNzO1xuICAgIHZhciBuZXh0Q2hpbGRyZW4gPSB2b2lkIDA7XG4gICAge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50UGhhc2UoJ3JlbmRlcicpO1xuICAgICAgbmV4dENoaWxkcmVuID0gaW5zdGFuY2UucmVuZGVyKCk7XG4gICAgICBpZiAoZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzKSB7XG4gICAgICAgIGluc3RhbmNlLnJlbmRlcigpO1xuICAgICAgfVxuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50UGhhc2UobnVsbCk7XG4gICAgfVxuICAgIC8vIFJlYWN0IERldlRvb2xzIHJlYWRzIHRoaXMgZmxhZy5cbiAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gUGVyZm9ybWVkV29yaztcbiAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKTtcbiAgICAvLyBNZW1vaXplIHByb3BzIGFuZCBzdGF0ZSB1c2luZyB0aGUgdmFsdWVzIHdlIGp1c3QgdXNlZCB0byByZW5kZXIuXG4gICAgLy8gVE9ETzogUmVzdHJ1Y3R1cmUgc28gd2UgbmV2ZXIgcmVhZCB2YWx1ZXMgZnJvbSB0aGUgaW5zdGFuY2UuXG4gICAgbWVtb2l6ZVN0YXRlKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZS5zdGF0ZSk7XG4gICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZS5wcm9wcyk7XG5cbiAgICAvLyBUaGUgY29udGV4dCBtaWdodCBoYXZlIGNoYW5nZWQgc28gd2UgbmVlZCB0byByZWNhbGN1bGF0ZSBpdC5cbiAgICBpZiAoaGFzQ29udGV4dCkge1xuICAgICAgaW52YWxpZGF0ZUNvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaEhvc3RSb290Q29udGV4dCh3b3JrSW5Qcm9ncmVzcykge1xuICAgIHZhciByb290ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgIGlmIChyb290LnBlbmRpbmdDb250ZXh0KSB7XG4gICAgICBwdXNoVG9wTGV2ZWxDb250ZXh0T2JqZWN0KHdvcmtJblByb2dyZXNzLCByb290LnBlbmRpbmdDb250ZXh0LCByb290LnBlbmRpbmdDb250ZXh0ICE9PSByb290LmNvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAocm9vdC5jb250ZXh0KSB7XG4gICAgICAvLyBTaG91bGQgYWx3YXlzIGJlIHNldFxuICAgICAgcHVzaFRvcExldmVsQ29udGV4dE9iamVjdCh3b3JrSW5Qcm9ncmVzcywgcm9vdC5jb250ZXh0LCBmYWxzZSk7XG4gICAgfVxuICAgIHB1c2hIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzLCByb290LmNvbnRhaW5lckluZm8pO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlSG9zdFJvb3QoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgcHVzaEhvc3RSb290Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgdmFyIHVwZGF0ZVF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gICAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICB2YXIgcHJldlN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIHZhciBzdGF0ZSA9IHByb2Nlc3NVcGRhdGVRdWV1ZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdXBkYXRlUXVldWUsIG51bGwsIG51bGwsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGlmIChwcmV2U3RhdGUgPT09IHN0YXRlKSB7XG4gICAgICAgIC8vIElmIHRoZSBzdGF0ZSBpcyB0aGUgc2FtZSBhcyBiZWZvcmUsIHRoYXQncyBhIGJhaWxvdXQgYmVjYXVzZSB3ZSBoYWRcbiAgICAgICAgLy8gbm8gd29yayB0aGF0IGV4cGlyZXMgYXQgdGhpcyB0aW1lLlxuICAgICAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG4gICAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIH1cbiAgICAgIHZhciBlbGVtZW50ID0gc3RhdGUuZWxlbWVudDtcbiAgICAgIHZhciByb290ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgaWYgKChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQuY2hpbGQgPT09IG51bGwpICYmIHJvb3QuaHlkcmF0ZSAmJiBlbnRlckh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKSkge1xuICAgICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGFueSBjdXJyZW50IGNoaWxkcmVuIHRoaXMgbWlnaHQgYmUgdGhlIGZpcnN0IHBhc3MuXG4gICAgICAgIC8vIFdlIGFsd2F5cyB0cnkgdG8gaHlkcmF0ZS4gSWYgdGhpcyBpc24ndCBhIGh5ZHJhdGlvbiBwYXNzIHRoZXJlIHdvbid0XG4gICAgICAgIC8vIGJlIGFueSBjaGlsZHJlbiB0byBoeWRyYXRlIHdoaWNoIGlzIGVmZmVjdGl2ZWx5IHRoZSBzYW1lIHRoaW5nIGFzXG4gICAgICAgIC8vIG5vdCBoeWRyYXRpbmcuXG5cbiAgICAgICAgLy8gVGhpcyBpcyBhIGJpdCBvZiBhIGhhY2suIFdlIHRyYWNrIHRoZSBob3N0IHJvb3QgYXMgYSBwbGFjZW1lbnQgdG9cbiAgICAgICAgLy8ga25vdyB0aGF0IHdlJ3JlIGN1cnJlbnRseSBpbiBhIG1vdW50aW5nIHN0YXRlLiBUaGF0IHdheSBpc01vdW50ZWRcbiAgICAgICAgLy8gd29ya3MgYXMgZXhwZWN0ZWQuIFdlIG11c3QgcmVzZXQgdGhpcyBiZWZvcmUgY29tbWl0dGluZy5cbiAgICAgICAgLy8gVE9ETzogRGVsZXRlIHRoaXMgd2hlbiB3ZSBkZWxldGUgaXNNb3VudGVkIGFuZCBmaW5kRE9NTm9kZS5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFBsYWNlbWVudDtcblxuICAgICAgICAvLyBFbnN1cmUgdGhhdCBjaGlsZHJlbiBtb3VudCBpbnRvIHRoaXMgcm9vdCB3aXRob3V0IHRyYWNraW5nXG4gICAgICAgIC8vIHNpZGUtZWZmZWN0cy4gVGhpcyBlbnN1cmVzIHRoYXQgd2UgZG9uJ3Qgc3RvcmUgUGxhY2VtZW50IGVmZmVjdHMgb25cbiAgICAgICAgLy8gbm9kZXMgdGhhdCB3aWxsIGJlIGh5ZHJhdGVkLlxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG1vdW50Q2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIG51bGwsIGVsZW1lbnQsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSByZXNldCBoeWRyYXRpb24gc3RhdGUgaW4gY2FzZSB3ZSBhYm9ydGVkIGFuZCByZXN1bWVkIGFub3RoZXJcbiAgICAgICAgLy8gcm9vdC5cbiAgICAgICAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuICAgICAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgZWxlbWVudCk7XG4gICAgICB9XG4gICAgICBtZW1vaXplU3RhdGUod29ya0luUHJvZ3Jlc3MsIHN0YXRlKTtcbiAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICB9XG4gICAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuICAgIC8vIElmIHRoZXJlIGlzIG5vIHVwZGF0ZSBxdWV1ZSwgdGhhdCdzIGEgYmFpbG91dCBiZWNhdXNlIHRoZSByb290IGhhcyBubyBwcm9wcy5cbiAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVIb3N0Q29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgIHB1c2hIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICB2YXIgbWVtb2l6ZWRQcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gICAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICBpZiAobmV4dFByb3BzID09PSBudWxsKSB7XG4gICAgICBuZXh0UHJvcHMgPSBtZW1vaXplZFByb3BzO1xuICAgICAgIShuZXh0UHJvcHMgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnV2Ugc2hvdWxkIGFsd2F5cyBoYXZlIHBlbmRpbmcgb3IgY3VycmVudCBwcm9wcy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICB9XG4gICAgdmFyIHByZXZQcm9wcyA9IGN1cnJlbnQgIT09IG51bGwgPyBjdXJyZW50Lm1lbW9pemVkUHJvcHMgOiBudWxsO1xuXG4gICAgaWYgKGhhc0NvbnRleHRDaGFuZ2VkKCkpIHtcbiAgICAgIC8vIE5vcm1hbGx5IHdlIGNhbiBiYWlsIG91dCBvbiBwcm9wcyBlcXVhbGl0eSBidXQgaWYgY29udGV4dCBoYXMgY2hhbmdlZFxuICAgICAgLy8gd2UgZG9uJ3QgZG8gdGhlIGJhaWxvdXQgYW5kIHdlIGhhdmUgdG8gcmV1c2UgZXhpc3RpbmcgcHJvcHMgaW5zdGVhZC5cbiAgICB9IGVsc2UgaWYgKG5leHRQcm9wcyA9PT0gbnVsbCB8fCBtZW1vaXplZFByb3BzID09PSBuZXh0UHJvcHMpIHtcbiAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICB2YXIgbmV4dENoaWxkcmVuID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuICAgIHZhciBpc0RpcmVjdFRleHRDaGlsZCA9IHNob3VsZFNldFRleHRDb250ZW50KHR5cGUsIG5leHRQcm9wcyk7XG5cbiAgICBpZiAoaXNEaXJlY3RUZXh0Q2hpbGQpIHtcbiAgICAgIC8vIFdlIHNwZWNpYWwgY2FzZSBhIGRpcmVjdCB0ZXh0IGNoaWxkIG9mIGEgaG9zdCBub2RlLiBUaGlzIGlzIGEgY29tbW9uXG4gICAgICAvLyBjYXNlLiBXZSB3b24ndCBoYW5kbGUgaXQgYXMgYSByZWlmaWVkIGNoaWxkLiBXZSB3aWxsIGluc3RlYWQgaGFuZGxlXG4gICAgICAvLyB0aGlzIGluIHRoZSBob3N0IGVudmlyb25tZW50IHRoYXQgYWxzbyBoYXZlIGFjY2VzcyB0byB0aGlzIHByb3AuIFRoYXRcbiAgICAgIC8vIGF2b2lkcyBhbGxvY2F0aW5nIGFub3RoZXIgSG9zdFRleHQgZmliZXIgYW5kIHRyYXZlcnNpbmcgaXQuXG4gICAgICBuZXh0Q2hpbGRyZW4gPSBudWxsO1xuICAgIH0gZWxzZSBpZiAocHJldlByb3BzICYmIHNob3VsZFNldFRleHRDb250ZW50KHR5cGUsIHByZXZQcm9wcykpIHtcbiAgICAgIC8vIElmIHdlJ3JlIHN3aXRjaGluZyBmcm9tIGEgZGlyZWN0IHRleHQgY2hpbGQgdG8gYSBub3JtYWwgY2hpbGQsIG9yIHRvXG4gICAgICAvLyBlbXB0eSwgd2UgbmVlZCB0byBzY2hlZHVsZSB0aGUgdGV4dCBjb250ZW50IHRvIGJlIHJlc2V0LlxuICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IENvbnRlbnRSZXNldDtcbiAgICB9XG5cbiAgICBtYXJrUmVmKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcblxuICAgIC8vIENoZWNrIHRoZSBob3N0IGNvbmZpZyB0byBzZWUgaWYgdGhlIGNoaWxkcmVuIGFyZSBvZmZzY3JlZW4vaGlkZGVuLlxuICAgIGlmIChyZW5kZXJFeHBpcmF0aW9uVGltZSAhPT0gTmV2ZXIgJiYgIXVzZVN5bmNTY2hlZHVsaW5nICYmIHNob3VsZERlcHJpb3JpdGl6ZVN1YnRyZWUodHlwZSwgbmV4dFByb3BzKSkge1xuICAgICAgLy8gRG93bi1wcmlvcml0aXplIHRoZSBjaGlsZHJlbi5cbiAgICAgIHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lID0gTmV2ZXI7XG4gICAgICAvLyBCYWlsb3V0IGFuZCBjb21lIGJhY2sgdG8gdGhpcyBmaWJlciBsYXRlci5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pO1xuICAgIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgbmV4dFByb3BzKTtcbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVIb3N0VGV4dChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICB0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuICAgIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgaWYgKG5leHRQcm9wcyA9PT0gbnVsbCkge1xuICAgICAgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgICB9XG4gICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXh0UHJvcHMpO1xuICAgIC8vIE5vdGhpbmcgdG8gZG8gaGVyZS4gVGhpcyBpcyB0ZXJtaW5hbC4gV2UnbGwgZG8gdGhlIGNvbXBsZXRpb24gc3RlcFxuICAgIC8vIGltbWVkaWF0ZWx5IGFmdGVyLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gbW91bnRJbmRldGVybWluYXRlQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgICEoY3VycmVudCA9PT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdBbiBpbmRldGVybWluYXRlIGNvbXBvbmVudCBzaG91bGQgbmV2ZXIgaGF2ZSBtb3VudGVkLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgIHZhciBmbiA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgdmFyIHByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgIHZhciB1bm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgIHZhciBjb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KTtcblxuICAgIHZhciB2YWx1ZTtcblxuICAgIHtcbiAgICAgIGlmIChmbi5wcm90b3R5cGUgJiYgdHlwZW9mIGZuLnByb3RvdHlwZS5yZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgXCJUaGUgPCVzIC8+IGNvbXBvbmVudCBhcHBlYXJzIHRvIGhhdmUgYSByZW5kZXIgbWV0aG9kLCBidXQgZG9lc24ndCBleHRlbmQgUmVhY3QuQ29tcG9uZW50LiBcIiArICdUaGlzIGlzIGxpa2VseSB0byBjYXVzZSBlcnJvcnMuIENoYW5nZSAlcyB0byBleHRlbmQgUmVhY3QuQ29tcG9uZW50IGluc3RlYWQuJywgY29tcG9uZW50TmFtZSwgY29tcG9uZW50TmFtZSk7XG4gICAgICB9XG4gICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICB2YWx1ZSA9IGZuKHByb3BzLCBjb250ZXh0KTtcbiAgICB9XG4gICAgLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBQZXJmb3JtZWRXb3JrO1xuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gUHJvY2VlZCB1bmRlciB0aGUgYXNzdW1wdGlvbiB0aGF0IHRoaXMgaXMgYSBjbGFzcyBpbnN0YW5jZVxuICAgICAgd29ya0luUHJvZ3Jlc3MudGFnID0gQ2xhc3NDb21wb25lbnQ7XG5cbiAgICAgIC8vIFB1c2ggY29udGV4dCBwcm92aWRlcnMgZWFybHkgdG8gcHJldmVudCBjb250ZXh0IHN0YWNrIG1pc21hdGNoZXMuXG4gICAgICAvLyBEdXJpbmcgbW91bnRpbmcgd2UgZG9uJ3Qga25vdyB0aGUgY2hpbGQgY29udGV4dCB5ZXQgYXMgdGhlIGluc3RhbmNlIGRvZXNuJ3QgZXhpc3QuXG4gICAgICAvLyBXZSB3aWxsIGludmFsaWRhdGUgdGhlIGNoaWxkIGNvbnRleHQgaW4gZmluaXNoQ2xhc3NDb21wb25lbnQoKSByaWdodCBhZnRlciByZW5kZXJpbmcuXG4gICAgICB2YXIgaGFzQ29udGV4dCA9IHB1c2hDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgYWRvcHRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCB2YWx1ZSk7XG4gICAgICBtb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIHJldHVybiBmaW5pc2hDbGFzc0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdHJ1ZSwgaGFzQ29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFByb2NlZWQgdW5kZXIgdGhlIGFzc3VtcHRpb24gdGhhdCB0aGlzIGlzIGEgZnVuY3Rpb25hbCBjb21wb25lbnRcbiAgICAgIHdvcmtJblByb2dyZXNzLnRhZyA9IEZ1bmN0aW9uYWxDb21wb25lbnQ7XG4gICAgICB7XG4gICAgICAgIHZhciBDb21wb25lbnQgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuXG4gICAgICAgIGlmIChDb21wb25lbnQpIHtcbiAgICAgICAgICB3YXJuaW5nKCFDb21wb25lbnQuY2hpbGRDb250ZXh0VHlwZXMsICclcyguLi4pOiBjaGlsZENvbnRleHRUeXBlcyBjYW5ub3QgYmUgZGVmaW5lZCBvbiBhIGZ1bmN0aW9uYWwgY29tcG9uZW50LicsIENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLnJlZiAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBpbmZvID0gJyc7XG4gICAgICAgICAgdmFyIG93bmVyTmFtZSA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lKCk7XG4gICAgICAgICAgaWYgKG93bmVyTmFtZSkge1xuICAgICAgICAgICAgaW5mbyArPSAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBvd25lck5hbWUgKyAnYC4nO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciB3YXJuaW5nS2V5ID0gb3duZXJOYW1lIHx8IHdvcmtJblByb2dyZXNzLl9kZWJ1Z0lEIHx8ICcnO1xuICAgICAgICAgIHZhciBkZWJ1Z1NvdXJjZSA9IHdvcmtJblByb2dyZXNzLl9kZWJ1Z1NvdXJjZTtcbiAgICAgICAgICBpZiAoZGVidWdTb3VyY2UpIHtcbiAgICAgICAgICAgIHdhcm5pbmdLZXkgPSBkZWJ1Z1NvdXJjZS5maWxlTmFtZSArICc6JyArIGRlYnVnU291cmNlLmxpbmVOdW1iZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghd2FybmVkQWJvdXRTdGF0ZWxlc3NSZWZzW3dhcm5pbmdLZXldKSB7XG4gICAgICAgICAgICB3YXJuZWRBYm91dFN0YXRlbGVzc1JlZnNbd2FybmluZ0tleV0gPSB0cnVlO1xuICAgICAgICAgICAgd2FybmluZyhmYWxzZSwgJ1N0YXRlbGVzcyBmdW5jdGlvbiBjb21wb25lbnRzIGNhbm5vdCBiZSBnaXZlbiByZWZzLiAnICsgJ0F0dGVtcHRzIHRvIGFjY2VzcyB0aGlzIHJlZiB3aWxsIGZhaWwuJXMlcycsIGluZm8sIFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB2YWx1ZSk7XG4gICAgICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIHByb3BzKTtcbiAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDYWxsQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgIHZhciBuZXh0Q2FsbCA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICBpZiAoaGFzQ29udGV4dENoYW5nZWQoKSkge1xuICAgICAgLy8gTm9ybWFsbHkgd2UgY2FuIGJhaWwgb3V0IG9uIHByb3BzIGVxdWFsaXR5IGJ1dCBpZiBjb250ZXh0IGhhcyBjaGFuZ2VkXG4gICAgICAvLyB3ZSBkb24ndCBkbyB0aGUgYmFpbG91dCBhbmQgd2UgaGF2ZSB0byByZXVzZSBleGlzdGluZyBwcm9wcyBpbnN0ZWFkLlxuICAgICAgaWYgKG5leHRDYWxsID09PSBudWxsKSB7XG4gICAgICAgIG5leHRDYWxsID0gY3VycmVudCAmJiBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgICAgICEobmV4dENhbGwgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnV2Ugc2hvdWxkIGFsd2F5cyBoYXZlIHBlbmRpbmcgb3IgY3VycmVudCBwcm9wcy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5leHRDYWxsID09PSBudWxsIHx8IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPT09IG5leHRDYWxsKSB7XG4gICAgICBuZXh0Q2FsbCA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gICAgICAvLyBUT0RPOiBXaGVuIGJhaWxpbmcgb3V0LCB3ZSBtaWdodCBuZWVkIHRvIHJldHVybiB0aGUgc3RhdGVOb2RlIGluc3RlYWRcbiAgICAgIC8vIG9mIHRoZSBjaGlsZC4gVG8gY2hlY2sgaXQgZm9yIHdvcmsuXG4gICAgICAvLyByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgdmFyIG5leHRDaGlsZHJlbiA9IG5leHRDYWxsLmNoaWxkcmVuO1xuXG4gICAgLy8gVGhlIGZvbGxvd2luZyBpcyBhIGZvcmsgb2YgcmVjb25jaWxlQ2hpbGRyZW5BdEV4cGlyYXRpb25UaW1lIGJ1dCB1c2luZ1xuICAgIC8vIHN0YXRlTm9kZSB0byBzdG9yZSB0aGUgY2hpbGQuXG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IG1vdW50Q2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSwgbmV4dENoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IHJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUsIG5leHRDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIH1cblxuICAgIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgbmV4dENhbGwpO1xuICAgIC8vIFRoaXMgZG9lc24ndCB0YWtlIGFyYml0cmFyeSB0aW1lIHNvIHdlIGNvdWxkIHN5bmNocm9ub3VzbHkganVzdCBiZWdpblxuICAgIC8vIGVhZ2VybHkgZG8gdGhlIHdvcmsgb2Ygd29ya0luUHJvZ3Jlc3MuY2hpbGQgYXMgYW4gb3B0aW1pemF0aW9uLlxuICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVQb3J0YWxDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgcHVzaEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTtcbiAgICB2YXIgbmV4dENoaWxkcmVuID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgIGlmIChoYXNDb250ZXh0Q2hhbmdlZCgpKSB7XG4gICAgICAvLyBOb3JtYWxseSB3ZSBjYW4gYmFpbCBvdXQgb24gcHJvcHMgZXF1YWxpdHkgYnV0IGlmIGNvbnRleHQgaGFzIGNoYW5nZWRcbiAgICAgIC8vIHdlIGRvbid0IGRvIHRoZSBiYWlsb3V0IGFuZCB3ZSBoYXZlIHRvIHJldXNlIGV4aXN0aW5nIHByb3BzIGluc3RlYWQuXG4gICAgICBpZiAobmV4dENoaWxkcmVuID09PSBudWxsKSB7XG4gICAgICAgIG5leHRDaGlsZHJlbiA9IGN1cnJlbnQgJiYgY3VycmVudC5tZW1vaXplZFByb3BzO1xuICAgICAgICAhKG5leHRDaGlsZHJlbiAhPSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1dlIHNob3VsZCBhbHdheXMgaGF2ZSBwZW5kaW5nIG9yIGN1cnJlbnQgcHJvcHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuZXh0Q2hpbGRyZW4gPT09IG51bGwgfHwgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9PT0gbmV4dENoaWxkcmVuKSB7XG4gICAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIFBvcnRhbHMgYXJlIHNwZWNpYWwgYmVjYXVzZSB3ZSBkb24ndCBhcHBlbmQgdGhlIGNoaWxkcmVuIGR1cmluZyBtb3VudFxuICAgICAgLy8gYnV0IGF0IGNvbW1pdC4gVGhlcmVmb3JlIHdlIG5lZWQgdG8gdHJhY2sgaW5zZXJ0aW9ucyB3aGljaCB0aGUgbm9ybWFsXG4gICAgICAvLyBmbG93IGRvZXNuJ3QgZG8gZHVyaW5nIG1vdW50LiBUaGlzIGRvZXNuJ3QgaGFwcGVuIGF0IHRoZSByb290IGJlY2F1c2VcbiAgICAgIC8vIHRoZSByb290IGFsd2F5cyBzdGFydHMgd2l0aCBhIFwiY3VycmVudFwiIHdpdGggYSBudWxsIGNoaWxkLlxuICAgICAgLy8gVE9ETzogQ29uc2lkZXIgdW5pZnlpbmcgdGhpcyB3aXRoIGhvdyB0aGUgcm9vdCB3b3Jrcy5cbiAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVjb25jaWxlQ2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIG51bGwsIG5leHRDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKTtcbiAgICAgIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKTtcbiAgICB9XG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9XG5cbiAgLypcbiAgZnVuY3Rpb24gcmV1c2VDaGlsZHJlbkVmZmVjdHMocmV0dXJuRmliZXIgOiBGaWJlciwgZmlyc3RDaGlsZCA6IEZpYmVyKSB7XG4gICAgbGV0IGNoaWxkID0gZmlyc3RDaGlsZDtcbiAgICBkbyB7XG4gICAgICAvLyBFbnN1cmUgdGhhdCB0aGUgZmlyc3QgYW5kIGxhc3QgZWZmZWN0IG9mIHRoZSBwYXJlbnQgY29ycmVzcG9uZHNcbiAgICAgIC8vIHRvIHRoZSBjaGlsZHJlbidzIGZpcnN0IGFuZCBsYXN0IGVmZmVjdC5cbiAgICAgIGlmICghcmV0dXJuRmliZXIuZmlyc3RFZmZlY3QpIHtcbiAgICAgICAgcmV0dXJuRmliZXIuZmlyc3RFZmZlY3QgPSBjaGlsZC5maXJzdEVmZmVjdDtcbiAgICAgIH1cbiAgICAgIGlmIChjaGlsZC5sYXN0RWZmZWN0KSB7XG4gICAgICAgIGlmIChyZXR1cm5GaWJlci5sYXN0RWZmZWN0KSB7XG4gICAgICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdC5uZXh0RWZmZWN0ID0gY2hpbGQuZmlyc3RFZmZlY3Q7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IGNoaWxkLmxhc3RFZmZlY3Q7XG4gICAgICB9XG4gICAgfSB3aGlsZSAoY2hpbGQgPSBjaGlsZC5zaWJsaW5nKTtcbiAgfVxuICAqL1xuXG4gIGZ1bmN0aW9uIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgICBjYW5jZWxXb3JrVGltZXIod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgLy8gVE9ETzogV2Ugc2hvdWxkIGlkZWFsbHkgYmUgYWJsZSB0byBiYWlsIG91dCBlYXJseSBpZiB0aGUgY2hpbGRyZW4gaGF2ZSBub1xuICAgIC8vIG1vcmUgd29yayB0byBkby4gSG93ZXZlciwgc2luY2Ugd2UgZG9uJ3QgaGF2ZSBhIHNlcGFyYXRpb24gb2YgdGhpc1xuICAgIC8vIEZpYmVyJ3MgcHJpb3JpdHkgYW5kIGl0cyBjaGlsZHJlbiB5ZXQgLSB3ZSBkb24ndCBrbm93IHdpdGhvdXQgZG9pbmcgbG90c1xuICAgIC8vIG9mIHRoZSBzYW1lIHdvcmsgd2UgZG8gYW55d2F5LiBPbmNlIHdlIGhhdmUgdGhhdCBzZXBhcmF0aW9uIHdlIGNhbiBqdXN0XG4gICAgLy8gYmFpbCBvdXQgaGVyZSBpZiB0aGUgY2hpbGRyZW4gaGFzIG5vIG1vcmUgd29yayBhdCB0aGlzIHByaW9yaXR5IGxldmVsLlxuICAgIC8vIGlmICh3b3JrSW5Qcm9ncmVzcy5wcmlvcml0eU9mQ2hpbGRyZW4gPD0gcHJpb3JpdHlMZXZlbCkge1xuICAgIC8vICAgLy8gSWYgdGhlcmUgYXJlIHNpZGUtZWZmZWN0cyBpbiB0aGVzZSBjaGlsZHJlbiB0aGF0IGhhdmUgbm90IHlldCBiZWVuXG4gICAgLy8gICAvLyBjb21taXR0ZWQgd2UgbmVlZCB0byBlbnN1cmUgdGhhdCB0aGV5IGdldCBwcm9wZXJseSB0cmFuc2ZlcnJlZCB1cC5cbiAgICAvLyAgIGlmIChjdXJyZW50ICYmIGN1cnJlbnQuY2hpbGQgIT09IHdvcmtJblByb2dyZXNzLmNoaWxkKSB7XG4gICAgLy8gICAgIHJldXNlQ2hpbGRyZW5FZmZlY3RzKHdvcmtJblByb2dyZXNzLCBjaGlsZCk7XG4gICAgLy8gICB9XG4gICAgLy8gICByZXR1cm4gbnVsbDtcbiAgICAvLyB9XG5cbiAgICBjbG9uZUNoaWxkRmliZXJzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiBiYWlsb3V0T25Mb3dQcmlvcml0eShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIGNhbmNlbFdvcmtUaW1lcih3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAvLyBUT0RPOiBIYW5kbGUgSG9zdENvbXBvbmVudCB0YWdzIGhlcmUgYXMgd2VsbCBhbmQgY2FsbCBwdXNoSG9zdENvbnRleHQoKT9cbiAgICAvLyBTZWUgUFIgODU5MCBkaXNjdXNzaW9uIGZvciBjb250ZXh0XG4gICAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHB1c2hIb3N0Um9vdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHB1c2hDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAgcHVzaEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIFRPRE86IFdoYXQgaWYgdGhpcyBpcyBjdXJyZW50bHkgaW4gcHJvZ3Jlc3M/XG4gICAgLy8gSG93IGNhbiB0aGF0IGhhcHBlbj8gSG93IGlzIHRoaXMgbm90IGJlaW5nIGNsb25lZD9cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIFRPRE86IERlbGV0ZSBtZW1vaXplUHJvcHMvU3RhdGUgYW5kIG1vdmUgdG8gcmVjb25jaWxlL2JhaWxvdXQgaW5zdGVhZFxuICBmdW5jdGlvbiBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcykge1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBuZXh0UHJvcHM7XG4gIH1cblxuICBmdW5jdGlvbiBtZW1vaXplU3RhdGUod29ya0luUHJvZ3Jlc3MsIG5leHRTdGF0ZSkge1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgLy8gRG9uJ3QgcmVzZXQgdGhlIHVwZGF0ZVF1ZXVlLCBpbiBjYXNlIHRoZXJlIGFyZSBwZW5kaW5nIHVwZGF0ZXMuIFJlc2V0dGluZ1xuICAgIC8vIGlzIGhhbmRsZWQgYnkgcHJvY2Vzc1VwZGF0ZVF1ZXVlLlxuICB9XG5cbiAgZnVuY3Rpb24gYmVnaW5Xb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lID4gcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgIHJldHVybiBiYWlsb3V0T25Mb3dQcmlvcml0eShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICAgIGNhc2UgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudDpcbiAgICAgICAgcmV0dXJuIG1vdW50SW5kZXRlcm1pbmF0ZUNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgY2FzZSBGdW5jdGlvbmFsQ29tcG9uZW50OlxuICAgICAgICByZXR1cm4gdXBkYXRlRnVuY3Rpb25hbENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICByZXR1cm4gdXBkYXRlQ2xhc3NDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHJldHVybiB1cGRhdGVIb3N0Um9vdChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICByZXR1cm4gdXBkYXRlSG9zdENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUhvc3RUZXh0KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIGNhc2UgQ2FsbEhhbmRsZXJQaGFzZTpcbiAgICAgICAgLy8gVGhpcyBpcyBhIHJlc3RhcnQuIFJlc2V0IHRoZSB0YWcgdG8gdGhlIGluaXRpYWwgcGhhc2UuXG4gICAgICAgIHdvcmtJblByb2dyZXNzLnRhZyA9IENhbGxDb21wb25lbnQ7XG4gICAgICAvLyBJbnRlbnRpb25hbGx5IGZhbGwgdGhyb3VnaCBzaW5jZSB0aGlzIGlzIG5vdyB0aGUgc2FtZS5cbiAgICAgIGNhc2UgQ2FsbENvbXBvbmVudDpcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUNhbGxDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNhc2UgUmV0dXJuQ29tcG9uZW50OlxuICAgICAgICAvLyBBIHJldHVybiBjb21wb25lbnQgaXMganVzdCBhIHBsYWNlaG9sZGVyLCB3ZSBjYW4ganVzdCBydW4gdGhyb3VnaCB0aGVcbiAgICAgICAgLy8gbmV4dCBvbmUgaW1tZWRpYXRlbHkuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgICByZXR1cm4gdXBkYXRlUG9ydGFsQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICBjYXNlIEZyYWdtZW50OlxuICAgICAgICByZXR1cm4gdXBkYXRlRnJhZ21lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnVW5rbm93biB1bml0IG9mIHdvcmsgdGFnLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGJlZ2luRmFpbGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBQdXNoIGNvbnRleHQgcHJvdmlkZXJzIGhlcmUgdG8gYXZvaWQgYSBwdXNoL3BvcCBjb250ZXh0IG1pc21hdGNoLlxuICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICBwdXNoQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICBwdXNoSG9zdFJvb3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdJbnZhbGlkIHR5cGUgb2Ygd29yay4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG5cbiAgICAvLyBBZGQgYW4gZXJyb3IgZWZmZWN0IHNvIHdlIGNhbiBoYW5kbGUgdGhlIGVycm9yIGR1cmluZyB0aGUgY29tbWl0IHBoYXNlXG4gICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IEVycjtcblxuICAgIC8vIFRoaXMgaXMgYSB3ZWlyZCBjYXNlIHdoZXJlIHdlIGRvIFwicmVzdW1lXCIgd29yayDigJQgd29yayB0aGF0IGZhaWxlZCBvblxuICAgIC8vIG91ciBmaXJzdCBhdHRlbXB0LiBCZWNhdXNlIHdlIG5vIGxvbmdlciBoYXZlIGEgbm90aW9uIG9mIFwicHJvZ3Jlc3NlZFxuICAgIC8vIGRlbGV0aW9ucyxcIiByZXNldCB0aGUgY2hpbGQgdG8gdGhlIGN1cnJlbnQgY2hpbGQgdG8gbWFrZSBzdXJlIHdlIGRlbGV0ZVxuICAgIC8vIGl0IGFnYWluLiBUT0RPOiBGaW5kIGEgYmV0dGVyIHdheSB0byBoYW5kbGUgdGhpcywgcGVyaGFwcyBkdXJpbmcgYSBtb3JlXG4gICAgLy8gZ2VuZXJhbCBvdmVyaGF1bCBvZiBlcnJvciBoYW5kbGluZy5cbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAod29ya0luUHJvZ3Jlc3MuY2hpbGQgIT09IGN1cnJlbnQuY2hpbGQpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gY3VycmVudC5jaGlsZDtcbiAgICB9XG5cbiAgICBpZiAod29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCB3b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZSA+IHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgICByZXR1cm4gYmFpbG91dE9uTG93UHJpb3JpdHkoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIC8vIElmIHdlIGRvbid0IGJhaWwgb3V0LCB3ZSdyZSBnb2luZyBiZSByZWNvbXB1dGluZyBvdXIgY2hpbGRyZW4gc28gd2UgbmVlZFxuICAgIC8vIHRvIGRyb3Agb3VyIGVmZmVjdCBsaXN0LlxuICAgIHdvcmtJblByb2dyZXNzLmZpcnN0RWZmZWN0ID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5sYXN0RWZmZWN0ID0gbnVsbDtcblxuICAgIC8vIFVubW91bnQgdGhlIGN1cnJlbnQgY2hpbGRyZW4gYXMgaWYgdGhlIGNvbXBvbmVudCByZW5kZXJlZCBudWxsXG4gICAgdmFyIG5leHRDaGlsZHJlbiA9IG51bGw7XG4gICAgcmVjb25jaWxlQ2hpbGRyZW5BdEV4cGlyYXRpb25UaW1lKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcblxuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy50YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gaW5zdGFuY2UucHJvcHM7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gaW5zdGFuY2Uuc3RhdGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBiZWdpbldvcms6IGJlZ2luV29yayxcbiAgICBiZWdpbkZhaWxlZFdvcms6IGJlZ2luRmFpbGVkV29ya1xuICB9O1xufTtcblxudmFyIFJlYWN0RmliZXJDb21wbGV0ZVdvcmsgPSBmdW5jdGlvbiAoY29uZmlnLCBob3N0Q29udGV4dCwgaHlkcmF0aW9uQ29udGV4dCkge1xuICB2YXIgY3JlYXRlSW5zdGFuY2UgPSBjb25maWcuY3JlYXRlSW5zdGFuY2UsXG4gICAgICBjcmVhdGVUZXh0SW5zdGFuY2UgPSBjb25maWcuY3JlYXRlVGV4dEluc3RhbmNlLFxuICAgICAgYXBwZW5kSW5pdGlhbENoaWxkID0gY29uZmlnLmFwcGVuZEluaXRpYWxDaGlsZCxcbiAgICAgIGZpbmFsaXplSW5pdGlhbENoaWxkcmVuID0gY29uZmlnLmZpbmFsaXplSW5pdGlhbENoaWxkcmVuLFxuICAgICAgcHJlcGFyZVVwZGF0ZSA9IGNvbmZpZy5wcmVwYXJlVXBkYXRlLFxuICAgICAgbXV0YXRpb24gPSBjb25maWcubXV0YXRpb24sXG4gICAgICBwZXJzaXN0ZW5jZSA9IGNvbmZpZy5wZXJzaXN0ZW5jZTtcbiAgdmFyIGdldFJvb3RIb3N0Q29udGFpbmVyID0gaG9zdENvbnRleHQuZ2V0Um9vdEhvc3RDb250YWluZXIsXG4gICAgICBwb3BIb3N0Q29udGV4dCA9IGhvc3RDb250ZXh0LnBvcEhvc3RDb250ZXh0LFxuICAgICAgZ2V0SG9zdENvbnRleHQgPSBob3N0Q29udGV4dC5nZXRIb3N0Q29udGV4dCxcbiAgICAgIHBvcEhvc3RDb250YWluZXIgPSBob3N0Q29udGV4dC5wb3BIb3N0Q29udGFpbmVyO1xuICB2YXIgcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSA9IGh5ZHJhdGlvbkNvbnRleHQucHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSxcbiAgICAgIHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlID0gaHlkcmF0aW9uQ29udGV4dC5wcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZSxcbiAgICAgIHBvcEh5ZHJhdGlvblN0YXRlID0gaHlkcmF0aW9uQ29udGV4dC5wb3BIeWRyYXRpb25TdGF0ZTtcblxuXG4gIGZ1bmN0aW9uIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpIHtcbiAgICAvLyBUYWcgdGhlIGZpYmVyIHdpdGggYW4gdXBkYXRlIGVmZmVjdC4gVGhpcyB0dXJucyBhIFBsYWNlbWVudCBpbnRvXG4gICAgLy8gYW4gVXBkYXRlQW5kUGxhY2VtZW50LlxuICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGU7XG4gIH1cblxuICBmdW5jdGlvbiBtYXJrUmVmKHdvcmtJblByb2dyZXNzKSB7XG4gICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFJlZjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFwcGVuZEFsbFJldHVybnMocmV0dXJucywgd29ya0luUHJvZ3Jlc3MpIHtcbiAgICB2YXIgbm9kZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICBpZiAobm9kZSkge1xuICAgICAgbm9kZVsncmV0dXJuJ10gPSB3b3JrSW5Qcm9ncmVzcztcbiAgICB9XG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQgfHwgbm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnQSBjYWxsIGNhbm5vdCBoYXZlIGhvc3QgY29tcG9uZW50IGNoaWxkcmVuLicpO1xuICAgICAgfSBlbHNlIGlmIChub2RlLnRhZyA9PT0gUmV0dXJuQ29tcG9uZW50KSB7XG4gICAgICAgIHJldHVybnMucHVzaChub2RlLnR5cGUpO1xuICAgICAgfSBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUuY2hpbGRbJ3JldHVybiddID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZVsncmV0dXJuJ10gPT09IG51bGwgfHwgbm9kZVsncmV0dXJuJ10gPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICAgIH1cbiAgICAgIG5vZGUuc2libGluZ1sncmV0dXJuJ10gPSBub2RlWydyZXR1cm4nXTtcbiAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbW92ZUNhbGxUb0hhbmRsZXJQaGFzZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICB2YXIgY2FsbCA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gICAgIWNhbGwgPyBpbnZhcmlhbnQoZmFsc2UsICdTaG91bGQgYmUgcmVzb2x2ZWQgYnkgbm93LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gICAgLy8gRmlyc3Qgc3RlcCBvZiB0aGUgY2FsbCBoYXMgY29tcGxldGVkLiBOb3cgd2UgbmVlZCB0byBkbyB0aGUgc2Vjb25kLlxuICAgIC8vIFRPRE86IEl0IHdvdWxkIGJlIG5pY2UgdG8gaGF2ZSBhIG11bHRpIHN0YWdlIGNhbGwgcmVwcmVzZW50ZWQgYnkgYVxuICAgIC8vIHNpbmdsZSBjb21wb25lbnQsIG9yIGF0IGxlYXN0IHRhaWwgY2FsbCBvcHRpbWl6ZSBuZXN0ZWQgb25lcy4gQ3VycmVudGx5XG4gICAgLy8gdGhhdCByZXF1aXJlcyBhZGRpdGlvbmFsIGZpZWxkcyB0aGF0IHdlIGRvbid0IHdhbnQgdG8gYWRkIHRvIHRoZSBmaWJlci5cbiAgICAvLyBTbyB0aGlzIHJlcXVpcmVzIG5lc3RlZCBoYW5kbGVycy5cbiAgICAvLyBOb3RlOiBUaGlzIGRvZXNuJ3QgbXV0YXRlIHRoZSBhbHRlcm5hdGUgbm9kZS4gSSBkb24ndCB0aGluayBpdCBuZWVkcyB0b1xuICAgIC8vIHNpbmNlIHRoaXMgc3RhZ2UgaXMgcmVzZXQgZm9yIGV2ZXJ5IHBhc3MuXG4gICAgd29ya0luUHJvZ3Jlc3MudGFnID0gQ2FsbEhhbmRsZXJQaGFzZTtcblxuICAgIC8vIEJ1aWxkIHVwIHRoZSByZXR1cm5zLlxuICAgIC8vIFRPRE86IENvbXBhcmUgdGhpcyB0byBhIGdlbmVyYXRvciBvciBvcGFxdWUgaGVscGVycyBsaWtlIENoaWxkcmVuLlxuICAgIHZhciByZXR1cm5zID0gW107XG4gICAgYXBwZW5kQWxsUmV0dXJucyhyZXR1cm5zLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgdmFyIGZuID0gY2FsbC5oYW5kbGVyO1xuICAgIHZhciBwcm9wcyA9IGNhbGwucHJvcHM7XG4gICAgdmFyIG5leHRDaGlsZHJlbiA9IGZuKHByb3BzLCByZXR1cm5zKTtcblxuICAgIHZhciBjdXJyZW50Rmlyc3RDaGlsZCA9IGN1cnJlbnQgIT09IG51bGwgPyBjdXJyZW50LmNoaWxkIDogbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV4dENoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9XG5cbiAgZnVuY3Rpb24gYXBwZW5kQWxsQ2hpbGRyZW4ocGFyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIC8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGNyZWF0ZWQgYnV0IHdlIG5lZWQgcmVjdXJzZSBkb3duIGl0c1xuICAgIC8vIGNoaWxkcmVuIHRvIGZpbmQgYWxsIHRoZSB0ZXJtaW5hbCBub2Rlcy5cbiAgICB2YXIgbm9kZSA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICAgIGFwcGVuZEluaXRpYWxDaGlsZChwYXJlbnQsIG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIHBvcnRhbCBjaGlsZCwgdGhlbiB3ZSBkb24ndCB3YW50IHRvIHRyYXZlcnNlXG4gICAgICAgIC8vIGRvd24gaXRzIGNoaWxkcmVuLiBJbnN0ZWFkLCB3ZSdsbCBnZXQgaW5zZXJ0aW9ucyBmcm9tIGVhY2ggY2hpbGQgaW5cbiAgICAgICAgLy8gdGhlIHBvcnRhbCBkaXJlY3RseS5cbiAgICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBub2RlLmNoaWxkWydyZXR1cm4nXSA9IG5vZGU7XG4gICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgIGlmIChub2RlWydyZXR1cm4nXSA9PT0gbnVsbCB8fCBub2RlWydyZXR1cm4nXSA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgfVxuICAgICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICB9XG4gIH1cblxuICB2YXIgdXBkYXRlSG9zdENvbnRhaW5lciA9IHZvaWQgMDtcbiAgdmFyIHVwZGF0ZUhvc3RDb21wb25lbnQgPSB2b2lkIDA7XG4gIHZhciB1cGRhdGVIb3N0VGV4dCA9IHZvaWQgMDtcbiAgaWYgKG11dGF0aW9uKSB7XG4gICAgaWYgKGVuYWJsZU11dGF0aW5nUmVjb25jaWxlcikge1xuICAgICAgLy8gTXV0YXRpb24gbW9kZVxuICAgICAgdXBkYXRlSG9zdENvbnRhaW5lciA9IGZ1bmN0aW9uICh3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAvLyBOb29wXG4gICAgICB9O1xuICAgICAgdXBkYXRlSG9zdENvbXBvbmVudCA9IGZ1bmN0aW9uIChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpIHtcbiAgICAgICAgLy8gVE9ETzogVHlwZSB0aGlzIHNwZWNpZmljIHRvIHRoaXMgdHlwZSBvZiBjb21wb25lbnQuXG4gICAgICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gdXBkYXRlUGF5bG9hZDtcbiAgICAgICAgLy8gSWYgdGhlIHVwZGF0ZSBwYXlsb2FkIGluZGljYXRlcyB0aGF0IHRoZXJlIGlzIGEgY2hhbmdlIG9yIGlmIHRoZXJlXG4gICAgICAgIC8vIGlzIGEgbmV3IHJlZiB3ZSBtYXJrIHRoaXMgYXMgYW4gdXBkYXRlLiBBbGwgdGhlIHdvcmsgaXMgZG9uZSBpbiBjb21taXRXb3JrLlxuICAgICAgICBpZiAodXBkYXRlUGF5bG9hZCkge1xuICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdXBkYXRlSG9zdFRleHQgPSBmdW5jdGlvbiAoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG9sZFRleHQsIG5ld1RleHQpIHtcbiAgICAgICAgLy8gSWYgdGhlIHRleHQgZGlmZmVycywgbWFyayBpdCBhcyBhbiB1cGRhdGUuIEFsbCB0aGUgd29yayBpbiBkb25lIGluIGNvbW1pdFdvcmsuXG4gICAgICAgIGlmIChvbGRUZXh0ICE9PSBuZXdUZXh0KSB7XG4gICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ011dGF0aW5nIHJlY29uY2lsZXIgaXMgZGlzYWJsZWQuJyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHBlcnNpc3RlbmNlKSB7XG4gICAgaWYgKGVuYWJsZVBlcnNpc3RlbnRSZWNvbmNpbGVyKSB7XG4gICAgICAvLyBQZXJzaXN0ZW50IGhvc3QgdHJlZSBtb2RlXG4gICAgICB2YXIgY2xvbmVJbnN0YW5jZSA9IHBlcnNpc3RlbmNlLmNsb25lSW5zdGFuY2UsXG4gICAgICAgICAgY3JlYXRlQ29udGFpbmVyQ2hpbGRTZXQgPSBwZXJzaXN0ZW5jZS5jcmVhdGVDb250YWluZXJDaGlsZFNldCxcbiAgICAgICAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyQ2hpbGRTZXQgPSBwZXJzaXN0ZW5jZS5hcHBlbmRDaGlsZFRvQ29udGFpbmVyQ2hpbGRTZXQsXG4gICAgICAgICAgZmluYWxpemVDb250YWluZXJDaGlsZHJlbiA9IHBlcnNpc3RlbmNlLmZpbmFsaXplQ29udGFpbmVyQ2hpbGRyZW47XG5cbiAgICAgIC8vIEFuIHVuZm9ydHVuYXRlIGZvcmsgb2YgYXBwZW5kQWxsQ2hpbGRyZW4gYmVjYXVzZSB3ZSBoYXZlIHR3byBkaWZmZXJlbnQgcGFyZW50IHR5cGVzLlxuXG4gICAgICB2YXIgYXBwZW5kQWxsQ2hpbGRyZW5Ub0NvbnRhaW5lciA9IGZ1bmN0aW9uIChjb250YWluZXJDaGlsZFNldCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgLy8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgY3JlYXRlZCBidXQgd2UgbmVlZCByZWN1cnNlIGRvd24gaXRzXG4gICAgICAgIC8vIGNoaWxkcmVuIHRvIGZpbmQgYWxsIHRoZSB0ZXJtaW5hbCBub2Rlcy5cbiAgICAgICAgdmFyIG5vZGUgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICAgICAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyQ2hpbGRTZXQoY29udGFpbmVyQ2hpbGRTZXQsIG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgcG9ydGFsIGNoaWxkLCB0aGVuIHdlIGRvbid0IHdhbnQgdG8gdHJhdmVyc2VcbiAgICAgICAgICAgIC8vIGRvd24gaXRzIGNoaWxkcmVuLiBJbnN0ZWFkLCB3ZSdsbCBnZXQgaW5zZXJ0aW9ucyBmcm9tIGVhY2ggY2hpbGQgaW5cbiAgICAgICAgICAgIC8vIHRoZSBwb3J0YWwgZGlyZWN0bHkuXG4gICAgICAgICAgfSBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBub2RlLmNoaWxkWydyZXR1cm4nXSA9IG5vZGU7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobm9kZSA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKG5vZGVbJ3JldHVybiddID09PSBudWxsIHx8IG5vZGVbJ3JldHVybiddID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlID0gbm9kZVsncmV0dXJuJ107XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGUuc2libGluZ1sncmV0dXJuJ10gPSBub2RlWydyZXR1cm4nXTtcbiAgICAgICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdXBkYXRlSG9zdENvbnRhaW5lciA9IGZ1bmN0aW9uICh3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICB2YXIgcG9ydGFsT3JSb290ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgICB2YXIgY2hpbGRyZW5VbmNoYW5nZWQgPSB3b3JrSW5Qcm9ncmVzcy5maXJzdEVmZmVjdCA9PT0gbnVsbDtcbiAgICAgICAgaWYgKGNoaWxkcmVuVW5jaGFuZ2VkKSB7XG4gICAgICAgICAgLy8gTm8gY2hhbmdlcywganVzdCByZXVzZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGNvbnRhaW5lciA9IHBvcnRhbE9yUm9vdC5jb250YWluZXJJbmZvO1xuICAgICAgICAgIHZhciBuZXdDaGlsZFNldCA9IGNyZWF0ZUNvbnRhaW5lckNoaWxkU2V0KGNvbnRhaW5lcik7XG4gICAgICAgICAgaWYgKGZpbmFsaXplQ29udGFpbmVyQ2hpbGRyZW4oY29udGFpbmVyLCBuZXdDaGlsZFNldCkpIHtcbiAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwb3J0YWxPclJvb3QucGVuZGluZ0NoaWxkcmVuID0gbmV3Q2hpbGRTZXQ7XG4gICAgICAgICAgLy8gSWYgY2hpbGRyZW4gbWlnaHQgaGF2ZSBjaGFuZ2VkLCB3ZSBoYXZlIHRvIGFkZCB0aGVtIGFsbCB0byB0aGUgc2V0LlxuICAgICAgICAgIGFwcGVuZEFsbENoaWxkcmVuVG9Db250YWluZXIobmV3Q2hpbGRTZXQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAvLyBTY2hlZHVsZSBhbiB1cGRhdGUgb24gdGhlIGNvbnRhaW5lciB0byBzd2FwIG91dCB0aGUgY29udGFpbmVyLlxuICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdXBkYXRlSG9zdENvbXBvbmVudCA9IGZ1bmN0aW9uIChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIGVmZmVjdHMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbm9kZSwgdGhlbiBub25lIG9mIG91ciBjaGlsZHJlbiBoYWQgYW55IHVwZGF0ZXMuXG4gICAgICAgIC8vIFRoaXMgZ3VhcmFudGVlcyB0aGF0IHdlIGNhbiByZXVzZSBhbGwgb2YgdGhlbS5cbiAgICAgICAgdmFyIGNoaWxkcmVuVW5jaGFuZ2VkID0gd29ya0luUHJvZ3Jlc3MuZmlyc3RFZmZlY3QgPT09IG51bGw7XG4gICAgICAgIHZhciBjdXJyZW50SW5zdGFuY2UgPSBjdXJyZW50LnN0YXRlTm9kZTtcbiAgICAgICAgaWYgKGNoaWxkcmVuVW5jaGFuZ2VkICYmIHVwZGF0ZVBheWxvYWQgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBObyBjaGFuZ2VzLCBqdXN0IHJldXNlIHRoZSBleGlzdGluZyBpbnN0YW5jZS5cbiAgICAgICAgICAvLyBOb3RlIHRoYXQgdGhpcyBtaWdodCByZWxlYXNlIGEgcHJldmlvdXMgY2xvbmUuXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3VycmVudEluc3RhbmNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciByZWN5Y2xhYmxlSW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgICAgdmFyIG5ld0luc3RhbmNlID0gY2xvbmVJbnN0YW5jZShjdXJyZW50SW5zdGFuY2UsIHVwZGF0ZVBheWxvYWQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgd29ya0luUHJvZ3Jlc3MsIGNoaWxkcmVuVW5jaGFuZ2VkLCByZWN5Y2xhYmxlSW5zdGFuY2UpO1xuICAgICAgICAgIGlmIChmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbihuZXdJbnN0YW5jZSwgdHlwZSwgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSkpIHtcbiAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBuZXdJbnN0YW5jZTtcbiAgICAgICAgICBpZiAoY2hpbGRyZW5VbmNoYW5nZWQpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBvdGhlciBlZmZlY3RzIGluIHRoaXMgdHJlZSwgd2UgbmVlZCB0byBmbGFnIHRoaXMgbm9kZSBhcyBoYXZpbmcgb25lLlxuICAgICAgICAgICAgLy8gRXZlbiB0aG91Z2ggd2UncmUgbm90IGdvaW5nIHRvIHVzZSBpdCBmb3IgYW55dGhpbmcuXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UgcGFyZW50cyB3b24ndCBrbm93IHRoYXQgdGhlcmUgYXJlIG5ldyBjaGlsZHJlbiB0byBwcm9wYWdhdGUgdXB3YXJkcy5cbiAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiBjaGlsZHJlbiBtaWdodCBoYXZlIGNoYW5nZWQsIHdlIGhhdmUgdG8gYWRkIHRoZW0gYWxsIHRvIHRoZSBzZXQuXG4gICAgICAgICAgICBhcHBlbmRBbGxDaGlsZHJlbihuZXdJbnN0YW5jZSwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHVwZGF0ZUhvc3RUZXh0ID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBvbGRUZXh0LCBuZXdUZXh0KSB7XG4gICAgICAgIGlmIChvbGRUZXh0ICE9PSBuZXdUZXh0KSB7XG4gICAgICAgICAgLy8gSWYgdGhlIHRleHQgY29udGVudCBkaWZmZXJzLCB3ZSdsbCBjcmVhdGUgYSBuZXcgdGV4dCBpbnN0YW5jZSBmb3IgaXQuXG4gICAgICAgICAgdmFyIHJvb3RDb250YWluZXJJbnN0YW5jZSA9IGdldFJvb3RIb3N0Q29udGFpbmVyKCk7XG4gICAgICAgICAgdmFyIGN1cnJlbnRIb3N0Q29udGV4dCA9IGdldEhvc3RDb250ZXh0KCk7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3JlYXRlVGV4dEluc3RhbmNlKG5ld1RleHQsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgY3VycmVudEhvc3RDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgLy8gV2UnbGwgaGF2ZSB0byBtYXJrIGl0IGFzIGhhdmluZyBhbiBlZmZlY3QsIGV2ZW4gdGhvdWdoIHdlIHdvbid0IHVzZSB0aGUgZWZmZWN0IGZvciBhbnl0aGluZy5cbiAgICAgICAgICAvLyBUaGlzIGxldHMgdGhlIHBhcmVudHMga25vdyB0aGF0IGF0IGxlYXN0IG9uZSBvZiB0aGVpciBjaGlsZHJlbiBoYXMgY2hhbmdlZC5cbiAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnUGVyc2lzdGVudCByZWNvbmNpbGVyIGlzIGRpc2FibGVkLicpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZW5hYmxlTm9vcFJlY29uY2lsZXIpIHtcbiAgICAgIC8vIE5vIGhvc3Qgb3BlcmF0aW9uc1xuICAgICAgdXBkYXRlSG9zdENvbnRhaW5lciA9IGZ1bmN0aW9uICh3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAvLyBOb29wXG4gICAgICB9O1xuICAgICAgdXBkYXRlSG9zdENvbXBvbmVudCA9IGZ1bmN0aW9uIChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpIHtcbiAgICAgICAgLy8gTm9vcFxuICAgICAgfTtcbiAgICAgIHVwZGF0ZUhvc3RUZXh0ID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBvbGRUZXh0LCBuZXdUZXh0KSB7XG4gICAgICAgIC8vIE5vb3BcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ05vb3AgcmVjb25jaWxlciBpcyBkaXNhYmxlZC4nKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21wbGV0ZVdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gR2V0IHRoZSBsYXRlc3QgcHJvcHMuXG4gICAgdmFyIG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgIGlmIChuZXdQcm9wcyA9PT0gbnVsbCkge1xuICAgICAgbmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICAgIH0gZWxzZSBpZiAod29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgIT09IE5ldmVyIHx8IHJlbmRlckV4cGlyYXRpb25UaW1lID09PSBOZXZlcikge1xuICAgICAgLy8gUmVzZXQgdGhlIHBlbmRpbmcgcHJvcHMsIHVubGVzcyB0aGlzIHdhcyBhIGRvd24tcHJpb3JpdGl6YXRpb24uXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMgPSBudWxsO1xuICAgIH1cblxuICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgICBjYXNlIEZ1bmN0aW9uYWxDb21wb25lbnQ6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIC8vIFdlIGFyZSBsZWF2aW5nIHRoaXMgc3VidHJlZSwgc28gcG9wIGNvbnRleHQgaWYgYW55LlxuICAgICAgICAgIHBvcENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHtcbiAgICAgICAgICBwb3BIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICBwb3BUb3BMZXZlbENvbnRleHRPYmplY3Qod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHZhciBmaWJlclJvb3QgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgICAgaWYgKGZpYmVyUm9vdC5wZW5kaW5nQ29udGV4dCkge1xuICAgICAgICAgICAgZmliZXJSb290LmNvbnRleHQgPSBmaWJlclJvb3QucGVuZGluZ0NvbnRleHQ7XG4gICAgICAgICAgICBmaWJlclJvb3QucGVuZGluZ0NvbnRleHQgPSBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQuY2hpbGQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGh5ZHJhdGVkLCBwb3Agc28gdGhhdCB3ZSBjYW4gZGVsZXRlIGFueSByZW1haW5pbmcgY2hpbGRyZW5cbiAgICAgICAgICAgIC8vIHRoYXQgd2VyZW4ndCBoeWRyYXRlZC5cbiAgICAgICAgICAgIHBvcEh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIC8vIFRoaXMgcmVzZXRzIHRoZSBoYWNreSBzdGF0ZSB0byBmaXggaXNNb3VudGVkIGJlZm9yZSBjb21taXR0aW5nLlxuICAgICAgICAgICAgLy8gVE9ETzogRGVsZXRlIHRoaXMgd2hlbiB3ZSBkZWxldGUgaXNNb3VudGVkIGFuZCBmaW5kRE9NTm9kZS5cbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyAmPSB+UGxhY2VtZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICB1cGRhdGVIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgcG9wSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHZhciByb290Q29udGFpbmVySW5zdGFuY2UgPSBnZXRSb290SG9zdENvbnRhaW5lcigpO1xuICAgICAgICAgIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhbiBhbHRlcm5hdGUsIHRoYXQgbWVhbnMgdGhpcyBpcyBhbiB1cGRhdGUgYW5kIHdlIG5lZWQgdG9cbiAgICAgICAgICAgIC8vIHNjaGVkdWxlIGEgc2lkZS1lZmZlY3QgdG8gZG8gdGhlIHVwZGF0ZXMuXG4gICAgICAgICAgICB2YXIgb2xkUHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICAvLyBJZiB3ZSBnZXQgdXBkYXRlZCBiZWNhdXNlIG9uZSBvZiBvdXIgY2hpbGRyZW4gdXBkYXRlZCwgd2UgZG9uJ3RcbiAgICAgICAgICAgIC8vIGhhdmUgbmV3UHJvcHMgc28gd2UnbGwgaGF2ZSB0byByZXVzZSB0aGVtLlxuICAgICAgICAgICAgLy8gVE9ETzogU3BsaXQgdGhlIHVwZGF0ZSBBUEkgYXMgc2VwYXJhdGUgZm9yIHRoZSBwcm9wcyB2cy4gY2hpbGRyZW4uXG4gICAgICAgICAgICAvLyBFdmVuIGJldHRlciB3b3VsZCBiZSBpZiBjaGlsZHJlbiB3ZXJlbid0IHNwZWNpYWwgY2FzZWQgYXQgYWxsIHRoby5cbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgICAgIHZhciBjdXJyZW50SG9zdENvbnRleHQgPSBnZXRIb3N0Q29udGV4dCgpO1xuICAgICAgICAgICAgdmFyIHVwZGF0ZVBheWxvYWQgPSBwcmVwYXJlVXBkYXRlKGluc3RhbmNlLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgY3VycmVudEhvc3RDb250ZXh0KTtcblxuICAgICAgICAgICAgdXBkYXRlSG9zdENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpO1xuXG4gICAgICAgICAgICBpZiAoY3VycmVudC5yZWYgIT09IHdvcmtJblByb2dyZXNzLnJlZikge1xuICAgICAgICAgICAgICBtYXJrUmVmKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFuZXdQcm9wcykge1xuICAgICAgICAgICAgICAhKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdXZSBtdXN0IGhhdmUgbmV3IHByb3BzIGZvciBuZXcgbW91bnRzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiB3ZSBhYm9ydCB3b3JrLlxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIF9jdXJyZW50SG9zdENvbnRleHQgPSBnZXRIb3N0Q29udGV4dCgpO1xuICAgICAgICAgICAgLy8gVE9ETzogTW92ZSBjcmVhdGVJbnN0YW5jZSB0byBiZWdpbldvcmsgYW5kIGtlZXAgaXQgb24gYSBjb250ZXh0XG4gICAgICAgICAgICAvLyBcInN0YWNrXCIgYXMgdGhlIHBhcmVudC4gVGhlbiBhcHBlbmQgY2hpbGRyZW4gYXMgd2UgZ28gaW4gYmVnaW5Xb3JrXG4gICAgICAgICAgICAvLyBvciBjb21wbGV0ZVdvcmsgZGVwZW5kaW5nIG9uIHdlIHdhbnQgdG8gYWRkIHRoZW4gdG9wLT5kb3duIG9yXG4gICAgICAgICAgICAvLyBib3R0b20tPnVwLiBUb3AtPmRvd24gaXMgZmFzdGVyIGluIElFMTEuXG4gICAgICAgICAgICB2YXIgd2FzSHlkcmF0ZWQgPSBwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICBpZiAod2FzSHlkcmF0ZWQpIHtcbiAgICAgICAgICAgICAgLy8gVE9ETzogTW92ZSB0aGlzIGFuZCBjcmVhdGVJbnN0YW5jZSBzdGVwIGludG8gdGhlIGJlZ2luUGhhc2VcbiAgICAgICAgICAgICAgLy8gdG8gY29uc29saWRhdGUuXG4gICAgICAgICAgICAgIGlmIChwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlKHdvcmtJblByb2dyZXNzLCByb290Q29udGFpbmVySW5zdGFuY2UsIF9jdXJyZW50SG9zdENvbnRleHQpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgY2hhbmdlcyB0byB0aGUgaHlkcmF0ZWQgbm9kZSBuZWVkcyB0byBiZSBhcHBsaWVkIGF0IHRoZVxuICAgICAgICAgICAgICAgIC8vIGNvbW1pdC1waGFzZSB3ZSBtYXJrIHRoaXMgYXMgc3VjaC5cbiAgICAgICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIF9pbnN0YW5jZSA9IGNyZWF0ZUluc3RhbmNlKHR5cGUsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIF9jdXJyZW50SG9zdENvbnRleHQsIHdvcmtJblByb2dyZXNzKTtcblxuICAgICAgICAgICAgICBhcHBlbmRBbGxDaGlsZHJlbihfaW5zdGFuY2UsIHdvcmtJblByb2dyZXNzKTtcblxuICAgICAgICAgICAgICAvLyBDZXJ0YWluIHJlbmRlcmVycyByZXF1aXJlIGNvbW1pdC10aW1lIGVmZmVjdHMgZm9yIGluaXRpYWwgbW91bnQuXG4gICAgICAgICAgICAgIC8vIChlZyBET00gcmVuZGVyZXIgc3VwcG9ydHMgYXV0by1mb2N1cyBmb3IgY2VydGFpbiBlbGVtZW50cykuXG4gICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBzdWNoIHJlbmRlcmVycyBnZXQgc2NoZWR1bGVkIGZvciBsYXRlciB3b3JrLlxuICAgICAgICAgICAgICBpZiAoZmluYWxpemVJbml0aWFsQ2hpbGRyZW4oX2luc3RhbmNlLCB0eXBlLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlKSkge1xuICAgICAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IF9pbnN0YW5jZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLnJlZiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIHJlZiBvbiBhIGhvc3Qgbm9kZSB3ZSBuZWVkIHRvIHNjaGVkdWxlIGEgY2FsbGJhY2tcbiAgICAgICAgICAgICAgbWFya1JlZih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIG5ld1RleHQgPSBuZXdQcm9wcztcbiAgICAgICAgICBpZiAoY3VycmVudCAmJiB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIG9sZFRleHQgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGFuIGFsdGVybmF0ZSwgdGhhdCBtZWFucyB0aGlzIGlzIGFuIHVwZGF0ZSBhbmQgd2UgbmVlZFxuICAgICAgICAgICAgLy8gdG8gc2NoZWR1bGUgYSBzaWRlLWVmZmVjdCB0byBkbyB0aGUgdXBkYXRlcy5cbiAgICAgICAgICAgIHVwZGF0ZUhvc3RUZXh0KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBvbGRUZXh0LCBuZXdUZXh0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBuZXdUZXh0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAhKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdXZSBtdXN0IGhhdmUgbmV3IHByb3BzIGZvciBuZXcgbW91bnRzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiB3ZSBhYm9ydCB3b3JrLlxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfcm9vdENvbnRhaW5lckluc3RhbmNlID0gZ2V0Um9vdEhvc3RDb250YWluZXIoKTtcbiAgICAgICAgICAgIHZhciBfY3VycmVudEhvc3RDb250ZXh0MiA9IGdldEhvc3RDb250ZXh0KCk7XG4gICAgICAgICAgICB2YXIgX3dhc0h5ZHJhdGVkID0gcG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgaWYgKF93YXNIeWRyYXRlZCkge1xuICAgICAgICAgICAgICBpZiAocHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpKSB7XG4gICAgICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGNyZWF0ZVRleHRJbnN0YW5jZShuZXdUZXh0LCBfcm9vdENvbnRhaW5lckluc3RhbmNlLCBfY3VycmVudEhvc3RDb250ZXh0Miwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgY2FzZSBDYWxsQ29tcG9uZW50OlxuICAgICAgICByZXR1cm4gbW92ZUNhbGxUb0hhbmRsZXJQaGFzZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgY2FzZSBDYWxsSGFuZGxlclBoYXNlOlxuICAgICAgICAvLyBSZXNldCB0aGUgdGFnIHRvIG5vdyBiZSBhIGZpcnN0IHBoYXNlIGNhbGwuXG4gICAgICAgIHdvcmtJblByb2dyZXNzLnRhZyA9IENhbGxDb21wb25lbnQ7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgY2FzZSBSZXR1cm5Db21wb25lbnQ6XG4gICAgICAgIC8vIERvZXMgbm90aGluZy5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBjYXNlIEZyYWdtZW50OlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAgcG9wSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHVwZGF0ZUhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIC8vIEVycm9yIGNhc2VzXG4gICAgICBjYXNlIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6XG4gICAgICAgIGludmFyaWFudChmYWxzZSwgJ0FuIGluZGV0ZXJtaW5hdGUgY29tcG9uZW50IHNob3VsZCBoYXZlIGJlY29tZSBkZXRlcm1pbmF0ZSBiZWZvcmUgY29tcGxldGluZy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnVW5rbm93biB1bml0IG9mIHdvcmsgdGFnLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY29tcGxldGVXb3JrOiBjb21wbGV0ZVdvcmtcbiAgfTtcbn07XG5cbnZhciBpbnZva2VHdWFyZGVkQ2FsbGJhY2skMiA9IFJlYWN0RXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2s7XG52YXIgaGFzQ2F1Z2h0RXJyb3IkMSA9IFJlYWN0RXJyb3JVdGlscy5oYXNDYXVnaHRFcnJvcjtcbnZhciBjbGVhckNhdWdodEVycm9yJDEgPSBSZWFjdEVycm9yVXRpbHMuY2xlYXJDYXVnaHRFcnJvcjtcblxuXG52YXIgUmVhY3RGaWJlckNvbW1pdFdvcmsgPSBmdW5jdGlvbiAoY29uZmlnLCBjYXB0dXJlRXJyb3IpIHtcbiAgdmFyIGdldFB1YmxpY0luc3RhbmNlID0gY29uZmlnLmdldFB1YmxpY0luc3RhbmNlLFxuICAgICAgbXV0YXRpb24gPSBjb25maWcubXV0YXRpb24sXG4gICAgICBwZXJzaXN0ZW5jZSA9IGNvbmZpZy5wZXJzaXN0ZW5jZTtcblxuXG4gIHZhciBjYWxsQ29tcG9uZW50V2lsbFVubW91bnRXaXRoVGltZXIgPSBmdW5jdGlvbiAoY3VycmVudCwgaW5zdGFuY2UpIHtcbiAgICBzdGFydFBoYXNlVGltZXIoY3VycmVudCwgJ2NvbXBvbmVudFdpbGxVbm1vdW50Jyk7XG4gICAgaW5zdGFuY2UucHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgaW5zdGFuY2Uuc3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVubW91bnQoKTtcbiAgICBzdG9wUGhhc2VUaW1lcigpO1xuICB9O1xuXG4gIC8vIENhcHR1cmUgZXJyb3JzIHNvIHRoZXkgZG9uJ3QgaW50ZXJydXB0IHVubW91bnRpbmcuXG4gIGZ1bmN0aW9uIHNhZmVseUNhbGxDb21wb25lbnRXaWxsVW5tb3VudChjdXJyZW50LCBpbnN0YW5jZSkge1xuICAgIHtcbiAgICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayQyKG51bGwsIGNhbGxDb21wb25lbnRXaWxsVW5tb3VudFdpdGhUaW1lciwgbnVsbCwgY3VycmVudCwgaW5zdGFuY2UpO1xuICAgICAgaWYgKGhhc0NhdWdodEVycm9yJDEoKSkge1xuICAgICAgICB2YXIgdW5tb3VudEVycm9yID0gY2xlYXJDYXVnaHRFcnJvciQxKCk7XG4gICAgICAgIGNhcHR1cmVFcnJvcihjdXJyZW50LCB1bm1vdW50RXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNhZmVseURldGFjaFJlZihjdXJyZW50KSB7XG4gICAgdmFyIHJlZiA9IGN1cnJlbnQucmVmO1xuICAgIGlmIChyZWYgIT09IG51bGwpIHtcbiAgICAgIHtcbiAgICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrJDIobnVsbCwgcmVmLCBudWxsLCBudWxsKTtcbiAgICAgICAgaWYgKGhhc0NhdWdodEVycm9yJDEoKSkge1xuICAgICAgICAgIHZhciByZWZFcnJvciA9IGNsZWFyQ2F1Z2h0RXJyb3IkMSgpO1xuICAgICAgICAgIGNhcHR1cmVFcnJvcihjdXJyZW50LCByZWZFcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21taXRMaWZlQ3ljbGVzKGN1cnJlbnQsIGZpbmlzaGVkV29yaykge1xuICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgaWYgKGZpbmlzaGVkV29yay5lZmZlY3RUYWcgJiBVcGRhdGUpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHN0YXJ0UGhhc2VUaW1lcihmaW5pc2hlZFdvcmssICdjb21wb25lbnREaWRNb3VudCcpO1xuICAgICAgICAgICAgICBpbnN0YW5jZS5wcm9wcyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgICBpbnN0YW5jZS5zdGF0ZSA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCgpO1xuICAgICAgICAgICAgICBzdG9wUGhhc2VUaW1lcigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIHByZXZQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgICAgdmFyIHByZXZTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICAgICAgc3RhcnRQaGFzZVRpbWVyKGZpbmlzaGVkV29yaywgJ2NvbXBvbmVudERpZFVwZGF0ZScpO1xuICAgICAgICAgICAgICBpbnN0YW5jZS5wcm9wcyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgICBpbnN0YW5jZS5zdGF0ZSA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzLCBwcmV2U3RhdGUpO1xuICAgICAgICAgICAgICBzdG9wUGhhc2VUaW1lcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdXBkYXRlUXVldWUgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWU7XG4gICAgICAgICAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb21taXRDYWxsYmFja3ModXBkYXRlUXVldWUsIGluc3RhbmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF91cGRhdGVRdWV1ZSA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcbiAgICAgICAgICBpZiAoX3VwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgX2luc3RhbmNlID0gZmluaXNoZWRXb3JrLmNoaWxkICE9PSBudWxsID8gZmluaXNoZWRXb3JrLmNoaWxkLnN0YXRlTm9kZSA6IG51bGw7XG4gICAgICAgICAgICBjb21taXRDYWxsYmFja3MoX3VwZGF0ZVF1ZXVlLCBfaW5zdGFuY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfaW5zdGFuY2UyID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcblxuICAgICAgICAgIC8vIFJlbmRlcmVycyBtYXkgc2NoZWR1bGUgd29yayB0byBiZSBkb25lIGFmdGVyIGhvc3QgY29tcG9uZW50cyBhcmUgbW91bnRlZFxuICAgICAgICAgIC8vIChlZyBET00gcmVuZGVyZXIgbWF5IHNjaGVkdWxlIGF1dG8tZm9jdXMgZm9yIGlucHV0cyBhbmQgZm9ybSBjb250cm9scykuXG4gICAgICAgICAgLy8gVGhlc2UgZWZmZWN0cyBzaG91bGQgb25seSBiZSBjb21taXR0ZWQgd2hlbiBjb21wb25lbnRzIGFyZSBmaXJzdCBtb3VudGVkLFxuICAgICAgICAgIC8vIGFrYSB3aGVuIHRoZXJlIGlzIG5vIGN1cnJlbnQvYWx0ZXJuYXRlLlxuICAgICAgICAgIGlmIChjdXJyZW50ID09PSBudWxsICYmIGZpbmlzaGVkV29yay5lZmZlY3RUYWcgJiBVcGRhdGUpIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gZmluaXNoZWRXb3JrLnR5cGU7XG4gICAgICAgICAgICB2YXIgcHJvcHMgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgIGNvbW1pdE1vdW50KF9pbnN0YW5jZTIsIHR5cGUsIHByb3BzLCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgICAge1xuICAgICAgICAgIC8vIFdlIGhhdmUgbm8gbGlmZS1jeWNsZXMgYXNzb2NpYXRlZCB3aXRoIHRleHQuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBXZSBoYXZlIG5vIGxpZmUtY3ljbGVzIGFzc29jaWF0ZWQgd2l0aCBwb3J0YWxzLlxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIGludmFyaWFudChmYWxzZSwgJ1RoaXMgdW5pdCBvZiB3b3JrIHRhZyBzaG91bGQgbm90IGhhdmUgc2lkZS1lZmZlY3RzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0QXR0YWNoUmVmKGZpbmlzaGVkV29yaykge1xuICAgIHZhciByZWYgPSBmaW5pc2hlZFdvcmsucmVmO1xuICAgIGlmIChyZWYgIT09IG51bGwpIHtcbiAgICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgIHJlZihnZXRQdWJsaWNJbnN0YW5jZShpbnN0YW5jZSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlZihpbnN0YW5jZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0RGV0YWNoUmVmKGN1cnJlbnQpIHtcbiAgICB2YXIgY3VycmVudFJlZiA9IGN1cnJlbnQucmVmO1xuICAgIGlmIChjdXJyZW50UmVmICE9PSBudWxsKSB7XG4gICAgICBjdXJyZW50UmVmKG51bGwpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFVzZXItb3JpZ2luYXRpbmcgZXJyb3JzIChsaWZlY3ljbGVzIGFuZCByZWZzKSBzaG91bGQgbm90IGludGVycnVwdFxuICAvLyBkZWxldGlvbiwgc28gZG9uJ3QgbGV0IHRoZW0gdGhyb3cuIEhvc3Qtb3JpZ2luYXRpbmcgZXJyb3JzIHNob3VsZFxuICAvLyBpbnRlcnJ1cHQgZGVsZXRpb24sIHNvIGl0J3Mgb2theVxuICBmdW5jdGlvbiBjb21taXRVbm1vdW50KGN1cnJlbnQpIHtcbiAgICBpZiAodHlwZW9mIG9uQ29tbWl0VW5tb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgb25Db21taXRVbm1vdW50KGN1cnJlbnQpO1xuICAgIH1cblxuICAgIHN3aXRjaCAoY3VycmVudC50YWcpIHtcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICBzYWZlbHlEZXRhY2hSZWYoY3VycmVudCk7XG4gICAgICAgICAgdmFyIGluc3RhbmNlID0gY3VycmVudC5zdGF0ZU5vZGU7XG4gICAgICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVW5tb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgc2FmZWx5Q2FsbENvbXBvbmVudFdpbGxVbm1vdW50KGN1cnJlbnQsIGluc3RhbmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICBzYWZlbHlEZXRhY2hSZWYoY3VycmVudCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIENhbGxDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICBjb21taXROZXN0ZWRVbm1vdW50cyhjdXJyZW50LnN0YXRlTm9kZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBUT0RPOiB0aGlzIGlzIHJlY3Vyc2l2ZS5cbiAgICAgICAgICAvLyBXZSBhcmUgYWxzbyBub3QgdXNpbmcgdGhpcyBwYXJlbnQgYmVjYXVzZVxuICAgICAgICAgIC8vIHRoZSBwb3J0YWwgd2lsbCBnZXQgcHVzaGVkIGltbWVkaWF0ZWx5LlxuICAgICAgICAgIGlmIChlbmFibGVNdXRhdGluZ1JlY29uY2lsZXIgJiYgbXV0YXRpb24pIHtcbiAgICAgICAgICAgIHVubW91bnRIb3N0Q29tcG9uZW50cyhjdXJyZW50KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGVuYWJsZVBlcnNpc3RlbnRSZWNvbmNpbGVyICYmIHBlcnNpc3RlbmNlKSB7XG4gICAgICAgICAgICBlbXB0eVBvcnRhbENvbnRhaW5lcihjdXJyZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0TmVzdGVkVW5tb3VudHMocm9vdCkge1xuICAgIC8vIFdoaWxlIHdlJ3JlIGluc2lkZSBhIHJlbW92ZWQgaG9zdCBub2RlIHdlIGRvbid0IHdhbnQgdG8gY2FsbFxuICAgIC8vIHJlbW92ZUNoaWxkIG9uIHRoZSBpbm5lciBub2RlcyBiZWNhdXNlIHRoZXkncmUgcmVtb3ZlZCBieSB0aGUgdG9wXG4gICAgLy8gY2FsbCBhbnl3YXkuIFdlIGFsc28gd2FudCB0byBjYWxsIGNvbXBvbmVudFdpbGxVbm1vdW50IG9uIGFsbFxuICAgIC8vIGNvbXBvc2l0ZXMgYmVmb3JlIHRoaXMgaG9zdCBub2RlIGlzIHJlbW92ZWQgZnJvbSB0aGUgdHJlZS4gVGhlcmVmb3JlXG4gICAgdmFyIG5vZGUgPSByb290O1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjb21taXRVbm1vdW50KG5vZGUpO1xuICAgICAgLy8gVmlzaXQgY2hpbGRyZW4gYmVjYXVzZSB0aGV5IG1heSBjb250YWluIG1vcmUgY29tcG9zaXRlIG9yIGhvc3Qgbm9kZXMuXG4gICAgICAvLyBTa2lwIHBvcnRhbHMgYmVjYXVzZSBjb21taXRVbm1vdW50KCkgY3VycmVudGx5IHZpc2l0cyB0aGVtIHJlY3Vyc2l2ZWx5LlxuICAgICAgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwgJiYgKFxuICAgICAgLy8gSWYgd2UgdXNlIG11dGF0aW9uIHdlIGRyaWxsIGRvd24gaW50byBwb3J0YWxzIHVzaW5nIGNvbW1pdFVubW91bnQgYWJvdmUuXG4gICAgICAvLyBJZiB3ZSBkb24ndCB1c2UgbXV0YXRpb24gd2UgZHJpbGwgZG93biBpbnRvIHBvcnRhbHMgaGVyZSBpbnN0ZWFkLlxuICAgICAgIW11dGF0aW9uIHx8IG5vZGUudGFnICE9PSBIb3N0UG9ydGFsKSkge1xuICAgICAgICBub2RlLmNoaWxkWydyZXR1cm4nXSA9IG5vZGU7XG4gICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlID09PSByb290KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGVbJ3JldHVybiddID09PSBudWxsIHx8IG5vZGVbJ3JldHVybiddID09PSByb290KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICAgIH1cbiAgICAgIG5vZGUuc2libGluZ1sncmV0dXJuJ10gPSBub2RlWydyZXR1cm4nXTtcbiAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGV0YWNoRmliZXIoY3VycmVudCkge1xuICAgIC8vIEN1dCBvZmYgdGhlIHJldHVybiBwb2ludGVycyB0byBkaXNjb25uZWN0IGl0IGZyb20gdGhlIHRyZWUuIElkZWFsbHksIHdlXG4gICAgLy8gc2hvdWxkIGNsZWFyIHRoZSBjaGlsZCBwb2ludGVyIG9mIHRoZSBwYXJlbnQgYWx0ZXJuYXRlIHRvIGxldCB0aGlzXG4gICAgLy8gZ2V0IEdDOmVkIGJ1dCB3ZSBkb24ndCBrbm93IHdoaWNoIGZvciBzdXJlIHdoaWNoIHBhcmVudCBpcyB0aGUgY3VycmVudFxuICAgIC8vIG9uZSBzbyB3ZSdsbCBzZXR0bGUgZm9yIEdDOmluZyB0aGUgc3VidHJlZSBvZiB0aGlzIGNoaWxkLiBUaGlzIGNoaWxkXG4gICAgLy8gaXRzZWxmIHdpbGwgYmUgR0M6ZWQgd2hlbiB0aGUgcGFyZW50IHVwZGF0ZXMgdGhlIG5leHQgdGltZS5cbiAgICBjdXJyZW50WydyZXR1cm4nXSA9IG51bGw7XG4gICAgY3VycmVudC5jaGlsZCA9IG51bGw7XG4gICAgaWYgKGN1cnJlbnQuYWx0ZXJuYXRlKSB7XG4gICAgICBjdXJyZW50LmFsdGVybmF0ZS5jaGlsZCA9IG51bGw7XG4gICAgICBjdXJyZW50LmFsdGVybmF0ZVsncmV0dXJuJ10gPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGlmICghbXV0YXRpb24pIHtcbiAgICB2YXIgY29tbWl0Q29udGFpbmVyID0gdm9pZCAwO1xuICAgIGlmIChwZXJzaXN0ZW5jZSkge1xuICAgICAgdmFyIHJlcGxhY2VDb250YWluZXJDaGlsZHJlbiA9IHBlcnNpc3RlbmNlLnJlcGxhY2VDb250YWluZXJDaGlsZHJlbixcbiAgICAgICAgICBjcmVhdGVDb250YWluZXJDaGlsZFNldCA9IHBlcnNpc3RlbmNlLmNyZWF0ZUNvbnRhaW5lckNoaWxkU2V0O1xuXG4gICAgICB2YXIgZW1wdHlQb3J0YWxDb250YWluZXIgPSBmdW5jdGlvbiAoY3VycmVudCkge1xuICAgICAgICB2YXIgcG9ydGFsID0gY3VycmVudC5zdGF0ZU5vZGU7XG4gICAgICAgIHZhciBjb250YWluZXJJbmZvID0gcG9ydGFsLmNvbnRhaW5lckluZm87XG5cbiAgICAgICAgdmFyIGVtcHR5Q2hpbGRTZXQgPSBjcmVhdGVDb250YWluZXJDaGlsZFNldChjb250YWluZXJJbmZvKTtcbiAgICAgICAgcmVwbGFjZUNvbnRhaW5lckNoaWxkcmVuKGNvbnRhaW5lckluZm8sIGVtcHR5Q2hpbGRTZXQpO1xuICAgICAgfTtcbiAgICAgIGNvbW1pdENvbnRhaW5lciA9IGZ1bmN0aW9uIChmaW5pc2hlZFdvcmspIHtcbiAgICAgICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIHBvcnRhbE9yUm9vdCA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgIHZhciBjb250YWluZXJJbmZvID0gcG9ydGFsT3JSb290LmNvbnRhaW5lckluZm8sXG4gICAgICAgICAgICAgICAgICBfcGVuZGluZ0NoaWxkcmVuID0gcG9ydGFsT3JSb290LnBlbmRpbmdDaGlsZHJlbjtcblxuICAgICAgICAgICAgICByZXBsYWNlQ29udGFpbmVyQ2hpbGRyZW4oY29udGFpbmVySW5mbywgX3BlbmRpbmdDaGlsZHJlbik7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdUaGlzIHVuaXQgb2Ygd29yayB0YWcgc2hvdWxkIG5vdCBoYXZlIHNpZGUtZWZmZWN0cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29tbWl0Q29udGFpbmVyID0gZnVuY3Rpb24gKGZpbmlzaGVkV29yaykge1xuICAgICAgICAvLyBOb29wXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoZW5hYmxlUGVyc2lzdGVudFJlY29uY2lsZXIgfHwgZW5hYmxlTm9vcFJlY29uY2lsZXIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbW1pdFJlc2V0VGV4dENvbnRlbnQ6IGZ1bmN0aW9uIChmaW5pc2hlZFdvcmspIHt9LFxuICAgICAgICBjb21taXRQbGFjZW1lbnQ6IGZ1bmN0aW9uIChmaW5pc2hlZFdvcmspIHt9LFxuICAgICAgICBjb21taXREZWxldGlvbjogZnVuY3Rpb24gKGN1cnJlbnQpIHtcbiAgICAgICAgICAvLyBEZXRhY2ggcmVmcyBhbmQgY2FsbCBjb21wb25lbnRXaWxsVW5tb3VudCgpIG9uIHRoZSB3aG9sZSBzdWJ0cmVlLlxuICAgICAgICAgIGNvbW1pdE5lc3RlZFVubW91bnRzKGN1cnJlbnQpO1xuICAgICAgICAgIGRldGFjaEZpYmVyKGN1cnJlbnQpO1xuICAgICAgICB9LFxuICAgICAgICBjb21taXRXb3JrOiBmdW5jdGlvbiAoY3VycmVudCwgZmluaXNoZWRXb3JrKSB7XG4gICAgICAgICAgY29tbWl0Q29udGFpbmVyKGZpbmlzaGVkV29yayk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY29tbWl0TGlmZUN5Y2xlczogY29tbWl0TGlmZUN5Y2xlcyxcbiAgICAgICAgY29tbWl0QXR0YWNoUmVmOiBjb21taXRBdHRhY2hSZWYsXG4gICAgICAgIGNvbW1pdERldGFjaFJlZjogY29tbWl0RGV0YWNoUmVmXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAocGVyc2lzdGVuY2UpIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ1BlcnNpc3RlbnQgcmVjb25jaWxlciBpcyBkaXNhYmxlZC4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnTm9vcCByZWNvbmNpbGVyIGlzIGRpc2FibGVkLicpO1xuICAgIH1cbiAgfVxuICB2YXIgY29tbWl0TW91bnQgPSBtdXRhdGlvbi5jb21taXRNb3VudCxcbiAgICAgIGNvbW1pdFVwZGF0ZSA9IG11dGF0aW9uLmNvbW1pdFVwZGF0ZSxcbiAgICAgIHJlc2V0VGV4dENvbnRlbnQgPSBtdXRhdGlvbi5yZXNldFRleHRDb250ZW50LFxuICAgICAgY29tbWl0VGV4dFVwZGF0ZSA9IG11dGF0aW9uLmNvbW1pdFRleHRVcGRhdGUsXG4gICAgICBhcHBlbmRDaGlsZCA9IG11dGF0aW9uLmFwcGVuZENoaWxkLFxuICAgICAgYXBwZW5kQ2hpbGRUb0NvbnRhaW5lciA9IG11dGF0aW9uLmFwcGVuZENoaWxkVG9Db250YWluZXIsXG4gICAgICBpbnNlcnRCZWZvcmUgPSBtdXRhdGlvbi5pbnNlcnRCZWZvcmUsXG4gICAgICBpbnNlcnRJbkNvbnRhaW5lckJlZm9yZSA9IG11dGF0aW9uLmluc2VydEluQ29udGFpbmVyQmVmb3JlLFxuICAgICAgcmVtb3ZlQ2hpbGQgPSBtdXRhdGlvbi5yZW1vdmVDaGlsZCxcbiAgICAgIHJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lciA9IG11dGF0aW9uLnJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lcjtcblxuXG4gIGZ1bmN0aW9uIGdldEhvc3RQYXJlbnRGaWJlcihmaWJlcikge1xuICAgIHZhciBwYXJlbnQgPSBmaWJlclsncmV0dXJuJ107XG4gICAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGlzSG9zdFBhcmVudChwYXJlbnQpKSB7XG4gICAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBwYXJlbnRbJ3JldHVybiddO1xuICAgIH1cbiAgICBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCB0byBmaW5kIGEgaG9zdCBwYXJlbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0hvc3RQYXJlbnQoZmliZXIpIHtcbiAgICByZXR1cm4gZmliZXIudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IGZpYmVyLnRhZyA9PT0gSG9zdFJvb3QgfHwgZmliZXIudGFnID09PSBIb3N0UG9ydGFsO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SG9zdFNpYmxpbmcoZmliZXIpIHtcbiAgICAvLyBXZSdyZSBnb2luZyB0byBzZWFyY2ggZm9yd2FyZCBpbnRvIHRoZSB0cmVlIHVudGlsIHdlIGZpbmQgYSBzaWJsaW5nIGhvc3RcbiAgICAvLyBub2RlLiBVbmZvcnR1bmF0ZWx5LCBpZiBtdWx0aXBsZSBpbnNlcnRpb25zIGFyZSBkb25lIGluIGEgcm93IHdlIGhhdmUgdG9cbiAgICAvLyBzZWFyY2ggcGFzdCB0aGVtLiBUaGlzIGxlYWRzIHRvIGV4cG9uZW50aWFsIHNlYXJjaCBmb3IgdGhlIG5leHQgc2libGluZy5cbiAgICB2YXIgbm9kZSA9IGZpYmVyO1xuICAgIHNpYmxpbmdzOiB3aGlsZSAodHJ1ZSkge1xuICAgICAgLy8gSWYgd2UgZGlkbid0IGZpbmQgYW55dGhpbmcsIGxldCdzIHRyeSB0aGUgbmV4dCBzaWJsaW5nLlxuICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZVsncmV0dXJuJ10gPT09IG51bGwgfHwgaXNIb3N0UGFyZW50KG5vZGVbJ3JldHVybiddKSkge1xuICAgICAgICAgIC8vIElmIHdlIHBvcCBvdXQgb2YgdGhlIHJvb3Qgb3IgaGl0IHRoZSBwYXJlbnQgdGhlIGZpYmVyIHdlIGFyZSB0aGVcbiAgICAgICAgICAvLyBsYXN0IHNpYmxpbmcuXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgfVxuICAgICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICAgIHdoaWxlIChub2RlLnRhZyAhPT0gSG9zdENvbXBvbmVudCAmJiBub2RlLnRhZyAhPT0gSG9zdFRleHQpIHtcbiAgICAgICAgLy8gSWYgaXQgaXMgbm90IGhvc3Qgbm9kZSBhbmQsIHdlIG1pZ2h0IGhhdmUgYSBob3N0IG5vZGUgaW5zaWRlIGl0LlxuICAgICAgICAvLyBUcnkgdG8gc2VhcmNoIGRvd24gdW50aWwgd2UgZmluZCBvbmUuXG4gICAgICAgIGlmIChub2RlLmVmZmVjdFRhZyAmIFBsYWNlbWVudCkge1xuICAgICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBjaGlsZCwgdHJ5IHRoZSBzaWJsaW5ncyBpbnN0ZWFkLlxuICAgICAgICAgIGNvbnRpbnVlIHNpYmxpbmdzO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBjaGlsZCwgdHJ5IHRoZSBzaWJsaW5ncyBpbnN0ZWFkLlxuICAgICAgICAvLyBXZSBhbHNvIHNraXAgcG9ydGFscyBiZWNhdXNlIHRoZXkgYXJlIG5vdCBwYXJ0IG9mIHRoaXMgaG9zdCB0cmVlLlxuICAgICAgICBpZiAobm9kZS5jaGlsZCA9PT0gbnVsbCB8fCBub2RlLnRhZyA9PT0gSG9zdFBvcnRhbCkge1xuICAgICAgICAgIGNvbnRpbnVlIHNpYmxpbmdzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUuY2hpbGRbJ3JldHVybiddID0gbm9kZTtcbiAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBob3N0IG5vZGUgaXMgc3RhYmxlIG9yIGFib3V0IHRvIGJlIHBsYWNlZC5cbiAgICAgIGlmICghKG5vZGUuZWZmZWN0VGFnICYgUGxhY2VtZW50KSkge1xuICAgICAgICAvLyBGb3VuZCBpdCFcbiAgICAgICAgcmV0dXJuIG5vZGUuc3RhdGVOb2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbW1pdFBsYWNlbWVudChmaW5pc2hlZFdvcmspIHtcbiAgICAvLyBSZWN1cnNpdmVseSBpbnNlcnQgYWxsIGhvc3Qgbm9kZXMgaW50byB0aGUgcGFyZW50LlxuICAgIHZhciBwYXJlbnRGaWJlciA9IGdldEhvc3RQYXJlbnRGaWJlcihmaW5pc2hlZFdvcmspO1xuICAgIHZhciBwYXJlbnQgPSB2b2lkIDA7XG4gICAgdmFyIGlzQ29udGFpbmVyID0gdm9pZCAwO1xuICAgIHN3aXRjaCAocGFyZW50RmliZXIudGFnKSB7XG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIHBhcmVudCA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgaXNDb250YWluZXIgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICBwYXJlbnQgPSBwYXJlbnRGaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgaXNDb250YWluZXIgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAgcGFyZW50ID0gcGFyZW50RmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgIGlzQ29udGFpbmVyID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdJbnZhbGlkIGhvc3QgcGFyZW50IGZpYmVyLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgICBpZiAocGFyZW50RmliZXIuZWZmZWN0VGFnICYgQ29udGVudFJlc2V0KSB7XG4gICAgICAvLyBSZXNldCB0aGUgdGV4dCBjb250ZW50IG9mIHRoZSBwYXJlbnQgYmVmb3JlIGRvaW5nIGFueSBpbnNlcnRpb25zXG4gICAgICByZXNldFRleHRDb250ZW50KHBhcmVudCk7XG4gICAgICAvLyBDbGVhciBDb250ZW50UmVzZXQgZnJvbSB0aGUgZWZmZWN0IHRhZ1xuICAgICAgcGFyZW50RmliZXIuZWZmZWN0VGFnICY9IH5Db250ZW50UmVzZXQ7XG4gICAgfVxuXG4gICAgdmFyIGJlZm9yZSA9IGdldEhvc3RTaWJsaW5nKGZpbmlzaGVkV29yayk7XG4gICAgLy8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgaW5zZXJ0ZWQgYnV0IHdlIG5lZWQgcmVjdXJzZSBkb3duIGl0c1xuICAgIC8vIGNoaWxkcmVuIHRvIGZpbmQgYWxsIHRoZSB0ZXJtaW5hbCBub2Rlcy5cbiAgICB2YXIgbm9kZSA9IGZpbmlzaGVkV29yaztcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IG5vZGUudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgICBpZiAoYmVmb3JlKSB7XG4gICAgICAgICAgaWYgKGlzQ29udGFpbmVyKSB7XG4gICAgICAgICAgICBpbnNlcnRJbkNvbnRhaW5lckJlZm9yZShwYXJlbnQsIG5vZGUuc3RhdGVOb2RlLCBiZWZvcmUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnNlcnRCZWZvcmUocGFyZW50LCBub2RlLnN0YXRlTm9kZSwgYmVmb3JlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGlzQ29udGFpbmVyKSB7XG4gICAgICAgICAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyKHBhcmVudCwgbm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcHBlbmRDaGlsZChwYXJlbnQsIG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgICAgLy8gSWYgdGhlIGluc2VydGlvbiBpdHNlbGYgaXMgYSBwb3J0YWwsIHRoZW4gd2UgZG9uJ3Qgd2FudCB0byB0cmF2ZXJzZVxuICAgICAgICAvLyBkb3duIGl0cyBjaGlsZHJlbi4gSW5zdGVhZCwgd2UnbGwgZ2V0IGluc2VydGlvbnMgZnJvbSBlYWNoIGNoaWxkIGluXG4gICAgICAgIC8vIHRoZSBwb3J0YWwgZGlyZWN0bHkuXG4gICAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgbm9kZS5jaGlsZFsncmV0dXJuJ10gPSBub2RlO1xuICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAobm9kZSA9PT0gZmluaXNoZWRXb3JrKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGVbJ3JldHVybiddID09PSBudWxsIHx8IG5vZGVbJ3JldHVybiddID09PSBmaW5pc2hlZFdvcmspIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgfVxuICAgICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1bm1vdW50SG9zdENvbXBvbmVudHMoY3VycmVudCkge1xuICAgIC8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGluc2VydGVkIGJ1dCB3ZSBuZWVkIHJlY3Vyc2UgZG93biBpdHNcbiAgICB2YXIgbm9kZSA9IGN1cnJlbnQ7XG5cbiAgICAvLyBFYWNoIGl0ZXJhdGlvbiwgY3VycmVudFBhcmVudCBpcyBwb3B1bGF0ZWQgd2l0aCBub2RlJ3MgaG9zdCBwYXJlbnQgaWYgbm90XG4gICAgLy8gY3VycmVudFBhcmVudElzVmFsaWQuXG4gICAgdmFyIGN1cnJlbnRQYXJlbnRJc1ZhbGlkID0gZmFsc2U7XG4gICAgdmFyIGN1cnJlbnRQYXJlbnQgPSB2b2lkIDA7XG4gICAgdmFyIGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lciA9IHZvaWQgMDtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAoIWN1cnJlbnRQYXJlbnRJc1ZhbGlkKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSBub2RlWydyZXR1cm4nXTtcbiAgICAgICAgZmluZFBhcmVudDogd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAhKHBhcmVudCAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCB0byBmaW5kIGEgaG9zdCBwYXJlbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICAgICAgc3dpdGNoIChwYXJlbnQudGFnKSB7XG4gICAgICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBwYXJlbnQuc3RhdGVOb2RlO1xuICAgICAgICAgICAgICBjdXJyZW50UGFyZW50SXNDb250YWluZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWsgZmluZFBhcmVudDtcbiAgICAgICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBwYXJlbnQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lciA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrIGZpbmRQYXJlbnQ7XG4gICAgICAgICAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBwYXJlbnQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lciA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrIGZpbmRQYXJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcmVudCA9IHBhcmVudFsncmV0dXJuJ107XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFBhcmVudElzVmFsaWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICAgIGNvbW1pdE5lc3RlZFVubW91bnRzKG5vZGUpO1xuICAgICAgICAvLyBBZnRlciBhbGwgdGhlIGNoaWxkcmVuIGhhdmUgdW5tb3VudGVkLCBpdCBpcyBub3cgc2FmZSB0byByZW1vdmUgdGhlXG4gICAgICAgIC8vIG5vZGUgZnJvbSB0aGUgdHJlZS5cbiAgICAgICAgaWYgKGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lcikge1xuICAgICAgICAgIHJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lcihjdXJyZW50UGFyZW50LCBub2RlLnN0YXRlTm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVtb3ZlQ2hpbGQoY3VycmVudFBhcmVudCwgbm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvbid0IHZpc2l0IGNoaWxkcmVuIGJlY2F1c2Ugd2UgYWxyZWFkeSB2aXNpdGVkIHRoZW0uXG4gICAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAgIC8vIFdoZW4gd2UgZ28gaW50byBhIHBvcnRhbCwgaXQgYmVjb21lcyB0aGUgcGFyZW50IHRvIHJlbW92ZSBmcm9tLlxuICAgICAgICAvLyBXZSB3aWxsIHJlYXNzaWduIGl0IGJhY2sgd2hlbiB3ZSBwb3AgdGhlIHBvcnRhbCBvbiB0aGUgd2F5IHVwLlxuICAgICAgICBjdXJyZW50UGFyZW50ID0gbm9kZS5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgLy8gVmlzaXQgY2hpbGRyZW4gYmVjYXVzZSBwb3J0YWxzIG1pZ2h0IGNvbnRhaW4gaG9zdCBjb21wb25lbnRzLlxuICAgICAgICBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgIG5vZGUuY2hpbGRbJ3JldHVybiddID0gbm9kZTtcbiAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29tbWl0VW5tb3VudChub2RlKTtcbiAgICAgICAgLy8gVmlzaXQgY2hpbGRyZW4gYmVjYXVzZSB3ZSBtYXkgZmluZCBtb3JlIGhvc3QgY29tcG9uZW50cyBiZWxvdy5cbiAgICAgICAgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICBub2RlLmNoaWxkWydyZXR1cm4nXSA9IG5vZGU7XG4gICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChub2RlID09PSBjdXJyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGVbJ3JldHVybiddID09PSBudWxsIHx8IG5vZGVbJ3JldHVybiddID09PSBjdXJyZW50KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICAgICAgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAgICAgLy8gV2hlbiB3ZSBnbyBvdXQgb2YgdGhlIHBvcnRhbCwgd2UgbmVlZCB0byByZXN0b3JlIHRoZSBwYXJlbnQuXG4gICAgICAgICAgLy8gU2luY2Ugd2UgZG9uJ3Qga2VlcCBhIHN0YWNrIG9mIHRoZW0sIHdlIHdpbGwgc2VhcmNoIGZvciBpdC5cbiAgICAgICAgICBjdXJyZW50UGFyZW50SXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBub2RlLnNpYmxpbmdbJ3JldHVybiddID0gbm9kZVsncmV0dXJuJ107XG4gICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbW1pdERlbGV0aW9uKGN1cnJlbnQpIHtcbiAgICAvLyBSZWN1cnNpdmVseSBkZWxldGUgYWxsIGhvc3Qgbm9kZXMgZnJvbSB0aGUgcGFyZW50LlxuICAgIC8vIERldGFjaCByZWZzIGFuZCBjYWxsIGNvbXBvbmVudFdpbGxVbm1vdW50KCkgb24gdGhlIHdob2xlIHN1YnRyZWUuXG4gICAgdW5tb3VudEhvc3RDb21wb25lbnRzKGN1cnJlbnQpO1xuICAgIGRldGFjaEZpYmVyKGN1cnJlbnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0V29yayhjdXJyZW50LCBmaW5pc2hlZFdvcmspIHtcbiAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgaWYgKGluc3RhbmNlICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIENvbW1pdCB0aGUgd29yayBwcmVwYXJlZCBlYXJsaWVyLlxuICAgICAgICAgICAgdmFyIG5ld1Byb3BzID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICAvLyBGb3IgaHlkcmF0aW9uIHdlIHJldXNlIHRoZSB1cGRhdGUgcGF0aCBidXQgd2UgdHJlYXQgdGhlIG9sZFByb3BzXG4gICAgICAgICAgICAvLyBhcyB0aGUgbmV3UHJvcHMuIFRoZSB1cGRhdGVQYXlsb2FkIHdpbGwgY29udGFpbiB0aGUgcmVhbCBjaGFuZ2UgaW5cbiAgICAgICAgICAgIC8vIHRoaXMgY2FzZS5cbiAgICAgICAgICAgIHZhciBvbGRQcm9wcyA9IGN1cnJlbnQgIT09IG51bGwgPyBjdXJyZW50Lm1lbW9pemVkUHJvcHMgOiBuZXdQcm9wcztcbiAgICAgICAgICAgIHZhciB0eXBlID0gZmluaXNoZWRXb3JrLnR5cGU7XG4gICAgICAgICAgICAvLyBUT0RPOiBUeXBlIHRoZSB1cGRhdGVRdWV1ZSB0byBiZSBzcGVjaWZpYyB0byBob3N0IGNvbXBvbmVudHMuXG4gICAgICAgICAgICB2YXIgdXBkYXRlUGF5bG9hZCA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcbiAgICAgICAgICAgIGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZSA9IG51bGw7XG4gICAgICAgICAgICBpZiAodXBkYXRlUGF5bG9hZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBjb21taXRVcGRhdGUoaW5zdGFuY2UsIHVwZGF0ZVBheWxvYWQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgICB7XG4gICAgICAgICAgIShmaW5pc2hlZFdvcmsuc3RhdGVOb2RlICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1RoaXMgc2hvdWxkIGhhdmUgYSB0ZXh0IG5vZGUgaW5pdGlhbGl6ZWQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICAgICAgdmFyIHRleHRJbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgdmFyIG5ld1RleHQgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAvLyBGb3IgaHlkcmF0aW9uIHdlIHJldXNlIHRoZSB1cGRhdGUgcGF0aCBidXQgd2UgdHJlYXQgdGhlIG9sZFByb3BzXG4gICAgICAgICAgLy8gYXMgdGhlIG5ld1Byb3BzLiBUaGUgdXBkYXRlUGF5bG9hZCB3aWxsIGNvbnRhaW4gdGhlIHJlYWwgY2hhbmdlIGluXG4gICAgICAgICAgLy8gdGhpcyBjYXNlLlxuICAgICAgICAgIHZhciBvbGRUZXh0ID0gY3VycmVudCAhPT0gbnVsbCA/IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyA6IG5ld1RleHQ7XG4gICAgICAgICAgY29tbWl0VGV4dFVwZGF0ZSh0ZXh0SW5zdGFuY2UsIG9sZFRleHQsIG5ld1RleHQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIGludmFyaWFudChmYWxzZSwgJ1RoaXMgdW5pdCBvZiB3b3JrIHRhZyBzaG91bGQgbm90IGhhdmUgc2lkZS1lZmZlY3RzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0UmVzZXRUZXh0Q29udGVudChjdXJyZW50KSB7XG4gICAgcmVzZXRUZXh0Q29udGVudChjdXJyZW50LnN0YXRlTm9kZSk7XG4gIH1cblxuICBpZiAoZW5hYmxlTXV0YXRpbmdSZWNvbmNpbGVyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbW1pdFJlc2V0VGV4dENvbnRlbnQ6IGNvbW1pdFJlc2V0VGV4dENvbnRlbnQsXG4gICAgICBjb21taXRQbGFjZW1lbnQ6IGNvbW1pdFBsYWNlbWVudCxcbiAgICAgIGNvbW1pdERlbGV0aW9uOiBjb21taXREZWxldGlvbixcbiAgICAgIGNvbW1pdFdvcms6IGNvbW1pdFdvcmssXG4gICAgICBjb21taXRMaWZlQ3ljbGVzOiBjb21taXRMaWZlQ3ljbGVzLFxuICAgICAgY29tbWl0QXR0YWNoUmVmOiBjb21taXRBdHRhY2hSZWYsXG4gICAgICBjb21taXREZXRhY2hSZWY6IGNvbW1pdERldGFjaFJlZlxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgaW52YXJpYW50KGZhbHNlLCAnTXV0YXRpbmcgcmVjb25jaWxlciBpcyBkaXNhYmxlZC4nKTtcbiAgfVxufTtcblxudmFyIE5PX0NPTlRFWFQgPSB7fTtcblxudmFyIFJlYWN0RmliZXJIb3N0Q29udGV4dCA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgdmFyIGdldENoaWxkSG9zdENvbnRleHQgPSBjb25maWcuZ2V0Q2hpbGRIb3N0Q29udGV4dCxcbiAgICAgIGdldFJvb3RIb3N0Q29udGV4dCA9IGNvbmZpZy5nZXRSb290SG9zdENvbnRleHQ7XG5cblxuICB2YXIgY29udGV4dFN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKE5PX0NPTlRFWFQpO1xuICB2YXIgY29udGV4dEZpYmVyU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IoTk9fQ09OVEVYVCk7XG4gIHZhciByb290SW5zdGFuY2VTdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvcihOT19DT05URVhUKTtcblxuICBmdW5jdGlvbiByZXF1aXJlZENvbnRleHQoYykge1xuICAgICEoYyAhPT0gTk9fQ09OVEVYVCkgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBob3N0IGNvbnRleHQgdG8gZXhpc3QuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgcmV0dXJuIGM7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRSb290SG9zdENvbnRhaW5lcigpIHtcbiAgICB2YXIgcm9vdEluc3RhbmNlID0gcmVxdWlyZWRDb250ZXh0KHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLmN1cnJlbnQpO1xuICAgIHJldHVybiByb290SW5zdGFuY2U7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoSG9zdENvbnRhaW5lcihmaWJlciwgbmV4dFJvb3RJbnN0YW5jZSkge1xuICAgIC8vIFB1c2ggY3VycmVudCByb290IGluc3RhbmNlIG9udG8gdGhlIHN0YWNrO1xuICAgIC8vIFRoaXMgYWxsb3dzIHVzIHRvIHJlc2V0IHJvb3Qgd2hlbiBwb3J0YWxzIGFyZSBwb3BwZWQuXG4gICAgcHVzaChyb290SW5zdGFuY2VTdGFja0N1cnNvciwgbmV4dFJvb3RJbnN0YW5jZSwgZmliZXIpO1xuXG4gICAgdmFyIG5leHRSb290Q29udGV4dCA9IGdldFJvb3RIb3N0Q29udGV4dChuZXh0Um9vdEluc3RhbmNlKTtcblxuICAgIC8vIFRyYWNrIHRoZSBjb250ZXh0IGFuZCB0aGUgRmliZXIgdGhhdCBwcm92aWRlZCBpdC5cbiAgICAvLyBUaGlzIGVuYWJsZXMgdXMgdG8gcG9wIG9ubHkgRmliZXJzIHRoYXQgcHJvdmlkZSB1bmlxdWUgY29udGV4dHMuXG4gICAgcHVzaChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIsIGZpYmVyKTtcbiAgICBwdXNoKGNvbnRleHRTdGFja0N1cnNvciwgbmV4dFJvb3RDb250ZXh0LCBmaWJlcik7XG4gIH1cblxuICBmdW5jdGlvbiBwb3BIb3N0Q29udGFpbmVyKGZpYmVyKSB7XG4gICAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgZmliZXIpO1xuICAgIHBvcChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIpO1xuICAgIHBvcChyb290SW5zdGFuY2VTdGFja0N1cnNvciwgZmliZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SG9zdENvbnRleHQoKSB7XG4gICAgdmFyIGNvbnRleHQgPSByZXF1aXJlZENvbnRleHQoY29udGV4dFN0YWNrQ3Vyc29yLmN1cnJlbnQpO1xuICAgIHJldHVybiBjb250ZXh0O1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaEhvc3RDb250ZXh0KGZpYmVyKSB7XG4gICAgdmFyIHJvb3RJbnN0YW5jZSA9IHJlcXVpcmVkQ29udGV4dChyb290SW5zdGFuY2VTdGFja0N1cnNvci5jdXJyZW50KTtcbiAgICB2YXIgY29udGV4dCA9IHJlcXVpcmVkQ29udGV4dChjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudCk7XG4gICAgdmFyIG5leHRDb250ZXh0ID0gZ2V0Q2hpbGRIb3N0Q29udGV4dChjb250ZXh0LCBmaWJlci50eXBlLCByb290SW5zdGFuY2UpO1xuXG4gICAgLy8gRG9uJ3QgcHVzaCB0aGlzIEZpYmVyJ3MgY29udGV4dCB1bmxlc3MgaXQncyB1bmlxdWUuXG4gICAgaWYgKGNvbnRleHQgPT09IG5leHRDb250ZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVHJhY2sgdGhlIGNvbnRleHQgYW5kIHRoZSBGaWJlciB0aGF0IHByb3ZpZGVkIGl0LlxuICAgIC8vIFRoaXMgZW5hYmxlcyB1cyB0byBwb3Agb25seSBGaWJlcnMgdGhhdCBwcm92aWRlIHVuaXF1ZSBjb250ZXh0cy5cbiAgICBwdXNoKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLCBmaWJlciwgZmliZXIpO1xuICAgIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBuZXh0Q29udGV4dCwgZmliZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gcG9wSG9zdENvbnRleHQoZmliZXIpIHtcbiAgICAvLyBEbyBub3QgcG9wIHVubGVzcyB0aGlzIEZpYmVyIHByb3ZpZGVkIHRoZSBjdXJyZW50IGNvbnRleHQuXG4gICAgLy8gcHVzaEhvc3RDb250ZXh0KCkgb25seSBwdXNoZXMgRmliZXJzIHRoYXQgcHJvdmlkZSB1bmlxdWUgY29udGV4dHMuXG4gICAgaWYgKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLmN1cnJlbnQgIT09IGZpYmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgZmliZXIpO1xuICAgIHBvcChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRIb3N0Q29udGFpbmVyKCkge1xuICAgIGNvbnRleHRTdGFja0N1cnNvci5jdXJyZW50ID0gTk9fQ09OVEVYVDtcbiAgICByb290SW5zdGFuY2VTdGFja0N1cnNvci5jdXJyZW50ID0gTk9fQ09OVEVYVDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZ2V0SG9zdENvbnRleHQ6IGdldEhvc3RDb250ZXh0LFxuICAgIGdldFJvb3RIb3N0Q29udGFpbmVyOiBnZXRSb290SG9zdENvbnRhaW5lcixcbiAgICBwb3BIb3N0Q29udGFpbmVyOiBwb3BIb3N0Q29udGFpbmVyLFxuICAgIHBvcEhvc3RDb250ZXh0OiBwb3BIb3N0Q29udGV4dCxcbiAgICBwdXNoSG9zdENvbnRhaW5lcjogcHVzaEhvc3RDb250YWluZXIsXG4gICAgcHVzaEhvc3RDb250ZXh0OiBwdXNoSG9zdENvbnRleHQsXG4gICAgcmVzZXRIb3N0Q29udGFpbmVyOiByZXNldEhvc3RDb250YWluZXJcbiAgfTtcbn07XG5cbnZhciBSZWFjdEZpYmVySHlkcmF0aW9uQ29udGV4dCA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgdmFyIHNob3VsZFNldFRleHRDb250ZW50ID0gY29uZmlnLnNob3VsZFNldFRleHRDb250ZW50LFxuICAgICAgaHlkcmF0aW9uID0gY29uZmlnLmh5ZHJhdGlvbjtcblxuICAvLyBJZiB0aGlzIGRvZXNuJ3QgaGF2ZSBoeWRyYXRpb24gbW9kZS5cblxuICBpZiAoIWh5ZHJhdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICBlbnRlckh5ZHJhdGlvblN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0sXG4gICAgICByZXNldEh5ZHJhdGlvblN0YXRlOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgIHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSgpIHRvIG5ldmVyIGJlIGNhbGxlZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgIH0sXG4gICAgICBwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZSgpIHRvIG5ldmVyIGJlIGNhbGxlZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgIH0sXG4gICAgICBwb3BIeWRyYXRpb25TdGF0ZTogZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgdmFyIGNhbkh5ZHJhdGVJbnN0YW5jZSA9IGh5ZHJhdGlvbi5jYW5IeWRyYXRlSW5zdGFuY2UsXG4gICAgICBjYW5IeWRyYXRlVGV4dEluc3RhbmNlID0gaHlkcmF0aW9uLmNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UsXG4gICAgICBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcgPSBoeWRyYXRpb24uZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nLFxuICAgICAgZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGQgPSBoeWRyYXRpb24uZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGQsXG4gICAgICBoeWRyYXRlSW5zdGFuY2UgPSBoeWRyYXRpb24uaHlkcmF0ZUluc3RhbmNlLFxuICAgICAgaHlkcmF0ZVRleHRJbnN0YW5jZSA9IGh5ZHJhdGlvbi5oeWRyYXRlVGV4dEluc3RhbmNlLFxuICAgICAgZGlkTm90TWF0Y2hIeWRyYXRlZENvbnRhaW5lclRleHRJbnN0YW5jZSA9IGh5ZHJhdGlvbi5kaWROb3RNYXRjaEh5ZHJhdGVkQ29udGFpbmVyVGV4dEluc3RhbmNlLFxuICAgICAgZGlkTm90TWF0Y2hIeWRyYXRlZFRleHRJbnN0YW5jZSA9IGh5ZHJhdGlvbi5kaWROb3RNYXRjaEh5ZHJhdGVkVGV4dEluc3RhbmNlLFxuICAgICAgZGlkTm90SHlkcmF0ZUNvbnRhaW5lckluc3RhbmNlID0gaHlkcmF0aW9uLmRpZE5vdEh5ZHJhdGVDb250YWluZXJJbnN0YW5jZSxcbiAgICAgIGRpZE5vdEh5ZHJhdGVJbnN0YW5jZSA9IGh5ZHJhdGlvbi5kaWROb3RIeWRyYXRlSW5zdGFuY2UsXG4gICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lckluc3RhbmNlID0gaHlkcmF0aW9uLmRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVySW5zdGFuY2UsXG4gICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lclRleHRJbnN0YW5jZSA9IGh5ZHJhdGlvbi5kaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lclRleHRJbnN0YW5jZSxcbiAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlSW5zdGFuY2UgPSBoeWRyYXRpb24uZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZSxcbiAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlVGV4dEluc3RhbmNlID0gaHlkcmF0aW9uLmRpZE5vdEZpbmRIeWRyYXRhYmxlVGV4dEluc3RhbmNlO1xuXG4gIC8vIFRoZSBkZWVwZXN0IEZpYmVyIG9uIHRoZSBzdGFjayBpbnZvbHZlZCBpbiBhIGh5ZHJhdGlvbiBjb250ZXh0LlxuICAvLyBUaGlzIG1heSBoYXZlIGJlZW4gYW4gaW5zZXJ0aW9uIG9yIGEgaHlkcmF0aW9uLlxuXG4gIHZhciBoeWRyYXRpb25QYXJlbnRGaWJlciA9IG51bGw7XG4gIHZhciBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gbnVsbDtcbiAgdmFyIGlzSHlkcmF0aW5nID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZW50ZXJIeWRyYXRpb25TdGF0ZShmaWJlcikge1xuICAgIHZhciBwYXJlbnRJbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZChwYXJlbnRJbnN0YW5jZSk7XG4gICAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlcjtcbiAgICBpc0h5ZHJhdGluZyA9IHRydWU7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBkZWxldGVIeWRyYXRhYmxlSW5zdGFuY2UocmV0dXJuRmliZXIsIGluc3RhbmNlKSB7XG4gICAge1xuICAgICAgc3dpdGNoIChyZXR1cm5GaWJlci50YWcpIHtcbiAgICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgICBkaWROb3RIeWRyYXRlQ29udGFpbmVySW5zdGFuY2UocmV0dXJuRmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8sIGluc3RhbmNlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgIGRpZE5vdEh5ZHJhdGVJbnN0YW5jZShyZXR1cm5GaWJlci50eXBlLCByZXR1cm5GaWJlci5tZW1vaXplZFByb3BzLCByZXR1cm5GaWJlci5zdGF0ZU5vZGUsIGluc3RhbmNlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY2hpbGRUb0RlbGV0ZSA9IGNyZWF0ZUZpYmVyRnJvbUhvc3RJbnN0YW5jZUZvckRlbGV0aW9uKCk7XG4gICAgY2hpbGRUb0RlbGV0ZS5zdGF0ZU5vZGUgPSBpbnN0YW5jZTtcbiAgICBjaGlsZFRvRGVsZXRlWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgIGNoaWxkVG9EZWxldGUuZWZmZWN0VGFnID0gRGVsZXRpb247XG5cbiAgICAvLyBUaGlzIG1pZ2h0IHNlZW0gbGlrZSBpdCBiZWxvbmdzIG9uIHByb2dyZXNzZWRGaXJzdERlbGV0aW9uLiBIb3dldmVyLFxuICAgIC8vIHRoZXNlIGNoaWxkcmVuIGFyZSBub3QgcGFydCBvZiB0aGUgcmVjb25jaWxpYXRpb24gbGlzdCBvZiBjaGlsZHJlbi5cbiAgICAvLyBFdmVuIGlmIHdlIGFib3J0IGFuZCByZXJlY29uY2lsZSB0aGUgY2hpbGRyZW4sIHRoYXQgd2lsbCB0cnkgdG8gaHlkcmF0ZVxuICAgIC8vIGFnYWluIGFuZCB0aGUgbm9kZXMgYXJlIHN0aWxsIGluIHRoZSBob3N0IHRyZWUgc28gdGhlc2Ugd2lsbCBiZVxuICAgIC8vIHJlY3JlYXRlZC5cbiAgICBpZiAocmV0dXJuRmliZXIubGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdC5uZXh0RWZmZWN0ID0gY2hpbGRUb0RlbGV0ZTtcbiAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9IHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluc2VydE5vbkh5ZHJhdGVkSW5zdGFuY2UocmV0dXJuRmliZXIsIGZpYmVyKSB7XG4gICAgZmliZXIuZWZmZWN0VGFnIHw9IFBsYWNlbWVudDtcbiAgICB7XG4gICAgICBzd2l0Y2ggKHJldHVybkZpYmVyLnRhZykge1xuICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnRDb250YWluZXIgPSByZXR1cm5GaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICAgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IGZpYmVyLnR5cGU7XG4gICAgICAgICAgICAgICAgdmFyIHByb3BzID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgICAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVySW5zdGFuY2UocGFyZW50Q29udGFpbmVyLCB0eXBlLCBwcm9wcyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICAgICAgICAgICAgdmFyIHRleHQgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJUZXh0SW5zdGFuY2UocGFyZW50Q29udGFpbmVyLCB0ZXh0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnRUeXBlID0gcmV0dXJuRmliZXIudHlwZTtcbiAgICAgICAgICAgIHZhciBwYXJlbnRQcm9wcyA9IHJldHVybkZpYmVyLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICB2YXIgcGFyZW50SW5zdGFuY2UgPSByZXR1cm5GaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgICAgICAgdmFyIF90eXBlID0gZmliZXIudHlwZTtcbiAgICAgICAgICAgICAgICB2YXIgX3Byb3BzID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgICAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlSW5zdGFuY2UocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCBfdHlwZSwgX3Byb3BzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgICAgICAgICAgICB2YXIgX3RleHQgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2UocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCBfdGV4dCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRyeUh5ZHJhdGUoZmliZXIsIG5leHRJbnN0YW5jZSkge1xuICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgdHlwZSA9IGZpYmVyLnR5cGU7XG4gICAgICAgICAgdmFyIHByb3BzID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGNhbkh5ZHJhdGVJbnN0YW5jZShuZXh0SW5zdGFuY2UsIHR5cGUsIHByb3BzKTtcbiAgICAgICAgICBpZiAoaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZpYmVyLnN0YXRlTm9kZSA9IGluc3RhbmNlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciB0ZXh0ID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgIHZhciB0ZXh0SW5zdGFuY2UgPSBjYW5IeWRyYXRlVGV4dEluc3RhbmNlKG5leHRJbnN0YW5jZSwgdGV4dCk7XG4gICAgICAgICAgaWYgKHRleHRJbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZmliZXIuc3RhdGVOb2RlID0gdGV4dEluc3RhbmNlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlKGZpYmVyKSB7XG4gICAgaWYgKCFpc0h5ZHJhdGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbmV4dEluc3RhbmNlID0gbmV4dEh5ZHJhdGFibGVJbnN0YW5jZTtcbiAgICBpZiAoIW5leHRJbnN0YW5jZSkge1xuICAgICAgLy8gTm90aGluZyB0byBoeWRyYXRlLiBNYWtlIGl0IGFuIGluc2VydGlvbi5cbiAgICAgIGluc2VydE5vbkh5ZHJhdGVkSW5zdGFuY2UoaHlkcmF0aW9uUGFyZW50RmliZXIsIGZpYmVyKTtcbiAgICAgIGlzSHlkcmF0aW5nID0gZmFsc2U7XG4gICAgICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IGZpYmVyO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRyeUh5ZHJhdGUoZmliZXIsIG5leHRJbnN0YW5jZSkpIHtcbiAgICAgIC8vIElmIHdlIGNhbid0IGh5ZHJhdGUgdGhpcyBpbnN0YW5jZSBsZXQncyB0cnkgdGhlIG5leHQgb25lLlxuICAgICAgLy8gV2UgdXNlIHRoaXMgYXMgYSBoZXVyaXN0aWMuIEl0J3MgYmFzZWQgb24gaW50dWl0aW9uIGFuZCBub3QgZGF0YSBzbyBpdFxuICAgICAgLy8gbWlnaHQgYmUgZmxhd2VkIG9yIHVubmVjZXNzYXJ5LlxuICAgICAgbmV4dEluc3RhbmNlID0gZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nKG5leHRJbnN0YW5jZSk7XG4gICAgICBpZiAoIW5leHRJbnN0YW5jZSB8fCAhdHJ5SHlkcmF0ZShmaWJlciwgbmV4dEluc3RhbmNlKSkge1xuICAgICAgICAvLyBOb3RoaW5nIHRvIGh5ZHJhdGUuIE1ha2UgaXQgYW4gaW5zZXJ0aW9uLlxuICAgICAgICBpbnNlcnROb25IeWRyYXRlZEluc3RhbmNlKGh5ZHJhdGlvblBhcmVudEZpYmVyLCBmaWJlcik7XG4gICAgICAgIGlzSHlkcmF0aW5nID0gZmFsc2U7XG4gICAgICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gZmliZXI7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIFdlIG1hdGNoZWQgdGhlIG5leHQgb25lLCB3ZSdsbCBub3cgYXNzdW1lIHRoYXQgdGhlIGZpcnN0IG9uZSB3YXNcbiAgICAgIC8vIHN1cGVyZmx1b3VzIGFuZCB3ZSdsbCBkZWxldGUgaXQuIFNpbmNlIHdlIGNhbid0IGVhZ2VybHkgZGVsZXRlIGl0XG4gICAgICAvLyB3ZSdsbCBoYXZlIHRvIHNjaGVkdWxlIGEgZGVsZXRpb24uIFRvIGRvIHRoYXQsIHRoaXMgbm9kZSBuZWVkcyBhIGR1bW15XG4gICAgICAvLyBmaWJlciBhc3NvY2lhdGVkIHdpdGggaXQuXG4gICAgICBkZWxldGVIeWRyYXRhYmxlSW5zdGFuY2UoaHlkcmF0aW9uUGFyZW50RmliZXIsIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UpO1xuICAgIH1cbiAgICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IGZpYmVyO1xuICAgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZChuZXh0SW5zdGFuY2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZShmaWJlciwgcm9vdENvbnRhaW5lckluc3RhbmNlLCBob3N0Q29udGV4dCkge1xuICAgIHZhciBpbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgICB2YXIgdXBkYXRlUGF5bG9hZCA9IGh5ZHJhdGVJbnN0YW5jZShpbnN0YW5jZSwgZmliZXIudHlwZSwgZmliZXIubWVtb2l6ZWRQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBob3N0Q29udGV4dCwgZmliZXIpO1xuICAgIC8vIFRPRE86IFR5cGUgdGhpcyBzcGVjaWZpYyB0byB0aGlzIHR5cGUgb2YgY29tcG9uZW50LlxuICAgIGZpYmVyLnVwZGF0ZVF1ZXVlID0gdXBkYXRlUGF5bG9hZDtcbiAgICAvLyBJZiB0aGUgdXBkYXRlIHBheWxvYWQgaW5kaWNhdGVzIHRoYXQgdGhlcmUgaXMgYSBjaGFuZ2Ugb3IgaWYgdGhlcmVcbiAgICAvLyBpcyBhIG5ldyByZWYgd2UgbWFyayB0aGlzIGFzIGFuIHVwZGF0ZS5cbiAgICBpZiAodXBkYXRlUGF5bG9hZCAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlKGZpYmVyKSB7XG4gICAgdmFyIHRleHRJbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgICB2YXIgdGV4dENvbnRlbnQgPSBmaWJlci5tZW1vaXplZFByb3BzO1xuICAgIHZhciBzaG91bGRVcGRhdGUgPSBoeWRyYXRlVGV4dEluc3RhbmNlKHRleHRJbnN0YW5jZSwgdGV4dENvbnRlbnQsIGZpYmVyKTtcbiAgICB7XG4gICAgICBpZiAoc2hvdWxkVXBkYXRlKSB7XG4gICAgICAgIC8vIFdlIGFzc3VtZSB0aGF0IHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlIGlzIGNhbGxlZCBpbiBhIGNvbnRleHQgd2hlcmUgdGhlXG4gICAgICAgIC8vIGh5ZHJhdGlvbiBwYXJlbnQgaXMgdGhlIHBhcmVudCBob3N0IGNvbXBvbmVudCBvZiB0aGlzIGhvc3QgdGV4dC5cbiAgICAgICAgdmFyIHJldHVybkZpYmVyID0gaHlkcmF0aW9uUGFyZW50RmliZXI7XG4gICAgICAgIGlmIChyZXR1cm5GaWJlciAhPT0gbnVsbCkge1xuICAgICAgICAgIHN3aXRjaCAocmV0dXJuRmliZXIudGFnKSB7XG4gICAgICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudENvbnRhaW5lciA9IHJldHVybkZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgICAgICAgICAgIGRpZE5vdE1hdGNoSHlkcmF0ZWRDb250YWluZXJUZXh0SW5zdGFuY2UocGFyZW50Q29udGFpbmVyLCB0ZXh0SW5zdGFuY2UsIHRleHRDb250ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudFR5cGUgPSByZXR1cm5GaWJlci50eXBlO1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRQcm9wcyA9IHJldHVybkZpYmVyLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudEluc3RhbmNlID0gcmV0dXJuRmliZXIuc3RhdGVOb2RlO1xuICAgICAgICAgICAgICAgIGRpZE5vdE1hdGNoSHlkcmF0ZWRUZXh0SW5zdGFuY2UocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCB0ZXh0SW5zdGFuY2UsIHRleHRDb250ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2hvdWxkVXBkYXRlO1xuICB9XG5cbiAgZnVuY3Rpb24gcG9wVG9OZXh0SG9zdFBhcmVudChmaWJlcikge1xuICAgIHZhciBwYXJlbnQgPSBmaWJlclsncmV0dXJuJ107XG4gICAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCAmJiBwYXJlbnQudGFnICE9PSBIb3N0Q29tcG9uZW50ICYmIHBhcmVudC50YWcgIT09IEhvc3RSb290KSB7XG4gICAgICBwYXJlbnQgPSBwYXJlbnRbJ3JldHVybiddO1xuICAgIH1cbiAgICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IHBhcmVudDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvcEh5ZHJhdGlvblN0YXRlKGZpYmVyKSB7XG4gICAgaWYgKGZpYmVyICE9PSBoeWRyYXRpb25QYXJlbnRGaWJlcikge1xuICAgICAgLy8gV2UncmUgZGVlcGVyIHRoYW4gdGhlIGN1cnJlbnQgaHlkcmF0aW9uIGNvbnRleHQsIGluc2lkZSBhbiBpbnNlcnRlZFxuICAgICAgLy8gdHJlZS5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFpc0h5ZHJhdGluZykge1xuICAgICAgLy8gSWYgd2UncmUgbm90IGN1cnJlbnRseSBoeWRyYXRpbmcgYnV0IHdlJ3JlIGluIGEgaHlkcmF0aW9uIGNvbnRleHQsIHRoZW5cbiAgICAgIC8vIHdlIHdlcmUgYW4gaW5zZXJ0aW9uIGFuZCBub3cgbmVlZCB0byBwb3AgdXAgcmVlbnRlciBoeWRyYXRpb24gb2Ygb3VyXG4gICAgICAvLyBzaWJsaW5ncy5cbiAgICAgIHBvcFRvTmV4dEhvc3RQYXJlbnQoZmliZXIpO1xuICAgICAgaXNIeWRyYXRpbmcgPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciB0eXBlID0gZmliZXIudHlwZTtcblxuICAgIC8vIElmIHdlIGhhdmUgYW55IHJlbWFpbmluZyBoeWRyYXRhYmxlIG5vZGVzLCB3ZSBuZWVkIHRvIGRlbGV0ZSB0aGVtIG5vdy5cbiAgICAvLyBXZSBvbmx5IGRvIHRoaXMgZGVlcGVyIHRoYW4gaGVhZCBhbmQgYm9keSBzaW5jZSB0aGV5IHRlbmQgdG8gaGF2ZSByYW5kb21cbiAgICAvLyBvdGhlciBub2RlcyBpbiB0aGVtLiBXZSBhbHNvIGlnbm9yZSBjb21wb25lbnRzIHdpdGggcHVyZSB0ZXh0IGNvbnRlbnQgaW5cbiAgICAvLyBzaWRlIG9mIHRoZW0uXG4gICAgLy8gVE9ETzogQmV0dGVyIGhldXJpc3RpYy5cbiAgICBpZiAoZmliZXIudGFnICE9PSBIb3N0Q29tcG9uZW50IHx8IHR5cGUgIT09ICdoZWFkJyAmJiB0eXBlICE9PSAnYm9keScgJiYgIXNob3VsZFNldFRleHRDb250ZW50KHR5cGUsIGZpYmVyLm1lbW9pemVkUHJvcHMpKSB7XG4gICAgICB2YXIgbmV4dEluc3RhbmNlID0gbmV4dEh5ZHJhdGFibGVJbnN0YW5jZTtcbiAgICAgIHdoaWxlIChuZXh0SW5zdGFuY2UpIHtcbiAgICAgICAgZGVsZXRlSHlkcmF0YWJsZUluc3RhbmNlKGZpYmVyLCBuZXh0SW5zdGFuY2UpO1xuICAgICAgICBuZXh0SW5zdGFuY2UgPSBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcobmV4dEluc3RhbmNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwb3BUb05leHRIb3N0UGFyZW50KGZpYmVyKTtcbiAgICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gaHlkcmF0aW9uUGFyZW50RmliZXIgPyBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcoZmliZXIuc3RhdGVOb2RlKSA6IG51bGw7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldEh5ZHJhdGlvblN0YXRlKCkge1xuICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gbnVsbDtcbiAgICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gbnVsbDtcbiAgICBpc0h5ZHJhdGluZyA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBlbnRlckh5ZHJhdGlvblN0YXRlOiBlbnRlckh5ZHJhdGlvblN0YXRlLFxuICAgIHJlc2V0SHlkcmF0aW9uU3RhdGU6IHJlc2V0SHlkcmF0aW9uU3RhdGUsXG4gICAgdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2U6IHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlLFxuICAgIHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2U6IHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2UsXG4gICAgcHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2U6IHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlLFxuICAgIHBvcEh5ZHJhdGlvblN0YXRlOiBwb3BIeWRyYXRpb25TdGF0ZVxuICB9O1xufTtcblxuLy8gVGhpcyBsZXRzIHVzIGhvb2sgaW50byBGaWJlciB0byBkZWJ1ZyB3aGF0IGl0J3MgZG9pbmcuXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvODAzMy5cbi8vIFRoaXMgaXMgbm90IHBhcnQgb2YgdGhlIHB1YmxpYyBBUEksIG5vdCBldmVuIGZvciBSZWFjdCBEZXZUb29scy5cbi8vIFlvdSBtYXkgb25seSBpbmplY3QgYSBkZWJ1Z1Rvb2wgaWYgeW91IHdvcmsgb24gUmVhY3QgRmliZXIgaXRzZWxmLlxudmFyIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb24gPSB7XG4gIGRlYnVnVG9vbDogbnVsbFxufTtcblxudmFyIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMSA9IFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb247XG5cbnZhciBkZWZhdWx0U2hvd0RpYWxvZyA9IGZ1bmN0aW9uIChjYXB0dXJlZEVycm9yKSB7XG4gIHJldHVybiB0cnVlO1xufTtcblxudmFyIHNob3dEaWFsb2cgPSBkZWZhdWx0U2hvd0RpYWxvZztcblxuZnVuY3Rpb24gbG9nQ2FwdHVyZWRFcnJvcihjYXB0dXJlZEVycm9yKSB7XG4gIHZhciBsb2dFcnJvciA9IHNob3dEaWFsb2coY2FwdHVyZWRFcnJvcik7XG5cbiAgLy8gQWxsb3cgaW5qZWN0ZWQgc2hvd0RpYWxvZygpIHRvIHByZXZlbnQgZGVmYXVsdCBjb25zb2xlLmVycm9yIGxvZ2dpbmcuXG4gIC8vIFRoaXMgZW5hYmxlcyByZW5kZXJlcnMgbGlrZSBSZWFjdE5hdGl2ZSB0byBiZXR0ZXIgbWFuYWdlIHJlZGJveCBiZWhhdmlvci5cbiAgaWYgKGxvZ0Vycm9yID09PSBmYWxzZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBlcnJvciA9IGNhcHR1cmVkRXJyb3IuZXJyb3I7XG4gIHZhciBzdXBwcmVzc0xvZ2dpbmcgPSBlcnJvciAmJiBlcnJvci5zdXBwcmVzc1JlYWN0RXJyb3JMb2dnaW5nO1xuICBpZiAoc3VwcHJlc3NMb2dnaW5nKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAge1xuICAgIHZhciBjb21wb25lbnROYW1lID0gY2FwdHVyZWRFcnJvci5jb21wb25lbnROYW1lLFxuICAgICAgICBjb21wb25lbnRTdGFjayA9IGNhcHR1cmVkRXJyb3IuY29tcG9uZW50U3RhY2ssXG4gICAgICAgIGVycm9yQm91bmRhcnlOYW1lID0gY2FwdHVyZWRFcnJvci5lcnJvckJvdW5kYXJ5TmFtZSxcbiAgICAgICAgZXJyb3JCb3VuZGFyeUZvdW5kID0gY2FwdHVyZWRFcnJvci5lcnJvckJvdW5kYXJ5Rm91bmQsXG4gICAgICAgIHdpbGxSZXRyeSA9IGNhcHR1cmVkRXJyb3Iud2lsbFJldHJ5O1xuXG5cbiAgICB2YXIgY29tcG9uZW50TmFtZU1lc3NhZ2UgPSBjb21wb25lbnROYW1lID8gJ1RoZSBhYm92ZSBlcnJvciBvY2N1cnJlZCBpbiB0aGUgPCcgKyBjb21wb25lbnROYW1lICsgJz4gY29tcG9uZW50OicgOiAnVGhlIGFib3ZlIGVycm9yIG9jY3VycmVkIGluIG9uZSBvZiB5b3VyIFJlYWN0IGNvbXBvbmVudHM6JztcblxuICAgIHZhciBlcnJvckJvdW5kYXJ5TWVzc2FnZSA9IHZvaWQgMDtcbiAgICAvLyBlcnJvckJvdW5kYXJ5Rm91bmQgY2hlY2sgaXMgc3VmZmljaWVudDsgZXJyb3JCb3VuZGFyeU5hbWUgY2hlY2sgaXMgdG8gc2F0aXNmeSBGbG93LlxuICAgIGlmIChlcnJvckJvdW5kYXJ5Rm91bmQgJiYgZXJyb3JCb3VuZGFyeU5hbWUpIHtcbiAgICAgIGlmICh3aWxsUmV0cnkpIHtcbiAgICAgICAgZXJyb3JCb3VuZGFyeU1lc3NhZ2UgPSAnUmVhY3Qgd2lsbCB0cnkgdG8gcmVjcmVhdGUgdGhpcyBjb21wb25lbnQgdHJlZSBmcm9tIHNjcmF0Y2ggJyArICgndXNpbmcgdGhlIGVycm9yIGJvdW5kYXJ5IHlvdSBwcm92aWRlZCwgJyArIGVycm9yQm91bmRhcnlOYW1lICsgJy4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9yQm91bmRhcnlNZXNzYWdlID0gJ1RoaXMgZXJyb3Igd2FzIGluaXRpYWxseSBoYW5kbGVkIGJ5IHRoZSBlcnJvciBib3VuZGFyeSAnICsgZXJyb3JCb3VuZGFyeU5hbWUgKyAnLlxcbicgKyAnUmVjcmVhdGluZyB0aGUgdHJlZSBmcm9tIHNjcmF0Y2ggZmFpbGVkIHNvIFJlYWN0IHdpbGwgdW5tb3VudCB0aGUgdHJlZS4nO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlcnJvckJvdW5kYXJ5TWVzc2FnZSA9ICdDb25zaWRlciBhZGRpbmcgYW4gZXJyb3IgYm91bmRhcnkgdG8geW91ciB0cmVlIHRvIGN1c3RvbWl6ZSBlcnJvciBoYW5kbGluZyBiZWhhdmlvci5cXG4nICsgJ1Zpc2l0IGh0dHBzOi8vZmIubWUvcmVhY3QtZXJyb3ItYm91bmRhcmllcyB0byBsZWFybiBtb3JlIGFib3V0IGVycm9yIGJvdW5kYXJpZXMuJztcbiAgICB9XG4gICAgdmFyIGNvbWJpbmVkTWVzc2FnZSA9ICcnICsgY29tcG9uZW50TmFtZU1lc3NhZ2UgKyBjb21wb25lbnRTdGFjayArICdcXG5cXG4nICsgKCcnICsgZXJyb3JCb3VuZGFyeU1lc3NhZ2UpO1xuXG4gICAgLy8gSW4gZGV2ZWxvcG1lbnQsIHdlIHByb3ZpZGUgb3VyIG93biBtZXNzYWdlIHdpdGgganVzdCB0aGUgY29tcG9uZW50IHN0YWNrLlxuICAgIC8vIFdlIGRvbid0IGluY2x1ZGUgdGhlIG9yaWdpbmFsIGVycm9yIG1lc3NhZ2UgYW5kIEpTIHN0YWNrIGJlY2F1c2UgdGhlIGJyb3dzZXJcbiAgICAvLyBoYXMgYWxyZWFkeSBwcmludGVkIGl0LiBFdmVuIGlmIHRoZSBhcHBsaWNhdGlvbiBzd2FsbG93cyB0aGUgZXJyb3IsIGl0IGlzIHN0aWxsXG4gICAgLy8gZGlzcGxheWVkIGJ5IHRoZSBicm93c2VyIHRoYW5rcyB0byB0aGUgREVWLW9ubHkgZmFrZSBldmVudCB0cmljayBpbiBSZWFjdEVycm9yVXRpbHMuXG4gICAgY29uc29sZS5lcnJvcihjb21iaW5lZE1lc3NhZ2UpO1xuICB9XG59XG5cbnZhciBpbnZva2VHdWFyZGVkQ2FsbGJhY2skMSA9IFJlYWN0RXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2s7XG52YXIgaGFzQ2F1Z2h0RXJyb3IgPSBSZWFjdEVycm9yVXRpbHMuaGFzQ2F1Z2h0RXJyb3I7XG52YXIgY2xlYXJDYXVnaHRFcnJvciA9IFJlYWN0RXJyb3JVdGlscy5jbGVhckNhdWdodEVycm9yO1xuXG5cbntcbiAgdmFyIGRpZFdhcm5BYm91dFN0YXRlVHJhbnNpdGlvbiA9IGZhbHNlO1xuICB2YXIgZGlkV2FyblNldFN0YXRlQ2hpbGRDb250ZXh0ID0gZmFsc2U7XG4gIHZhciBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnQgPSB7fTtcblxuICB2YXIgd2FybkFib3V0VXBkYXRlT25Vbm1vdW50ZWQgPSBmdW5jdGlvbiAoZmliZXIpIHtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoZmliZXIpIHx8ICdSZWFjdENsYXNzJztcbiAgICBpZiAoZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHdhcm5pbmcoZmFsc2UsICdDYW4gb25seSB1cGRhdGUgYSBtb3VudGVkIG9yIG1vdW50aW5nICcgKyAnY29tcG9uZW50LiBUaGlzIHVzdWFsbHkgbWVhbnMgeW91IGNhbGxlZCBzZXRTdGF0ZSwgcmVwbGFjZVN0YXRlLCAnICsgJ29yIGZvcmNlVXBkYXRlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuIFRoaXMgaXMgYSBuby1vcC5cXG5cXG5QbGVhc2UgJyArICdjaGVjayB0aGUgY29kZSBmb3IgdGhlICVzIGNvbXBvbmVudC4nLCBjb21wb25lbnROYW1lKTtcbiAgICBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnRbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICB9O1xuXG4gIHZhciB3YXJuQWJvdXRJbnZhbGlkVXBkYXRlcyA9IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgIHN3aXRjaCAoUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5waGFzZSkge1xuICAgICAgY2FzZSAnZ2V0Q2hpbGRDb250ZXh0JzpcbiAgICAgICAgaWYgKGRpZFdhcm5TZXRTdGF0ZUNoaWxkQ29udGV4dCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnc2V0U3RhdGUoLi4uKTogQ2Fubm90IGNhbGwgc2V0U3RhdGUoKSBpbnNpZGUgZ2V0Q2hpbGRDb250ZXh0KCknKTtcbiAgICAgICAgZGlkV2FyblNldFN0YXRlQ2hpbGRDb250ZXh0ID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdyZW5kZXInOlxuICAgICAgICBpZiAoZGlkV2FybkFib3V0U3RhdGVUcmFuc2l0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdDYW5ub3QgdXBkYXRlIGR1cmluZyBhbiBleGlzdGluZyBzdGF0ZSB0cmFuc2l0aW9uIChzdWNoIGFzIHdpdGhpbiAnICsgXCJgcmVuZGVyYCBvciBhbm90aGVyIGNvbXBvbmVudCdzIGNvbnN0cnVjdG9yKS4gUmVuZGVyIG1ldGhvZHMgc2hvdWxkIFwiICsgJ2JlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGU7IGNvbnN0cnVjdG9yIHNpZGUtZWZmZWN0cyBhcmUgJyArICdhbiBhbnRpLXBhdHRlcm4sIGJ1dCBjYW4gYmUgbW92ZWQgdG8gYGNvbXBvbmVudFdpbGxNb3VudGAuJyk7XG4gICAgICAgIGRpZFdhcm5BYm91dFN0YXRlVHJhbnNpdGlvbiA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIFJlYWN0RmliZXJTY2hlZHVsZXIgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gIHZhciBob3N0Q29udGV4dCA9IFJlYWN0RmliZXJIb3N0Q29udGV4dChjb25maWcpO1xuICB2YXIgaHlkcmF0aW9uQ29udGV4dCA9IFJlYWN0RmliZXJIeWRyYXRpb25Db250ZXh0KGNvbmZpZyk7XG4gIHZhciBwb3BIb3N0Q29udGFpbmVyID0gaG9zdENvbnRleHQucG9wSG9zdENvbnRhaW5lcixcbiAgICAgIHBvcEhvc3RDb250ZXh0ID0gaG9zdENvbnRleHQucG9wSG9zdENvbnRleHQsXG4gICAgICByZXNldEhvc3RDb250YWluZXIgPSBob3N0Q29udGV4dC5yZXNldEhvc3RDb250YWluZXI7XG5cbiAgdmFyIF9SZWFjdEZpYmVyQmVnaW5Xb3JrID0gUmVhY3RGaWJlckJlZ2luV29yayhjb25maWcsIGhvc3RDb250ZXh0LCBoeWRyYXRpb25Db250ZXh0LCBzY2hlZHVsZVdvcmssIGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIpLFxuICAgICAgYmVnaW5Xb3JrID0gX1JlYWN0RmliZXJCZWdpbldvcmsuYmVnaW5Xb3JrLFxuICAgICAgYmVnaW5GYWlsZWRXb3JrID0gX1JlYWN0RmliZXJCZWdpbldvcmsuYmVnaW5GYWlsZWRXb3JrO1xuXG4gIHZhciBfUmVhY3RGaWJlckNvbXBsZXRlV28gPSBSZWFjdEZpYmVyQ29tcGxldGVXb3JrKGNvbmZpZywgaG9zdENvbnRleHQsIGh5ZHJhdGlvbkNvbnRleHQpLFxuICAgICAgY29tcGxldGVXb3JrID0gX1JlYWN0RmliZXJDb21wbGV0ZVdvLmNvbXBsZXRlV29yaztcblxuICB2YXIgX1JlYWN0RmliZXJDb21taXRXb3JrID0gUmVhY3RGaWJlckNvbW1pdFdvcmsoY29uZmlnLCBjYXB0dXJlRXJyb3IpLFxuICAgICAgY29tbWl0UmVzZXRUZXh0Q29udGVudCA9IF9SZWFjdEZpYmVyQ29tbWl0V29yay5jb21taXRSZXNldFRleHRDb250ZW50LFxuICAgICAgY29tbWl0UGxhY2VtZW50ID0gX1JlYWN0RmliZXJDb21taXRXb3JrLmNvbW1pdFBsYWNlbWVudCxcbiAgICAgIGNvbW1pdERlbGV0aW9uID0gX1JlYWN0RmliZXJDb21taXRXb3JrLmNvbW1pdERlbGV0aW9uLFxuICAgICAgY29tbWl0V29yayA9IF9SZWFjdEZpYmVyQ29tbWl0V29yay5jb21taXRXb3JrLFxuICAgICAgY29tbWl0TGlmZUN5Y2xlcyA9IF9SZWFjdEZpYmVyQ29tbWl0V29yay5jb21taXRMaWZlQ3ljbGVzLFxuICAgICAgY29tbWl0QXR0YWNoUmVmID0gX1JlYWN0RmliZXJDb21taXRXb3JrLmNvbW1pdEF0dGFjaFJlZixcbiAgICAgIGNvbW1pdERldGFjaFJlZiA9IF9SZWFjdEZpYmVyQ29tbWl0V29yay5jb21taXREZXRhY2hSZWY7XG5cbiAgdmFyIG5vdyA9IGNvbmZpZy5ub3csXG4gICAgICBzY2hlZHVsZURlZmVycmVkQ2FsbGJhY2sgPSBjb25maWcuc2NoZWR1bGVEZWZlcnJlZENhbGxiYWNrLFxuICAgICAgY2FuY2VsRGVmZXJyZWRDYWxsYmFjayA9IGNvbmZpZy5jYW5jZWxEZWZlcnJlZENhbGxiYWNrLFxuICAgICAgdXNlU3luY1NjaGVkdWxpbmcgPSBjb25maWcudXNlU3luY1NjaGVkdWxpbmcsXG4gICAgICBwcmVwYXJlRm9yQ29tbWl0ID0gY29uZmlnLnByZXBhcmVGb3JDb21taXQsXG4gICAgICByZXNldEFmdGVyQ29tbWl0ID0gY29uZmlnLnJlc2V0QWZ0ZXJDb21taXQ7XG5cbiAgLy8gUmVwcmVzZW50cyB0aGUgY3VycmVudCB0aW1lIGluIG1zLlxuXG4gIHZhciBzdGFydFRpbWUgPSBub3coKTtcbiAgdmFyIG1vc3RSZWNlbnRDdXJyZW50VGltZSA9IG1zVG9FeHBpcmF0aW9uVGltZSgwKTtcblxuICAvLyBSZXByZXNlbnRzIHRoZSBleHBpcmF0aW9uIHRpbWUgdGhhdCBpbmNvbWluZyB1cGRhdGVzIHNob3VsZCB1c2UuIChJZiB0aGlzXG4gIC8vIGlzIE5vV29yaywgdXNlIHRoZSBkZWZhdWx0IHN0cmF0ZWd5OiBhc3luYyB1cGRhdGVzIGluIGFzeW5jIG1vZGUsIHN5bmNcbiAgLy8gdXBkYXRlcyBpbiBzeW5jIG1vZGUuKVxuICB2YXIgZXhwaXJhdGlvbkNvbnRleHQgPSBOb1dvcms7XG5cbiAgdmFyIGlzV29ya2luZyA9IGZhbHNlO1xuXG4gIC8vIFRoZSBuZXh0IHdvcmsgaW4gcHJvZ3Jlc3MgZmliZXIgdGhhdCB3ZSdyZSBjdXJyZW50bHkgd29ya2luZyBvbi5cbiAgdmFyIG5leHRVbml0T2ZXb3JrID0gbnVsbDtcbiAgdmFyIG5leHRSb290ID0gbnVsbDtcbiAgLy8gVGhlIHRpbWUgYXQgd2hpY2ggd2UncmUgY3VycmVudGx5IHJlbmRlcmluZyB3b3JrLlxuICB2YXIgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuXG4gIC8vIFRoZSBuZXh0IGZpYmVyIHdpdGggYW4gZWZmZWN0IHRoYXQgd2UncmUgY3VycmVudGx5IGNvbW1pdHRpbmcuXG4gIHZhciBuZXh0RWZmZWN0ID0gbnVsbDtcblxuICAvLyBLZWVwIHRyYWNrIG9mIHdoaWNoIGZpYmVycyBoYXZlIGNhcHR1cmVkIGFuIGVycm9yIHRoYXQgbmVlZCB0byBiZSBoYW5kbGVkLlxuICAvLyBXb3JrIGlzIHJlbW92ZWQgZnJvbSB0aGlzIGNvbGxlY3Rpb24gYWZ0ZXIgY29tcG9uZW50RGlkQ2F0Y2ggaXMgY2FsbGVkLlxuICB2YXIgY2FwdHVyZWRFcnJvcnMgPSBudWxsO1xuICAvLyBLZWVwIHRyYWNrIG9mIHdoaWNoIGZpYmVycyBoYXZlIGZhaWxlZCBkdXJpbmcgdGhlIGN1cnJlbnQgYmF0Y2ggb2Ygd29yay5cbiAgLy8gVGhpcyBpcyBhIGRpZmZlcmVudCBzZXQgdGhhbiBjYXB0dXJlZEVycm9ycywgYmVjYXVzZSBpdCBpcyBub3QgcmVzZXQgdW50aWxcbiAgLy8gdGhlIGVuZCBvZiB0aGUgYmF0Y2guIFRoaXMgaXMgbmVlZGVkIHRvIHByb3BhZ2F0ZSBlcnJvcnMgY29ycmVjdGx5IGlmIGFcbiAgLy8gc3VidHJlZSBmYWlscyBtb3JlIHRoYW4gb25jZS5cbiAgdmFyIGZhaWxlZEJvdW5kYXJpZXMgPSBudWxsO1xuICAvLyBFcnJvciBib3VuZGFyaWVzIHRoYXQgY2FwdHVyZWQgYW4gZXJyb3IgZHVyaW5nIHRoZSBjdXJyZW50IGNvbW1pdC5cbiAgdmFyIGNvbW1pdFBoYXNlQm91bmRhcmllcyA9IG51bGw7XG4gIHZhciBmaXJzdFVuY2F1Z2h0RXJyb3IgPSBudWxsO1xuICB2YXIgZGlkRmF0YWwgPSBmYWxzZTtcblxuICB2YXIgaXNDb21taXR0aW5nID0gZmFsc2U7XG4gIHZhciBpc1VubW91bnRpbmcgPSBmYWxzZTtcblxuICAvLyBVc2VkIGZvciBwZXJmb3JtYW5jZSB0cmFja2luZy5cbiAgdmFyIGludGVycnVwdGVkQnkgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIHJlc2V0Q29udGV4dFN0YWNrKCkge1xuICAgIC8vIFJlc2V0IHRoZSBzdGFja1xuICAgIHJlc2V0JDEoKTtcbiAgICAvLyBSZXNldCB0aGUgY3Vyc29yc1xuICAgIHJlc2V0Q29udGV4dCgpO1xuICAgIHJlc2V0SG9zdENvbnRhaW5lcigpO1xuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0QWxsSG9zdEVmZmVjdHMoKSB7XG4gICAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgIHtcbiAgICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50RmliZXIobmV4dEVmZmVjdCk7XG4gICAgICB9XG4gICAgICByZWNvcmRFZmZlY3QoKTtcblxuICAgICAgdmFyIGVmZmVjdFRhZyA9IG5leHRFZmZlY3QuZWZmZWN0VGFnO1xuICAgICAgaWYgKGVmZmVjdFRhZyAmIENvbnRlbnRSZXNldCkge1xuICAgICAgICBjb21taXRSZXNldFRleHRDb250ZW50KG5leHRFZmZlY3QpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWZmZWN0VGFnICYgUmVmKSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gbmV4dEVmZmVjdC5hbHRlcm5hdGU7XG4gICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgY29tbWl0RGV0YWNoUmVmKGN1cnJlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBmb2xsb3dpbmcgc3dpdGNoIHN0YXRlbWVudCBpcyBvbmx5IGNvbmNlcm5lZCBhYm91dCBwbGFjZW1lbnQsXG4gICAgICAvLyB1cGRhdGVzLCBhbmQgZGVsZXRpb25zLiBUbyBhdm9pZCBuZWVkaW5nIHRvIGFkZCBhIGNhc2UgZm9yIGV2ZXJ5XG4gICAgICAvLyBwb3NzaWJsZSBiaXRtYXAgdmFsdWUsIHdlIHJlbW92ZSB0aGUgc2Vjb25kYXJ5IGVmZmVjdHMgZnJvbSB0aGVcbiAgICAgIC8vIGVmZmVjdCB0YWcgYW5kIHN3aXRjaCBvbiB0aGF0IHZhbHVlLlxuICAgICAgdmFyIHByaW1hcnlFZmZlY3RUYWcgPSBlZmZlY3RUYWcgJiB+KENhbGxiYWNrIHwgRXJyIHwgQ29udGVudFJlc2V0IHwgUmVmIHwgUGVyZm9ybWVkV29yayk7XG4gICAgICBzd2l0Y2ggKHByaW1hcnlFZmZlY3RUYWcpIHtcbiAgICAgICAgY2FzZSBQbGFjZW1lbnQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29tbWl0UGxhY2VtZW50KG5leHRFZmZlY3QpO1xuICAgICAgICAgICAgLy8gQ2xlYXIgdGhlIFwicGxhY2VtZW50XCIgZnJvbSBlZmZlY3QgdGFnIHNvIHRoYXQgd2Uga25vdyB0aGF0IHRoaXMgaXMgaW5zZXJ0ZWQsIGJlZm9yZVxuICAgICAgICAgICAgLy8gYW55IGxpZmUtY3ljbGVzIGxpa2UgY29tcG9uZW50RGlkTW91bnQgZ2V0cyBjYWxsZWQuXG4gICAgICAgICAgICAvLyBUT0RPOiBmaW5kRE9NTm9kZSBkb2Vzbid0IHJlbHkgb24gdGhpcyBhbnkgbW9yZSBidXQgaXNNb3VudGVkXG4gICAgICAgICAgICAvLyBkb2VzIGFuZCBpc01vdW50ZWQgaXMgZGVwcmVjYXRlZCBhbnl3YXkgc28gd2Ugc2hvdWxkIGJlIGFibGVcbiAgICAgICAgICAgIC8vIHRvIGtpbGwgdGhpcy5cbiAgICAgICAgICAgIG5leHRFZmZlY3QuZWZmZWN0VGFnICY9IH5QbGFjZW1lbnQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgUGxhY2VtZW50QW5kVXBkYXRlOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vIFBsYWNlbWVudFxuICAgICAgICAgICAgY29tbWl0UGxhY2VtZW50KG5leHRFZmZlY3QpO1xuICAgICAgICAgICAgLy8gQ2xlYXIgdGhlIFwicGxhY2VtZW50XCIgZnJvbSBlZmZlY3QgdGFnIHNvIHRoYXQgd2Uga25vdyB0aGF0IHRoaXMgaXMgaW5zZXJ0ZWQsIGJlZm9yZVxuICAgICAgICAgICAgLy8gYW55IGxpZmUtY3ljbGVzIGxpa2UgY29tcG9uZW50RGlkTW91bnQgZ2V0cyBjYWxsZWQuXG4gICAgICAgICAgICBuZXh0RWZmZWN0LmVmZmVjdFRhZyAmPSB+UGxhY2VtZW50O1xuXG4gICAgICAgICAgICAvLyBVcGRhdGVcbiAgICAgICAgICAgIHZhciBfY3VycmVudCA9IG5leHRFZmZlY3QuYWx0ZXJuYXRlO1xuICAgICAgICAgICAgY29tbWl0V29yayhfY3VycmVudCwgbmV4dEVmZmVjdCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgVXBkYXRlOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfY3VycmVudDIgPSBuZXh0RWZmZWN0LmFsdGVybmF0ZTtcbiAgICAgICAgICAgIGNvbW1pdFdvcmsoX2N1cnJlbnQyLCBuZXh0RWZmZWN0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBEZWxldGlvbjpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpc1VubW91bnRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgY29tbWl0RGVsZXRpb24obmV4dEVmZmVjdCk7XG4gICAgICAgICAgICBpc1VubW91bnRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5leHRFZmZlY3QgPSBuZXh0RWZmZWN0Lm5leHRFZmZlY3Q7XG4gICAgfVxuXG4gICAge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5yZXNldEN1cnJlbnRGaWJlcigpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbW1pdEFsbExpZmVDeWNsZXMoKSB7XG4gICAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgIHZhciBlZmZlY3RUYWcgPSBuZXh0RWZmZWN0LmVmZmVjdFRhZztcblxuICAgICAgaWYgKGVmZmVjdFRhZyAmIChVcGRhdGUgfCBDYWxsYmFjaykpIHtcbiAgICAgICAgcmVjb3JkRWZmZWN0KCk7XG4gICAgICAgIHZhciBjdXJyZW50ID0gbmV4dEVmZmVjdC5hbHRlcm5hdGU7XG4gICAgICAgIGNvbW1pdExpZmVDeWNsZXMoY3VycmVudCwgbmV4dEVmZmVjdCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlZmZlY3RUYWcgJiBSZWYpIHtcbiAgICAgICAgcmVjb3JkRWZmZWN0KCk7XG4gICAgICAgIGNvbW1pdEF0dGFjaFJlZihuZXh0RWZmZWN0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVmZmVjdFRhZyAmIEVycikge1xuICAgICAgICByZWNvcmRFZmZlY3QoKTtcbiAgICAgICAgY29tbWl0RXJyb3JIYW5kbGluZyhuZXh0RWZmZWN0KTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5leHQgPSBuZXh0RWZmZWN0Lm5leHRFZmZlY3Q7XG4gICAgICAvLyBFbnN1cmUgdGhhdCB3ZSBjbGVhbiB0aGVzZSB1cCBzbyB0aGF0IHdlIGRvbid0IGFjY2lkZW50YWxseSBrZWVwIHRoZW0uXG4gICAgICAvLyBJJ20gbm90IGFjdHVhbGx5IHN1cmUgdGhpcyBtYXR0ZXJzIGJlY2F1c2Ugd2UgY2FuJ3QgcmVzZXQgZmlyc3RFZmZlY3RcbiAgICAgIC8vIGFuZCBsYXN0RWZmZWN0IHNpbmNlIHRoZXkncmUgb24gZXZlcnkgbm9kZSwgbm90IGp1c3QgdGhlIGVmZmVjdGZ1bFxuICAgICAgLy8gb25lcy4gU28gd2UgaGF2ZSB0byBjbGVhbiBldmVyeXRoaW5nIGFzIHdlIHJldXNlIG5vZGVzIGFueXdheS5cbiAgICAgIG5leHRFZmZlY3QubmV4dEVmZmVjdCA9IG51bGw7XG4gICAgICAvLyBFbnN1cmUgdGhhdCB3ZSByZXNldCB0aGUgZWZmZWN0VGFnIGhlcmUgc28gdGhhdCB3ZSBjYW4gcmVseSBvbiBlZmZlY3RcbiAgICAgIC8vIHRhZ3MgdG8gcmVhc29uIGFib3V0IHRoZSBjdXJyZW50IGxpZmUtY3ljbGUuXG4gICAgICBuZXh0RWZmZWN0ID0gbmV4dDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21taXRSb290KGZpbmlzaGVkV29yaykge1xuICAgIC8vIFdlIGtlZXAgdHJhY2sgb2YgdGhpcyBzbyB0aGF0IGNhcHR1cmVFcnJvciBjYW4gY29sbGVjdCBhbnkgYm91bmRhcmllc1xuICAgIC8vIHRoYXQgY2FwdHVyZSBhbiBlcnJvciBkdXJpbmcgdGhlIGNvbW1pdCBwaGFzZS4gVGhlIHJlYXNvbiB0aGVzZSBhcmVuJ3RcbiAgICAvLyBsb2NhbCB0byB0aGlzIGZ1bmN0aW9uIGlzIGJlY2F1c2UgZXJyb3JzIHRoYXQgb2NjdXIgZHVyaW5nIGNXVSBhcmVcbiAgICAvLyBjYXB0dXJlZCBlbHNld2hlcmUsIHRvIHByZXZlbnQgdGhlIHVubW91bnQgZnJvbSBiZWluZyBpbnRlcnJ1cHRlZC5cbiAgICBpc1dvcmtpbmcgPSB0cnVlO1xuICAgIGlzQ29tbWl0dGluZyA9IHRydWU7XG4gICAgc3RhcnRDb21taXRUaW1lcigpO1xuXG4gICAgdmFyIHJvb3QgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICEocm9vdC5jdXJyZW50ICE9PSBmaW5pc2hlZFdvcmspID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGNvbW1pdCB0aGUgc2FtZSB0cmVlIGFzIGJlZm9yZS4gVGhpcyBpcyBwcm9iYWJseSBhIGJ1ZyByZWxhdGVkIHRvIHRoZSByZXR1cm4gZmllbGQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgcm9vdC5pc1JlYWR5Rm9yQ29tbWl0ID0gZmFsc2U7XG5cbiAgICAvLyBSZXNldCB0aGlzIHRvIG51bGwgYmVmb3JlIGNhbGxpbmcgbGlmZWN5Y2xlc1xuICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSBudWxsO1xuXG4gICAgdmFyIGZpcnN0RWZmZWN0ID0gdm9pZCAwO1xuICAgIGlmIChmaW5pc2hlZFdvcmsuZWZmZWN0VGFnID4gUGVyZm9ybWVkV29yaykge1xuICAgICAgLy8gQSBmaWJlcidzIGVmZmVjdCBsaXN0IGNvbnNpc3RzIG9ubHkgb2YgaXRzIGNoaWxkcmVuLCBub3QgaXRzZWxmLiBTbyBpZlxuICAgICAgLy8gdGhlIHJvb3QgaGFzIGFuIGVmZmVjdCwgd2UgbmVlZCB0byBhZGQgaXQgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdC4gVGhlXG4gICAgICAvLyByZXN1bHRpbmcgbGlzdCBpcyB0aGUgc2V0IHRoYXQgd291bGQgYmVsb25nIHRvIHRoZSByb290J3MgcGFyZW50LCBpZlxuICAgICAgLy8gaXQgaGFkIG9uZTsgdGhhdCBpcywgYWxsIHRoZSBlZmZlY3RzIGluIHRoZSB0cmVlIGluY2x1ZGluZyB0aGUgcm9vdC5cbiAgICAgIGlmIChmaW5pc2hlZFdvcmsubGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgICBmaW5pc2hlZFdvcmsubGFzdEVmZmVjdC5uZXh0RWZmZWN0ID0gZmluaXNoZWRXb3JrO1xuICAgICAgICBmaXJzdEVmZmVjdCA9IGZpbmlzaGVkV29yay5maXJzdEVmZmVjdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpcnN0RWZmZWN0ID0gZmluaXNoZWRXb3JrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGVyZSBpcyBubyBlZmZlY3Qgb24gdGhlIHJvb3QuXG4gICAgICBmaXJzdEVmZmVjdCA9IGZpbmlzaGVkV29yay5maXJzdEVmZmVjdDtcbiAgICB9XG5cbiAgICBwcmVwYXJlRm9yQ29tbWl0KCk7XG5cbiAgICAvLyBDb21taXQgYWxsIHRoZSBzaWRlLWVmZmVjdHMgd2l0aGluIGEgdHJlZS4gV2UnbGwgZG8gdGhpcyBpbiB0d28gcGFzc2VzLlxuICAgIC8vIFRoZSBmaXJzdCBwYXNzIHBlcmZvcm1zIGFsbCB0aGUgaG9zdCBpbnNlcnRpb25zLCB1cGRhdGVzLCBkZWxldGlvbnMgYW5kXG4gICAgLy8gcmVmIHVubW91bnRzLlxuICAgIG5leHRFZmZlY3QgPSBmaXJzdEVmZmVjdDtcbiAgICBzdGFydENvbW1pdEhvc3RFZmZlY3RzVGltZXIoKTtcbiAgICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgdmFyIGRpZEVycm9yID0gZmFsc2U7XG4gICAgICB2YXIgX2Vycm9yID0gdm9pZCAwO1xuICAgICAge1xuICAgICAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2skMShudWxsLCBjb21taXRBbGxIb3N0RWZmZWN0cywgbnVsbCk7XG4gICAgICAgIGlmIChoYXNDYXVnaHRFcnJvcigpKSB7XG4gICAgICAgICAgZGlkRXJyb3IgPSB0cnVlO1xuICAgICAgICAgIF9lcnJvciA9IGNsZWFyQ2F1Z2h0RXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGRpZEVycm9yKSB7XG4gICAgICAgICEobmV4dEVmZmVjdCAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdTaG91bGQgaGF2ZSBuZXh0IGVmZmVjdC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgICAgY2FwdHVyZUVycm9yKG5leHRFZmZlY3QsIF9lcnJvcik7XG4gICAgICAgIC8vIENsZWFuLXVwXG4gICAgICAgIGlmIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgbmV4dEVmZmVjdCA9IG5leHRFZmZlY3QubmV4dEVmZmVjdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBzdG9wQ29tbWl0SG9zdEVmZmVjdHNUaW1lcigpO1xuXG4gICAgcmVzZXRBZnRlckNvbW1pdCgpO1xuXG4gICAgLy8gVGhlIHdvcmstaW4tcHJvZ3Jlc3MgdHJlZSBpcyBub3cgdGhlIGN1cnJlbnQgdHJlZS4gVGhpcyBtdXN0IGNvbWUgYWZ0ZXJcbiAgICAvLyB0aGUgZmlyc3QgcGFzcyBvZiB0aGUgY29tbWl0IHBoYXNlLCBzbyB0aGF0IHRoZSBwcmV2aW91cyB0cmVlIGlzIHN0aWxsXG4gICAgLy8gY3VycmVudCBkdXJpbmcgY29tcG9uZW50V2lsbFVubW91bnQsIGJ1dCBiZWZvcmUgdGhlIHNlY29uZCBwYXNzLCBzbyB0aGF0XG4gICAgLy8gdGhlIGZpbmlzaGVkIHdvcmsgaXMgY3VycmVudCBkdXJpbmcgY29tcG9uZW50RGlkTW91bnQvVXBkYXRlLlxuICAgIHJvb3QuY3VycmVudCA9IGZpbmlzaGVkV29yaztcblxuICAgIC8vIEluIHRoZSBzZWNvbmQgcGFzcyB3ZSdsbCBwZXJmb3JtIGFsbCBsaWZlLWN5Y2xlcyBhbmQgcmVmIGNhbGxiYWNrcy5cbiAgICAvLyBMaWZlLWN5Y2xlcyBoYXBwZW4gYXMgYSBzZXBhcmF0ZSBwYXNzIHNvIHRoYXQgYWxsIHBsYWNlbWVudHMsIHVwZGF0ZXMsXG4gICAgLy8gYW5kIGRlbGV0aW9ucyBpbiB0aGUgZW50aXJlIHRyZWUgaGF2ZSBhbHJlYWR5IGJlZW4gaW52b2tlZC5cbiAgICAvLyBUaGlzIHBhc3MgYWxzbyB0cmlnZ2VycyBhbnkgcmVuZGVyZXItc3BlY2lmaWMgaW5pdGlhbCBlZmZlY3RzLlxuICAgIG5leHRFZmZlY3QgPSBmaXJzdEVmZmVjdDtcbiAgICBzdGFydENvbW1pdExpZmVDeWNsZXNUaW1lcigpO1xuICAgIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICB2YXIgX2RpZEVycm9yID0gZmFsc2U7XG4gICAgICB2YXIgX2Vycm9yMiA9IHZvaWQgMDtcbiAgICAgIHtcbiAgICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrJDEobnVsbCwgY29tbWl0QWxsTGlmZUN5Y2xlcywgbnVsbCk7XG4gICAgICAgIGlmIChoYXNDYXVnaHRFcnJvcigpKSB7XG4gICAgICAgICAgX2RpZEVycm9yID0gdHJ1ZTtcbiAgICAgICAgICBfZXJyb3IyID0gY2xlYXJDYXVnaHRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoX2RpZEVycm9yKSB7XG4gICAgICAgICEobmV4dEVmZmVjdCAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdTaG91bGQgaGF2ZSBuZXh0IGVmZmVjdC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgICAgY2FwdHVyZUVycm9yKG5leHRFZmZlY3QsIF9lcnJvcjIpO1xuICAgICAgICBpZiAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgICAgIG5leHRFZmZlY3QgPSBuZXh0RWZmZWN0Lm5leHRFZmZlY3Q7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpc0NvbW1pdHRpbmcgPSBmYWxzZTtcbiAgICBpc1dvcmtpbmcgPSBmYWxzZTtcbiAgICBzdG9wQ29tbWl0TGlmZUN5Y2xlc1RpbWVyKCk7XG4gICAgc3RvcENvbW1pdFRpbWVyKCk7XG4gICAgaWYgKHR5cGVvZiBvbkNvbW1pdFJvb3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG9uQ29tbWl0Um9vdChmaW5pc2hlZFdvcmsuc3RhdGVOb2RlKTtcbiAgICB9XG4gICAgaWYgKHRydWUgJiYgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbCkge1xuICAgICAgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbC5vbkNvbW1pdFdvcmsoZmluaXNoZWRXb3JrKTtcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBjYXVnaHQgYW55IGVycm9ycyBkdXJpbmcgdGhpcyBjb21taXQsIHNjaGVkdWxlIHRoZWlyIGJvdW5kYXJpZXNcbiAgICAvLyB0byB1cGRhdGUuXG4gICAgaWYgKGNvbW1pdFBoYXNlQm91bmRhcmllcykge1xuICAgICAgY29tbWl0UGhhc2VCb3VuZGFyaWVzLmZvckVhY2goc2NoZWR1bGVFcnJvclJlY292ZXJ5KTtcbiAgICAgIGNvbW1pdFBoYXNlQm91bmRhcmllcyA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGZpcnN0VW5jYXVnaHRFcnJvciAhPT0gbnVsbCkge1xuICAgICAgdmFyIF9lcnJvcjMgPSBmaXJzdFVuY2F1Z2h0RXJyb3I7XG4gICAgICBmaXJzdFVuY2F1Z2h0RXJyb3IgPSBudWxsO1xuICAgICAgb25VbmNhdWdodEVycm9yKF9lcnJvcjMpO1xuICAgIH1cblxuICAgIHZhciByZW1haW5pbmdUaW1lID0gcm9vdC5jdXJyZW50LmV4cGlyYXRpb25UaW1lO1xuXG4gICAgaWYgKHJlbWFpbmluZ1RpbWUgPT09IE5vV29yaykge1xuICAgICAgY2FwdHVyZWRFcnJvcnMgPSBudWxsO1xuICAgICAgZmFpbGVkQm91bmRhcmllcyA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlbWFpbmluZ1RpbWU7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldEV4cGlyYXRpb25UaW1lKHdvcmtJblByb2dyZXNzLCByZW5kZXJUaW1lKSB7XG4gICAgaWYgKHJlbmRlclRpbWUgIT09IE5ldmVyICYmIHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lID09PSBOZXZlcikge1xuICAgICAgLy8gVGhlIGNoaWxkcmVuIG9mIHRoaXMgY29tcG9uZW50IGFyZSBoaWRkZW4uIERvbid0IGJ1YmJsZSB0aGVpclxuICAgICAgLy8gZXhwaXJhdGlvbiB0aW1lcy5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgcGVuZGluZyB1cGRhdGVzLlxuICAgIHZhciBuZXdFeHBpcmF0aW9uVGltZSA9IGdldFVwZGF0ZUV4cGlyYXRpb25UaW1lKHdvcmtJblByb2dyZXNzKTtcblxuICAgIC8vIFRPRE86IENhbGxzIG5lZWQgdG8gdmlzaXQgc3RhdGVOb2RlXG5cbiAgICAvLyBCdWJibGUgdXAgdGhlIGVhcmxpZXN0IGV4cGlyYXRpb24gdGltZS5cbiAgICB2YXIgY2hpbGQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIGlmIChjaGlsZC5leHBpcmF0aW9uVGltZSAhPT0gTm9Xb3JrICYmIChuZXdFeHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IG5ld0V4cGlyYXRpb25UaW1lID4gY2hpbGQuZXhwaXJhdGlvblRpbWUpKSB7XG4gICAgICAgIG5ld0V4cGlyYXRpb25UaW1lID0gY2hpbGQuZXhwaXJhdGlvblRpbWU7XG4gICAgICB9XG4gICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgfVxuICAgIHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lID0gbmV3RXhwaXJhdGlvblRpbWU7XG4gIH1cblxuICBmdW5jdGlvbiBjb21wbGV0ZVVuaXRPZldvcmsod29ya0luUHJvZ3Jlc3MpIHtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgLy8gVGhlIGN1cnJlbnQsIGZsdXNoZWQsIHN0YXRlIG9mIHRoaXMgZmliZXIgaXMgdGhlIGFsdGVybmF0ZS5cbiAgICAgIC8vIElkZWFsbHkgbm90aGluZyBzaG91bGQgcmVseSBvbiB0aGlzLCBidXQgcmVseWluZyBvbiBpdCBoZXJlXG4gICAgICAvLyBtZWFucyB0aGF0IHdlIGRvbid0IG5lZWQgYW4gYWRkaXRpb25hbCBmaWVsZCBvbiB0aGUgd29yayBpblxuICAgICAgLy8gcHJvZ3Jlc3MuXG4gICAgICB2YXIgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtcbiAgICAgIHtcbiAgICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50RmliZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgfVxuICAgICAgdmFyIG5leHQgPSBjb21wbGV0ZVdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICB7XG4gICAgICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIucmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJldHVybkZpYmVyID0gd29ya0luUHJvZ3Jlc3NbJ3JldHVybiddO1xuICAgICAgdmFyIHNpYmxpbmdGaWJlciA9IHdvcmtJblByb2dyZXNzLnNpYmxpbmc7XG5cbiAgICAgIHJlc2V0RXhwaXJhdGlvblRpbWUod29ya0luUHJvZ3Jlc3MsIG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSk7XG5cbiAgICAgIGlmIChuZXh0ICE9PSBudWxsKSB7XG4gICAgICAgIHN0b3BXb3JrVGltZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBpZiAodHJ1ZSAmJiBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sKSB7XG4gICAgICAgICAgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbC5vbkNvbXBsZXRlV29yayh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgY29tcGxldGluZyB0aGlzIHdvcmsgc3Bhd25lZCBuZXcgd29yaywgZG8gdGhhdCBuZXh0LiBXZSdsbCBjb21lXG4gICAgICAgIC8vIGJhY2sgaGVyZSBhZ2Fpbi5cbiAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXR1cm5GaWJlciAhPT0gbnVsbCkge1xuICAgICAgICAvLyBBcHBlbmQgYWxsIHRoZSBlZmZlY3RzIG9mIHRoZSBzdWJ0cmVlIGFuZCB0aGlzIGZpYmVyIG9udG8gdGhlIGVmZmVjdFxuICAgICAgICAvLyBsaXN0IG9mIHRoZSBwYXJlbnQuIFRoZSBjb21wbGV0aW9uIG9yZGVyIG9mIHRoZSBjaGlsZHJlbiBhZmZlY3RzIHRoZVxuICAgICAgICAvLyBzaWRlLWVmZmVjdCBvcmRlci5cbiAgICAgICAgaWYgKHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuRmliZXIuZmlyc3RFZmZlY3QgPSB3b3JrSW5Qcm9ncmVzcy5maXJzdEVmZmVjdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MubGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChyZXR1cm5GaWJlci5sYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0Lm5leHRFZmZlY3QgPSB3b3JrSW5Qcm9ncmVzcy5maXJzdEVmZmVjdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IHdvcmtJblByb2dyZXNzLmxhc3RFZmZlY3Q7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGlzIGZpYmVyIGhhZCBzaWRlLWVmZmVjdHMsIHdlIGFwcGVuZCBpdCBBRlRFUiB0aGUgY2hpbGRyZW4nc1xuICAgICAgICAvLyBzaWRlLWVmZmVjdHMuIFdlIGNhbiBwZXJmb3JtIGNlcnRhaW4gc2lkZS1lZmZlY3RzIGVhcmxpZXIgaWZcbiAgICAgICAgLy8gbmVlZGVkLCBieSBkb2luZyBtdWx0aXBsZSBwYXNzZXMgb3ZlciB0aGUgZWZmZWN0IGxpc3QuIFdlIGRvbid0IHdhbnRcbiAgICAgICAgLy8gdG8gc2NoZWR1bGUgb3VyIG93biBzaWRlLWVmZmVjdCBvbiBvdXIgb3duIGxpc3QgYmVjYXVzZSBpZiBlbmQgdXBcbiAgICAgICAgLy8gcmV1c2luZyBjaGlsZHJlbiB3ZSdsbCBzY2hlZHVsZSB0aGlzIGVmZmVjdCBvbnRvIGl0c2VsZiBzaW5jZSB3ZSdyZVxuICAgICAgICAvLyBhdCB0aGUgZW5kLlxuICAgICAgICB2YXIgZWZmZWN0VGFnID0gd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnO1xuICAgICAgICAvLyBTa2lwIGJvdGggTm9Xb3JrIGFuZCBQZXJmb3JtZWRXb3JrIHRhZ3Mgd2hlbiBjcmVhdGluZyB0aGUgZWZmZWN0IGxpc3QuXG4gICAgICAgIC8vIFBlcmZvcm1lZFdvcmsgZWZmZWN0IGlzIHJlYWQgYnkgUmVhY3QgRGV2VG9vbHMgYnV0IHNob3VsZG4ndCBiZSBjb21taXR0ZWQuXG4gICAgICAgIGlmIChlZmZlY3RUYWcgPiBQZXJmb3JtZWRXb3JrKSB7XG4gICAgICAgICAgaWYgKHJldHVybkZpYmVyLmxhc3RFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QubmV4dEVmZmVjdCA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3RvcFdvcmtUaW1lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBpZiAodHJ1ZSAmJiBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sKSB7XG4gICAgICAgIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wub25Db21wbGV0ZVdvcmsod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2libGluZ0ZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG1vcmUgd29yayB0byBkbyBpbiB0aGlzIHJldHVybkZpYmVyLCBkbyB0aGF0IG5leHQuXG4gICAgICAgIHJldHVybiBzaWJsaW5nRmliZXI7XG4gICAgICB9IGVsc2UgaWYgKHJldHVybkZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gbW9yZSB3b3JrIGluIHRoaXMgcmV0dXJuRmliZXIuIENvbXBsZXRlIHRoZSByZXR1cm5GaWJlci5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSByZXR1cm5GaWJlcjtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXZSd2ZSByZWFjaGVkIHRoZSByb290LlxuICAgICAgICB2YXIgcm9vdCA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgcm9vdC5pc1JlYWR5Rm9yQ29tbWl0ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gV2l0aG91dCB0aGlzIGV4cGxpY2l0IG51bGwgcmV0dXJuIEZsb3cgY29tcGxhaW5zIG9mIGludmFsaWQgcmV0dXJuIHR5cGVcbiAgICAvLyBUT0RPIFJlbW92ZSB0aGUgYWJvdmUgd2hpbGUodHJ1ZSkgbG9vcFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnJlYWNoYWJsZVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVyZm9ybVVuaXRPZldvcmsod29ya0luUHJvZ3Jlc3MpIHtcbiAgICAvLyBUaGUgY3VycmVudCwgZmx1c2hlZCwgc3RhdGUgb2YgdGhpcyBmaWJlciBpcyB0aGUgYWx0ZXJuYXRlLlxuICAgIC8vIElkZWFsbHkgbm90aGluZyBzaG91bGQgcmVseSBvbiB0aGlzLCBidXQgcmVseWluZyBvbiBpdCBoZXJlXG4gICAgLy8gbWVhbnMgdGhhdCB3ZSBkb24ndCBuZWVkIGFuIGFkZGl0aW9uYWwgZmllbGQgb24gdGhlIHdvcmsgaW5cbiAgICAvLyBwcm9ncmVzcy5cbiAgICB2YXIgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtcblxuICAgIC8vIFNlZSBpZiBiZWdpbm5pbmcgdGhpcyB3b3JrIHNwYXducyBtb3JlIHdvcmsuXG4gICAgc3RhcnRXb3JrVGltZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIuc2V0Q3VycmVudEZpYmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICB2YXIgbmV4dCA9IGJlZ2luV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgfVxuICAgIGlmICh0cnVlICYmIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wpIHtcbiAgICAgIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wub25CZWdpbldvcmsod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIGlmIChuZXh0ID09PSBudWxsKSB7XG4gICAgICAvLyBJZiB0aGlzIGRvZXNuJ3Qgc3Bhd24gbmV3IHdvcmssIGNvbXBsZXRlIHRoZSBjdXJyZW50IHdvcmsuXG4gICAgICBuZXh0ID0gY29tcGxldGVVbml0T2ZXb3JrKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gbnVsbDtcblxuICAgIHJldHVybiBuZXh0O1xuICB9XG5cbiAgZnVuY3Rpb24gcGVyZm9ybUZhaWxlZFVuaXRPZldvcmsod29ya0luUHJvZ3Jlc3MpIHtcbiAgICAvLyBUaGUgY3VycmVudCwgZmx1c2hlZCwgc3RhdGUgb2YgdGhpcyBmaWJlciBpcyB0aGUgYWx0ZXJuYXRlLlxuICAgIC8vIElkZWFsbHkgbm90aGluZyBzaG91bGQgcmVseSBvbiB0aGlzLCBidXQgcmVseWluZyBvbiBpdCBoZXJlXG4gICAgLy8gbWVhbnMgdGhhdCB3ZSBkb24ndCBuZWVkIGFuIGFkZGl0aW9uYWwgZmllbGQgb24gdGhlIHdvcmsgaW5cbiAgICAvLyBwcm9ncmVzcy5cbiAgICB2YXIgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtcblxuICAgIC8vIFNlZSBpZiBiZWdpbm5pbmcgdGhpcyB3b3JrIHNwYXducyBtb3JlIHdvcmsuXG4gICAgc3RhcnRXb3JrVGltZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIuc2V0Q3VycmVudEZpYmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gICAgdmFyIG5leHQgPSBiZWdpbkZhaWxlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5yZXNldEN1cnJlbnRGaWJlcigpO1xuICAgIH1cbiAgICBpZiAodHJ1ZSAmJiBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sKSB7XG4gICAgICBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sLm9uQmVnaW5Xb3JrKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICBpZiAobmV4dCA9PT0gbnVsbCkge1xuICAgICAgLy8gSWYgdGhpcyBkb2Vzbid0IHNwYXduIG5ldyB3b3JrLCBjb21wbGV0ZSB0aGUgY3VycmVudCB3b3JrLlxuICAgICAgbmV4dCA9IGNvbXBsZXRlVW5pdE9mV29yayh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IG51bGw7XG5cbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdvcmtMb29wKGV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKGNhcHR1cmVkRXJyb3JzICE9PSBudWxsKSB7XG4gICAgICAvLyBJZiB0aGVyZSBhcmUgdW5oYW5kbGVkIGVycm9ycywgc3dpdGNoIHRvIHRoZSBzbG93IHdvcmsgbG9vcC5cbiAgICAgIC8vIFRPRE86IEhvdyB0byBhdm9pZCB0aGlzIGNoZWNrIGluIHRoZSBmYXN0IHBhdGg/IE1heWJlIHRoZSByZW5kZXJlclxuICAgICAgLy8gY291bGQga2VlcCB0cmFjayBvZiB3aGljaCByb290cyBoYXZlIHVuaGFuZGxlZCBlcnJvcnMgYW5kIGNhbGwgYVxuICAgICAgLy8gZm9ya2VkIHZlcnNpb24gb2YgcmVuZGVyUm9vdC5cbiAgICAgIHNsb3dXb3JrTG9vcFRoYXRDaGVja3NGb3JGYWlsZWRXb3JrKGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSA+IGV4cGlyYXRpb25UaW1lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSA8PSBtb3N0UmVjZW50Q3VycmVudFRpbWUpIHtcbiAgICAgIC8vIEZsdXNoIGFsbCBleHBpcmVkIHdvcmsuXG4gICAgICB3aGlsZSAobmV4dFVuaXRPZldvcmsgIT09IG51bGwpIHtcbiAgICAgICAgbmV4dFVuaXRPZldvcmsgPSBwZXJmb3JtVW5pdE9mV29yayhuZXh0VW5pdE9mV29yayk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZsdXNoIGFzeW5jaHJvbm91cyB3b3JrIHVudGlsIHRoZSBkZWFkbGluZSBydW5zIG91dCBvZiB0aW1lLlxuICAgICAgd2hpbGUgKG5leHRVbml0T2ZXb3JrICE9PSBudWxsICYmICFzaG91bGRZaWVsZCgpKSB7XG4gICAgICAgIG5leHRVbml0T2ZXb3JrID0gcGVyZm9ybVVuaXRPZldvcmsobmV4dFVuaXRPZldvcmspO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNsb3dXb3JrTG9vcFRoYXRDaGVja3NGb3JGYWlsZWRXb3JrKGV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSA+IGV4cGlyYXRpb25UaW1lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSA8PSBtb3N0UmVjZW50Q3VycmVudFRpbWUpIHtcbiAgICAgIC8vIEZsdXNoIGFsbCBleHBpcmVkIHdvcmsuXG4gICAgICB3aGlsZSAobmV4dFVuaXRPZldvcmsgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKGhhc0NhcHR1cmVkRXJyb3IobmV4dFVuaXRPZldvcmspKSB7XG4gICAgICAgICAgLy8gVXNlIGEgZm9ya2VkIHZlcnNpb24gb2YgcGVyZm9ybVVuaXRPZldvcmtcbiAgICAgICAgICBuZXh0VW5pdE9mV29yayA9IHBlcmZvcm1GYWlsZWRVbml0T2ZXb3JrKG5leHRVbml0T2ZXb3JrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0VW5pdE9mV29yayA9IHBlcmZvcm1Vbml0T2ZXb3JrKG5leHRVbml0T2ZXb3JrKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGbHVzaCBhc3luY2hyb25vdXMgd29yayB1bnRpbCB0aGUgZGVhZGxpbmUgcnVucyBvdXQgb2YgdGltZS5cbiAgICAgIHdoaWxlIChuZXh0VW5pdE9mV29yayAhPT0gbnVsbCAmJiAhc2hvdWxkWWllbGQoKSkge1xuICAgICAgICBpZiAoaGFzQ2FwdHVyZWRFcnJvcihuZXh0VW5pdE9mV29yaykpIHtcbiAgICAgICAgICAvLyBVc2UgYSBmb3JrZWQgdmVyc2lvbiBvZiBwZXJmb3JtVW5pdE9mV29ya1xuICAgICAgICAgIG5leHRVbml0T2ZXb3JrID0gcGVyZm9ybUZhaWxlZFVuaXRPZldvcmsobmV4dFVuaXRPZldvcmspO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHRVbml0T2ZXb3JrID0gcGVyZm9ybVVuaXRPZldvcmsobmV4dFVuaXRPZldvcmspO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVuZGVyUm9vdENhdGNoQmxvY2socm9vdCwgZmFpbGVkV29yaywgYm91bmRhcnksIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gV2UncmUgZ29pbmcgdG8gcmVzdGFydCB0aGUgZXJyb3IgYm91bmRhcnkgdGhhdCBjYXB0dXJlZCB0aGUgZXJyb3IuXG4gICAgLy8gQ29uY2VwdHVhbGx5LCB3ZSdyZSB1bndpbmRpbmcgdGhlIHN0YWNrLiBXZSBuZWVkIHRvIHVud2luZCB0aGVcbiAgICAvLyBjb250ZXh0IHN0YWNrLCB0b28uXG4gICAgdW53aW5kQ29udGV4dHMoZmFpbGVkV29yaywgYm91bmRhcnkpO1xuXG4gICAgLy8gUmVzdGFydCB0aGUgZXJyb3IgYm91bmRhcnkgdXNpbmcgYSBmb3JrZWQgdmVyc2lvbiBvZlxuICAgIC8vIHBlcmZvcm1Vbml0T2ZXb3JrIHRoYXQgZGVsZXRlcyB0aGUgYm91bmRhcnkncyBjaGlsZHJlbi4gVGhlIGVudGlyZVxuICAgIC8vIGZhaWxlZCBzdWJyZWUgd2lsbCBiZSB1bm1vdW50ZWQuIER1cmluZyB0aGUgY29tbWl0IHBoYXNlLCBhIHNwZWNpYWxcbiAgICAvLyBsaWZlY3ljbGUgbWV0aG9kIGlzIGNhbGxlZCBvbiB0aGUgZXJyb3IgYm91bmRhcnksIHdoaWNoIHRyaWdnZXJzXG4gICAgLy8gYSByZS1yZW5kZXIuXG4gICAgbmV4dFVuaXRPZldvcmsgPSBwZXJmb3JtRmFpbGVkVW5pdE9mV29yayhib3VuZGFyeSk7XG5cbiAgICAvLyBDb250aW51ZSB3b3JraW5nLlxuICAgIHdvcmtMb29wKGV4cGlyYXRpb25UaW1lKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbmRlclJvb3Qocm9vdCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICAhIWlzV29ya2luZyA/IGludmFyaWFudChmYWxzZSwgJ3JlbmRlclJvb3Qgd2FzIGNhbGxlZCByZWN1cnNpdmVseS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICBpc1dvcmtpbmcgPSB0cnVlO1xuXG4gICAgLy8gV2UncmUgYWJvdXQgdG8gbXV0YXRlIHRoZSB3b3JrLWluLXByb2dyZXNzIHRyZWUuIElmIHRoZSByb290IHdhcyBwZW5kaW5nXG4gICAgLy8gY29tbWl0LCBpdCBubyBsb25nZXIgaXM6IHdlJ2xsIG5lZWQgdG8gY29tcGxldGUgaXQgYWdhaW4uXG4gICAgcm9vdC5pc1JlYWR5Rm9yQ29tbWl0ID0gZmFsc2U7XG5cbiAgICAvLyBDaGVjayBpZiB3ZSdyZSBzdGFydGluZyBmcm9tIGEgZnJlc2ggc3RhY2ssIG9yIGlmIHdlJ3JlIHJlc3VtaW5nIGZyb21cbiAgICAvLyBwcmV2aW91c2x5IHlpZWxkZWQgd29yay5cbiAgICBpZiAocm9vdCAhPT0gbmV4dFJvb3QgfHwgZXhwaXJhdGlvblRpbWUgIT09IG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSB8fCBuZXh0VW5pdE9mV29yayA9PT0gbnVsbCkge1xuICAgICAgLy8gUmVzZXQgdGhlIHN0YWNrIGFuZCBzdGFydCB3b3JraW5nIGZyb20gdGhlIHJvb3QuXG4gICAgICByZXNldENvbnRleHRTdGFjaygpO1xuICAgICAgbmV4dFJvb3QgPSByb290O1xuICAgICAgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gICAgICBuZXh0VW5pdE9mV29yayA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKG5leHRSb290LmN1cnJlbnQsIG51bGwsIGV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG5cbiAgICBzdGFydFdvcmtMb29wVGltZXIobmV4dFVuaXRPZldvcmspO1xuXG4gICAgdmFyIGRpZEVycm9yID0gZmFsc2U7XG4gICAgdmFyIGVycm9yID0gbnVsbDtcbiAgICB7XG4gICAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2skMShudWxsLCB3b3JrTG9vcCwgbnVsbCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgaWYgKGhhc0NhdWdodEVycm9yKCkpIHtcbiAgICAgICAgZGlkRXJyb3IgPSB0cnVlO1xuICAgICAgICBlcnJvciA9IGNsZWFyQ2F1Z2h0RXJyb3IoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBbiBlcnJvciB3YXMgdGhyb3duIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlLlxuICAgIHdoaWxlIChkaWRFcnJvcikge1xuICAgICAgaWYgKGRpZEZhdGFsKSB7XG4gICAgICAgIC8vIFRoaXMgd2FzIGEgZmF0YWwgZXJyb3IuIERvbid0IGF0dGVtcHQgdG8gcmVjb3ZlciBmcm9tIGl0LlxuICAgICAgICBmaXJzdFVuY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHZhciBmYWlsZWRXb3JrID0gbmV4dFVuaXRPZldvcms7XG4gICAgICBpZiAoZmFpbGVkV29yayA9PT0gbnVsbCkge1xuICAgICAgICAvLyBBbiBlcnJvciB3YXMgdGhyb3duIGJ1dCB0aGVyZSdzIG5vIGN1cnJlbnQgdW5pdCBvZiB3b3JrLiBUaGlzIGNhblxuICAgICAgICAvLyBoYXBwZW4gZHVyaW5nIHRoZSBjb21taXQgcGhhc2UgaWYgdGhlcmUncyBhIGJ1ZyBpbiB0aGUgcmVuZGVyZXIuXG4gICAgICAgIGRpZEZhdGFsID0gdHJ1ZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIFwiQ2FwdHVyZVwiIHRoZSBlcnJvciBieSBmaW5kaW5nIHRoZSBuZWFyZXN0IGJvdW5kYXJ5LiBJZiB0aGVyZSBpcyBub1xuICAgICAgLy8gZXJyb3IgYm91bmRhcnksIHdlIHVzZSB0aGUgcm9vdC5cbiAgICAgIHZhciBib3VuZGFyeSA9IGNhcHR1cmVFcnJvcihmYWlsZWRXb3JrLCBlcnJvcik7XG4gICAgICAhKGJvdW5kYXJ5ICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1Nob3VsZCBoYXZlIGZvdW5kIGFuIGVycm9yIGJvdW5kYXJ5LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gICAgICBpZiAoZGlkRmF0YWwpIHtcbiAgICAgICAgLy8gVGhlIGVycm9yIHdlIGp1c3QgY2FwdHVyZWQgd2FzIGEgZmF0YWwgZXJyb3IuIFRoaXMgaGFwcGVuc1xuICAgICAgICAvLyB3aGVuIHRoZSBlcnJvciBwcm9wYWdhdGVzIHRvIHRoZSByb290IG1vcmUgdGhhbiBvbmNlLlxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgZGlkRXJyb3IgPSBmYWxzZTtcbiAgICAgIGVycm9yID0gbnVsbDtcbiAgICAgIHtcbiAgICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrJDEobnVsbCwgcmVuZGVyUm9vdENhdGNoQmxvY2ssIG51bGwsIHJvb3QsIGZhaWxlZFdvcmssIGJvdW5kYXJ5LCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgIGlmIChoYXNDYXVnaHRFcnJvcigpKSB7XG4gICAgICAgICAgZGlkRXJyb3IgPSB0cnVlO1xuICAgICAgICAgIGVycm9yID0gY2xlYXJDYXVnaHRFcnJvcigpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBXZSdyZSBmaW5pc2hlZCB3b3JraW5nLiBFeGl0IHRoZSBlcnJvciBsb29wLlxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIHVuY2F1Z2h0RXJyb3IgPSBmaXJzdFVuY2F1Z2h0RXJyb3I7XG5cbiAgICAvLyBXZSdyZSBkb25lIHBlcmZvcm1pbmcgd29yay4gVGltZSB0byBjbGVhbiB1cC5cbiAgICBzdG9wV29ya0xvb3BUaW1lcihpbnRlcnJ1cHRlZEJ5KTtcbiAgICBpbnRlcnJ1cHRlZEJ5ID0gbnVsbDtcbiAgICBpc1dvcmtpbmcgPSBmYWxzZTtcbiAgICBkaWRGYXRhbCA9IGZhbHNlO1xuICAgIGZpcnN0VW5jYXVnaHRFcnJvciA9IG51bGw7XG5cbiAgICBpZiAodW5jYXVnaHRFcnJvciAhPT0gbnVsbCkge1xuICAgICAgb25VbmNhdWdodEVycm9yKHVuY2F1Z2h0RXJyb3IpO1xuICAgIH1cblxuICAgIHJldHVybiByb290LmlzUmVhZHlGb3JDb21taXQgPyByb290LmN1cnJlbnQuYWx0ZXJuYXRlIDogbnVsbDtcbiAgfVxuXG4gIC8vIFJldHVybnMgdGhlIGJvdW5kYXJ5IHRoYXQgY2FwdHVyZWQgdGhlIGVycm9yLCBvciBudWxsIGlmIHRoZSBlcnJvciBpcyBpZ25vcmVkXG4gIGZ1bmN0aW9uIGNhcHR1cmVFcnJvcihmYWlsZWRXb3JrLCBlcnJvcikge1xuICAgIC8vIEl0IGlzIG5vIGxvbmdlciB2YWxpZCBiZWNhdXNlIHdlIGV4aXRlZCB0aGUgdXNlciBjb2RlLlxuICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSBudWxsO1xuICAgIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIucmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICB9XG5cbiAgICAvLyBTZWFyY2ggZm9yIHRoZSBuZWFyZXN0IGVycm9yIGJvdW5kYXJ5LlxuICAgIHZhciBib3VuZGFyeSA9IG51bGw7XG5cbiAgICAvLyBQYXNzZWQgdG8gbG9nQ2FwdHVyZWRFcnJvcigpXG4gICAgdmFyIGVycm9yQm91bmRhcnlGb3VuZCA9IGZhbHNlO1xuICAgIHZhciB3aWxsUmV0cnkgPSBmYWxzZTtcbiAgICB2YXIgZXJyb3JCb3VuZGFyeU5hbWUgPSBudWxsO1xuXG4gICAgLy8gSG9zdCBjb250YWluZXJzIGFyZSBhIHNwZWNpYWwgY2FzZS4gSWYgdGhlIGZhaWxlZCB3b3JrIGl0c2VsZiBpcyBhIGhvc3RcbiAgICAvLyBjb250YWluZXIsIHRoZW4gaXQgYWN0cyBhcyBpdHMgb3duIGJvdW5kYXJ5LiBJbiBhbGwgb3RoZXIgY2FzZXMsIHdlXG4gICAgLy8gaWdub3JlIHRoZSB3b3JrIGl0c2VsZiBhbmQgb25seSBzZWFyY2ggdGhyb3VnaCB0aGUgcGFyZW50cy5cbiAgICBpZiAoZmFpbGVkV29yay50YWcgPT09IEhvc3RSb290KSB7XG4gICAgICBib3VuZGFyeSA9IGZhaWxlZFdvcms7XG5cbiAgICAgIGlmIChpc0ZhaWxlZEJvdW5kYXJ5KGZhaWxlZFdvcmspKSB7XG4gICAgICAgIC8vIElmIHRoaXMgcm9vdCBhbHJlYWR5IGZhaWxlZCwgdGhlcmUgbXVzdCBoYXZlIGJlZW4gYW4gZXJyb3Igd2hlblxuICAgICAgICAvLyBhdHRlbXB0aW5nIHRvIHVubW91bnQgaXQuIFRoaXMgaXMgYSB3b3JzdC1jYXNlIHNjZW5hcmlvIGFuZFxuICAgICAgICAvLyBzaG91bGQgb25seSBiZSBwb3NzaWJsZSBpZiB0aGVyZSdzIGEgYnVnIGluIHRoZSByZW5kZXJlci5cbiAgICAgICAgZGlkRmF0YWwgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbm9kZSA9IGZhaWxlZFdvcmtbJ3JldHVybiddO1xuICAgICAgd2hpbGUgKG5vZGUgIT09IG51bGwgJiYgYm91bmRhcnkgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGUudGFnID09PSBDbGFzc0NvbXBvbmVudCkge1xuICAgICAgICAgIHZhciBpbnN0YW5jZSA9IG5vZGUuc3RhdGVOb2RlO1xuICAgICAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkQ2F0Y2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGVycm9yQm91bmRhcnlGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICBlcnJvckJvdW5kYXJ5TmFtZSA9IGdldENvbXBvbmVudE5hbWUobm9kZSk7XG5cbiAgICAgICAgICAgIC8vIEZvdW5kIGFuIGVycm9yIGJvdW5kYXJ5IVxuICAgICAgICAgICAgYm91bmRhcnkgPSBub2RlO1xuICAgICAgICAgICAgd2lsbFJldHJ5ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IEhvc3RSb290KSB7XG4gICAgICAgICAgLy8gVHJlYXQgdGhlIHJvb3QgbGlrZSBhIG5vLW9wIGVycm9yIGJvdW5kYXJ5XG4gICAgICAgICAgYm91bmRhcnkgPSBub2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRmFpbGVkQm91bmRhcnkobm9kZSkpIHtcbiAgICAgICAgICAvLyBUaGlzIGJvdW5kYXJ5IGlzIGFscmVhZHkgaW4gYSBmYWlsZWQgc3RhdGUuXG5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBjdXJyZW50bHkgdW5tb3VudGluZywgdGhhdCBtZWFucyB0aGlzIGVycm9yIHdhc1xuICAgICAgICAgIC8vIHRocm93biB3aGlsZSB1bm1vdW50aW5nIGEgZmFpbGVkIHN1YnRyZWUuIFdlIHNob3VsZCBpZ25vcmVcbiAgICAgICAgICAvLyB0aGUgZXJyb3IuXG4gICAgICAgICAgaWYgKGlzVW5tb3VudGluZykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSWYgd2UncmUgaW4gdGhlIGNvbW1pdCBwaGFzZSwgd2Ugc2hvdWxkIGNoZWNrIHRvIHNlZSBpZlxuICAgICAgICAgIC8vIHRoaXMgYm91bmRhcnkgYWxyZWFkeSBjYXB0dXJlZCBhbiBlcnJvciBkdXJpbmcgdGhpcyBjb21taXQuXG4gICAgICAgICAgLy8gVGhpcyBjYXNlIGV4aXN0cyBiZWNhdXNlIG11bHRpcGxlIGVycm9ycyBjYW4gYmUgdGhyb3duIGR1cmluZ1xuICAgICAgICAgIC8vIGEgc2luZ2xlIGNvbW1pdCB3aXRob3V0IGludGVycnVwdGlvbi5cbiAgICAgICAgICBpZiAoY29tbWl0UGhhc2VCb3VuZGFyaWVzICE9PSBudWxsICYmIChjb21taXRQaGFzZUJvdW5kYXJpZXMuaGFzKG5vZGUpIHx8IG5vZGUuYWx0ZXJuYXRlICE9PSBudWxsICYmIGNvbW1pdFBoYXNlQm91bmRhcmllcy5oYXMobm9kZS5hbHRlcm5hdGUpKSkge1xuICAgICAgICAgICAgLy8gSWYgc28sIHdlIHNob3VsZCBpZ25vcmUgdGhpcyBlcnJvci5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFRoZSBlcnJvciBzaG91bGQgcHJvcGFnYXRlIHRvIHRoZSBuZXh0IGJvdW5kYXJ5IC3igJQgd2Uga2VlcCBsb29raW5nLlxuICAgICAgICAgIGJvdW5kYXJ5ID0gbnVsbDtcbiAgICAgICAgICB3aWxsUmV0cnkgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYm91bmRhcnkgIT09IG51bGwpIHtcbiAgICAgIC8vIEFkZCB0byB0aGUgY29sbGVjdGlvbiBvZiBmYWlsZWQgYm91bmRhcmllcy4gVGhpcyBsZXRzIHVzIGtub3cgdGhhdFxuICAgICAgLy8gc3Vic2VxdWVudCBlcnJvcnMgaW4gdGhpcyBzdWJ0cmVlIHNob3VsZCBwcm9wYWdhdGUgdG8gdGhlIG5leHQgYm91bmRhcnkuXG4gICAgICBpZiAoZmFpbGVkQm91bmRhcmllcyA9PT0gbnVsbCkge1xuICAgICAgICBmYWlsZWRCb3VuZGFyaWVzID0gbmV3IFNldCgpO1xuICAgICAgfVxuICAgICAgZmFpbGVkQm91bmRhcmllcy5hZGQoYm91bmRhcnkpO1xuXG4gICAgICAvLyBUaGlzIG1ldGhvZCBpcyB1bnNhZmUgb3V0c2lkZSBvZiB0aGUgYmVnaW4gYW5kIGNvbXBsZXRlIHBoYXNlcy5cbiAgICAgIC8vIFdlIG1pZ2h0IGJlIGluIHRoZSBjb21taXQgcGhhc2Ugd2hlbiBhbiBlcnJvciBpcyBjYXB0dXJlZC5cbiAgICAgIC8vIFRoZSByaXNrIGlzIHRoYXQgdGhlIHJldHVybiBwYXRoIGZyb20gdGhpcyBGaWJlciBtYXkgbm90IGJlIGFjY3VyYXRlLlxuICAgICAgLy8gVGhhdCByaXNrIGlzIGFjY2VwdGFibGUgZ2l2ZW4gdGhlIGJlbmVmaXQgb2YgcHJvdmlkaW5nIHVzZXJzIG1vcmUgY29udGV4dC5cbiAgICAgIHZhciBfY29tcG9uZW50U3RhY2sgPSBnZXRTdGFja0FkZGVuZHVtQnlXb3JrSW5Qcm9ncmVzc0ZpYmVyKGZhaWxlZFdvcmspO1xuICAgICAgdmFyIF9jb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmYWlsZWRXb3JrKTtcblxuICAgICAgLy8gQWRkIHRvIHRoZSBjb2xsZWN0aW9uIG9mIGNhcHR1cmVkIGVycm9ycy4gVGhpcyBpcyBzdG9yZWQgYXMgYSBnbG9iYWxcbiAgICAgIC8vIG1hcCBvZiBlcnJvcnMgYW5kIHRoZWlyIGNvbXBvbmVudCBzdGFjayBsb2NhdGlvbiBrZXllZCBieSB0aGUgYm91bmRhcmllc1xuICAgICAgLy8gdGhhdCBjYXB0dXJlIHRoZW0uIFdlIG1vc3RseSB1c2UgdGhpcyBNYXAgYXMgYSBTZXQ7IGl0J3MgYSBNYXAgb25seSB0b1xuICAgICAgLy8gYXZvaWQgYWRkaW5nIGEgZmllbGQgdG8gRmliZXIgdG8gc3RvcmUgdGhlIGVycm9yLlxuICAgICAgaWYgKGNhcHR1cmVkRXJyb3JzID09PSBudWxsKSB7XG4gICAgICAgIGNhcHR1cmVkRXJyb3JzID0gbmV3IE1hcCgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2FwdHVyZWRFcnJvciA9IHtcbiAgICAgICAgY29tcG9uZW50TmFtZTogX2NvbXBvbmVudE5hbWUsXG4gICAgICAgIGNvbXBvbmVudFN0YWNrOiBfY29tcG9uZW50U3RhY2ssXG4gICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgZXJyb3JCb3VuZGFyeTogZXJyb3JCb3VuZGFyeUZvdW5kID8gYm91bmRhcnkuc3RhdGVOb2RlIDogbnVsbCxcbiAgICAgICAgZXJyb3JCb3VuZGFyeUZvdW5kOiBlcnJvckJvdW5kYXJ5Rm91bmQsXG4gICAgICAgIGVycm9yQm91bmRhcnlOYW1lOiBlcnJvckJvdW5kYXJ5TmFtZSxcbiAgICAgICAgd2lsbFJldHJ5OiB3aWxsUmV0cnlcbiAgICAgIH07XG5cbiAgICAgIGNhcHR1cmVkRXJyb3JzLnNldChib3VuZGFyeSwgY2FwdHVyZWRFcnJvcik7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGxvZ0NhcHR1cmVkRXJyb3IoY2FwdHVyZWRFcnJvcik7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIFByZXZlbnQgY3ljbGUgaWYgbG9nQ2FwdHVyZWRFcnJvcigpIHRocm93cy5cbiAgICAgICAgLy8gQSBjeWNsZSBtYXkgc3RpbGwgb2NjdXIgaWYgbG9nQ2FwdHVyZWRFcnJvciByZW5kZXJzIGEgY29tcG9uZW50IHRoYXQgdGhyb3dzLlxuICAgICAgICB2YXIgc3VwcHJlc3NMb2dnaW5nID0gZSAmJiBlLnN1cHByZXNzUmVhY3RFcnJvckxvZ2dpbmc7XG4gICAgICAgIGlmICghc3VwcHJlc3NMb2dnaW5nKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJZiB3ZSdyZSBpbiB0aGUgY29tbWl0IHBoYXNlLCBkZWZlciBzY2hlZHVsaW5nIGFuIHVwZGF0ZSBvbiB0aGVcbiAgICAgIC8vIGJvdW5kYXJ5IHVudGlsIGFmdGVyIHRoZSBjb21taXQgaXMgY29tcGxldGVcbiAgICAgIGlmIChpc0NvbW1pdHRpbmcpIHtcbiAgICAgICAgaWYgKGNvbW1pdFBoYXNlQm91bmRhcmllcyA9PT0gbnVsbCkge1xuICAgICAgICAgIGNvbW1pdFBoYXNlQm91bmRhcmllcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb21taXRQaGFzZUJvdW5kYXJpZXMuYWRkKGJvdW5kYXJ5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSwgc2NoZWR1bGUgYW4gdXBkYXRlIG5vdy5cbiAgICAgICAgLy8gVE9ETzogSXMgdGhpcyBhY3R1YWxseSBuZWNlc3NhcnkgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2U/IElzIGl0XG4gICAgICAgIC8vIHBvc3NpYmxlIHRvIHVud2luZCBhbmQgY29udGludWUgcmVuZGVyaW5nIGF0IHRoZSBzYW1lIHByaW9yaXR5LFxuICAgICAgICAvLyB3aXRob3V0IGNvcnJ1cHRpbmcgaW50ZXJuYWwgc3RhdGU/XG4gICAgICAgIHNjaGVkdWxlRXJyb3JSZWNvdmVyeShib3VuZGFyeSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYm91bmRhcnk7XG4gICAgfSBlbHNlIGlmIChmaXJzdFVuY2F1Z2h0RXJyb3IgPT09IG51bGwpIHtcbiAgICAgIC8vIElmIG5vIGJvdW5kYXJ5IGlzIGZvdW5kLCB3ZSdsbCBuZWVkIHRvIHRocm93IHRoZSBlcnJvclxuICAgICAgZmlyc3RVbmNhdWdodEVycm9yID0gZXJyb3I7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFzQ2FwdHVyZWRFcnJvcihmaWJlcikge1xuICAgIC8vIFRPRE86IGNhcHR1cmVkRXJyb3JzIHNob3VsZCBzdG9yZSB0aGUgYm91bmRhcnkgaW5zdGFuY2UsIHRvIGF2b2lkIG5lZWRpbmdcbiAgICAvLyB0byBjaGVjayB0aGUgYWx0ZXJuYXRlLlxuICAgIHJldHVybiBjYXB0dXJlZEVycm9ycyAhPT0gbnVsbCAmJiAoY2FwdHVyZWRFcnJvcnMuaGFzKGZpYmVyKSB8fCBmaWJlci5hbHRlcm5hdGUgIT09IG51bGwgJiYgY2FwdHVyZWRFcnJvcnMuaGFzKGZpYmVyLmFsdGVybmF0ZSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNGYWlsZWRCb3VuZGFyeShmaWJlcikge1xuICAgIC8vIFRPRE86IGZhaWxlZEJvdW5kYXJpZXMgc2hvdWxkIHN0b3JlIHRoZSBib3VuZGFyeSBpbnN0YW5jZSwgdG8gYXZvaWRcbiAgICAvLyBuZWVkaW5nIHRvIGNoZWNrIHRoZSBhbHRlcm5hdGUuXG4gICAgcmV0dXJuIGZhaWxlZEJvdW5kYXJpZXMgIT09IG51bGwgJiYgKGZhaWxlZEJvdW5kYXJpZXMuaGFzKGZpYmVyKSB8fCBmaWJlci5hbHRlcm5hdGUgIT09IG51bGwgJiYgZmFpbGVkQm91bmRhcmllcy5oYXMoZmliZXIuYWx0ZXJuYXRlKSk7XG4gIH1cblxuICBmdW5jdGlvbiBjb21taXRFcnJvckhhbmRsaW5nKGVmZmVjdGZ1bEZpYmVyKSB7XG4gICAgdmFyIGNhcHR1cmVkRXJyb3IgPSB2b2lkIDA7XG4gICAgaWYgKGNhcHR1cmVkRXJyb3JzICE9PSBudWxsKSB7XG4gICAgICBjYXB0dXJlZEVycm9yID0gY2FwdHVyZWRFcnJvcnMuZ2V0KGVmZmVjdGZ1bEZpYmVyKTtcbiAgICAgIGNhcHR1cmVkRXJyb3JzWydkZWxldGUnXShlZmZlY3RmdWxGaWJlcik7XG4gICAgICBpZiAoY2FwdHVyZWRFcnJvciA9PSBudWxsKSB7XG4gICAgICAgIGlmIChlZmZlY3RmdWxGaWJlci5hbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgICBlZmZlY3RmdWxGaWJlciA9IGVmZmVjdGZ1bEZpYmVyLmFsdGVybmF0ZTtcbiAgICAgICAgICBjYXB0dXJlZEVycm9yID0gY2FwdHVyZWRFcnJvcnMuZ2V0KGVmZmVjdGZ1bEZpYmVyKTtcbiAgICAgICAgICBjYXB0dXJlZEVycm9yc1snZGVsZXRlJ10oZWZmZWN0ZnVsRmliZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgIShjYXB0dXJlZEVycm9yICE9IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnTm8gZXJyb3IgZm9yIGdpdmVuIHVuaXQgb2Ygd29yay4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcblxuICAgIHN3aXRjaCAoZWZmZWN0ZnVsRmliZXIudGFnKSB7XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICB2YXIgaW5zdGFuY2UgPSBlZmZlY3RmdWxGaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgICAgdmFyIGluZm8gPSB7XG4gICAgICAgICAgY29tcG9uZW50U3RhY2s6IGNhcHR1cmVkRXJyb3IuY29tcG9uZW50U3RhY2tcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBBbGxvdyB0aGUgYm91bmRhcnkgdG8gaGFuZGxlIHRoZSBlcnJvciwgdXN1YWxseSBieSBzY2hlZHVsaW5nXG4gICAgICAgIC8vIGFuIHVwZGF0ZSB0byBpdHNlbGZcbiAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50RGlkQ2F0Y2goY2FwdHVyZWRFcnJvci5lcnJvciwgaW5mbyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIGlmIChmaXJzdFVuY2F1Z2h0RXJyb3IgPT09IG51bGwpIHtcbiAgICAgICAgICBmaXJzdFVuY2F1Z2h0RXJyb3IgPSBjYXB0dXJlZEVycm9yLmVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGludmFyaWFudChmYWxzZSwgJ0ludmFsaWQgdHlwZSBvZiB3b3JrLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVud2luZENvbnRleHRzKGZyb20sIHRvKSB7XG4gICAgdmFyIG5vZGUgPSBmcm9tO1xuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKG5vZGUudGFnKSB7XG4gICAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgICAgcG9wQ29udGV4dFByb3ZpZGVyKG5vZGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgcG9wSG9zdENvbnRleHQobm9kZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAgcG9wSG9zdENvbnRhaW5lcihub2RlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgICAgIHBvcEhvc3RDb250YWluZXIobm9kZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAobm9kZSA9PT0gdG8gfHwgbm9kZS5hbHRlcm5hdGUgPT09IHRvKSB7XG4gICAgICAgIHN0b3BGYWlsZWRXb3JrVGltZXIobm9kZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RvcFdvcmtUaW1lcihub2RlKTtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21wdXRlQXN5bmNFeHBpcmF0aW9uKCkge1xuICAgIC8vIEdpdmVuIHRoZSBjdXJyZW50IGNsb2NrIHRpbWUsIHJldHVybnMgYW4gZXhwaXJhdGlvbiB0aW1lLiBXZSB1c2Ugcm91bmRpbmdcbiAgICAvLyB0byBiYXRjaCBsaWtlIHVwZGF0ZXMgdG9nZXRoZXIuXG4gICAgLy8gU2hvdWxkIGNvbXBsZXRlIHdpdGhpbiB+MTAwMG1zLiAxMjAwbXMgbWF4LlxuICAgIHZhciBjdXJyZW50VGltZSA9IHJlY2FsY3VsYXRlQ3VycmVudFRpbWUoKTtcbiAgICB2YXIgZXhwaXJhdGlvbk1zID0gMTAwMDtcbiAgICB2YXIgYnVja2V0U2l6ZU1zID0gMjAwO1xuICAgIHJldHVybiBjb21wdXRlRXhwaXJhdGlvbkJ1Y2tldChjdXJyZW50VGltZSwgZXhwaXJhdGlvbk1zLCBidWNrZXRTaXplTXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcihmaWJlcikge1xuICAgIHZhciBleHBpcmF0aW9uVGltZSA9IHZvaWQgMDtcbiAgICBpZiAoZXhwaXJhdGlvbkNvbnRleHQgIT09IE5vV29yaykge1xuICAgICAgLy8gQW4gZXhwbGljaXQgZXhwaXJhdGlvbiBjb250ZXh0IHdhcyBzZXQ7XG4gICAgICBleHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25Db250ZXh0O1xuICAgIH0gZWxzZSBpZiAoaXNXb3JraW5nKSB7XG4gICAgICBpZiAoaXNDb21taXR0aW5nKSB7XG4gICAgICAgIC8vIFVwZGF0ZXMgdGhhdCBvY2N1ciBkdXJpbmcgdGhlIGNvbW1pdCBwaGFzZSBzaG91bGQgaGF2ZSBzeW5jIHByaW9yaXR5XG4gICAgICAgIC8vIGJ5IGRlZmF1bHQuXG4gICAgICAgIGV4cGlyYXRpb25UaW1lID0gU3luYztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFVwZGF0ZXMgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2Ugc2hvdWxkIGV4cGlyZSBhdCB0aGUgc2FtZSB0aW1lIGFzXG4gICAgICAgIC8vIHRoZSB3b3JrIHRoYXQgaXMgYmVpbmcgcmVuZGVyZWQuXG4gICAgICAgIGV4cGlyYXRpb25UaW1lID0gbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBObyBleHBsaWNpdCBleHBpcmF0aW9uIGNvbnRleHQgd2FzIHNldCwgYW5kIHdlJ3JlIG5vdCBjdXJyZW50bHlcbiAgICAgIC8vIHBlcmZvcm1pbmcgd29yay4gQ2FsY3VsYXRlIGEgbmV3IGV4cGlyYXRpb24gdGltZS5cbiAgICAgIGlmICh1c2VTeW5jU2NoZWR1bGluZyAmJiAhKGZpYmVyLmludGVybmFsQ29udGV4dFRhZyAmIEFzeW5jVXBkYXRlcykpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIHN5bmMgdXBkYXRlXG4gICAgICAgIGV4cGlyYXRpb25UaW1lID0gU3luYztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYW4gYXN5bmMgdXBkYXRlXG4gICAgICAgIGV4cGlyYXRpb25UaW1lID0gY29tcHV0ZUFzeW5jRXhwaXJhdGlvbigpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXhwaXJhdGlvblRpbWU7XG4gIH1cblxuICBmdW5jdGlvbiBzY2hlZHVsZVdvcmsoZmliZXIsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgcmV0dXJuIHNjaGVkdWxlV29ya0ltcGwoZmliZXIsIGV4cGlyYXRpb25UaW1lLCBmYWxzZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja1Jvb3ROZWVkc0NsZWFyaW5nKHJvb3QsIGZpYmVyLCBleHBpcmF0aW9uVGltZSkge1xuICAgIGlmICghaXNXb3JraW5nICYmIHJvb3QgPT09IG5leHRSb290ICYmIGV4cGlyYXRpb25UaW1lIDwgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAvLyBSZXN0YXJ0IHRoZSByb290IGZyb20gdGhlIHRvcC5cbiAgICAgIGlmIChuZXh0VW5pdE9mV29yayAhPT0gbnVsbCkge1xuICAgICAgICAvLyBUaGlzIGlzIGFuIGludGVycnVwdGlvbi4gKFVzZWQgZm9yIHBlcmZvcm1hbmNlIHRyYWNraW5nLilcbiAgICAgICAgaW50ZXJydXB0ZWRCeSA9IGZpYmVyO1xuICAgICAgfVxuICAgICAgbmV4dFJvb3QgPSBudWxsO1xuICAgICAgbmV4dFVuaXRPZldvcmsgPSBudWxsO1xuICAgICAgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNjaGVkdWxlV29ya0ltcGwoZmliZXIsIGV4cGlyYXRpb25UaW1lLCBpc0Vycm9yUmVjb3ZlcnkpIHtcbiAgICByZWNvcmRTY2hlZHVsZVVwZGF0ZSgpO1xuXG4gICAge1xuICAgICAgaWYgKCFpc0Vycm9yUmVjb3ZlcnkgJiYgZmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCkge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgIHdhcm5BYm91dEludmFsaWRVcGRhdGVzKGluc3RhbmNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbm9kZSA9IGZpYmVyO1xuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICAvLyBXYWxrIHRoZSBwYXJlbnQgcGF0aCB0byB0aGUgcm9vdCBhbmQgdXBkYXRlIGVhY2ggbm9kZSdzXG4gICAgICAvLyBleHBpcmF0aW9uIHRpbWUuXG4gICAgICBpZiAobm9kZS5leHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IG5vZGUuZXhwaXJhdGlvblRpbWUgPiBleHBpcmF0aW9uVGltZSkge1xuICAgICAgICBub2RlLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gICAgICB9XG4gICAgICBpZiAobm9kZS5hbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGUuYWx0ZXJuYXRlLmV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgbm9kZS5hbHRlcm5hdGUuZXhwaXJhdGlvblRpbWUgPiBleHBpcmF0aW9uVGltZSkge1xuICAgICAgICAgIG5vZGUuYWx0ZXJuYXRlLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChub2RlWydyZXR1cm4nXSA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RSb290KSB7XG4gICAgICAgICAgdmFyIHJvb3QgPSBub2RlLnN0YXRlTm9kZTtcblxuICAgICAgICAgIGNoZWNrUm9vdE5lZWRzQ2xlYXJpbmcocm9vdCwgZmliZXIsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICByZXF1ZXN0V29yayhyb290LCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgY2hlY2tSb290TmVlZHNDbGVhcmluZyhyb290LCBmaWJlciwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmICghaXNFcnJvclJlY292ZXJ5ICYmIGZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgd2FybkFib3V0VXBkYXRlT25Vbm1vdW50ZWQoZmliZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzY2hlZHVsZUVycm9yUmVjb3ZlcnkoZmliZXIpIHtcbiAgICBzY2hlZHVsZVdvcmtJbXBsKGZpYmVyLCBTeW5jLCB0cnVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY2FsY3VsYXRlQ3VycmVudFRpbWUoKSB7XG4gICAgLy8gU3VidHJhY3QgaW5pdGlhbCB0aW1lIHNvIGl0IGZpdHMgaW5zaWRlIDMyYml0c1xuICAgIHZhciBtcyA9IG5vdygpIC0gc3RhcnRUaW1lO1xuICAgIG1vc3RSZWNlbnRDdXJyZW50VGltZSA9IG1zVG9FeHBpcmF0aW9uVGltZShtcyk7XG4gICAgcmV0dXJuIG1vc3RSZWNlbnRDdXJyZW50VGltZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZmVycmVkVXBkYXRlcyhmbikge1xuICAgIHZhciBwcmV2aW91c0V4cGlyYXRpb25Db250ZXh0ID0gZXhwaXJhdGlvbkNvbnRleHQ7XG4gICAgZXhwaXJhdGlvbkNvbnRleHQgPSBjb21wdXRlQXN5bmNFeHBpcmF0aW9uKCk7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmbigpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBleHBpcmF0aW9uQ29udGV4dCA9IHByZXZpb3VzRXhwaXJhdGlvbkNvbnRleHQ7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc3luY1VwZGF0ZXMoZm4pIHtcbiAgICB2YXIgcHJldmlvdXNFeHBpcmF0aW9uQ29udGV4dCA9IGV4cGlyYXRpb25Db250ZXh0O1xuICAgIGV4cGlyYXRpb25Db250ZXh0ID0gU3luYztcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZuKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGV4cGlyYXRpb25Db250ZXh0ID0gcHJldmlvdXNFeHBpcmF0aW9uQ29udGV4dDtcbiAgICB9XG4gIH1cblxuICAvLyBUT0RPOiBFdmVyeXRoaW5nIGJlbG93IHRoaXMgaXMgd3JpdHRlbiBhcyBpZiBpdCBoYXMgYmVlbiBsaWZ0ZWQgdG8gdGhlXG4gIC8vIHJlbmRlcmVycy4gSSdsbCBkbyB0aGlzIGluIGEgZm9sbG93LXVwLlxuXG4gIC8vIExpbmtlZC1saXN0IG9mIHJvb3RzXG4gIHZhciBmaXJzdFNjaGVkdWxlZFJvb3QgPSBudWxsO1xuICB2YXIgbGFzdFNjaGVkdWxlZFJvb3QgPSBudWxsO1xuXG4gIHZhciBjYWxsYmFja0V4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuICB2YXIgY2FsbGJhY2tJRCA9IC0xO1xuICB2YXIgaXNSZW5kZXJpbmcgPSBmYWxzZTtcbiAgdmFyIG5leHRGbHVzaGVkUm9vdCA9IG51bGw7XG4gIHZhciBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuICB2YXIgZGVhZGxpbmVEaWRFeHBpcmUgPSBmYWxzZTtcbiAgdmFyIGhhc1VuaGFuZGxlZEVycm9yID0gZmFsc2U7XG4gIHZhciB1bmhhbmRsZWRFcnJvciA9IG51bGw7XG4gIHZhciBkZWFkbGluZSA9IG51bGw7XG5cbiAgdmFyIGlzQmF0Y2hpbmdVcGRhdGVzID0gZmFsc2U7XG4gIHZhciBpc1VuYmF0Y2hpbmdVcGRhdGVzID0gZmFsc2U7XG5cbiAgLy8gVXNlIHRoZXNlIHRvIHByZXZlbnQgYW4gaW5maW5pdGUgbG9vcCBvZiBuZXN0ZWQgdXBkYXRlc1xuICB2YXIgTkVTVEVEX1VQREFURV9MSU1JVCA9IDEwMDA7XG4gIHZhciBuZXN0ZWRVcGRhdGVDb3VudCA9IDA7XG5cbiAgdmFyIHRpbWVIZXVyaXN0aWNGb3JVbml0T2ZXb3JrID0gMTtcblxuICBmdW5jdGlvbiBzY2hlZHVsZUNhbGxiYWNrV2l0aEV4cGlyYXRpb24oZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAoY2FsbGJhY2tFeHBpcmF0aW9uVGltZSAhPT0gTm9Xb3JrKSB7XG4gICAgICAvLyBBIGNhbGxiYWNrIGlzIGFscmVhZHkgc2NoZWR1bGVkLiBDaGVjayBpdHMgZXhwaXJhdGlvbiB0aW1lICh0aW1lb3V0KS5cbiAgICAgIGlmIChleHBpcmF0aW9uVGltZSA+IGNhbGxiYWNrRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgLy8gRXhpc3RpbmcgY2FsbGJhY2sgaGFzIHN1ZmZpY2llbnQgdGltZW91dC4gRXhpdC5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRXhpc3RpbmcgY2FsbGJhY2sgaGFzIGluc3VmZmljaWVudCB0aW1lb3V0LiBDYW5jZWwgYW5kIHNjaGVkdWxlIGFcbiAgICAgICAgLy8gbmV3IG9uZS5cbiAgICAgICAgY2FuY2VsRGVmZXJyZWRDYWxsYmFjayhjYWxsYmFja0lEKTtcbiAgICAgIH1cbiAgICAgIC8vIFRoZSByZXF1ZXN0IGNhbGxiYWNrIHRpbWVyIGlzIGFscmVhZHkgcnVubmluZy4gRG9uJ3Qgc3RhcnQgYSBuZXcgb25lLlxuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydFJlcXVlc3RDYWxsYmFja1RpbWVyKCk7XG4gICAgfVxuXG4gICAgLy8gQ29tcHV0ZSBhIHRpbWVvdXQgZm9yIHRoZSBnaXZlbiBleHBpcmF0aW9uIHRpbWUuXG4gICAgdmFyIGN1cnJlbnRNcyA9IG5vdygpIC0gc3RhcnRUaW1lO1xuICAgIHZhciBleHBpcmF0aW9uTXMgPSBleHBpcmF0aW9uVGltZVRvTXMoZXhwaXJhdGlvblRpbWUpO1xuICAgIHZhciB0aW1lb3V0ID0gZXhwaXJhdGlvbk1zIC0gY3VycmVudE1zO1xuXG4gICAgY2FsbGJhY2tFeHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICAgIGNhbGxiYWNrSUQgPSBzY2hlZHVsZURlZmVycmVkQ2FsbGJhY2socGVyZm9ybUFzeW5jV29yaywgeyB0aW1lb3V0OiB0aW1lb3V0IH0pO1xuICB9XG5cbiAgLy8gcmVxdWVzdFdvcmsgaXMgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIgd2hlbmV2ZXIgYSByb290IHJlY2VpdmVzIGFuIHVwZGF0ZS5cbiAgLy8gSXQncyB1cCB0byB0aGUgcmVuZGVyZXIgdG8gY2FsbCByZW5kZXJSb290IGF0IHNvbWUgcG9pbnQgaW4gdGhlIGZ1dHVyZS5cbiAgZnVuY3Rpb24gcmVxdWVzdFdvcmsocm9vdCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAobmVzdGVkVXBkYXRlQ291bnQgPiBORVNURURfVVBEQVRFX0xJTUlUKSB7XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdNYXhpbXVtIHVwZGF0ZSBkZXB0aCBleGNlZWRlZC4gVGhpcyBjYW4gaGFwcGVuIHdoZW4gYSBjb21wb25lbnQgcmVwZWF0ZWRseSBjYWxscyBzZXRTdGF0ZSBpbnNpZGUgY29tcG9uZW50V2lsbFVwZGF0ZSBvciBjb21wb25lbnREaWRVcGRhdGUuIFJlYWN0IGxpbWl0cyB0aGUgbnVtYmVyIG9mIG5lc3RlZCB1cGRhdGVzIHRvIHByZXZlbnQgaW5maW5pdGUgbG9vcHMuJyk7XG4gICAgfVxuXG4gICAgLy8gQWRkIHRoZSByb290IHRvIHRoZSBzY2hlZHVsZS5cbiAgICAvLyBDaGVjayBpZiB0aGlzIHJvb3QgaXMgYWxyZWFkeSBwYXJ0IG9mIHRoZSBzY2hlZHVsZS5cbiAgICBpZiAocm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9PT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyByb290IGlzIG5vdCBhbHJlYWR5IHNjaGVkdWxlZC4gQWRkIGl0LlxuICAgICAgcm9vdC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICAgICAgaWYgKGxhc3RTY2hlZHVsZWRSb290ID09PSBudWxsKSB7XG4gICAgICAgIGZpcnN0U2NoZWR1bGVkUm9vdCA9IGxhc3RTY2hlZHVsZWRSb290ID0gcm9vdDtcbiAgICAgICAgcm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IHJvb3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYXN0U2NoZWR1bGVkUm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IHJvb3Q7XG4gICAgICAgIGxhc3RTY2hlZHVsZWRSb290ID0gcm9vdDtcbiAgICAgICAgbGFzdFNjaGVkdWxlZFJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSBmaXJzdFNjaGVkdWxlZFJvb3Q7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgcm9vdCBpcyBhbHJlYWR5IHNjaGVkdWxlZCwgYnV0IGl0cyBwcmlvcml0eSBtYXkgaGF2ZSBpbmNyZWFzZWQuXG4gICAgICB2YXIgcmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPSByb290LnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lO1xuICAgICAgaWYgKHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgZXhwaXJhdGlvblRpbWUgPCByZW1haW5pbmdFeHBpcmF0aW9uVGltZSkge1xuICAgICAgICAvLyBVcGRhdGUgdGhlIHByaW9yaXR5LlxuICAgICAgICByb290LnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzUmVuZGVyaW5nKSB7XG4gICAgICAvLyBQcmV2ZW50IHJlZW50cmFuY3kuIFJlbWFpbmluZyB3b3JrIHdpbGwgYmUgc2NoZWR1bGVkIGF0IHRoZSBlbmQgb2ZcbiAgICAgIC8vIHRoZSBjdXJyZW50bHkgcmVuZGVyaW5nIGJhdGNoLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpc0JhdGNoaW5nVXBkYXRlcykge1xuICAgICAgLy8gRmx1c2ggd29yayBhdCB0aGUgZW5kIG9mIHRoZSBiYXRjaC5cbiAgICAgIGlmIChpc1VuYmF0Y2hpbmdVcGRhdGVzKSB7XG4gICAgICAgIC8vIC4uLnVubGVzcyB3ZSdyZSBpbnNpZGUgdW5iYXRjaGVkVXBkYXRlcywgaW4gd2hpY2ggY2FzZSB3ZSBzaG91bGRcbiAgICAgICAgLy8gZmx1c2ggaXQgbm93LlxuICAgICAgICBuZXh0Rmx1c2hlZFJvb3QgPSByb290O1xuICAgICAgICBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lID0gU3luYztcbiAgICAgICAgcGVyZm9ybVdvcmtPblJvb3QobmV4dEZsdXNoZWRSb290LCBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBHZXQgcmlkIG9mIFN5bmMgYW5kIHVzZSBjdXJyZW50IHRpbWU/XG4gICAgaWYgKGV4cGlyYXRpb25UaW1lID09PSBTeW5jKSB7XG4gICAgICBwZXJmb3JtV29yayhTeW5jLCBudWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NoZWR1bGVDYWxsYmFja1dpdGhFeHBpcmF0aW9uKGV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kSGlnaGVzdFByaW9yaXR5Um9vdCgpIHtcbiAgICB2YXIgaGlnaGVzdFByaW9yaXR5V29yayA9IE5vV29yaztcbiAgICB2YXIgaGlnaGVzdFByaW9yaXR5Um9vdCA9IG51bGw7XG5cbiAgICBpZiAobGFzdFNjaGVkdWxlZFJvb3QgIT09IG51bGwpIHtcbiAgICAgIHZhciBwcmV2aW91c1NjaGVkdWxlZFJvb3QgPSBsYXN0U2NoZWR1bGVkUm9vdDtcbiAgICAgIHZhciByb290ID0gZmlyc3RTY2hlZHVsZWRSb290O1xuICAgICAgd2hpbGUgKHJvb3QgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID0gcm9vdC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZTtcbiAgICAgICAgaWYgKHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID09PSBOb1dvcmspIHtcbiAgICAgICAgICAvLyBUaGlzIHJvb3Qgbm8gbG9uZ2VyIGhhcyB3b3JrLiBSZW1vdmUgaXQgZnJvbSB0aGUgc2NoZWR1bGVyLlxuXG4gICAgICAgICAgLy8gVE9ETzogVGhpcyBjaGVjayBpcyByZWR1ZGFudCwgYnV0IEZsb3cgaXMgY29uZnVzZWQgYnkgdGhlIGJyYW5jaFxuICAgICAgICAgIC8vIGJlbG93IHdoZXJlIHdlIHNldCBsYXN0U2NoZWR1bGVkUm9vdCB0byBudWxsLCBldmVuIHRob3VnaCB3ZSBicmVha1xuICAgICAgICAgIC8vIGZyb20gdGhlIGxvb3AgcmlnaHQgYWZ0ZXIuXG4gICAgICAgICAgIShwcmV2aW91c1NjaGVkdWxlZFJvb3QgIT09IG51bGwgJiYgbGFzdFNjaGVkdWxlZFJvb3QgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnU2hvdWxkIGhhdmUgYSBwcmV2aW91cyBhbmQgbGFzdCByb290LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgICAgIGlmIChyb290ID09PSByb290Lm5leHRTY2hlZHVsZWRSb290KSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBvbmx5IHJvb3QgaW4gdGhlIGxpc3QuXG4gICAgICAgICAgICByb290Lm5leHRTY2hlZHVsZWRSb290ID0gbnVsbDtcbiAgICAgICAgICAgIGZpcnN0U2NoZWR1bGVkUm9vdCA9IGxhc3RTY2hlZHVsZWRSb290ID0gbnVsbDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSBpZiAocm9vdCA9PT0gZmlyc3RTY2hlZHVsZWRSb290KSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCByb290IGluIHRoZSBsaXN0LlxuICAgICAgICAgICAgdmFyIG5leHQgPSByb290Lm5leHRTY2hlZHVsZWRSb290O1xuICAgICAgICAgICAgZmlyc3RTY2hlZHVsZWRSb290ID0gbmV4dDtcbiAgICAgICAgICAgIGxhc3RTY2hlZHVsZWRSb290Lm5leHRTY2hlZHVsZWRSb290ID0gbmV4dDtcbiAgICAgICAgICAgIHJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSBpZiAocm9vdCA9PT0gbGFzdFNjaGVkdWxlZFJvb3QpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGxhc3Qgcm9vdCBpbiB0aGUgbGlzdC5cbiAgICAgICAgICAgIGxhc3RTY2hlZHVsZWRSb290ID0gcHJldmlvdXNTY2hlZHVsZWRSb290O1xuICAgICAgICAgICAgbGFzdFNjaGVkdWxlZFJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSBmaXJzdFNjaGVkdWxlZFJvb3Q7XG4gICAgICAgICAgICByb290Lm5leHRTY2hlZHVsZWRSb290ID0gbnVsbDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcmV2aW91c1NjaGVkdWxlZFJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSByb290Lm5leHRTY2hlZHVsZWRSb290O1xuICAgICAgICAgICAgcm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJvb3QgPSBwcmV2aW91c1NjaGVkdWxlZFJvb3QubmV4dFNjaGVkdWxlZFJvb3Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGhpZ2hlc3RQcmlvcml0eVdvcmsgPT09IE5vV29yayB8fCByZW1haW5pbmdFeHBpcmF0aW9uVGltZSA8IGhpZ2hlc3RQcmlvcml0eVdvcmspIHtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgcHJpb3JpdHksIGlmIGl0J3MgaGlnaGVyXG4gICAgICAgICAgICBoaWdoZXN0UHJpb3JpdHlXb3JrID0gcmVtYWluaW5nRXhwaXJhdGlvblRpbWU7XG4gICAgICAgICAgICBoaWdoZXN0UHJpb3JpdHlSb290ID0gcm9vdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJvb3QgPT09IGxhc3RTY2hlZHVsZWRSb290KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgcHJldmlvdXNTY2hlZHVsZWRSb290ID0gcm9vdDtcbiAgICAgICAgICByb290ID0gcm9vdC5uZXh0U2NoZWR1bGVkUm9vdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHRoZSBuZXh0IHJvb3QgaXMgdGhlIHNhbWUgYXMgdGhlIHByZXZpb3VzIHJvb3QsIHRoaXMgaXMgYSBuZXN0ZWRcbiAgICAvLyB1cGRhdGUuIFRvIHByZXZlbnQgYW4gaW5maW5pdGUgbG9vcCwgaW5jcmVtZW50IHRoZSBuZXN0ZWQgdXBkYXRlIGNvdW50LlxuICAgIHZhciBwcmV2aW91c0ZsdXNoZWRSb290ID0gbmV4dEZsdXNoZWRSb290O1xuICAgIGlmIChwcmV2aW91c0ZsdXNoZWRSb290ICE9PSBudWxsICYmIHByZXZpb3VzRmx1c2hlZFJvb3QgPT09IGhpZ2hlc3RQcmlvcml0eVJvb3QpIHtcbiAgICAgIG5lc3RlZFVwZGF0ZUNvdW50Kys7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlc2V0IHdoZW5ldmVyIHdlIHN3aXRjaCByb290cy5cbiAgICAgIG5lc3RlZFVwZGF0ZUNvdW50ID0gMDtcbiAgICB9XG4gICAgbmV4dEZsdXNoZWRSb290ID0gaGlnaGVzdFByaW9yaXR5Um9vdDtcbiAgICBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lID0gaGlnaGVzdFByaW9yaXR5V29yaztcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlcmZvcm1Bc3luY1dvcmsoZGwpIHtcbiAgICBwZXJmb3JtV29yayhOb1dvcmssIGRsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlcmZvcm1Xb3JrKG1pbkV4cGlyYXRpb25UaW1lLCBkbCkge1xuICAgIGRlYWRsaW5lID0gZGw7XG5cbiAgICAvLyBLZWVwIHdvcmtpbmcgb24gcm9vdHMgdW50aWwgdGhlcmUncyBubyBtb3JlIHdvcmssIG9yIHVudGlsIHRoZSB3ZSByZWFjaFxuICAgIC8vIHRoZSBkZWFkbGluZS5cbiAgICBmaW5kSGlnaGVzdFByaW9yaXR5Um9vdCgpO1xuXG4gICAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkgJiYgZGVhZGxpbmUgIT09IG51bGwpIHtcbiAgICAgIHZhciBkaWRFeHBpcmUgPSBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lIDwgcmVjYWxjdWxhdGVDdXJyZW50VGltZSgpO1xuICAgICAgc3RvcFJlcXVlc3RDYWxsYmFja1RpbWVyKGRpZEV4cGlyZSk7XG4gICAgfVxuXG4gICAgd2hpbGUgKG5leHRGbHVzaGVkUm9vdCAhPT0gbnVsbCAmJiBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lICE9PSBOb1dvcmsgJiYgKG1pbkV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgbmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSA8PSBtaW5FeHBpcmF0aW9uVGltZSkgJiYgIWRlYWRsaW5lRGlkRXhwaXJlKSB7XG4gICAgICBwZXJmb3JtV29ya09uUm9vdChuZXh0Rmx1c2hlZFJvb3QsIG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUpO1xuICAgICAgLy8gRmluZCB0aGUgbmV4dCBoaWdoZXN0IHByaW9yaXR5IHdvcmsuXG4gICAgICBmaW5kSGlnaGVzdFByaW9yaXR5Um9vdCgpO1xuICAgIH1cblxuICAgIC8vIFdlJ3JlIGRvbmUgZmx1c2hpbmcgd29yay4gRWl0aGVyIHdlIHJhbiBvdXQgb2YgdGltZSBpbiB0aGlzIGNhbGxiYWNrLFxuICAgIC8vIG9yIHRoZXJlJ3Mgbm8gbW9yZSB3b3JrIGxlZnQgd2l0aCBzdWZmaWNpZW50IHByaW9yaXR5LlxuXG4gICAgLy8gSWYgd2UncmUgaW5zaWRlIGEgY2FsbGJhY2ssIHNldCB0aGlzIHRvIGZhbHNlIHNpbmNlIHdlIGp1c3QgY29tcGxldGVkIGl0LlxuICAgIGlmIChkZWFkbGluZSAhPT0gbnVsbCkge1xuICAgICAgY2FsbGJhY2tFeHBpcmF0aW9uVGltZSA9IE5vV29yaztcbiAgICAgIGNhbGxiYWNrSUQgPSAtMTtcbiAgICB9XG4gICAgLy8gSWYgdGhlcmUncyB3b3JrIGxlZnQgb3Zlciwgc2NoZWR1bGUgYSBuZXcgY2FsbGJhY2suXG4gICAgaWYgKG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUgIT09IE5vV29yaykge1xuICAgICAgc2NoZWR1bGVDYWxsYmFja1dpdGhFeHBpcmF0aW9uKG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUpO1xuICAgIH1cblxuICAgIC8vIENsZWFuLXVwLlxuICAgIGRlYWRsaW5lID0gbnVsbDtcbiAgICBkZWFkbGluZURpZEV4cGlyZSA9IGZhbHNlO1xuICAgIG5lc3RlZFVwZGF0ZUNvdW50ID0gMDtcblxuICAgIGlmIChoYXNVbmhhbmRsZWRFcnJvcikge1xuICAgICAgdmFyIF9lcnJvcjQgPSB1bmhhbmRsZWRFcnJvcjtcbiAgICAgIHVuaGFuZGxlZEVycm9yID0gbnVsbDtcbiAgICAgIGhhc1VuaGFuZGxlZEVycm9yID0gZmFsc2U7XG4gICAgICB0aHJvdyBfZXJyb3I0O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBlcmZvcm1Xb3JrT25Sb290KHJvb3QsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgISFpc1JlbmRlcmluZyA/IGludmFyaWFudChmYWxzZSwgJ3BlcmZvcm1Xb3JrT25Sb290IHdhcyBjYWxsZWQgcmVjdXJzaXZlbHkuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG5cbiAgICBpc1JlbmRlcmluZyA9IHRydWU7XG5cbiAgICAvLyBDaGVjayBpZiB0aGlzIGlzIGFzeW5jIHdvcmsgb3Igc3luYy9leHBpcmVkIHdvcmsuXG4gICAgLy8gVE9ETzogUGFzcyBjdXJyZW50IHRpbWUgYXMgYXJndW1lbnQgdG8gcmVuZGVyUm9vdCwgY29tbWl0Um9vdFxuICAgIGlmIChleHBpcmF0aW9uVGltZSA8PSByZWNhbGN1bGF0ZUN1cnJlbnRUaW1lKCkpIHtcbiAgICAgIC8vIEZsdXNoIHN5bmMgd29yay5cbiAgICAgIHZhciBmaW5pc2hlZFdvcmsgPSByb290LmZpbmlzaGVkV29yaztcbiAgICAgIGlmIChmaW5pc2hlZFdvcmsgIT09IG51bGwpIHtcbiAgICAgICAgLy8gVGhpcyByb290IGlzIGFscmVhZHkgY29tcGxldGUuIFdlIGNhbiBjb21taXQgaXQuXG4gICAgICAgIHJvb3QuZmluaXNoZWRXb3JrID0gbnVsbDtcbiAgICAgICAgcm9vdC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IGNvbW1pdFJvb3QoZmluaXNoZWRXb3JrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3QuZmluaXNoZWRXb3JrID0gbnVsbDtcbiAgICAgICAgZmluaXNoZWRXb3JrID0gcmVuZGVyUm9vdChyb290LCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgIGlmIChmaW5pc2hlZFdvcmsgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBXZSd2ZSBjb21wbGV0ZWQgdGhlIHJvb3QuIENvbW1pdCBpdC5cbiAgICAgICAgICByb290LnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID0gY29tbWl0Um9vdChmaW5pc2hlZFdvcmspO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZsdXNoIGFzeW5jIHdvcmsuXG4gICAgICB2YXIgX2ZpbmlzaGVkV29yayA9IHJvb3QuZmluaXNoZWRXb3JrO1xuICAgICAgaWYgKF9maW5pc2hlZFdvcmsgIT09IG51bGwpIHtcbiAgICAgICAgLy8gVGhpcyByb290IGlzIGFscmVhZHkgY29tcGxldGUuIFdlIGNhbiBjb21taXQgaXQuXG4gICAgICAgIHJvb3QuZmluaXNoZWRXb3JrID0gbnVsbDtcbiAgICAgICAgcm9vdC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IGNvbW1pdFJvb3QoX2ZpbmlzaGVkV29yayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByb290LmZpbmlzaGVkV29yayA9IG51bGw7XG4gICAgICAgIF9maW5pc2hlZFdvcmsgPSByZW5kZXJSb290KHJvb3QsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgaWYgKF9maW5pc2hlZFdvcmsgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBXZSd2ZSBjb21wbGV0ZWQgdGhlIHJvb3QuIENoZWNrIHRoZSBkZWFkbGluZSBvbmUgbW9yZSB0aW1lXG4gICAgICAgICAgLy8gYmVmb3JlIGNvbW1pdHRpbmcuXG4gICAgICAgICAgaWYgKCFzaG91bGRZaWVsZCgpKSB7XG4gICAgICAgICAgICAvLyBTdGlsbCB0aW1lIGxlZnQuIENvbW1pdCB0aGUgcm9vdC5cbiAgICAgICAgICAgIHJvb3QucmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPSBjb21taXRSb290KF9maW5pc2hlZFdvcmspO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGVyZSdzIG5vIHRpbWUgbGVmdC4gTWFyayB0aGlzIHJvb3QgYXMgY29tcGxldGUuIFdlJ2xsIGNvbWVcbiAgICAgICAgICAgIC8vIGJhY2sgYW5kIGNvbW1pdCBpdCBsYXRlci5cbiAgICAgICAgICAgIHJvb3QuZmluaXNoZWRXb3JrID0gX2ZpbmlzaGVkV29yaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpc1JlbmRlcmluZyA9IGZhbHNlO1xuICB9XG5cbiAgLy8gV2hlbiB3b3JraW5nIG9uIGFzeW5jIHdvcmssIHRoZSByZWNvbmNpbGVyIGFza3MgdGhlIHJlbmRlcmVyIGlmIGl0IHNob3VsZFxuICAvLyB5aWVsZCBleGVjdXRpb24uIEZvciBET00sIHdlIGltcGxlbWVudCB0aGlzIHdpdGggcmVxdWVzdElkbGVDYWxsYmFjay5cbiAgZnVuY3Rpb24gc2hvdWxkWWllbGQoKSB7XG4gICAgaWYgKGRlYWRsaW5lID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChkZWFkbGluZS50aW1lUmVtYWluaW5nKCkgPiB0aW1lSGV1cmlzdGljRm9yVW5pdE9mV29yaykge1xuICAgICAgLy8gRGlzcmVnYXJkIGRlYWRsaW5lLmRpZFRpbWVvdXQuIE9ubHkgZXhwaXJlZCB3b3JrIHNob3VsZCBiZSBmbHVzaGVkXG4gICAgICAvLyBkdXJpbmcgYSB0aW1lb3V0LiBUaGlzIHBhdGggaXMgb25seSBoaXQgZm9yIG5vbi1leHBpcmVkIHdvcmsuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGRlYWRsaW5lRGlkRXhwaXJlID0gdHJ1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIFRPRE86IE5vdCBoYXBweSBhYm91dCB0aGlzIGhvb2suIENvbmNlcHR1YWxseSwgcmVuZGVyUm9vdCBzaG91bGQgcmV0dXJuIGFcbiAgLy8gdHVwbGUgb2YgKGlzUmVhZHlGb3JDb21taXQsIGRpZEVycm9yLCBlcnJvcilcbiAgZnVuY3Rpb24gb25VbmNhdWdodEVycm9yKGVycm9yKSB7XG4gICAgIShuZXh0Rmx1c2hlZFJvb3QgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnU2hvdWxkIGJlIHdvcmtpbmcgb24gYSByb290LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgIC8vIFVuc2NoZWR1bGUgdGhpcyByb290IHNvIHdlIGRvbid0IHdvcmsgb24gaXQgYWdhaW4gdW50aWwgdGhlcmUnc1xuICAgIC8vIGFub3RoZXIgdXBkYXRlLlxuICAgIG5leHRGbHVzaGVkUm9vdC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IE5vV29yaztcbiAgICBpZiAoIWhhc1VuaGFuZGxlZEVycm9yKSB7XG4gICAgICBoYXNVbmhhbmRsZWRFcnJvciA9IHRydWU7XG4gICAgICB1bmhhbmRsZWRFcnJvciA9IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRPRE86IEJhdGNoaW5nIHNob3VsZCBiZSBpbXBsZW1lbnRlZCBhdCB0aGUgcmVuZGVyZXIgbGV2ZWwsIG5vdCBpbnNpZGVcbiAgLy8gdGhlIHJlY29uY2lsZXIuXG4gIGZ1bmN0aW9uIGJhdGNoZWRVcGRhdGVzKGZuLCBhKSB7XG4gICAgdmFyIHByZXZpb3VzSXNCYXRjaGluZ1VwZGF0ZXMgPSBpc0JhdGNoaW5nVXBkYXRlcztcbiAgICBpc0JhdGNoaW5nVXBkYXRlcyA9IHRydWU7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmbihhKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaXNCYXRjaGluZ1VwZGF0ZXMgPSBwcmV2aW91c0lzQmF0Y2hpbmdVcGRhdGVzO1xuICAgICAgaWYgKCFpc0JhdGNoaW5nVXBkYXRlcyAmJiAhaXNSZW5kZXJpbmcpIHtcbiAgICAgICAgcGVyZm9ybVdvcmsoU3luYywgbnVsbCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gVE9ETzogQmF0Y2hpbmcgc2hvdWxkIGJlIGltcGxlbWVudGVkIGF0IHRoZSByZW5kZXJlciBsZXZlbCwgbm90IGluc2lkZVxuICAvLyB0aGUgcmVjb25jaWxlci5cbiAgZnVuY3Rpb24gdW5iYXRjaGVkVXBkYXRlcyhmbikge1xuICAgIGlmIChpc0JhdGNoaW5nVXBkYXRlcyAmJiAhaXNVbmJhdGNoaW5nVXBkYXRlcykge1xuICAgICAgaXNVbmJhdGNoaW5nVXBkYXRlcyA9IHRydWU7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlzVW5iYXRjaGluZ1VwZGF0ZXMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZuKCk7XG4gIH1cblxuICAvLyBUT0RPOiBCYXRjaGluZyBzaG91bGQgYmUgaW1wbGVtZW50ZWQgYXQgdGhlIHJlbmRlcmVyIGxldmVsLCBub3Qgd2l0aGluXG4gIC8vIHRoZSByZWNvbmNpbGVyLlxuICBmdW5jdGlvbiBmbHVzaFN5bmMoZm4pIHtcbiAgICB2YXIgcHJldmlvdXNJc0JhdGNoaW5nVXBkYXRlcyA9IGlzQmF0Y2hpbmdVcGRhdGVzO1xuICAgIGlzQmF0Y2hpbmdVcGRhdGVzID0gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHN5bmNVcGRhdGVzKGZuKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaXNCYXRjaGluZ1VwZGF0ZXMgPSBwcmV2aW91c0lzQmF0Y2hpbmdVcGRhdGVzO1xuICAgICAgISFpc1JlbmRlcmluZyA/IGludmFyaWFudChmYWxzZSwgJ2ZsdXNoU3luYyB3YXMgY2FsbGVkIGZyb20gaW5zaWRlIGEgbGlmZWN5Y2xlIG1ldGhvZC4gSXQgY2Fubm90IGJlIGNhbGxlZCB3aGVuIFJlYWN0IGlzIGFscmVhZHkgcmVuZGVyaW5nLicpIDogdm9pZCAwO1xuICAgICAgcGVyZm9ybVdvcmsoU3luYywgbnVsbCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjb21wdXRlQXN5bmNFeHBpcmF0aW9uOiBjb21wdXRlQXN5bmNFeHBpcmF0aW9uLFxuICAgIGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXI6IGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIsXG4gICAgc2NoZWR1bGVXb3JrOiBzY2hlZHVsZVdvcmssXG4gICAgYmF0Y2hlZFVwZGF0ZXM6IGJhdGNoZWRVcGRhdGVzLFxuICAgIHVuYmF0Y2hlZFVwZGF0ZXM6IHVuYmF0Y2hlZFVwZGF0ZXMsXG4gICAgZmx1c2hTeW5jOiBmbHVzaFN5bmMsXG4gICAgZGVmZXJyZWRVcGRhdGVzOiBkZWZlcnJlZFVwZGF0ZXNcbiAgfTtcbn07XG5cbntcbiAgdmFyIGRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXMgPSBmYWxzZTtcbn1cblxuLy8gMCBpcyBQUk9ELCAxIGlzIERFVi5cbi8vIE1pZ2h0IGFkZCBQUk9GSUxFIGxhdGVyLlxuXG5cbmZ1bmN0aW9uIGdldENvbnRleHRGb3JTdWJ0cmVlKHBhcmVudENvbXBvbmVudCkge1xuICBpZiAoIXBhcmVudENvbXBvbmVudCkge1xuICAgIHJldHVybiBlbXB0eU9iamVjdDtcbiAgfVxuXG4gIHZhciBmaWJlciA9IGdldChwYXJlbnRDb21wb25lbnQpO1xuICB2YXIgcGFyZW50Q29udGV4dCA9IGZpbmRDdXJyZW50VW5tYXNrZWRDb250ZXh0KGZpYmVyKTtcbiAgcmV0dXJuIGlzQ29udGV4dFByb3ZpZGVyKGZpYmVyKSA/IHByb2Nlc3NDaGlsZENvbnRleHQoZmliZXIsIHBhcmVudENvbnRleHQpIDogcGFyZW50Q29udGV4dDtcbn1cblxudmFyIFJlYWN0RmliZXJSZWNvbmNpbGVyJDEgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gIHZhciBnZXRQdWJsaWNJbnN0YW5jZSA9IGNvbmZpZy5nZXRQdWJsaWNJbnN0YW5jZTtcblxuICB2YXIgX1JlYWN0RmliZXJTY2hlZHVsZXIgPSBSZWFjdEZpYmVyU2NoZWR1bGVyKGNvbmZpZyksXG4gICAgICBjb21wdXRlQXN5bmNFeHBpcmF0aW9uID0gX1JlYWN0RmliZXJTY2hlZHVsZXIuY29tcHV0ZUFzeW5jRXhwaXJhdGlvbixcbiAgICAgIGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIgPSBfUmVhY3RGaWJlclNjaGVkdWxlci5jb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyLFxuICAgICAgc2NoZWR1bGVXb3JrID0gX1JlYWN0RmliZXJTY2hlZHVsZXIuc2NoZWR1bGVXb3JrLFxuICAgICAgYmF0Y2hlZFVwZGF0ZXMgPSBfUmVhY3RGaWJlclNjaGVkdWxlci5iYXRjaGVkVXBkYXRlcyxcbiAgICAgIHVuYmF0Y2hlZFVwZGF0ZXMgPSBfUmVhY3RGaWJlclNjaGVkdWxlci51bmJhdGNoZWRVcGRhdGVzLFxuICAgICAgZmx1c2hTeW5jID0gX1JlYWN0RmliZXJTY2hlZHVsZXIuZmx1c2hTeW5jLFxuICAgICAgZGVmZXJyZWRVcGRhdGVzID0gX1JlYWN0RmliZXJTY2hlZHVsZXIuZGVmZXJyZWRVcGRhdGVzO1xuXG4gIGZ1bmN0aW9uIHNjaGVkdWxlVG9wTGV2ZWxVcGRhdGUoY3VycmVudCwgZWxlbWVudCwgY2FsbGJhY2spIHtcbiAgICB7XG4gICAgICBpZiAoUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5waGFzZSA9PT0gJ3JlbmRlcicgJiYgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5jdXJyZW50ICE9PSBudWxsICYmICFkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXMgPSB0cnVlO1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnUmVuZGVyIG1ldGhvZHMgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGU7ICcgKyAndHJpZ2dlcmluZyBuZXN0ZWQgY29tcG9uZW50IHVwZGF0ZXMgZnJvbSByZW5kZXIgaXMgbm90IGFsbG93ZWQuICcgKyAnSWYgbmVjZXNzYXJ5LCB0cmlnZ2VyIG5lc3RlZCB1cGRhdGVzIGluIGNvbXBvbmVudERpZFVwZGF0ZS5cXG5cXG4nICsgJ0NoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mICVzLicsIGdldENvbXBvbmVudE5hbWUoUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5jdXJyZW50KSB8fCAnVW5rbm93bicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjYWxsYmFjaztcbiAgICB7XG4gICAgICB3YXJuaW5nKGNhbGxiYWNrID09PSBudWxsIHx8IHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJywgJ3JlbmRlciguLi4pOiBFeHBlY3RlZCB0aGUgbGFzdCBvcHRpb25hbCBgY2FsbGJhY2tgIGFyZ3VtZW50IHRvIGJlIGEgJyArICdmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMuJywgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIHZhciBleHBpcmF0aW9uVGltZSA9IHZvaWQgMDtcbiAgICAvLyBDaGVjayBpZiB0aGUgdG9wLWxldmVsIGVsZW1lbnQgaXMgYW4gYXN5bmMgd3JhcHBlciBjb21wb25lbnQuIElmIHNvLFxuICAgIC8vIHRyZWF0IHVwZGF0ZXMgdG8gdGhlIHJvb3QgYXMgYXN5bmMuIFRoaXMgaXMgYSBiaXQgd2VpcmQgYnV0IGxldHMgdXNcbiAgICAvLyBhdm9pZCBhIHNlcGFyYXRlIGByZW5kZXJBc3luY2AgQVBJLlxuICAgIGlmIChlbmFibGVBc3luY1N1YnRyZWVBUEkgJiYgZWxlbWVudCAhPSBudWxsICYmIGVsZW1lbnQudHlwZSAhPSBudWxsICYmIGVsZW1lbnQudHlwZS5wcm90b3R5cGUgIT0gbnVsbCAmJiBlbGVtZW50LnR5cGUucHJvdG90eXBlLnVuc3RhYmxlX2lzQXN5bmNSZWFjdENvbXBvbmVudCA9PT0gdHJ1ZSkge1xuICAgICAgZXhwaXJhdGlvblRpbWUgPSBjb21wdXRlQXN5bmNFeHBpcmF0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cGlyYXRpb25UaW1lID0gY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcihjdXJyZW50KTtcbiAgICB9XG5cbiAgICB2YXIgdXBkYXRlID0ge1xuICAgICAgZXhwaXJhdGlvblRpbWU6IGV4cGlyYXRpb25UaW1lLFxuICAgICAgcGFydGlhbFN0YXRlOiB7IGVsZW1lbnQ6IGVsZW1lbnQgfSxcbiAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgIGlzUmVwbGFjZTogZmFsc2UsXG4gICAgICBpc0ZvcmNlZDogZmFsc2UsXG4gICAgICBuZXh0Q2FsbGJhY2s6IG51bGwsXG4gICAgICBuZXh0OiBudWxsXG4gICAgfTtcbiAgICBpbnNlcnRVcGRhdGVJbnRvRmliZXIoY3VycmVudCwgdXBkYXRlKTtcbiAgICBzY2hlZHVsZVdvcmsoY3VycmVudCwgZXhwaXJhdGlvblRpbWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluZEhvc3RJbnN0YW5jZShmaWJlcikge1xuICAgIHZhciBob3N0RmliZXIgPSBmaW5kQ3VycmVudEhvc3RGaWJlcihmaWJlcik7XG4gICAgaWYgKGhvc3RGaWJlciA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBob3N0RmliZXIuc3RhdGVOb2RlO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjcmVhdGVDb250YWluZXI6IGZ1bmN0aW9uIChjb250YWluZXJJbmZvLCBoeWRyYXRlKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRmliZXJSb290KGNvbnRhaW5lckluZm8sIGh5ZHJhdGUpO1xuICAgIH0sXG4gICAgdXBkYXRlQ29udGFpbmVyOiBmdW5jdGlvbiAoZWxlbWVudCwgY29udGFpbmVyLCBwYXJlbnRDb21wb25lbnQsIGNhbGxiYWNrKSB7XG4gICAgICAvLyBUT0RPOiBJZiB0aGlzIGlzIGEgbmVzdGVkIGNvbnRhaW5lciwgdGhpcyB3b24ndCBiZSB0aGUgcm9vdC5cbiAgICAgIHZhciBjdXJyZW50ID0gY29udGFpbmVyLmN1cnJlbnQ7XG5cbiAgICAgIHtcbiAgICAgICAgaWYgKFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wpIHtcbiAgICAgICAgICBpZiAoY3VycmVudC5hbHRlcm5hdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wub25Nb3VudENvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbC5vblVubW91bnRDb250YWluZXIoY29udGFpbmVyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbC5vblVwZGF0ZUNvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IGdldENvbnRleHRGb3JTdWJ0cmVlKHBhcmVudENvbXBvbmVudCk7XG4gICAgICBpZiAoY29udGFpbmVyLmNvbnRleHQgPT09IG51bGwpIHtcbiAgICAgICAgY29udGFpbmVyLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGFpbmVyLnBlbmRpbmdDb250ZXh0ID0gY29udGV4dDtcbiAgICAgIH1cblxuICAgICAgc2NoZWR1bGVUb3BMZXZlbFVwZGF0ZShjdXJyZW50LCBlbGVtZW50LCBjYWxsYmFjayk7XG4gICAgfSxcblxuXG4gICAgYmF0Y2hlZFVwZGF0ZXM6IGJhdGNoZWRVcGRhdGVzLFxuXG4gICAgdW5iYXRjaGVkVXBkYXRlczogdW5iYXRjaGVkVXBkYXRlcyxcblxuICAgIGRlZmVycmVkVXBkYXRlczogZGVmZXJyZWRVcGRhdGVzLFxuXG4gICAgZmx1c2hTeW5jOiBmbHVzaFN5bmMsXG5cbiAgICBnZXRQdWJsaWNSb290SW5zdGFuY2U6IGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgICAgIHZhciBjb250YWluZXJGaWJlciA9IGNvbnRhaW5lci5jdXJyZW50O1xuICAgICAgaWYgKCFjb250YWluZXJGaWJlci5jaGlsZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoY29udGFpbmVyRmliZXIuY2hpbGQudGFnKSB7XG4gICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICByZXR1cm4gZ2V0UHVibGljSW5zdGFuY2UoY29udGFpbmVyRmliZXIuY2hpbGQuc3RhdGVOb2RlKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gY29udGFpbmVyRmliZXIuY2hpbGQuc3RhdGVOb2RlO1xuICAgICAgfVxuICAgIH0sXG5cblxuICAgIGZpbmRIb3N0SW5zdGFuY2U6IGZpbmRIb3N0SW5zdGFuY2UsXG5cbiAgICBmaW5kSG9zdEluc3RhbmNlV2l0aE5vUG9ydGFsczogZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICB2YXIgaG9zdEZpYmVyID0gZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzKGZpYmVyKTtcbiAgICAgIGlmIChob3N0RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gaG9zdEZpYmVyLnN0YXRlTm9kZTtcbiAgICB9LFxuICAgIGluamVjdEludG9EZXZUb29sczogZnVuY3Rpb24gKGRldlRvb2xzQ29uZmlnKSB7XG4gICAgICB2YXIgZmluZEZpYmVyQnlIb3N0SW5zdGFuY2UgPSBkZXZUb29sc0NvbmZpZy5maW5kRmliZXJCeUhvc3RJbnN0YW5jZTtcblxuICAgICAgcmV0dXJuIGluamVjdEludGVybmFscyhfYXNzaWduKHt9LCBkZXZUb29sc0NvbmZpZywge1xuICAgICAgICBmaW5kSG9zdEluc3RhbmNlQnlGaWJlcjogZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgICAgcmV0dXJuIGZpbmRIb3N0SW5zdGFuY2UoZmliZXIpO1xuICAgICAgICB9LFxuICAgICAgICBmaW5kRmliZXJCeUhvc3RJbnN0YW5jZTogZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgICAgICAgaWYgKCFmaW5kRmliZXJCeUhvc3RJbnN0YW5jZSkge1xuICAgICAgICAgICAgLy8gTWlnaHQgbm90IGJlIGltcGxlbWVudGVkIGJ5IHRoZSByZW5kZXJlci5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmluZEZpYmVyQnlIb3N0SW5zdGFuY2UoaW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgfVxuICB9O1xufTtcblxudmFyIFJlYWN0RmliZXJSZWNvbmNpbGVyJDIgPSBPYmplY3QuZnJlZXplKHtcblx0ZGVmYXVsdDogUmVhY3RGaWJlclJlY29uY2lsZXIkMVxufSk7XG5cbnZhciBSZWFjdEZpYmVyUmVjb25jaWxlciQzID0gKCBSZWFjdEZpYmVyUmVjb25jaWxlciQyICYmIFJlYWN0RmliZXJSZWNvbmNpbGVyJDEgKSB8fCBSZWFjdEZpYmVyUmVjb25jaWxlciQyO1xuXG4vLyBUT0RPOiBidW5kbGUgRmxvdyB0eXBlcyB3aXRoIHRoZSBwYWNrYWdlLlxuXG5cblxuLy8gVE9ETzogZGVjaWRlIG9uIHRoZSB0b3AtbGV2ZWwgZXhwb3J0IGZvcm0uXG4vLyBUaGlzIGlzIGhhY2t5IGJ1dCBtYWtlcyBpdCB3b3JrIHdpdGggYm90aCBSb2xsdXAgYW5kIEplc3QuXG52YXIgcmVhY3RSZWNvbmNpbGVyID0gUmVhY3RGaWJlclJlY29uY2lsZXIkM1snZGVmYXVsdCddID8gUmVhY3RGaWJlclJlY29uY2lsZXIkM1snZGVmYXVsdCddIDogUmVhY3RGaWJlclJlY29uY2lsZXIkMztcblxuZnVuY3Rpb24gY3JlYXRlUG9ydGFsJDEoY2hpbGRyZW4sIGNvbnRhaW5lckluZm8sXG4vLyBUT0RPOiBmaWd1cmUgb3V0IHRoZSBBUEkgZm9yIGNyb3NzLXJlbmRlcmVyIGltcGxlbWVudGF0aW9uLlxuaW1wbGVtZW50YXRpb24pIHtcbiAgdmFyIGtleSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogbnVsbDtcblxuICByZXR1cm4ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93IHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBQb3J0YWxcbiAgICAkJHR5cGVvZjogUkVBQ1RfUE9SVEFMX1RZUEUsXG4gICAga2V5OiBrZXkgPT0gbnVsbCA/IG51bGwgOiAnJyArIGtleSxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgY29udGFpbmVySW5mbzogY29udGFpbmVySW5mbyxcbiAgICBpbXBsZW1lbnRhdGlvbjogaW1wbGVtZW50YXRpb25cbiAgfTtcbn1cblxuLy8gVE9ETzogdGhpcyBpcyBzcGVjaWFsIGJlY2F1c2UgaXQgZ2V0cyBpbXBvcnRlZCBkdXJpbmcgYnVpbGQuXG5cbnZhciBSZWFjdFZlcnNpb24gPSAnMTYuMi4wJztcblxuLy8gYSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUsIHN0b3JpbmcgdGhlIHRpbWUgZm9yIHRoZSBzdGFydCBvZiB0aGUgZnJhbWUsIHRoZW5cbi8vIHNjaGVkdWxpbmcgYSBwb3N0TWVzc2FnZSB3aGljaCBnZXRzIHNjaGVkdWxlZCBhZnRlciBwYWludC4gV2l0aGluIHRoZVxuLy8gcG9zdE1lc3NhZ2UgaGFuZGxlciBkbyBhcyBtdWNoIHdvcmsgYXMgcG9zc2libGUgdW50aWwgdGltZSArIGZyYW1lIHJhdGUuXG4vLyBCeSBzZXBhcmF0aW5nIHRoZSBpZGxlIGNhbGwgaW50byBhIHNlcGFyYXRlIGV2ZW50IHRpY2sgd2UgZW5zdXJlIHRoYXRcbi8vIGxheW91dCwgcGFpbnQgYW5kIG90aGVyIGJyb3dzZXIgd29yayBpcyBjb3VudGVkIGFnYWluc3QgdGhlIGF2YWlsYWJsZSB0aW1lLlxuLy8gVGhlIGZyYW1lIHJhdGUgaXMgZHluYW1pY2FsbHkgYWRqdXN0ZWQuXG5cbntcbiAgaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiB0eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgd2FybmluZyhmYWxzZSwgJ1JlYWN0IGRlcGVuZHMgb24gcmVxdWVzdEFuaW1hdGlvbkZyYW1lLiBNYWtlIHN1cmUgdGhhdCB5b3UgbG9hZCBhICcgKyAncG9seWZpbGwgaW4gb2xkZXIgYnJvd3NlcnMuIGh0dHA6Ly9mYi5tZS9yZWFjdC1wb2x5ZmlsbHMnKTtcbiAgfVxufVxuXG52YXIgaGFzTmF0aXZlUGVyZm9ybWFuY2VOb3cgPSB0eXBlb2YgcGVyZm9ybWFuY2UgPT09ICdvYmplY3QnICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5ub3cgPT09ICdmdW5jdGlvbic7XG5cbnZhciBub3cgPSB2b2lkIDA7XG5pZiAoaGFzTmF0aXZlUGVyZm9ybWFuY2VOb3cpIHtcbiAgbm93ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTtcbiAgfTtcbn0gZWxzZSB7XG4gIG5vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gRGF0ZS5ub3coKTtcbiAgfTtcbn1cblxuLy8gVE9ETzogVGhlcmUncyBubyB3YXkgdG8gY2FuY2VsLCBiZWNhdXNlIEZpYmVyIGRvZXNuJ3QgYXRtLlxudmFyIHJJQyA9IHZvaWQgMDtcbnZhciBjSUMgPSB2b2lkIDA7XG5cbmlmICghRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIHJJQyA9IGZ1bmN0aW9uIChmcmFtZUNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgZnJhbWVDYWxsYmFjayh7XG4gICAgICAgIHRpbWVSZW1haW5pbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuICBjSUMgPSBmdW5jdGlvbiAodGltZW91dElEKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJRCk7XG4gIH07XG59IGVsc2UgaWYgKHR5cGVvZiByZXF1ZXN0SWRsZUNhbGxiYWNrICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBjYW5jZWxJZGxlQ2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgLy8gUG9seWZpbGwgcmVxdWVzdElkbGVDYWxsYmFjayBhbmQgY2FuY2VsSWRsZUNhbGxiYWNrXG5cbiAgdmFyIHNjaGVkdWxlZFJJQ0NhbGxiYWNrID0gbnVsbDtcbiAgdmFyIGlzSWRsZVNjaGVkdWxlZCA9IGZhbHNlO1xuICB2YXIgdGltZW91dFRpbWUgPSAtMTtcblxuICB2YXIgaXNBbmltYXRpb25GcmFtZVNjaGVkdWxlZCA9IGZhbHNlO1xuXG4gIHZhciBmcmFtZURlYWRsaW5lID0gMDtcbiAgLy8gV2Ugc3RhcnQgb3V0IGFzc3VtaW5nIHRoYXQgd2UgcnVuIGF0IDMwZnBzIGJ1dCB0aGVuIHRoZSBoZXVyaXN0aWMgdHJhY2tpbmdcbiAgLy8gd2lsbCBhZGp1c3QgdGhpcyB2YWx1ZSB0byBhIGZhc3RlciBmcHMgaWYgd2UgZ2V0IG1vcmUgZnJlcXVlbnQgYW5pbWF0aW9uXG4gIC8vIGZyYW1lcy5cbiAgdmFyIHByZXZpb3VzRnJhbWVUaW1lID0gMzM7XG4gIHZhciBhY3RpdmVGcmFtZVRpbWUgPSAzMztcblxuICB2YXIgZnJhbWVEZWFkbGluZU9iamVjdDtcbiAgaWYgKGhhc05hdGl2ZVBlcmZvcm1hbmNlTm93KSB7XG4gICAgZnJhbWVEZWFkbGluZU9iamVjdCA9IHtcbiAgICAgIGRpZFRpbWVvdXQ6IGZhbHNlLFxuICAgICAgdGltZVJlbWFpbmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBXZSBhc3N1bWUgdGhhdCBpZiB3ZSBoYXZlIGEgcGVyZm9ybWFuY2UgdGltZXIgdGhhdCB0aGUgckFGIGNhbGxiYWNrXG4gICAgICAgIC8vIGdldHMgYSBwZXJmb3JtYW5jZSB0aW1lciB2YWx1ZS4gTm90IHN1cmUgaWYgdGhpcyBpcyBhbHdheXMgdHJ1ZS5cbiAgICAgICAgdmFyIHJlbWFpbmluZyA9IGZyYW1lRGVhZGxpbmUgLSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgcmV0dXJuIHJlbWFpbmluZyA+IDAgPyByZW1haW5pbmcgOiAwO1xuICAgICAgfVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgZnJhbWVEZWFkbGluZU9iamVjdCA9IHtcbiAgICAgIGRpZFRpbWVvdXQ6IGZhbHNlLFxuICAgICAgdGltZVJlbWFpbmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBGYWxsYmFjayB0byBEYXRlLm5vdygpXG4gICAgICAgIHZhciByZW1haW5pbmcgPSBmcmFtZURlYWRsaW5lIC0gRGF0ZS5ub3coKTtcbiAgICAgICAgcmV0dXJuIHJlbWFpbmluZyA+IDAgPyByZW1haW5pbmcgOiAwO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBXZSB1c2UgdGhlIHBvc3RNZXNzYWdlIHRyaWNrIHRvIGRlZmVyIGlkbGUgd29yayB1bnRpbCBhZnRlciB0aGUgcmVwYWludC5cbiAgdmFyIG1lc3NhZ2VLZXkgPSAnX19yZWFjdElkbGVDYWxsYmFjayQnICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7XG4gIHZhciBpZGxlVGljayA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmIChldmVudC5zb3VyY2UgIT09IHdpbmRvdyB8fCBldmVudC5kYXRhICE9PSBtZXNzYWdlS2V5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaXNJZGxlU2NoZWR1bGVkID0gZmFsc2U7XG5cbiAgICB2YXIgY3VycmVudFRpbWUgPSBub3coKTtcbiAgICBpZiAoZnJhbWVEZWFkbGluZSAtIGN1cnJlbnRUaW1lIDw9IDApIHtcbiAgICAgIC8vIFRoZXJlJ3Mgbm8gdGltZSBsZWZ0IGluIHRoaXMgaWRsZSBwZXJpb2QuIENoZWNrIGlmIHRoZSBjYWxsYmFjayBoYXNcbiAgICAgIC8vIGEgdGltZW91dCBhbmQgd2hldGhlciBpdCdzIGJlZW4gZXhjZWVkZWQuXG4gICAgICBpZiAodGltZW91dFRpbWUgIT09IC0xICYmIHRpbWVvdXRUaW1lIDw9IGN1cnJlbnRUaW1lKSB7XG4gICAgICAgIC8vIEV4Y2VlZGVkIHRoZSB0aW1lb3V0LiBJbnZva2UgdGhlIGNhbGxiYWNrIGV2ZW4gdGhvdWdoIHRoZXJlJ3Mgbm9cbiAgICAgICAgLy8gdGltZSBsZWZ0LlxuICAgICAgICBmcmFtZURlYWRsaW5lT2JqZWN0LmRpZFRpbWVvdXQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm8gdGltZW91dC5cbiAgICAgICAgaWYgKCFpc0FuaW1hdGlvbkZyYW1lU2NoZWR1bGVkKSB7XG4gICAgICAgICAgLy8gU2NoZWR1bGUgYW5vdGhlciBhbmltYXRpb24gY2FsbGJhY2sgc28gd2UgcmV0cnkgbGF0ZXIuXG4gICAgICAgICAgaXNBbmltYXRpb25GcmFtZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvblRpY2spO1xuICAgICAgICB9XG4gICAgICAgIC8vIEV4aXQgd2l0aG91dCBpbnZva2luZyB0aGUgY2FsbGJhY2suXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlcmUncyBzdGlsbCB0aW1lIGxlZnQgaW4gdGhpcyBpZGxlIHBlcmlvZC5cbiAgICAgIGZyYW1lRGVhZGxpbmVPYmplY3QuZGlkVGltZW91dCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRpbWVvdXRUaW1lID0gLTE7XG4gICAgdmFyIGNhbGxiYWNrID0gc2NoZWR1bGVkUklDQ2FsbGJhY2s7XG4gICAgc2NoZWR1bGVkUklDQ2FsbGJhY2sgPSBudWxsO1xuICAgIGlmIChjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgY2FsbGJhY2soZnJhbWVEZWFkbGluZU9iamVjdCk7XG4gICAgfVxuICB9O1xuICAvLyBBc3N1bWVzIHRoYXQgd2UgaGF2ZSBhZGRFdmVudExpc3RlbmVyIGluIHRoaXMgZW52aXJvbm1lbnQuIE1pZ2h0IG5lZWRcbiAgLy8gc29tZXRoaW5nIGJldHRlciBmb3Igb2xkIElFLlxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGlkbGVUaWNrLCBmYWxzZSk7XG5cbiAgdmFyIGFuaW1hdGlvblRpY2sgPSBmdW5jdGlvbiAocmFmVGltZSkge1xuICAgIGlzQW5pbWF0aW9uRnJhbWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICB2YXIgbmV4dEZyYW1lVGltZSA9IHJhZlRpbWUgLSBmcmFtZURlYWRsaW5lICsgYWN0aXZlRnJhbWVUaW1lO1xuICAgIGlmIChuZXh0RnJhbWVUaW1lIDwgYWN0aXZlRnJhbWVUaW1lICYmIHByZXZpb3VzRnJhbWVUaW1lIDwgYWN0aXZlRnJhbWVUaW1lKSB7XG4gICAgICBpZiAobmV4dEZyYW1lVGltZSA8IDgpIHtcbiAgICAgICAgLy8gRGVmZW5zaXZlIGNvZGluZy4gV2UgZG9uJ3Qgc3VwcG9ydCBoaWdoZXIgZnJhbWUgcmF0ZXMgdGhhbiAxMjBoei5cbiAgICAgICAgLy8gSWYgd2UgZ2V0IGxvd2VyIHRoYW4gdGhhdCwgaXQgaXMgcHJvYmFibHkgYSBidWcuXG4gICAgICAgIG5leHRGcmFtZVRpbWUgPSA4O1xuICAgICAgfVxuICAgICAgLy8gSWYgb25lIGZyYW1lIGdvZXMgbG9uZywgdGhlbiB0aGUgbmV4dCBvbmUgY2FuIGJlIHNob3J0IHRvIGNhdGNoIHVwLlxuICAgICAgLy8gSWYgdHdvIGZyYW1lcyBhcmUgc2hvcnQgaW4gYSByb3csIHRoZW4gdGhhdCdzIGFuIGluZGljYXRpb24gdGhhdCB3ZVxuICAgICAgLy8gYWN0dWFsbHkgaGF2ZSBhIGhpZ2hlciBmcmFtZSByYXRlIHRoYW4gd2hhdCB3ZSdyZSBjdXJyZW50bHkgb3B0aW1pemluZy5cbiAgICAgIC8vIFdlIGFkanVzdCBvdXIgaGV1cmlzdGljIGR5bmFtaWNhbGx5IGFjY29yZGluZ2x5LiBGb3IgZXhhbXBsZSwgaWYgd2UncmVcbiAgICAgIC8vIHJ1bm5pbmcgb24gMTIwaHogZGlzcGxheSBvciA5MGh6IFZSIGRpc3BsYXkuXG4gICAgICAvLyBUYWtlIHRoZSBtYXggb2YgdGhlIHR3byBpbiBjYXNlIG9uZSBvZiB0aGVtIHdhcyBhbiBhbm9tYWx5IGR1ZSB0b1xuICAgICAgLy8gbWlzc2VkIGZyYW1lIGRlYWRsaW5lcy5cbiAgICAgIGFjdGl2ZUZyYW1lVGltZSA9IG5leHRGcmFtZVRpbWUgPCBwcmV2aW91c0ZyYW1lVGltZSA/IHByZXZpb3VzRnJhbWVUaW1lIDogbmV4dEZyYW1lVGltZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJldmlvdXNGcmFtZVRpbWUgPSBuZXh0RnJhbWVUaW1lO1xuICAgIH1cbiAgICBmcmFtZURlYWRsaW5lID0gcmFmVGltZSArIGFjdGl2ZUZyYW1lVGltZTtcbiAgICBpZiAoIWlzSWRsZVNjaGVkdWxlZCkge1xuICAgICAgaXNJZGxlU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIHdpbmRvdy5wb3N0TWVzc2FnZShtZXNzYWdlS2V5LCAnKicpO1xuICAgIH1cbiAgfTtcblxuICBySUMgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICAvLyBUaGlzIGFzc3VtZXMgdGhhdCB3ZSBvbmx5IHNjaGVkdWxlIG9uZSBjYWxsYmFjayBhdCBhIHRpbWUgYmVjYXVzZSB0aGF0J3NcbiAgICAvLyBob3cgRmliZXIgdXNlcyBpdC5cbiAgICBzY2hlZHVsZWRSSUNDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIGlmIChvcHRpb25zICE9IG51bGwgJiYgdHlwZW9mIG9wdGlvbnMudGltZW91dCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRpbWVvdXRUaW1lID0gbm93KCkgKyBvcHRpb25zLnRpbWVvdXQ7XG4gICAgfVxuICAgIGlmICghaXNBbmltYXRpb25GcmFtZVNjaGVkdWxlZCkge1xuICAgICAgLy8gSWYgckFGIGRpZG4ndCBhbHJlYWR5IHNjaGVkdWxlIG9uZSwgd2UgbmVlZCB0byBzY2hlZHVsZSBhIGZyYW1lLlxuICAgICAgLy8gVE9ETzogSWYgdGhpcyByQUYgZG9lc24ndCBtYXRlcmlhbGl6ZSBiZWNhdXNlIHRoZSBicm93c2VyIHRocm90dGxlcywgd2VcbiAgICAgIC8vIG1pZ2h0IHdhbnQgdG8gc3RpbGwgaGF2ZSBzZXRUaW1lb3V0IHRyaWdnZXIgcklDIGFzIGEgYmFja3VwIHRvIGVuc3VyZVxuICAgICAgLy8gdGhhdCB3ZSBrZWVwIHBlcmZvcm1pbmcgd29yay5cbiAgICAgIGlzQW5pbWF0aW9uRnJhbWVTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvblRpY2spO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfTtcblxuICBjSUMgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2NoZWR1bGVkUklDQ2FsbGJhY2sgPSBudWxsO1xuICAgIGlzSWRsZVNjaGVkdWxlZCA9IGZhbHNlO1xuICAgIHRpbWVvdXRUaW1lID0gLTE7XG4gIH07XG59IGVsc2Uge1xuICBySUMgPSB3aW5kb3cucmVxdWVzdElkbGVDYWxsYmFjaztcbiAgY0lDID0gd2luZG93LmNhbmNlbElkbGVDYWxsYmFjaztcbn1cblxuLyoqXG4gKiBGb3JrZWQgZnJvbSBmYmpzL3dhcm5pbmc6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmJqcy9ibG9iL2U2NmJhMjBhZDViZTQzM2ViNTQ0MjNmMmIwOTdkODI5MzI0ZDlkZTYvcGFja2FnZXMvZmJqcy9zcmMvX19mb3Jrc19fL3dhcm5pbmcuanNcbiAqXG4gKiBPbmx5IGNoYW5nZSBpcyB3ZSB1c2UgY29uc29sZS53YXJuIGluc3RlYWQgb2YgY29uc29sZS5lcnJvcixcbiAqIGFuZCBkbyBub3RoaW5nIHdoZW4gJ2NvbnNvbGUnIGlzIG5vdCBzdXBwb3J0ZWQuXG4gKiBUaGlzIHJlYWxseSBzaW1wbGlmaWVzIHRoZSBjb2RlLlxuICogLS0tXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIGxvd1ByaW9yaXR5V2FybmluZyA9IGZ1bmN0aW9uICgpIHt9O1xuXG57XG4gIHZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xuXG4gIGxvd1ByaW9yaXR5V2FybmluZyA9IGZ1bmN0aW9uIChjb25kaXRpb24sIGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICsgJ21lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4yID4gMiA/IF9sZW4yIC0gMiA6IDApLCBfa2V5MiA9IDI7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nLmFwcGx5KHVuZGVmaW5lZCwgW2Zvcm1hdF0uY29uY2F0KGFyZ3MpKTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBsb3dQcmlvcml0eVdhcm5pbmckMSA9IGxvd1ByaW9yaXR5V2FybmluZztcblxuLy8gaXNBdHRyaWJ1dGVOYW1lU2FmZSgpIGlzIGN1cnJlbnRseSBkdXBsaWNhdGVkIGluIERPTU1hcmt1cE9wZXJhdGlvbnMuXG4vLyBUT0RPOiBGaW5kIGEgYmV0dGVyIHBsYWNlIGZvciB0aGlzLlxudmFyIFZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYID0gbmV3IFJlZ0V4cCgnXlsnICsgQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiArICddWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xudmFyIGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGUgPSB7fTtcbnZhciB2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGlzQXR0cmlidXRlTmFtZVNhZmUoYXR0cmlidXRlTmFtZSkge1xuICBpZiAodmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlLmhhc093blByb3BlcnR5KGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGUuaGFzT3duUHJvcGVydHkoYXR0cmlidXRlTmFtZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKFZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYLnRlc3QoYXR0cmlidXRlTmFtZSkpIHtcbiAgICB2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGVbYXR0cmlidXRlTmFtZV0gPSB0cnVlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGVbYXR0cmlidXRlTmFtZV0gPSB0cnVlO1xuICB7XG4gICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXR0cmlidXRlIG5hbWU6IGAlc2AnLCBhdHRyaWJ1dGVOYW1lKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIHNob3VsZElnbm9yZVZhbHVlKCkgaXMgY3VycmVudGx5IGR1cGxpY2F0ZWQgaW4gRE9NTWFya3VwT3BlcmF0aW9ucy5cbi8vIFRPRE86IEZpbmQgYSBiZXR0ZXIgcGxhY2UgZm9yIHRoaXMuXG5mdW5jdGlvbiBzaG91bGRJZ25vcmVWYWx1ZShwcm9wZXJ0eUluZm8sIHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsIHx8IHByb3BlcnR5SW5mby5oYXNCb29sZWFuVmFsdWUgJiYgIXZhbHVlIHx8IHByb3BlcnR5SW5mby5oYXNOdW1lcmljVmFsdWUgJiYgaXNOYU4odmFsdWUpIHx8IHByb3BlcnR5SW5mby5oYXNQb3NpdGl2ZU51bWVyaWNWYWx1ZSAmJiB2YWx1ZSA8IDEgfHwgcHJvcGVydHlJbmZvLmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWUgJiYgdmFsdWUgPT09IGZhbHNlO1xufVxuXG4vKipcbiAqIE9wZXJhdGlvbnMgZm9yIGRlYWxpbmcgd2l0aCBET00gcHJvcGVydGllcy5cbiAqL1xuXG5cblxuXG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBmb3IgYSBwcm9wZXJ0eSBvbiBhIG5vZGUuIE9ubHkgdXNlZCBpbiBERVYgZm9yIFNTUiB2YWxpZGF0aW9uLlxuICogVGhlIFwiZXhwZWN0ZWRcIiBhcmd1bWVudCBpcyB1c2VkIGFzIGEgaGludCBvZiB3aGF0IHRoZSBleHBlY3RlZCB2YWx1ZSBpcy5cbiAqIFNvbWUgcHJvcGVydGllcyBoYXZlIG11bHRpcGxlIGVxdWl2YWxlbnQgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZUZvclByb3BlcnR5KG5vZGUsIG5hbWUsIGV4cGVjdGVkKSB7XG4gIHtcbiAgICB2YXIgcHJvcGVydHlJbmZvID0gZ2V0UHJvcGVydHlJbmZvKG5hbWUpO1xuICAgIGlmIChwcm9wZXJ0eUluZm8pIHtcbiAgICAgIHZhciBtdXRhdGlvbk1ldGhvZCA9IHByb3BlcnR5SW5mby5tdXRhdGlvbk1ldGhvZDtcbiAgICAgIGlmIChtdXRhdGlvbk1ldGhvZCB8fCBwcm9wZXJ0eUluZm8ubXVzdFVzZVByb3BlcnR5KSB7XG4gICAgICAgIHJldHVybiBub2RlW3Byb3BlcnR5SW5mby5wcm9wZXJ0eU5hbWVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZTtcblxuICAgICAgICB2YXIgc3RyaW5nVmFsdWUgPSBudWxsO1xuXG4gICAgICAgIGlmIChwcm9wZXJ0eUluZm8uaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZSkge1xuICAgICAgICAgIGlmIChub2RlLmhhc0F0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gbm9kZS5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSk7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNob3VsZElnbm9yZVZhbHVlKHByb3BlcnR5SW5mbywgZXhwZWN0ZWQpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gJycgKyBleHBlY3RlZCkge1xuICAgICAgICAgICAgICByZXR1cm4gZXhwZWN0ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG5vZGUuaGFzQXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgICAgICAgaWYgKHNob3VsZElnbm9yZVZhbHVlKHByb3BlcnR5SW5mbywgZXhwZWN0ZWQpKSB7XG4gICAgICAgICAgICAvLyBXZSBoYWQgYW4gYXR0cmlidXRlIGJ1dCBzaG91bGRuJ3QgaGF2ZSBoYWQgb25lLCBzbyByZWFkIGl0XG4gICAgICAgICAgICAvLyBmb3IgdGhlIGVycm9yIG1lc3NhZ2UuXG4gICAgICAgICAgICByZXR1cm4gbm9kZS5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIHdhcyBhIGJvb2xlYW4sIGl0IGRvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIHZhbHVlIGlzXG4gICAgICAgICAgICAvLyB0aGUgZmFjdCB0aGF0IHdlIGhhdmUgaXQgaXMgdGhlIHNhbWUgYXMgdGhlIGV4cGVjdGVkLlxuICAgICAgICAgICAgcmV0dXJuIGV4cGVjdGVkO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBFdmVuIGlmIHRoaXMgcHJvcGVydHkgdXNlcyBhIG5hbWVzcGFjZSB3ZSB1c2UgZ2V0QXR0cmlidXRlXG4gICAgICAgICAgLy8gYmVjYXVzZSB3ZSBhc3N1bWUgaXRzIG5hbWVzcGFjZWQgbmFtZSBpcyB0aGUgc2FtZSBhcyBvdXIgY29uZmlnLlxuICAgICAgICAgIC8vIFRvIHVzZSBnZXRBdHRyaWJ1dGVOUyB3ZSBuZWVkIHRoZSBsb2NhbCBuYW1lIHdoaWNoIHdlIGRvbid0IGhhdmVcbiAgICAgICAgICAvLyBpbiBvdXIgY29uZmlnIGF0bS5cbiAgICAgICAgICBzdHJpbmdWYWx1ZSA9IG5vZGUuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNob3VsZElnbm9yZVZhbHVlKHByb3BlcnR5SW5mbywgZXhwZWN0ZWQpKSB7XG4gICAgICAgICAgcmV0dXJuIHN0cmluZ1ZhbHVlID09PSBudWxsID8gZXhwZWN0ZWQgOiBzdHJpbmdWYWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChzdHJpbmdWYWx1ZSA9PT0gJycgKyBleHBlY3RlZCkge1xuICAgICAgICAgIHJldHVybiBleHBlY3RlZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gc3RyaW5nVmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIGZvciBhIGF0dHJpYnV0ZSBvbiBhIG5vZGUuIE9ubHkgdXNlZCBpbiBERVYgZm9yIFNTUiB2YWxpZGF0aW9uLlxuICogVGhlIHRoaXJkIGFyZ3VtZW50IGlzIHVzZWQgYXMgYSBoaW50IG9mIHdoYXQgdGhlIGV4cGVjdGVkIHZhbHVlIGlzLiBTb21lXG4gKiBhdHRyaWJ1dGVzIGhhdmUgbXVsdGlwbGUgZXF1aXZhbGVudCB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlRm9yQXR0cmlidXRlKG5vZGUsIG5hbWUsIGV4cGVjdGVkKSB7XG4gIHtcbiAgICBpZiAoIWlzQXR0cmlidXRlTmFtZVNhZmUobmFtZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFub2RlLmhhc0F0dHJpYnV0ZShuYW1lKSkge1xuICAgICAgcmV0dXJuIGV4cGVjdGVkID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBudWxsO1xuICAgIH1cbiAgICB2YXIgdmFsdWUgPSBub2RlLmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICBpZiAodmFsdWUgPT09ICcnICsgZXhwZWN0ZWQpIHtcbiAgICAgIHJldHVybiBleHBlY3RlZDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5cbi8qKlxuICogU2V0cyB0aGUgdmFsdWUgZm9yIGEgcHJvcGVydHkgb24gYSBub2RlLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqL1xuZnVuY3Rpb24gc2V0VmFsdWVGb3JQcm9wZXJ0eShub2RlLCBuYW1lLCB2YWx1ZSkge1xuICB2YXIgcHJvcGVydHlJbmZvID0gZ2V0UHJvcGVydHlJbmZvKG5hbWUpO1xuXG4gIGlmIChwcm9wZXJ0eUluZm8gJiYgc2hvdWxkU2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKSkge1xuICAgIHZhciBtdXRhdGlvbk1ldGhvZCA9IHByb3BlcnR5SW5mby5tdXRhdGlvbk1ldGhvZDtcbiAgICBpZiAobXV0YXRpb25NZXRob2QpIHtcbiAgICAgIG11dGF0aW9uTWV0aG9kKG5vZGUsIHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHNob3VsZElnbm9yZVZhbHVlKHByb3BlcnR5SW5mbywgdmFsdWUpKSB7XG4gICAgICBkZWxldGVWYWx1ZUZvclByb3BlcnR5KG5vZGUsIG5hbWUpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAocHJvcGVydHlJbmZvLm11c3RVc2VQcm9wZXJ0eSkge1xuICAgICAgLy8gQ29udHJhcnkgdG8gYHNldEF0dHJpYnV0ZWAsIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBwcm9wZXJseVxuICAgICAgLy8gYHRvU3RyaW5nYGVkIGJ5IElFOC85LlxuICAgICAgbm9kZVtwcm9wZXJ0eUluZm8ucHJvcGVydHlOYW1lXSA9IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lO1xuICAgICAgdmFyIG5hbWVzcGFjZSA9IHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lc3BhY2U7XG4gICAgICAvLyBgc2V0QXR0cmlidXRlYCB3aXRoIG9iamVjdHMgYmVjb21lcyBvbmx5IGBbb2JqZWN0XWAgaW4gSUU4LzksXG4gICAgICAvLyAoJycgKyB2YWx1ZSkgbWFrZXMgaXQgb3V0cHV0IHRoZSBjb3JyZWN0IHRvU3RyaW5nKCktdmFsdWUuXG4gICAgICBpZiAobmFtZXNwYWNlKSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlTlMobmFtZXNwYWNlLCBhdHRyaWJ1dGVOYW1lLCAnJyArIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvcGVydHlJbmZvLmhhc0Jvb2xlYW5WYWx1ZSB8fCBwcm9wZXJ0eUluZm8uaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZSAmJiB2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCAnJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCAnJyArIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc2V0VmFsdWVGb3JBdHRyaWJ1dGUobm9kZSwgbmFtZSwgc2hvdWxkU2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKSA/IHZhbHVlIDogbnVsbCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAge1xuICAgIFxuICB9XG59XG5cbmZ1bmN0aW9uIHNldFZhbHVlRm9yQXR0cmlidXRlKG5vZGUsIG5hbWUsIHZhbHVlKSB7XG4gIGlmICghaXNBdHRyaWJ1dGVOYW1lU2FmZShuYW1lKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICB9IGVsc2Uge1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKG5hbWUsICcnICsgdmFsdWUpO1xuICB9XG5cbiAge1xuICAgIFxuICB9XG59XG5cbi8qKlxuICogRGVsZXRlcyBhbiBhdHRyaWJ1dGVzIGZyb20gYSBub2RlLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqL1xuZnVuY3Rpb24gZGVsZXRlVmFsdWVGb3JBdHRyaWJ1dGUobm9kZSwgbmFtZSkge1xuICBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbn1cblxuLyoqXG4gKiBEZWxldGVzIHRoZSB2YWx1ZSBmb3IgYSBwcm9wZXJ0eSBvbiBhIG5vZGUuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICovXG5mdW5jdGlvbiBkZWxldGVWYWx1ZUZvclByb3BlcnR5KG5vZGUsIG5hbWUpIHtcbiAgdmFyIHByb3BlcnR5SW5mbyA9IGdldFByb3BlcnR5SW5mbyhuYW1lKTtcbiAgaWYgKHByb3BlcnR5SW5mbykge1xuICAgIHZhciBtdXRhdGlvbk1ldGhvZCA9IHByb3BlcnR5SW5mby5tdXRhdGlvbk1ldGhvZDtcbiAgICBpZiAobXV0YXRpb25NZXRob2QpIHtcbiAgICAgIG11dGF0aW9uTWV0aG9kKG5vZGUsIHVuZGVmaW5lZCk7XG4gICAgfSBlbHNlIGlmIChwcm9wZXJ0eUluZm8ubXVzdFVzZVByb3BlcnR5KSB7XG4gICAgICB2YXIgcHJvcE5hbWUgPSBwcm9wZXJ0eUluZm8ucHJvcGVydHlOYW1lO1xuICAgICAgaWYgKHByb3BlcnR5SW5mby5oYXNCb29sZWFuVmFsdWUpIHtcbiAgICAgICAgbm9kZVtwcm9wTmFtZV0gPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGVbcHJvcE5hbWVdID0gJyc7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gIH1cbn1cblxudmFyIFJlYWN0Q29udHJvbGxlZFZhbHVlUHJvcFR5cGVzID0ge1xuICBjaGVja1Byb3BUeXBlczogbnVsbFxufTtcblxue1xuICB2YXIgaGFzUmVhZE9ubHlWYWx1ZSA9IHtcbiAgICBidXR0b246IHRydWUsXG4gICAgY2hlY2tib3g6IHRydWUsXG4gICAgaW1hZ2U6IHRydWUsXG4gICAgaGlkZGVuOiB0cnVlLFxuICAgIHJhZGlvOiB0cnVlLFxuICAgIHJlc2V0OiB0cnVlLFxuICAgIHN1Ym1pdDogdHJ1ZVxuICB9O1xuXG4gIHZhciBwcm9wVHlwZXMgPSB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIChwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICAgIGlmICghcHJvcHNbcHJvcE5hbWVdIHx8IGhhc1JlYWRPbmx5VmFsdWVbcHJvcHMudHlwZV0gfHwgcHJvcHMub25DaGFuZ2UgfHwgcHJvcHMucmVhZE9ubHkgfHwgcHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdZb3UgcHJvdmlkZWQgYSBgdmFsdWVgIHByb3AgdG8gYSBmb3JtIGZpZWxkIHdpdGhvdXQgYW4gJyArICdgb25DaGFuZ2VgIGhhbmRsZXIuIFRoaXMgd2lsbCByZW5kZXIgYSByZWFkLW9ubHkgZmllbGQuIElmICcgKyAndGhlIGZpZWxkIHNob3VsZCBiZSBtdXRhYmxlIHVzZSBgZGVmYXVsdFZhbHVlYC4gT3RoZXJ3aXNlLCAnICsgJ3NldCBlaXRoZXIgYG9uQ2hhbmdlYCBvciBgcmVhZE9ubHlgLicpO1xuICAgIH0sXG4gICAgY2hlY2tlZDogZnVuY3Rpb24gKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgICAgaWYgKCFwcm9wc1twcm9wTmFtZV0gfHwgcHJvcHMub25DaGFuZ2UgfHwgcHJvcHMucmVhZE9ubHkgfHwgcHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdZb3UgcHJvdmlkZWQgYSBgY2hlY2tlZGAgcHJvcCB0byBhIGZvcm0gZmllbGQgd2l0aG91dCBhbiAnICsgJ2BvbkNoYW5nZWAgaGFuZGxlci4gVGhpcyB3aWxsIHJlbmRlciBhIHJlYWQtb25seSBmaWVsZC4gSWYgJyArICd0aGUgZmllbGQgc2hvdWxkIGJlIG11dGFibGUgdXNlIGBkZWZhdWx0Q2hlY2tlZGAuIE90aGVyd2lzZSwgJyArICdzZXQgZWl0aGVyIGBvbkNoYW5nZWAgb3IgYHJlYWRPbmx5YC4nKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFByb3ZpZGUgYSBsaW5rZWQgYHZhbHVlYCBhdHRyaWJ1dGUgZm9yIGNvbnRyb2xsZWQgZm9ybXMuIFlvdSBzaG91bGQgbm90IHVzZVxuICAgKiB0aGlzIG91dHNpZGUgb2YgdGhlIFJlYWN0RE9NIGNvbnRyb2xsZWQgZm9ybSBjb21wb25lbnRzLlxuICAgKi9cbiAgUmVhY3RDb250cm9sbGVkVmFsdWVQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMgPSBmdW5jdGlvbiAodGFnTmFtZSwgcHJvcHMsIGdldFN0YWNrKSB7XG4gICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBwcm9wcywgJ3Byb3AnLCB0YWdOYW1lLCBnZXRTdGFjayk7XG4gIH07XG59XG5cbi8vIFRPRE86IGRpcmVjdCBpbXBvcnRzIGxpa2Ugc29tZS1wYWNrYWdlL3NyYy8qIGFyZSBiYWQuIEZpeCBtZS5cbnZhciBnZXRDdXJyZW50RmliZXJPd25lck5hbWUkMiA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lO1xudmFyIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMyA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bTtcblxudmFyIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSA9IGZhbHNlO1xudmFyIGRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQgPSBmYWxzZTtcbnZhciBkaWRXYXJuQ29udHJvbGxlZFRvVW5jb250cm9sbGVkID0gZmFsc2U7XG52YXIgZGlkV2FyblVuY29udHJvbGxlZFRvQ29udHJvbGxlZCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBpc0NvbnRyb2xsZWQocHJvcHMpIHtcbiAgdmFyIHVzZXNDaGVja2VkID0gcHJvcHMudHlwZSA9PT0gJ2NoZWNrYm94JyB8fCBwcm9wcy50eXBlID09PSAncmFkaW8nO1xuICByZXR1cm4gdXNlc0NoZWNrZWQgPyBwcm9wcy5jaGVja2VkICE9IG51bGwgOiBwcm9wcy52YWx1ZSAhPSBudWxsO1xufVxuXG4vKipcbiAqIEltcGxlbWVudHMgYW4gPGlucHV0PiBob3N0IGNvbXBvbmVudCB0aGF0IGFsbG93cyBzZXR0aW5nIHRoZXNlIG9wdGlvbmFsXG4gKiBwcm9wczogYGNoZWNrZWRgLCBgdmFsdWVgLCBgZGVmYXVsdENoZWNrZWRgLCBhbmQgYGRlZmF1bHRWYWx1ZWAuXG4gKlxuICogSWYgYGNoZWNrZWRgIG9yIGB2YWx1ZWAgYXJlIG5vdCBzdXBwbGllZCAob3IgbnVsbC91bmRlZmluZWQpLCB1c2VyIGFjdGlvbnNcbiAqIHRoYXQgYWZmZWN0IHRoZSBjaGVja2VkIHN0YXRlIG9yIHZhbHVlIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LlxuICpcbiAqIElmIHRoZXkgYXJlIHN1cHBsaWVkIChhbmQgbm90IG51bGwvdW5kZWZpbmVkKSwgdGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbCBub3RcbiAqIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC4gSW5zdGVhZCwgdGhlIHByb3BzIG11c3QgY2hhbmdlIGluIG9yZGVyIGZvclxuICogdGhlIHJlbmRlcmVkIGVsZW1lbnQgdG8gYmUgdXBkYXRlZC5cbiAqXG4gKiBUaGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsIGJlIGluaXRpYWxpemVkIGFzIHVuY2hlY2tlZCAob3IgYGRlZmF1bHRDaGVja2VkYClcbiAqIHdpdGggYW4gZW1wdHkgdmFsdWUgKG9yIGBkZWZhdWx0VmFsdWVgKS5cbiAqXG4gKiBTZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMi9XRC1odG1sNS0yMDEyMTAyNS90aGUtaW5wdXQtZWxlbWVudC5odG1sXG4gKi9cblxuZnVuY3Rpb24gZ2V0SG9zdFByb3BzKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG4gIHZhciBjaGVja2VkID0gcHJvcHMuY2hlY2tlZDtcblxuICB2YXIgaG9zdFByb3BzID0gX2Fzc2lnbih7XG4gICAgLy8gTWFrZSBzdXJlIHdlIHNldCAudHlwZSBiZWZvcmUgYW55IG90aGVyIHByb3BlcnRpZXMgKHNldHRpbmcgLnZhbHVlXG4gICAgLy8gYmVmb3JlIC50eXBlIG1lYW5zIC52YWx1ZSBpcyBsb3N0IGluIElFMTEgYW5kIGJlbG93KVxuICAgIHR5cGU6IHVuZGVmaW5lZCxcbiAgICAvLyBNYWtlIHN1cmUgd2Ugc2V0IC5zdGVwIGJlZm9yZSAudmFsdWUgKHNldHRpbmcgLnZhbHVlIGJlZm9yZSAuc3RlcFxuICAgIC8vIG1lYW5zIC52YWx1ZSBpcyByb3VuZGVkIG9uIG1vdW50LCBiYXNlZCB1cG9uIHN0ZXAgcHJlY2lzaW9uKVxuICAgIHN0ZXA6IHVuZGVmaW5lZCxcbiAgICAvLyBNYWtlIHN1cmUgd2Ugc2V0IC5taW4gJiAubWF4IGJlZm9yZSAudmFsdWUgKHRvIGVuc3VyZSBwcm9wZXIgb3JkZXJcbiAgICAvLyBpbiBjb3JuZXIgY2FzZXMgc3VjaCBhcyBtaW4gb3IgbWF4IGRlcml2aW5nIGZyb20gdmFsdWUsIGUuZy4gSXNzdWUgIzcxNzApXG4gICAgbWluOiB1bmRlZmluZWQsXG4gICAgbWF4OiB1bmRlZmluZWRcbiAgfSwgcHJvcHMsIHtcbiAgICBkZWZhdWx0Q2hlY2tlZDogdW5kZWZpbmVkLFxuICAgIGRlZmF1bHRWYWx1ZTogdW5kZWZpbmVkLFxuICAgIHZhbHVlOiB2YWx1ZSAhPSBudWxsID8gdmFsdWUgOiBub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlLFxuICAgIGNoZWNrZWQ6IGNoZWNrZWQgIT0gbnVsbCA/IGNoZWNrZWQgOiBub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbENoZWNrZWRcbiAgfSk7XG5cbiAgcmV0dXJuIGhvc3RQcm9wcztcbn1cblxuZnVuY3Rpb24gaW5pdFdyYXBwZXJTdGF0ZShlbGVtZW50LCBwcm9wcykge1xuICB7XG4gICAgUmVhY3RDb250cm9sbGVkVmFsdWVQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMoJ2lucHV0JywgcHJvcHMsIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMyk7XG5cbiAgICBpZiAocHJvcHMuY2hlY2tlZCAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRDaGVja2VkICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICclcyBjb250YWlucyBhbiBpbnB1dCBvZiB0eXBlICVzIHdpdGggYm90aCBjaGVja2VkIGFuZCBkZWZhdWx0Q2hlY2tlZCBwcm9wcy4gJyArICdJbnB1dCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgY2hlY2tlZCBwcm9wLCBvciB0aGUgZGVmYXVsdENoZWNrZWQgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcgKyAnZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJywgZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lJDIoKSB8fCAnQSBjb21wb25lbnQnLCBwcm9wcy50eXBlKTtcbiAgICAgIGRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAocHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnJXMgY29udGFpbnMgYW4gaW5wdXQgb2YgdHlwZSAlcyB3aXRoIGJvdGggdmFsdWUgYW5kIGRlZmF1bHRWYWx1ZSBwcm9wcy4gJyArICdJbnB1dCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgdmFsdWUgcHJvcCwgb3IgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJyArICdlbGVtZW50IGFuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHMnLCBnZXRDdXJyZW50RmliZXJPd25lck5hbWUkMigpIHx8ICdBIGNvbXBvbmVudCcsIHByb3BzLnR5cGUpO1xuICAgICAgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB2YXIgZGVmYXVsdFZhbHVlID0gcHJvcHMuZGVmYXVsdFZhbHVlO1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIG5vZGUuX3dyYXBwZXJTdGF0ZSA9IHtcbiAgICBpbml0aWFsQ2hlY2tlZDogcHJvcHMuY2hlY2tlZCAhPSBudWxsID8gcHJvcHMuY2hlY2tlZCA6IHByb3BzLmRlZmF1bHRDaGVja2VkLFxuICAgIGluaXRpYWxWYWx1ZTogcHJvcHMudmFsdWUgIT0gbnVsbCA/IHByb3BzLnZhbHVlIDogZGVmYXVsdFZhbHVlLFxuICAgIGNvbnRyb2xsZWQ6IGlzQ29udHJvbGxlZChwcm9wcylcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ2hlY2tlZChlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHZhciBjaGVja2VkID0gcHJvcHMuY2hlY2tlZDtcbiAgaWYgKGNoZWNrZWQgIT0gbnVsbCkge1xuICAgIHNldFZhbHVlRm9yUHJvcGVydHkobm9kZSwgJ2NoZWNrZWQnLCBjaGVja2VkKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVXcmFwcGVyKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAge1xuICAgIHZhciBjb250cm9sbGVkID0gaXNDb250cm9sbGVkKHByb3BzKTtcblxuICAgIGlmICghbm9kZS5fd3JhcHBlclN0YXRlLmNvbnRyb2xsZWQgJiYgY29udHJvbGxlZCAmJiAhZGlkV2FyblVuY29udHJvbGxlZFRvQ29udHJvbGxlZCkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ0EgY29tcG9uZW50IGlzIGNoYW5naW5nIGFuIHVuY29udHJvbGxlZCBpbnB1dCBvZiB0eXBlICVzIHRvIGJlIGNvbnRyb2xsZWQuICcgKyAnSW5wdXQgZWxlbWVudHMgc2hvdWxkIG5vdCBzd2l0Y2ggZnJvbSB1bmNvbnRyb2xsZWQgdG8gY29udHJvbGxlZCAob3IgdmljZSB2ZXJzYSkuICcgKyAnRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgZm9yIHRoZSBsaWZldGltZSBvZiB0aGUgY29tcG9uZW50LiBNb3JlIGluZm86IGh0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJXMnLCBwcm9wcy50eXBlLCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDMoKSk7XG4gICAgICBkaWRXYXJuVW5jb250cm9sbGVkVG9Db250cm9sbGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG5vZGUuX3dyYXBwZXJTdGF0ZS5jb250cm9sbGVkICYmICFjb250cm9sbGVkICYmICFkaWRXYXJuQ29udHJvbGxlZFRvVW5jb250cm9sbGVkKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnQSBjb21wb25lbnQgaXMgY2hhbmdpbmcgYSBjb250cm9sbGVkIGlucHV0IG9mIHR5cGUgJXMgdG8gYmUgdW5jb250cm9sbGVkLiAnICsgJ0lucHV0IGVsZW1lbnRzIHNob3VsZCBub3Qgc3dpdGNoIGZyb20gY29udHJvbGxlZCB0byB1bmNvbnRyb2xsZWQgKG9yIHZpY2UgdmVyc2EpLiAnICsgJ0RlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJyArICdlbGVtZW50IGZvciB0aGUgbGlmZXRpbWUgb2YgdGhlIGNvbXBvbmVudC4gTW9yZSBpbmZvOiBodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cyVzJywgcHJvcHMudHlwZSwgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQzKCkpO1xuICAgICAgZGlkV2FybkNvbnRyb2xsZWRUb1VuY29udHJvbGxlZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlQ2hlY2tlZChlbGVtZW50LCBwcm9wcyk7XG5cbiAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgaWYgKHZhbHVlID09PSAwICYmIG5vZGUudmFsdWUgPT09ICcnKSB7XG4gICAgICBub2RlLnZhbHVlID0gJzAnO1xuICAgICAgLy8gTm90ZTogSUU5IHJlcG9ydHMgYSBudW1iZXIgaW5wdXRzIGFzICd0ZXh0Jywgc28gY2hlY2sgcHJvcHMgaW5zdGVhZC5cbiAgICB9IGVsc2UgaWYgKHByb3BzLnR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAvLyBTaW11bGF0ZSBgaW5wdXQudmFsdWVBc051bWJlcmAuIElFOSBkb2VzIG5vdCBzdXBwb3J0IGl0XG4gICAgICB2YXIgdmFsdWVBc051bWJlciA9IHBhcnNlRmxvYXQobm9kZS52YWx1ZSkgfHwgMDtcblxuICAgICAgaWYgKFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICB2YWx1ZSAhPSB2YWx1ZUFzTnVtYmVyIHx8XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgIHZhbHVlID09IHZhbHVlQXNOdW1iZXIgJiYgbm9kZS52YWx1ZSAhPSB2YWx1ZSkge1xuICAgICAgICAvLyBDYXN0IGB2YWx1ZWAgdG8gYSBzdHJpbmcgdG8gZW5zdXJlIHRoZSB2YWx1ZSBpcyBzZXQgY29ycmVjdGx5LiBXaGlsZVxuICAgICAgICAvLyBicm93c2VycyB0eXBpY2FsbHkgZG8gdGhpcyBhcyBuZWNlc3NhcnksIGpzZG9tIGRvZXNuJ3QuXG4gICAgICAgIG5vZGUudmFsdWUgPSAnJyArIHZhbHVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobm9kZS52YWx1ZSAhPT0gJycgKyB2YWx1ZSkge1xuICAgICAgLy8gQ2FzdCBgdmFsdWVgIHRvIGEgc3RyaW5nIHRvIGVuc3VyZSB0aGUgdmFsdWUgaXMgc2V0IGNvcnJlY3RseS4gV2hpbGVcbiAgICAgIC8vIGJyb3dzZXJzIHR5cGljYWxseSBkbyB0aGlzIGFzIG5lY2Vzc2FyeSwganNkb20gZG9lc24ndC5cbiAgICAgIG5vZGUudmFsdWUgPSAnJyArIHZhbHVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAocHJvcHMudmFsdWUgPT0gbnVsbCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT0gbnVsbCkge1xuICAgICAgLy8gSW4gQ2hyb21lLCBhc3NpZ25pbmcgZGVmYXVsdFZhbHVlIHRvIGNlcnRhaW4gaW5wdXQgdHlwZXMgdHJpZ2dlcnMgaW5wdXQgdmFsaWRhdGlvbi5cbiAgICAgIC8vIEZvciBudW1iZXIgaW5wdXRzLCB0aGUgZGlzcGxheSB2YWx1ZSBsb3NlcyB0cmFpbGluZyBkZWNpbWFsIHBvaW50cy4gRm9yIGVtYWlsIGlucHV0cyxcbiAgICAgIC8vIENocm9tZSByYWlzZXMgXCJUaGUgc3BlY2lmaWVkIHZhbHVlIDx4PiBpcyBub3QgYSB2YWxpZCBlbWFpbCBhZGRyZXNzXCIuXG4gICAgICAvL1xuICAgICAgLy8gSGVyZSB3ZSBjaGVjayB0byBzZWUgaWYgdGhlIGRlZmF1bHRWYWx1ZSBoYXMgYWN0dWFsbHkgY2hhbmdlZCwgYXZvaWRpbmcgdGhlc2UgcHJvYmxlbXNcbiAgICAgIC8vIHdoZW4gdGhlIHVzZXIgaXMgaW5wdXR0aW5nIHRleHRcbiAgICAgIC8vXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzcyNTNcbiAgICAgIGlmIChub2RlLmRlZmF1bHRWYWx1ZSAhPT0gJycgKyBwcm9wcy5kZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgbm9kZS5kZWZhdWx0VmFsdWUgPSAnJyArIHByb3BzLmRlZmF1bHRWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb3BzLmNoZWNrZWQgPT0gbnVsbCAmJiBwcm9wcy5kZWZhdWx0Q2hlY2tlZCAhPSBudWxsKSB7XG4gICAgICBub2RlLmRlZmF1bHRDaGVja2VkID0gISFwcm9wcy5kZWZhdWx0Q2hlY2tlZDtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9zdE1vdW50V3JhcHBlcihlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG5cbiAgLy8gRGV0YWNoIHZhbHVlIGZyb20gZGVmYXVsdFZhbHVlLiBXZSB3b24ndCBkbyBhbnl0aGluZyBpZiB3ZSdyZSB3b3JraW5nIG9uXG4gIC8vIHN1Ym1pdCBvciByZXNldCBpbnB1dHMgYXMgdGhvc2UgdmFsdWVzICYgZGVmYXVsdFZhbHVlcyBhcmUgbGlua2VkLiBUaGV5XG4gIC8vIGFyZSBub3QgcmVzZXRhYmxlIG5vZGVzIHNvIHRoaXMgb3BlcmF0aW9uIGRvZXNuJ3QgbWF0dGVyIGFuZCBhY3R1YWxseVxuICAvLyByZW1vdmVzIGJyb3dzZXItZGVmYXVsdCB2YWx1ZXMgKGVnIFwiU3VibWl0IFF1ZXJ5XCIpIHdoZW4gbm8gdmFsdWUgaXNcbiAgLy8gcHJvdmlkZWQuXG5cbiAgc3dpdGNoIChwcm9wcy50eXBlKSB7XG4gICAgY2FzZSAnc3VibWl0JzpcbiAgICBjYXNlICdyZXNldCc6XG4gICAgICBicmVhaztcbiAgICBjYXNlICdjb2xvcic6XG4gICAgY2FzZSAnZGF0ZSc6XG4gICAgY2FzZSAnZGF0ZXRpbWUnOlxuICAgIGNhc2UgJ2RhdGV0aW1lLWxvY2FsJzpcbiAgICBjYXNlICdtb250aCc6XG4gICAgY2FzZSAndGltZSc6XG4gICAgY2FzZSAnd2Vlayc6XG4gICAgICAvLyBUaGlzIGZpeGVzIHRoZSBuby1zaG93IGlzc3VlIG9uIGlPUyBTYWZhcmkgYW5kIEFuZHJvaWQgQ2hyb21lOlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MjMzXG4gICAgICBub2RlLnZhbHVlID0gJyc7XG4gICAgICBub2RlLnZhbHVlID0gbm9kZS5kZWZhdWx0VmFsdWU7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgbm9kZS52YWx1ZSA9IG5vZGUudmFsdWU7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIC8vIE5vcm1hbGx5LCB3ZSdkIGp1c3QgZG8gYG5vZGUuY2hlY2tlZCA9IG5vZGUuY2hlY2tlZGAgdXBvbiBpbml0aWFsIG1vdW50LCBsZXNzIHRoaXMgYnVnXG4gIC8vIHRoaXMgaXMgbmVlZGVkIHRvIHdvcmsgYXJvdW5kIGEgY2hyb21lIGJ1ZyB3aGVyZSBzZXR0aW5nIGRlZmF1bHRDaGVja2VkXG4gIC8vIHdpbGwgc29tZXRpbWVzIGluZmx1ZW5jZSB0aGUgdmFsdWUgb2YgY2hlY2tlZCAoZXZlbiBhZnRlciBkZXRhY2htZW50KS5cbiAgLy8gUmVmZXJlbmNlOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD02MDg0MTZcbiAgLy8gV2UgbmVlZCB0byB0ZW1wb3JhcmlseSB1bnNldCBuYW1lIHRvIGF2b2lkIGRpc3J1cHRpbmcgcmFkaW8gYnV0dG9uIGdyb3Vwcy5cbiAgdmFyIG5hbWUgPSBub2RlLm5hbWU7XG4gIGlmIChuYW1lICE9PSAnJykge1xuICAgIG5vZGUubmFtZSA9ICcnO1xuICB9XG4gIG5vZGUuZGVmYXVsdENoZWNrZWQgPSAhbm9kZS5kZWZhdWx0Q2hlY2tlZDtcbiAgbm9kZS5kZWZhdWx0Q2hlY2tlZCA9ICFub2RlLmRlZmF1bHRDaGVja2VkO1xuICBpZiAobmFtZSAhPT0gJycpIHtcbiAgICBub2RlLm5hbWUgPSBuYW1lO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMShlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHVwZGF0ZVdyYXBwZXIobm9kZSwgcHJvcHMpO1xuICB1cGRhdGVOYW1lZENvdXNpbnMobm9kZSwgcHJvcHMpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVOYW1lZENvdXNpbnMocm9vdE5vZGUsIHByb3BzKSB7XG4gIHZhciBuYW1lID0gcHJvcHMubmFtZTtcbiAgaWYgKHByb3BzLnR5cGUgPT09ICdyYWRpbycgJiYgbmFtZSAhPSBudWxsKSB7XG4gICAgdmFyIHF1ZXJ5Um9vdCA9IHJvb3ROb2RlO1xuXG4gICAgd2hpbGUgKHF1ZXJ5Um9vdC5wYXJlbnROb2RlKSB7XG4gICAgICBxdWVyeVJvb3QgPSBxdWVyeVJvb3QucGFyZW50Tm9kZTtcbiAgICB9XG5cbiAgICAvLyBJZiBgcm9vdE5vZGUuZm9ybWAgd2FzIG5vbi1udWxsLCB0aGVuIHdlIGNvdWxkIHRyeSBgZm9ybS5lbGVtZW50c2AsXG4gICAgLy8gYnV0IHRoYXQgc29tZXRpbWVzIGJlaGF2ZXMgc3RyYW5nZWx5IGluIElFOC4gV2UgY291bGQgYWxzbyB0cnkgdXNpbmdcbiAgICAvLyBgZm9ybS5nZXRFbGVtZW50c0J5TmFtZWAsIGJ1dCB0aGF0IHdpbGwgb25seSByZXR1cm4gZGlyZWN0IGNoaWxkcmVuXG4gICAgLy8gYW5kIHdvbid0IGluY2x1ZGUgaW5wdXRzIHRoYXQgdXNlIHRoZSBIVE1MNSBgZm9ybT1gIGF0dHJpYnV0ZS4gU2luY2VcbiAgICAvLyB0aGUgaW5wdXQgbWlnaHQgbm90IGV2ZW4gYmUgaW4gYSBmb3JtLiBJdCBtaWdodCBub3QgZXZlbiBiZSBpbiB0aGVcbiAgICAvLyBkb2N1bWVudC4gTGV0J3MganVzdCB1c2UgdGhlIGxvY2FsIGBxdWVyeVNlbGVjdG9yQWxsYCB0byBlbnN1cmUgd2UgZG9uJ3RcbiAgICAvLyBtaXNzIGFueXRoaW5nLlxuICAgIHZhciBncm91cCA9IHF1ZXJ5Um9vdC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFtuYW1lPScgKyBKU09OLnN0cmluZ2lmeSgnJyArIG5hbWUpICsgJ11bdHlwZT1cInJhZGlvXCJdJyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3VwLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgb3RoZXJOb2RlID0gZ3JvdXBbaV07XG4gICAgICBpZiAob3RoZXJOb2RlID09PSByb290Tm9kZSB8fCBvdGhlck5vZGUuZm9ybSAhPT0gcm9vdE5vZGUuZm9ybSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBpZiByYWRpbyBidXR0b25zIHJlbmRlcmVkIGJ5IGRpZmZlcmVudCBjb3BpZXMgb2YgUmVhY3RcbiAgICAgIC8vIGFuZCB0aGUgc2FtZSBuYW1lIGFyZSByZW5kZXJlZCBpbnRvIHRoZSBzYW1lIGZvcm0gKHNhbWUgYXMgIzE5MzkpLlxuICAgICAgLy8gVGhhdCdzIHByb2JhYmx5IG9rYXk7IHdlIGRvbid0IHN1cHBvcnQgaXQganVzdCBhcyB3ZSBkb24ndCBzdXBwb3J0XG4gICAgICAvLyBtaXhpbmcgUmVhY3QgcmFkaW8gYnV0dG9ucyB3aXRoIG5vbi1SZWFjdCBvbmVzLlxuICAgICAgdmFyIG90aGVyUHJvcHMgPSBnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlJDEob3RoZXJOb2RlKTtcbiAgICAgICFvdGhlclByb3BzID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RET01JbnB1dDogTWl4aW5nIFJlYWN0IGFuZCBub24tUmVhY3QgcmFkaW8gaW5wdXRzIHdpdGggdGhlIHNhbWUgYG5hbWVgIGlzIG5vdCBzdXBwb3J0ZWQuJykgOiB2b2lkIDA7XG5cbiAgICAgIC8vIFdlIG5lZWQgdXBkYXRlIHRoZSB0cmFja2VkIHZhbHVlIG9uIHRoZSBuYW1lZCBjb3VzaW4gc2luY2UgdGhlIHZhbHVlXG4gICAgICAvLyB3YXMgY2hhbmdlZCBidXQgdGhlIGlucHV0IHNhdyBubyBldmVudCBvciB2YWx1ZSBzZXRcbiAgICAgIHVwZGF0ZVZhbHVlSWZDaGFuZ2VkKG90aGVyTm9kZSk7XG5cbiAgICAgIC8vIElmIHRoaXMgaXMgYSBjb250cm9sbGVkIHJhZGlvIGJ1dHRvbiBncm91cCwgZm9yY2luZyB0aGUgaW5wdXQgdGhhdFxuICAgICAgLy8gd2FzIHByZXZpb3VzbHkgY2hlY2tlZCB0byB1cGRhdGUgd2lsbCBjYXVzZSBpdCB0byBiZSBjb21lIHJlLWNoZWNrZWRcbiAgICAgIC8vIGFzIGFwcHJvcHJpYXRlLlxuICAgICAgdXBkYXRlV3JhcHBlcihvdGhlck5vZGUsIG90aGVyUHJvcHMpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmbGF0dGVuQ2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgdmFyIGNvbnRlbnQgPSAnJztcblxuICAvLyBGbGF0dGVuIGNoaWxkcmVuIGFuZCB3YXJuIGlmIHRoZXkgYXJlbid0IHN0cmluZ3Mgb3IgbnVtYmVycztcbiAgLy8gaW52YWxpZCB0eXBlcyBhcmUgaWdub3JlZC5cbiAgLy8gV2UgY2FuIHNpbGVudGx5IHNraXAgdGhlbSBiZWNhdXNlIGludmFsaWQgRE9NIG5lc3Rpbmcgd2FybmluZ1xuICAvLyBjYXRjaGVzIHRoZXNlIGNhc2VzIGluIEZpYmVyLlxuICBSZWFjdC5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgY2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICBjb250ZW50ICs9IGNoaWxkO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGNvbnRlbnQ7XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyBhbiA8b3B0aW9uPiBob3N0IGNvbXBvbmVudCB0aGF0IHdhcm5zIHdoZW4gYHNlbGVjdGVkYCBpcyBzZXQuXG4gKi9cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wcyhlbGVtZW50LCBwcm9wcykge1xuICAvLyBUT0RPICh5dW5nc3RlcnMpOiBSZW1vdmUgc3VwcG9ydCBmb3IgYHNlbGVjdGVkYCBpbiA8b3B0aW9uPi5cbiAge1xuICAgIHdhcm5pbmcocHJvcHMuc2VsZWN0ZWQgPT0gbnVsbCwgJ1VzZSB0aGUgYGRlZmF1bHRWYWx1ZWAgb3IgYHZhbHVlYCBwcm9wcyBvbiA8c2VsZWN0PiBpbnN0ZWFkIG9mICcgKyAnc2V0dGluZyBgc2VsZWN0ZWRgIG9uIDxvcHRpb24+LicpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBvc3RNb3VudFdyYXBwZXIkMShlbGVtZW50LCBwcm9wcykge1xuICAvLyB2YWx1ZT1cIlwiIHNob3VsZCBtYWtlIGEgdmFsdWUgYXR0cmlidXRlICgjNjIxOSlcbiAgaWYgKHByb3BzLnZhbHVlICE9IG51bGwpIHtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndmFsdWUnLCBwcm9wcy52YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0SG9zdFByb3BzJDEoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIGhvc3RQcm9wcyA9IF9hc3NpZ24oeyBjaGlsZHJlbjogdW5kZWZpbmVkIH0sIHByb3BzKTtcbiAgdmFyIGNvbnRlbnQgPSBmbGF0dGVuQ2hpbGRyZW4ocHJvcHMuY2hpbGRyZW4pO1xuXG4gIGlmIChjb250ZW50KSB7XG4gICAgaG9zdFByb3BzLmNoaWxkcmVuID0gY29udGVudDtcbiAgfVxuXG4gIHJldHVybiBob3N0UHJvcHM7XG59XG5cbi8vIFRPRE86IGRpcmVjdCBpbXBvcnRzIGxpa2Ugc29tZS1wYWNrYWdlL3NyYy8qIGFyZSBiYWQuIEZpeCBtZS5cbnZhciBnZXRDdXJyZW50RmliZXJPd25lck5hbWUkMyA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lO1xudmFyIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kNCA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bTtcblxuXG57XG4gIHZhciBkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUkMSA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHZhciBvd25lck5hbWUgPSBnZXRDdXJyZW50RmliZXJPd25lck5hbWUkMygpO1xuICBpZiAob3duZXJOYW1lKSB7XG4gICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG93bmVyTmFtZSArICdgLic7XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgdmFsdWVQcm9wTmFtZXMgPSBbJ3ZhbHVlJywgJ2RlZmF1bHRWYWx1ZSddO1xuXG4vKipcbiAqIFZhbGlkYXRpb24gZnVuY3Rpb24gZm9yIGB2YWx1ZWAgYW5kIGBkZWZhdWx0VmFsdWVgLlxuICovXG5mdW5jdGlvbiBjaGVja1NlbGVjdFByb3BUeXBlcyhwcm9wcykge1xuICBSZWFjdENvbnRyb2xsZWRWYWx1ZVByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygnc2VsZWN0JywgcHJvcHMsIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kNCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZVByb3BOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwcm9wTmFtZSA9IHZhbHVlUHJvcE5hbWVzW2ldO1xuICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShwcm9wc1twcm9wTmFtZV0pO1xuICAgIGlmIChwcm9wcy5tdWx0aXBsZSAmJiAhaXNBcnJheSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1RoZSBgJXNgIHByb3Agc3VwcGxpZWQgdG8gPHNlbGVjdD4gbXVzdCBiZSBhbiBhcnJheSBpZiAnICsgJ2BtdWx0aXBsZWAgaXMgdHJ1ZS4lcycsIHByb3BOYW1lLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSk7XG4gICAgfSBlbHNlIGlmICghcHJvcHMubXVsdGlwbGUgJiYgaXNBcnJheSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1RoZSBgJXNgIHByb3Agc3VwcGxpZWQgdG8gPHNlbGVjdD4gbXVzdCBiZSBhIHNjYWxhciAnICsgJ3ZhbHVlIGlmIGBtdWx0aXBsZWAgaXMgZmFsc2UuJXMnLCBwcm9wTmFtZSwgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVPcHRpb25zKG5vZGUsIG11bHRpcGxlLCBwcm9wVmFsdWUsIHNldERlZmF1bHRTZWxlY3RlZCkge1xuICB2YXIgb3B0aW9ucyA9IG5vZGUub3B0aW9ucztcblxuICBpZiAobXVsdGlwbGUpIHtcbiAgICB2YXIgc2VsZWN0ZWRWYWx1ZXMgPSBwcm9wVmFsdWU7XG4gICAgdmFyIHNlbGVjdGVkVmFsdWUgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGVjdGVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBQcmVmaXggdG8gYXZvaWQgY2hhb3Mgd2l0aCBzcGVjaWFsIGtleXMuXG4gICAgICBzZWxlY3RlZFZhbHVlWyckJyArIHNlbGVjdGVkVmFsdWVzW2ldXSA9IHRydWU7XG4gICAgfVxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBvcHRpb25zLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIHNlbGVjdGVkID0gc2VsZWN0ZWRWYWx1ZS5oYXNPd25Qcm9wZXJ0eSgnJCcgKyBvcHRpb25zW19pXS52YWx1ZSk7XG4gICAgICBpZiAob3B0aW9uc1tfaV0uc2VsZWN0ZWQgIT09IHNlbGVjdGVkKSB7XG4gICAgICAgIG9wdGlvbnNbX2ldLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICB9XG4gICAgICBpZiAoc2VsZWN0ZWQgJiYgc2V0RGVmYXVsdFNlbGVjdGVkKSB7XG4gICAgICAgIG9wdGlvbnNbX2ldLmRlZmF1bHRTZWxlY3RlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIERvIG5vdCBzZXQgYHNlbGVjdC52YWx1ZWAgYXMgZXhhY3QgYmVoYXZpb3IgaXNuJ3QgY29uc2lzdGVudCBhY3Jvc3MgYWxsXG4gICAgLy8gYnJvd3NlcnMgZm9yIGFsbCBjYXNlcy5cbiAgICB2YXIgX3NlbGVjdGVkVmFsdWUgPSAnJyArIHByb3BWYWx1ZTtcbiAgICB2YXIgZGVmYXVsdFNlbGVjdGVkID0gbnVsbDtcbiAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBvcHRpb25zLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgIGlmIChvcHRpb25zW19pMl0udmFsdWUgPT09IF9zZWxlY3RlZFZhbHVlKSB7XG4gICAgICAgIG9wdGlvbnNbX2kyXS5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIGlmIChzZXREZWZhdWx0U2VsZWN0ZWQpIHtcbiAgICAgICAgICBvcHRpb25zW19pMl0uZGVmYXVsdFNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZGVmYXVsdFNlbGVjdGVkID09PSBudWxsICYmICFvcHRpb25zW19pMl0uZGlzYWJsZWQpIHtcbiAgICAgICAgZGVmYXVsdFNlbGVjdGVkID0gb3B0aW9uc1tfaTJdO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGVmYXVsdFNlbGVjdGVkICE9PSBudWxsKSB7XG4gICAgICBkZWZhdWx0U2VsZWN0ZWQuc2VsZWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEltcGxlbWVudHMgYSA8c2VsZWN0PiBob3N0IGNvbXBvbmVudCB0aGF0IGFsbG93cyBvcHRpb25hbGx5IHNldHRpbmcgdGhlXG4gKiBwcm9wcyBgdmFsdWVgIGFuZCBgZGVmYXVsdFZhbHVlYC4gSWYgYG11bHRpcGxlYCBpcyBmYWxzZSwgdGhlIHByb3AgbXVzdCBiZSBhXG4gKiBzdHJpbmdhYmxlLiBJZiBgbXVsdGlwbGVgIGlzIHRydWUsIHRoZSBwcm9wIG11c3QgYmUgYW4gYXJyYXkgb2Ygc3RyaW5nYWJsZXMuXG4gKlxuICogSWYgYHZhbHVlYCBpcyBub3Qgc3VwcGxpZWQgKG9yIG51bGwvdW5kZWZpbmVkKSwgdXNlciBhY3Rpb25zIHRoYXQgY2hhbmdlIHRoZVxuICogc2VsZWN0ZWQgb3B0aW9uIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSByZW5kZXJlZCBvcHRpb25zLlxuICpcbiAqIElmIGl0IGlzIHN1cHBsaWVkIChhbmQgbm90IG51bGwvdW5kZWZpbmVkKSwgdGhlIHJlbmRlcmVkIG9wdGlvbnMgd2lsbCBub3RcbiAqIHVwZGF0ZSBpbiByZXNwb25zZSB0byB1c2VyIGFjdGlvbnMuIEluc3RlYWQsIHRoZSBgdmFsdWVgIHByb3AgbXVzdCBjaGFuZ2UgaW5cbiAqIG9yZGVyIGZvciB0aGUgcmVuZGVyZWQgb3B0aW9ucyB0byB1cGRhdGUuXG4gKlxuICogSWYgYGRlZmF1bHRWYWx1ZWAgaXMgcHJvdmlkZWQsIGFueSBvcHRpb25zIHdpdGggdGhlIHN1cHBsaWVkIHZhbHVlcyB3aWxsIGJlXG4gKiBzZWxlY3RlZC5cbiAqL1xuXG5mdW5jdGlvbiBnZXRIb3N0UHJvcHMkMihlbGVtZW50LCBwcm9wcykge1xuICByZXR1cm4gX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICB2YWx1ZTogdW5kZWZpbmVkXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBpbml0V3JhcHBlclN0YXRlJDEoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICB7XG4gICAgY2hlY2tTZWxlY3RQcm9wVHlwZXMocHJvcHMpO1xuICB9XG5cbiAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG4gIG5vZGUuX3dyYXBwZXJTdGF0ZSA9IHtcbiAgICBpbml0aWFsVmFsdWU6IHZhbHVlICE9IG51bGwgPyB2YWx1ZSA6IHByb3BzLmRlZmF1bHRWYWx1ZSxcbiAgICB3YXNNdWx0aXBsZTogISFwcm9wcy5tdWx0aXBsZVxuICB9O1xuXG4gIHtcbiAgICBpZiAocHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlJDEpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdTZWxlY3QgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIHNlbGVjdCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cycpO1xuICAgICAgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlJDEgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwb3N0TW91bnRXcmFwcGVyJDIoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICBub2RlLm11bHRpcGxlID0gISFwcm9wcy5tdWx0aXBsZTtcbiAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgdXBkYXRlT3B0aW9ucyhub2RlLCAhIXByb3BzLm11bHRpcGxlLCB2YWx1ZSwgZmFsc2UpO1xuICB9IGVsc2UgaWYgKHByb3BzLmRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgdXBkYXRlT3B0aW9ucyhub2RlLCAhIXByb3BzLm11bHRpcGxlLCBwcm9wcy5kZWZhdWx0VmFsdWUsIHRydWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBvc3RVcGRhdGVXcmFwcGVyKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgLy8gQWZ0ZXIgdGhlIGluaXRpYWwgbW91bnQsIHdlIGNvbnRyb2wgc2VsZWN0ZWQtbmVzcyBtYW51YWxseSBzbyBkb24ndCBwYXNzXG4gIC8vIHRoaXMgdmFsdWUgZG93blxuICBub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlID0gdW5kZWZpbmVkO1xuXG4gIHZhciB3YXNNdWx0aXBsZSA9IG5vZGUuX3dyYXBwZXJTdGF0ZS53YXNNdWx0aXBsZTtcbiAgbm9kZS5fd3JhcHBlclN0YXRlLndhc011bHRpcGxlID0gISFwcm9wcy5tdWx0aXBsZTtcblxuICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICB1cGRhdGVPcHRpb25zKG5vZGUsICEhcHJvcHMubXVsdGlwbGUsIHZhbHVlLCBmYWxzZSk7XG4gIH0gZWxzZSBpZiAod2FzTXVsdGlwbGUgIT09ICEhcHJvcHMubXVsdGlwbGUpIHtcbiAgICAvLyBGb3Igc2ltcGxpY2l0eSwgcmVhcHBseSBgZGVmYXVsdFZhbHVlYCBpZiBgbXVsdGlwbGVgIGlzIHRvZ2dsZWQuXG4gICAgaWYgKHByb3BzLmRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgICB1cGRhdGVPcHRpb25zKG5vZGUsICEhcHJvcHMubXVsdGlwbGUsIHByb3BzLmRlZmF1bHRWYWx1ZSwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJldmVydCB0aGUgc2VsZWN0IGJhY2sgdG8gaXRzIGRlZmF1bHQgdW5zZWxlY3RlZCBzdGF0ZS5cbiAgICAgIHVwZGF0ZU9wdGlvbnMobm9kZSwgISFwcm9wcy5tdWx0aXBsZSwgcHJvcHMubXVsdGlwbGUgPyBbXSA6ICcnLCBmYWxzZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMihlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHZhciB2YWx1ZSA9IHByb3BzLnZhbHVlO1xuXG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgdXBkYXRlT3B0aW9ucyhub2RlLCAhIXByb3BzLm11bHRpcGxlLCB2YWx1ZSwgZmFsc2UpO1xuICB9XG59XG5cbi8vIFRPRE86IGRpcmVjdCBpbXBvcnRzIGxpa2Ugc29tZS1wYWNrYWdlL3NyYy8qIGFyZSBiYWQuIEZpeCBtZS5cbnZhciBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDUgPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW07XG5cbnZhciBkaWRXYXJuVmFsRGVmYXVsdFZhbCA9IGZhbHNlO1xuXG4vKipcbiAqIEltcGxlbWVudHMgYSA8dGV4dGFyZWE+IGhvc3QgY29tcG9uZW50IHRoYXQgYWxsb3dzIHNldHRpbmcgYHZhbHVlYCwgYW5kXG4gKiBgZGVmYXVsdFZhbHVlYC4gVGhpcyBkaWZmZXJzIGZyb20gdGhlIHRyYWRpdGlvbmFsIERPTSBBUEkgYmVjYXVzZSB2YWx1ZSBpc1xuICogdXN1YWxseSBzZXQgYXMgUENEQVRBIGNoaWxkcmVuLlxuICpcbiAqIElmIGB2YWx1ZWAgaXMgbm90IHN1cHBsaWVkIChvciBudWxsL3VuZGVmaW5lZCksIHVzZXIgYWN0aW9ucyB0aGF0IGFmZmVjdCB0aGVcbiAqIHZhbHVlIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LlxuICpcbiAqIElmIGB2YWx1ZWAgaXMgc3VwcGxpZWQgKGFuZCBub3QgbnVsbC91bmRlZmluZWQpLCB0aGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsXG4gKiBub3QgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LiBJbnN0ZWFkLCB0aGUgYHZhbHVlYCBwcm9wIG11c3QgY2hhbmdlIGluXG4gKiBvcmRlciBmb3IgdGhlIHJlbmRlcmVkIGVsZW1lbnQgdG8gYmUgdXBkYXRlZC5cbiAqXG4gKiBUaGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsIGJlIGluaXRpYWxpemVkIHdpdGggYW4gZW1wdHkgdmFsdWUsIHRoZSBwcm9wXG4gKiBgZGVmYXVsdFZhbHVlYCBpZiBzcGVjaWZpZWQsIG9yIHRoZSBjaGlsZHJlbiBjb250ZW50IChkZXByZWNhdGVkKS5cbiAqL1xuXG5mdW5jdGlvbiBnZXRIb3N0UHJvcHMkMyhlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gICEocHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIGRvZXMgbm90IG1ha2Ugc2Vuc2Ugb24gPHRleHRhcmVhPi4nKSA6IHZvaWQgMDtcblxuICAvLyBBbHdheXMgc2V0IGNoaWxkcmVuIHRvIHRoZSBzYW1lIHRoaW5nLiBJbiBJRTksIHRoZSBzZWxlY3Rpb24gcmFuZ2Ugd2lsbFxuICAvLyBnZXQgcmVzZXQgaWYgYHRleHRDb250ZW50YCBpcyBtdXRhdGVkLiAgV2UgY291bGQgYWRkIGEgY2hlY2sgaW4gc2V0VGV4dENvbnRlbnRcbiAgLy8gdG8gb25seSBzZXQgdGhlIHZhbHVlIGlmL3doZW4gdGhlIHZhbHVlIGRpZmZlcnMgZnJvbSB0aGUgbm9kZSB2YWx1ZSAod2hpY2ggd291bGRcbiAgLy8gY29tcGxldGVseSBzb2x2ZSB0aGlzIElFOSBidWcpLCBidXQgU2ViYXN0aWFuK1NvcGhpZSBzZWVtZWQgdG8gbGlrZSB0aGlzXG4gIC8vIHNvbHV0aW9uLiBUaGUgdmFsdWUgY2FuIGJlIGEgYm9vbGVhbiBvciBvYmplY3Qgc28gdGhhdCdzIHdoeSBpdCdzIGZvcmNlZFxuICAvLyB0byBiZSBhIHN0cmluZy5cbiAgdmFyIGhvc3RQcm9wcyA9IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICBkZWZhdWx0VmFsdWU6IHVuZGVmaW5lZCxcbiAgICBjaGlsZHJlbjogJycgKyBub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlXG4gIH0pO1xuXG4gIHJldHVybiBob3N0UHJvcHM7XG59XG5cbmZ1bmN0aW9uIGluaXRXcmFwcGVyU3RhdGUkMihlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHtcbiAgICBSZWFjdENvbnRyb2xsZWRWYWx1ZVByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygndGV4dGFyZWEnLCBwcm9wcywgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQ1KTtcbiAgICBpZiAocHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblZhbERlZmF1bHRWYWwpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdUZXh0YXJlYSBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgdmFsdWUgcHJvcCwgb3IgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgdGV4dGFyZWEgJyArICdhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJyk7XG4gICAgICBkaWRXYXJuVmFsRGVmYXVsdFZhbCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGluaXRpYWxWYWx1ZSA9IHByb3BzLnZhbHVlO1xuXG4gIC8vIE9ubHkgYm90aGVyIGZldGNoaW5nIGRlZmF1bHQgdmFsdWUgaWYgd2UncmUgZ29pbmcgdG8gdXNlIGl0XG4gIGlmIChpbml0aWFsVmFsdWUgPT0gbnVsbCkge1xuICAgIHZhciBkZWZhdWx0VmFsdWUgPSBwcm9wcy5kZWZhdWx0VmFsdWU7XG4gICAgLy8gVE9ETyAoeXVuZ3N0ZXJzKTogUmVtb3ZlIHN1cHBvcnQgZm9yIGNoaWxkcmVuIGNvbnRlbnQgaW4gPHRleHRhcmVhPi5cbiAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcbiAgICBpZiAoY2hpbGRyZW4gIT0gbnVsbCkge1xuICAgICAge1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnVXNlIHRoZSBgZGVmYXVsdFZhbHVlYCBvciBgdmFsdWVgIHByb3BzIGluc3RlYWQgb2Ygc2V0dGluZyAnICsgJ2NoaWxkcmVuIG9uIDx0ZXh0YXJlYT4uJyk7XG4gICAgICB9XG4gICAgICAhKGRlZmF1bHRWYWx1ZSA9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ0lmIHlvdSBzdXBwbHkgYGRlZmF1bHRWYWx1ZWAgb24gYSA8dGV4dGFyZWE+LCBkbyBub3QgcGFzcyBjaGlsZHJlbi4nKSA6IHZvaWQgMDtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICAhKGNoaWxkcmVuLmxlbmd0aCA8PSAxKSA/IGludmFyaWFudChmYWxzZSwgJzx0ZXh0YXJlYT4gY2FuIG9ubHkgaGF2ZSBhdCBtb3N0IG9uZSBjaGlsZC4nKSA6IHZvaWQgMDtcbiAgICAgICAgY2hpbGRyZW4gPSBjaGlsZHJlblswXTtcbiAgICAgIH1cblxuICAgICAgZGVmYXVsdFZhbHVlID0gJycgKyBjaGlsZHJlbjtcbiAgICB9XG4gICAgaWYgKGRlZmF1bHRWYWx1ZSA9PSBudWxsKSB7XG4gICAgICBkZWZhdWx0VmFsdWUgPSAnJztcbiAgICB9XG4gICAgaW5pdGlhbFZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICB9XG5cbiAgbm9kZS5fd3JhcHBlclN0YXRlID0ge1xuICAgIGluaXRpYWxWYWx1ZTogJycgKyBpbml0aWFsVmFsdWVcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlV3JhcHBlciQxKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgLy8gQ2FzdCBgdmFsdWVgIHRvIGEgc3RyaW5nIHRvIGVuc3VyZSB0aGUgdmFsdWUgaXMgc2V0IGNvcnJlY3RseS4gV2hpbGVcbiAgICAvLyBicm93c2VycyB0eXBpY2FsbHkgZG8gdGhpcyBhcyBuZWNlc3NhcnksIGpzZG9tIGRvZXNuJ3QuXG4gICAgdmFyIG5ld1ZhbHVlID0gJycgKyB2YWx1ZTtcblxuICAgIC8vIFRvIGF2b2lkIHNpZGUgZWZmZWN0cyAoc3VjaCBhcyBsb3NpbmcgdGV4dCBzZWxlY3Rpb24pLCBvbmx5IHNldCB2YWx1ZSBpZiBjaGFuZ2VkXG4gICAgaWYgKG5ld1ZhbHVlICE9PSBub2RlLnZhbHVlKSB7XG4gICAgICBub2RlLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgfVxuICAgIGlmIChwcm9wcy5kZWZhdWx0VmFsdWUgPT0gbnVsbCkge1xuICAgICAgbm9kZS5kZWZhdWx0VmFsdWUgPSBuZXdWYWx1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKHByb3BzLmRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgbm9kZS5kZWZhdWx0VmFsdWUgPSBwcm9wcy5kZWZhdWx0VmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9zdE1vdW50V3JhcHBlciQzKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgLy8gVGhpcyBpcyBpbiBwb3N0TW91bnQgYmVjYXVzZSB3ZSBuZWVkIGFjY2VzcyB0byB0aGUgRE9NIG5vZGUsIHdoaWNoIGlzIG5vdFxuICAvLyBhdmFpbGFibGUgdW50aWwgYWZ0ZXIgdGhlIGNvbXBvbmVudCBoYXMgbW91bnRlZC5cbiAgdmFyIHRleHRDb250ZW50ID0gbm9kZS50ZXh0Q29udGVudDtcblxuICAvLyBPbmx5IHNldCBub2RlLnZhbHVlIGlmIHRleHRDb250ZW50IGlzIGVxdWFsIHRvIHRoZSBleHBlY3RlZFxuICAvLyBpbml0aWFsIHZhbHVlLiBJbiBJRTEwL0lFMTEgdGhlcmUgaXMgYSBidWcgd2hlcmUgdGhlIHBsYWNlaG9sZGVyIGF0dHJpYnV0ZVxuICAvLyB3aWxsIHBvcHVsYXRlIHRleHRDb250ZW50IGFzIHdlbGwuXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1pY3Jvc29mdC5jb20vbWljcm9zb2Z0LWVkZ2UvcGxhdGZvcm0vaXNzdWVzLzEwMTUyNS9cbiAgaWYgKHRleHRDb250ZW50ID09PSBub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlKSB7XG4gICAgbm9kZS52YWx1ZSA9IHRleHRDb250ZW50O1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMyhlbGVtZW50LCBwcm9wcykge1xuICAvLyBET00gY29tcG9uZW50IGlzIHN0aWxsIG1vdW50ZWQ7IHVwZGF0ZVxuICB1cGRhdGVXcmFwcGVyJDEoZWxlbWVudCwgcHJvcHMpO1xufVxuXG52YXIgSFRNTF9OQU1FU1BBQ0UkMSA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJztcbnZhciBNQVRIX05BTUVTUEFDRSA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJztcbnZhciBTVkdfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcblxudmFyIE5hbWVzcGFjZXMgPSB7XG4gIGh0bWw6IEhUTUxfTkFNRVNQQUNFJDEsXG4gIG1hdGhtbDogTUFUSF9OQU1FU1BBQ0UsXG4gIHN2ZzogU1ZHX05BTUVTUEFDRVxufTtcblxuLy8gQXNzdW1lcyB0aGVyZSBpcyBubyBwYXJlbnQgbmFtZXNwYWNlLlxuZnVuY3Rpb24gZ2V0SW50cmluc2ljTmFtZXNwYWNlKHR5cGUpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnc3ZnJzpcbiAgICAgIHJldHVybiBTVkdfTkFNRVNQQUNFO1xuICAgIGNhc2UgJ21hdGgnOlxuICAgICAgcmV0dXJuIE1BVEhfTkFNRVNQQUNFO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gSFRNTF9OQU1FU1BBQ0UkMTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRDaGlsZE5hbWVzcGFjZShwYXJlbnROYW1lc3BhY2UsIHR5cGUpIHtcbiAgaWYgKHBhcmVudE5hbWVzcGFjZSA9PSBudWxsIHx8IHBhcmVudE5hbWVzcGFjZSA9PT0gSFRNTF9OQU1FU1BBQ0UkMSkge1xuICAgIC8vIE5vIChvciBkZWZhdWx0KSBwYXJlbnQgbmFtZXNwYWNlOiBwb3RlbnRpYWwgZW50cnkgcG9pbnQuXG4gICAgcmV0dXJuIGdldEludHJpbnNpY05hbWVzcGFjZSh0eXBlKTtcbiAgfVxuICBpZiAocGFyZW50TmFtZXNwYWNlID09PSBTVkdfTkFNRVNQQUNFICYmIHR5cGUgPT09ICdmb3JlaWduT2JqZWN0Jykge1xuICAgIC8vIFdlJ3JlIGxlYXZpbmcgU1ZHLlxuICAgIHJldHVybiBIVE1MX05BTUVTUEFDRSQxO1xuICB9XG4gIC8vIEJ5IGRlZmF1bHQsIHBhc3MgbmFtZXNwYWNlIGJlbG93LlxuICByZXR1cm4gcGFyZW50TmFtZXNwYWNlO1xufVxuXG4vKiBnbG9iYWxzIE1TQXBwICovXG5cbi8qKlxuICogQ3JlYXRlIGEgZnVuY3Rpb24gd2hpY2ggaGFzICd1bnNhZmUnIHByaXZpbGVnZXMgKHJlcXVpcmVkIGJ5IHdpbmRvd3M4IGFwcHMpXG4gKi9cbnZhciBjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgaWYgKHR5cGVvZiBNU0FwcCAhPT0gJ3VuZGVmaW5lZCcgJiYgTVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAgIE1TQXBwLmV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmdW5jO1xuICB9XG59O1xuXG4vLyBTVkcgdGVtcCBjb250YWluZXIgZm9yIElFIGxhY2tpbmcgaW5uZXJIVE1MXG52YXIgcmV1c2FibGVTVkdDb250YWluZXIgPSB2b2lkIDA7XG5cbi8qKlxuICogU2V0IHRoZSBpbm5lckhUTUwgcHJvcGVydHkgb2YgYSBub2RlXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuICogQGludGVybmFsXG4gKi9cbnZhciBzZXRJbm5lckhUTUwgPSBjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uKGZ1bmN0aW9uIChub2RlLCBodG1sKSB7XG4gIC8vIElFIGRvZXMgbm90IGhhdmUgaW5uZXJIVE1MIGZvciBTVkcgbm9kZXMsIHNvIGluc3RlYWQgd2UgaW5qZWN0IHRoZVxuICAvLyBuZXcgbWFya3VwIGluIGEgdGVtcCBub2RlIGFuZCB0aGVuIG1vdmUgdGhlIGNoaWxkIG5vZGVzIGFjcm9zcyBpbnRvXG4gIC8vIHRoZSB0YXJnZXQgbm9kZVxuXG4gIGlmIChub2RlLm5hbWVzcGFjZVVSSSA9PT0gTmFtZXNwYWNlcy5zdmcgJiYgISgnaW5uZXJIVE1MJyBpbiBub2RlKSkge1xuICAgIHJldXNhYmxlU1ZHQ29udGFpbmVyID0gcmV1c2FibGVTVkdDb250YWluZXIgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgcmV1c2FibGVTVkdDb250YWluZXIuaW5uZXJIVE1MID0gJzxzdmc+JyArIGh0bWwgKyAnPC9zdmc+JztcbiAgICB2YXIgc3ZnTm9kZSA9IHJldXNhYmxlU1ZHQ29udGFpbmVyLmZpcnN0Q2hpbGQ7XG4gICAgd2hpbGUgKG5vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgbm9kZS5yZW1vdmVDaGlsZChub2RlLmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgICB3aGlsZSAoc3ZnTm9kZS5maXJzdENoaWxkKSB7XG4gICAgICBub2RlLmFwcGVuZENoaWxkKHN2Z05vZGUuZmlyc3RDaGlsZCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG5vZGUuaW5uZXJIVE1MID0gaHRtbDtcbiAgfVxufSk7XG5cbi8qKlxuICogU2V0IHRoZSB0ZXh0Q29udGVudCBwcm9wZXJ0eSBvZiBhIG5vZGUsIGVuc3VyaW5nIHRoYXQgd2hpdGVzcGFjZSBpcyBwcmVzZXJ2ZWRcbiAqIGV2ZW4gaW4gSUU4LiBpbm5lclRleHQgaXMgYSBwb29yIHN1YnN0aXR1dGUgZm9yIHRleHRDb250ZW50IGFuZCwgYW1vbmcgbWFueVxuICogaXNzdWVzLCBpbnNlcnRzIDxicj4gaW5zdGVhZCBvZiB0aGUgbGl0ZXJhbCBuZXdsaW5lIGNoYXJzLiBpbm5lckhUTUwgYmVoYXZlc1xuICogYXMgaXQgc2hvdWxkLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgc2V0VGV4dENvbnRlbnQgPSBmdW5jdGlvbiAobm9kZSwgdGV4dCkge1xuICBpZiAodGV4dCkge1xuICAgIHZhciBmaXJzdENoaWxkID0gbm9kZS5maXJzdENoaWxkO1xuXG4gICAgaWYgKGZpcnN0Q2hpbGQgJiYgZmlyc3RDaGlsZCA9PT0gbm9kZS5sYXN0Q2hpbGQgJiYgZmlyc3RDaGlsZC5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFKSB7XG4gICAgICBmaXJzdENoaWxkLm5vZGVWYWx1ZSA9IHRleHQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIG5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xufTtcblxuLyoqXG4gKiBDU1MgcHJvcGVydGllcyB3aGljaCBhY2NlcHQgbnVtYmVycyBidXQgYXJlIG5vdCBpbiB1bml0cyBvZiBcInB4XCIuXG4gKi9cbnZhciBpc1VuaXRsZXNzTnVtYmVyID0ge1xuICBhbmltYXRpb25JdGVyYXRpb25Db3VudDogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VPdXRzZXQ6IHRydWUsXG4gIGJvcmRlckltYWdlU2xpY2U6IHRydWUsXG4gIGJvcmRlckltYWdlV2lkdGg6IHRydWUsXG4gIGJveEZsZXg6IHRydWUsXG4gIGJveEZsZXhHcm91cDogdHJ1ZSxcbiAgYm94T3JkaW5hbEdyb3VwOiB0cnVlLFxuICBjb2x1bW5Db3VudDogdHJ1ZSxcbiAgY29sdW1uczogdHJ1ZSxcbiAgZmxleDogdHJ1ZSxcbiAgZmxleEdyb3c6IHRydWUsXG4gIGZsZXhQb3NpdGl2ZTogdHJ1ZSxcbiAgZmxleFNocmluazogdHJ1ZSxcbiAgZmxleE5lZ2F0aXZlOiB0cnVlLFxuICBmbGV4T3JkZXI6IHRydWUsXG4gIGdyaWRSb3c6IHRydWUsXG4gIGdyaWRSb3dFbmQ6IHRydWUsXG4gIGdyaWRSb3dTcGFuOiB0cnVlLFxuICBncmlkUm93U3RhcnQ6IHRydWUsXG4gIGdyaWRDb2x1bW46IHRydWUsXG4gIGdyaWRDb2x1bW5FbmQ6IHRydWUsXG4gIGdyaWRDb2x1bW5TcGFuOiB0cnVlLFxuICBncmlkQ29sdW1uU3RhcnQ6IHRydWUsXG4gIGZvbnRXZWlnaHQ6IHRydWUsXG4gIGxpbmVDbGFtcDogdHJ1ZSxcbiAgbGluZUhlaWdodDogdHJ1ZSxcbiAgb3BhY2l0eTogdHJ1ZSxcbiAgb3JkZXI6IHRydWUsXG4gIG9ycGhhbnM6IHRydWUsXG4gIHRhYlNpemU6IHRydWUsXG4gIHdpZG93czogdHJ1ZSxcbiAgekluZGV4OiB0cnVlLFxuICB6b29tOiB0cnVlLFxuXG4gIC8vIFNWRy1yZWxhdGVkIHByb3BlcnRpZXNcbiAgZmlsbE9wYWNpdHk6IHRydWUsXG4gIGZsb29kT3BhY2l0eTogdHJ1ZSxcbiAgc3RvcE9wYWNpdHk6IHRydWUsXG4gIHN0cm9rZURhc2hhcnJheTogdHJ1ZSxcbiAgc3Ryb2tlRGFzaG9mZnNldDogdHJ1ZSxcbiAgc3Ryb2tlTWl0ZXJsaW1pdDogdHJ1ZSxcbiAgc3Ryb2tlT3BhY2l0eTogdHJ1ZSxcbiAgc3Ryb2tlV2lkdGg6IHRydWVcbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHByZWZpeCB2ZW5kb3Itc3BlY2lmaWMgcHJlZml4LCBlZzogV2Via2l0XG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHN0eWxlIG5hbWUsIGVnOiB0cmFuc2l0aW9uRHVyYXRpb25cbiAqIEByZXR1cm4ge3N0cmluZ30gc3R5bGUgbmFtZSBwcmVmaXhlZCB3aXRoIGBwcmVmaXhgLCBwcm9wZXJseSBjYW1lbENhc2VkLCBlZzpcbiAqIFdlYmtpdFRyYW5zaXRpb25EdXJhdGlvblxuICovXG5mdW5jdGlvbiBwcmVmaXhLZXkocHJlZml4LCBrZXkpIHtcbiAgcmV0dXJuIHByZWZpeCArIGtleS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGtleS5zdWJzdHJpbmcoMSk7XG59XG5cbi8qKlxuICogU3VwcG9ydCBzdHlsZSBuYW1lcyB0aGF0IG1heSBjb21lIHBhc3NlZCBpbiBwcmVmaXhlZCBieSBhZGRpbmcgcGVybXV0YXRpb25zXG4gKiBvZiB2ZW5kb3IgcHJlZml4ZXMuXG4gKi9cbnZhciBwcmVmaXhlcyA9IFsnV2Via2l0JywgJ21zJywgJ01veicsICdPJ107XG5cbi8vIFVzaW5nIE9iamVjdC5rZXlzIGhlcmUsIG9yIGVsc2UgdGhlIHZhbmlsbGEgZm9yLWluIGxvb3AgbWFrZXMgSUU4IGdvIGludG8gYW5cbi8vIGluZmluaXRlIGxvb3AsIGJlY2F1c2UgaXQgaXRlcmF0ZXMgb3ZlciB0aGUgbmV3bHkgYWRkZWQgcHJvcHMgdG9vLlxuT2JqZWN0LmtleXMoaXNVbml0bGVzc051bWJlcikuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICBwcmVmaXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChwcmVmaXgpIHtcbiAgICBpc1VuaXRsZXNzTnVtYmVyW3ByZWZpeEtleShwcmVmaXgsIHByb3ApXSA9IGlzVW5pdGxlc3NOdW1iZXJbcHJvcF07XG4gIH0pO1xufSk7XG5cbi8qKlxuICogQ29udmVydCBhIHZhbHVlIGludG8gdGhlIHByb3BlciBjc3Mgd3JpdGFibGUgdmFsdWUuIFRoZSBzdHlsZSBuYW1lIGBuYW1lYFxuICogc2hvdWxkIGJlIGxvZ2ljYWwgKG5vIGh5cGhlbnMpLCBhcyBzcGVjaWZpZWRcbiAqIGluIGBDU1NQcm9wZXJ0eS5pc1VuaXRsZXNzTnVtYmVyYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBDU1MgcHJvcGVydHkgbmFtZSBzdWNoIGFzIGB0b3BNYXJnaW5gLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBDU1MgcHJvcGVydHkgdmFsdWUgc3VjaCBhcyBgMTBweGAuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IE5vcm1hbGl6ZWQgc3R5bGUgdmFsdWUgd2l0aCBkaW1lbnNpb25zIGFwcGxpZWQuXG4gKi9cbmZ1bmN0aW9uIGRhbmdlcm91c1N0eWxlVmFsdWUobmFtZSwgdmFsdWUsIGlzQ3VzdG9tUHJvcGVydHkpIHtcbiAgLy8gTm90ZSB0aGF0IHdlJ3ZlIHJlbW92ZWQgZXNjYXBlVGV4dEZvckJyb3dzZXIoKSBjYWxscyBoZXJlIHNpbmNlIHRoZVxuICAvLyB3aG9sZSBzdHJpbmcgd2lsbCBiZSBlc2NhcGVkIHdoZW4gdGhlIGF0dHJpYnV0ZSBpcyBpbmplY3RlZCBpbnRvXG4gIC8vIHRoZSBtYXJrdXAuIElmIHlvdSBwcm92aWRlIHVuc2FmZSB1c2VyIGRhdGEgaGVyZSB0aGV5IGNhbiBpbmplY3RcbiAgLy8gYXJiaXRyYXJ5IENTUyB3aGljaCBtYXkgYmUgcHJvYmxlbWF0aWMgKEkgY291bGRuJ3QgcmVwcm8gdGhpcyk6XG4gIC8vIGh0dHBzOi8vd3d3Lm93YXNwLm9yZy9pbmRleC5waHAvWFNTX0ZpbHRlcl9FdmFzaW9uX0NoZWF0X1NoZWV0XG4gIC8vIGh0dHA6Ly93d3cudGhlc3Bhbm5lci5jby51ay8yMDA3LzExLzI2L3VsdGltYXRlLXhzcy1jc3MtaW5qZWN0aW9uL1xuICAvLyBUaGlzIGlzIG5vdCBhbiBYU1MgaG9sZSBidXQgaW5zdGVhZCBhIHBvdGVudGlhbCBDU1MgaW5qZWN0aW9uIGlzc3VlXG4gIC8vIHdoaWNoIGhhcyBsZWFkIHRvIGEgZ3JlYXRlciBkaXNjdXNzaW9uIGFib3V0IGhvdyB3ZSdyZSBnb2luZyB0b1xuICAvLyB0cnVzdCBVUkxzIG1vdmluZyBmb3J3YXJkLiBTZWUgIzIxMTU5MDFcblxuICB2YXIgaXNFbXB0eSA9IHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgfHwgdmFsdWUgPT09ICcnO1xuICBpZiAoaXNFbXB0eSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmICghaXNDdXN0b21Qcm9wZXJ0eSAmJiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIHZhbHVlICE9PSAwICYmICEoaXNVbml0bGVzc051bWJlci5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiBpc1VuaXRsZXNzTnVtYmVyW25hbWVdKSkge1xuICAgIHJldHVybiB2YWx1ZSArICdweCc7IC8vIFByZXN1bWVzIGltcGxpY2l0ICdweCcgc3VmZml4IGZvciB1bml0bGVzcyBudW1iZXJzXG4gIH1cblxuICByZXR1cm4gKCcnICsgdmFsdWUpLnRyaW0oKTtcbn1cblxudmFyIHdhcm5WYWxpZFN0eWxlID0gZW1wdHlGdW5jdGlvbjtcblxue1xuICAvLyAnbXNUcmFuc2Zvcm0nIGlzIGNvcnJlY3QsIGJ1dCB0aGUgb3RoZXIgcHJlZml4ZXMgc2hvdWxkIGJlIGNhcGl0YWxpemVkXG4gIHZhciBiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4gPSAvXig/OndlYmtpdHxtb3p8bylbQS1aXS87XG5cbiAgLy8gc3R5bGUgdmFsdWVzIHNob3VsZG4ndCBjb250YWluIGEgc2VtaWNvbG9uXG4gIHZhciBiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4gPSAvO1xccyokLztcblxuICB2YXIgd2FybmVkU3R5bGVOYW1lcyA9IHt9O1xuICB2YXIgd2FybmVkU3R5bGVWYWx1ZXMgPSB7fTtcbiAgdmFyIHdhcm5lZEZvck5hTlZhbHVlID0gZmFsc2U7XG4gIHZhciB3YXJuZWRGb3JJbmZpbml0eVZhbHVlID0gZmFsc2U7XG5cbiAgdmFyIHdhcm5IeXBoZW5hdGVkU3R5bGVOYW1lID0gZnVuY3Rpb24gKG5hbWUsIGdldFN0YWNrKSB7XG4gICAgaWYgKHdhcm5lZFN0eWxlTmFtZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0gPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsICdVbnN1cHBvcnRlZCBzdHlsZSBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuICVzPyVzJywgbmFtZSwgY2FtZWxpemVTdHlsZU5hbWUobmFtZSksIGdldFN0YWNrKCkpO1xuICB9O1xuXG4gIHZhciB3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWUgPSBmdW5jdGlvbiAobmFtZSwgZ2V0U3RhY2spIHtcbiAgICBpZiAod2FybmVkU3R5bGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRTdHlsZU5hbWVzW25hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ1Vuc3VwcG9ydGVkIHZlbmRvci1wcmVmaXhlZCBzdHlsZSBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuICVzPyVzJywgbmFtZSwgbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSksIGdldFN0YWNrKCkpO1xuICB9O1xuXG4gIHZhciB3YXJuU3R5bGVWYWx1ZVdpdGhTZW1pY29sb24gPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIGdldFN0YWNrKSB7XG4gICAgaWYgKHdhcm5lZFN0eWxlVmFsdWVzLmhhc093blByb3BlcnR5KHZhbHVlKSAmJiB3YXJuZWRTdHlsZVZhbHVlc1t2YWx1ZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZVZhbHVlc1t2YWx1ZV0gPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsIFwiU3R5bGUgcHJvcGVydHkgdmFsdWVzIHNob3VsZG4ndCBjb250YWluIGEgc2VtaWNvbG9uLiBcIiArICdUcnkgXCIlczogJXNcIiBpbnN0ZWFkLiVzJywgbmFtZSwgdmFsdWUucmVwbGFjZShiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4sICcnKSwgZ2V0U3RhY2soKSk7XG4gIH07XG5cbiAgdmFyIHdhcm5TdHlsZVZhbHVlSXNOYU4gPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIGdldFN0YWNrKSB7XG4gICAgaWYgKHdhcm5lZEZvck5hTlZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkRm9yTmFOVmFsdWUgPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsICdgTmFOYCBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvciB0aGUgYCVzYCBjc3Mgc3R5bGUgcHJvcGVydHkuJXMnLCBuYW1lLCBnZXRTdGFjaygpKTtcbiAgfTtcblxuICB2YXIgd2FyblN0eWxlVmFsdWVJc0luZmluaXR5ID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBnZXRTdGFjaykge1xuICAgIGlmICh3YXJuZWRGb3JJbmZpbml0eVZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkRm9ySW5maW5pdHlWYWx1ZSA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ2BJbmZpbml0eWAgaXMgYW4gaW52YWxpZCB2YWx1ZSBmb3IgdGhlIGAlc2AgY3NzIHN0eWxlIHByb3BlcnR5LiVzJywgbmFtZSwgZ2V0U3RhY2soKSk7XG4gIH07XG5cbiAgd2FyblZhbGlkU3R5bGUgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIGdldFN0YWNrKSB7XG4gICAgaWYgKG5hbWUuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgIHdhcm5IeXBoZW5hdGVkU3R5bGVOYW1lKG5hbWUsIGdldFN0YWNrKTtcbiAgICB9IGVsc2UgaWYgKGJhZFZlbmRvcmVkU3R5bGVOYW1lUGF0dGVybi50ZXN0KG5hbWUpKSB7XG4gICAgICB3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWUobmFtZSwgZ2V0U3RhY2spO1xuICAgIH0gZWxzZSBpZiAoYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuLnRlc3QodmFsdWUpKSB7XG4gICAgICB3YXJuU3R5bGVWYWx1ZVdpdGhTZW1pY29sb24obmFtZSwgdmFsdWUsIGdldFN0YWNrKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgICAgICB3YXJuU3R5bGVWYWx1ZUlzTmFOKG5hbWUsIHZhbHVlLCBnZXRTdGFjayk7XG4gICAgICB9IGVsc2UgaWYgKCFpc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICAgICAgd2FyblN0eWxlVmFsdWVJc0luZmluaXR5KG5hbWUsIHZhbHVlLCBnZXRTdGFjayk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG52YXIgd2FyblZhbGlkU3R5bGUkMSA9IHdhcm5WYWxpZFN0eWxlO1xuXG4vKipcbiAqIE9wZXJhdGlvbnMgZm9yIGRlYWxpbmcgd2l0aCBDU1MgcHJvcGVydGllcy5cbiAqL1xuXG4vKipcbiAqIFRoaXMgY3JlYXRlcyBhIHN0cmluZyB0aGF0IGlzIGV4cGVjdGVkIHRvIGJlIGVxdWl2YWxlbnQgdG8gdGhlIHN0eWxlXG4gKiBhdHRyaWJ1dGUgZ2VuZXJhdGVkIGJ5IHNlcnZlci1zaWRlIHJlbmRlcmluZy4gSXQgYnktcGFzc2VzIHdhcm5pbmdzIGFuZFxuICogc2VjdXJpdHkgY2hlY2tzIHNvIGl0J3Mgbm90IHNhZmUgdG8gdXNlIHRoaXMgdmFsdWUgZm9yIGFueXRoaW5nIG90aGVyIHRoYW5cbiAqIGNvbXBhcmlzb24uIEl0IGlzIG9ubHkgdXNlZCBpbiBERVYgZm9yIFNTUiB2YWxpZGF0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVEYW5nZXJvdXNTdHJpbmdGb3JTdHlsZXMoc3R5bGVzKSB7XG4gIHtcbiAgICB2YXIgc2VyaWFsaXplZCA9ICcnO1xuICAgIHZhciBkZWxpbWl0ZXIgPSAnJztcbiAgICBmb3IgKHZhciBzdHlsZU5hbWUgaW4gc3R5bGVzKSB7XG4gICAgICBpZiAoIXN0eWxlcy5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIHN0eWxlVmFsdWUgPSBzdHlsZXNbc3R5bGVOYW1lXTtcbiAgICAgIGlmIChzdHlsZVZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGlzQ3VzdG9tUHJvcGVydHkgPSBzdHlsZU5hbWUuaW5kZXhPZignLS0nKSA9PT0gMDtcbiAgICAgICAgc2VyaWFsaXplZCArPSBkZWxpbWl0ZXIgKyBoeXBoZW5hdGVTdHlsZU5hbWUoc3R5bGVOYW1lKSArICc6JztcbiAgICAgICAgc2VyaWFsaXplZCArPSBkYW5nZXJvdXNTdHlsZVZhbHVlKHN0eWxlTmFtZSwgc3R5bGVWYWx1ZSwgaXNDdXN0b21Qcm9wZXJ0eSk7XG5cbiAgICAgICAgZGVsaW1pdGVyID0gJzsnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VyaWFsaXplZCB8fCBudWxsO1xuICB9XG59XG5cbi8qKlxuICogU2V0cyB0aGUgdmFsdWUgZm9yIG11bHRpcGxlIHN0eWxlcyBvbiBhIG5vZGUuICBJZiBhIHZhbHVlIGlzIHNwZWNpZmllZCBhc1xuICogJycgKGVtcHR5IHN0cmluZyksIHRoZSBjb3JyZXNwb25kaW5nIHN0eWxlIHByb3BlcnR5IHdpbGwgYmUgdW5zZXQuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge29iamVjdH0gc3R5bGVzXG4gKi9cbmZ1bmN0aW9uIHNldFZhbHVlRm9yU3R5bGVzKG5vZGUsIHN0eWxlcywgZ2V0U3RhY2spIHtcbiAgdmFyIHN0eWxlID0gbm9kZS5zdHlsZTtcbiAgZm9yICh2YXIgc3R5bGVOYW1lIGluIHN0eWxlcykge1xuICAgIGlmICghc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgaXNDdXN0b21Qcm9wZXJ0eSA9IHN0eWxlTmFtZS5pbmRleE9mKCctLScpID09PSAwO1xuICAgIHtcbiAgICAgIGlmICghaXNDdXN0b21Qcm9wZXJ0eSkge1xuICAgICAgICB3YXJuVmFsaWRTdHlsZSQxKHN0eWxlTmFtZSwgc3R5bGVzW3N0eWxlTmFtZV0sIGdldFN0YWNrKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHN0eWxlVmFsdWUgPSBkYW5nZXJvdXNTdHlsZVZhbHVlKHN0eWxlTmFtZSwgc3R5bGVzW3N0eWxlTmFtZV0sIGlzQ3VzdG9tUHJvcGVydHkpO1xuICAgIGlmIChzdHlsZU5hbWUgPT09ICdmbG9hdCcpIHtcbiAgICAgIHN0eWxlTmFtZSA9ICdjc3NGbG9hdCc7XG4gICAgfVxuICAgIGlmIChpc0N1c3RvbVByb3BlcnR5KSB7XG4gICAgICBzdHlsZS5zZXRQcm9wZXJ0eShzdHlsZU5hbWUsIHN0eWxlVmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZVtzdHlsZU5hbWVdID0gc3R5bGVWYWx1ZTtcbiAgICB9XG4gIH1cbn1cblxuLy8gRm9yIEhUTUwsIGNlcnRhaW4gdGFncyBzaG91bGQgb21pdCB0aGVpciBjbG9zZSB0YWcuIFdlIGtlZXAgYSB3aGl0ZWxpc3QgZm9yXG4vLyB0aG9zZSBzcGVjaWFsLWNhc2UgdGFncy5cblxudmFyIG9taXR0ZWRDbG9zZVRhZ3MgPSB7XG4gIGFyZWE6IHRydWUsXG4gIGJhc2U6IHRydWUsXG4gIGJyOiB0cnVlLFxuICBjb2w6IHRydWUsXG4gIGVtYmVkOiB0cnVlLFxuICBocjogdHJ1ZSxcbiAgaW1nOiB0cnVlLFxuICBpbnB1dDogdHJ1ZSxcbiAga2V5Z2VuOiB0cnVlLFxuICBsaW5rOiB0cnVlLFxuICBtZXRhOiB0cnVlLFxuICBwYXJhbTogdHJ1ZSxcbiAgc291cmNlOiB0cnVlLFxuICB0cmFjazogdHJ1ZSxcbiAgd2JyOiB0cnVlXG59O1xuXG4vLyBGb3IgSFRNTCwgY2VydGFpbiB0YWdzIGNhbm5vdCBoYXZlIGNoaWxkcmVuLiBUaGlzIGhhcyB0aGUgc2FtZSBwdXJwb3NlIGFzXG4vLyBgb21pdHRlZENsb3NlVGFnc2AgZXhjZXB0IHRoYXQgYG1lbnVpdGVtYCBzaG91bGQgc3RpbGwgaGF2ZSBpdHMgY2xvc2luZyB0YWcuXG5cbnZhciB2b2lkRWxlbWVudFRhZ3MgPSBfYXNzaWduKHtcbiAgbWVudWl0ZW06IHRydWVcbn0sIG9taXR0ZWRDbG9zZVRhZ3MpO1xuXG52YXIgSFRNTCQxID0gJ19faHRtbCc7XG5cbmZ1bmN0aW9uIGFzc2VydFZhbGlkUHJvcHModGFnLCBwcm9wcywgZ2V0U3RhY2spIHtcbiAgaWYgKCFwcm9wcykge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBOb3RlIHRoZSB1c2Ugb2YgYD09YCB3aGljaCBjaGVja3MgZm9yIG51bGwgb3IgdW5kZWZpbmVkLlxuICBpZiAodm9pZEVsZW1lbnRUYWdzW3RhZ10pIHtcbiAgICAhKHByb3BzLmNoaWxkcmVuID09IG51bGwgJiYgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICclcyBpcyBhIHZvaWQgZWxlbWVudCB0YWcgYW5kIG11c3QgbmVpdGhlciBoYXZlIGBjaGlsZHJlbmAgbm9yIHVzZSBgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLiVzJywgdGFnLCBnZXRTdGFjaygpKSA6IHZvaWQgMDtcbiAgfVxuICBpZiAocHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgIT0gbnVsbCkge1xuICAgICEocHJvcHMuY2hpbGRyZW4gPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW4gb25seSBzZXQgb25lIG9mIGBjaGlsZHJlbmAgb3IgYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4nKSA6IHZvaWQgMDtcbiAgICAhKHR5cGVvZiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PT0gJ29iamVjdCcgJiYgSFRNTCQxIGluIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MKSA/IGludmFyaWFudChmYWxzZSwgJ2Bwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAgbXVzdCBiZSBpbiB0aGUgZm9ybSBge19faHRtbDogLi4ufWAuIFBsZWFzZSB2aXNpdCBodHRwczovL2ZiLm1lL3JlYWN0LWludmFyaWFudC1kYW5nZXJvdXNseS1zZXQtaW5uZXItaHRtbCBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nKSA6IHZvaWQgMDtcbiAgfVxuICB7XG4gICAgd2FybmluZyhwcm9wcy5zdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcgfHwgIXByb3BzLmNvbnRlbnRFZGl0YWJsZSB8fCBwcm9wcy5jaGlsZHJlbiA9PSBudWxsLCAnQSBjb21wb25lbnQgaXMgYGNvbnRlbnRFZGl0YWJsZWAgYW5kIGNvbnRhaW5zIGBjaGlsZHJlbmAgbWFuYWdlZCBieSAnICsgJ1JlYWN0LiBJdCBpcyBub3cgeW91ciByZXNwb25zaWJpbGl0eSB0byBndWFyYW50ZWUgdGhhdCBub25lIG9mICcgKyAndGhvc2Ugbm9kZXMgYXJlIHVuZXhwZWN0ZWRseSBtb2RpZmllZCBvciBkdXBsaWNhdGVkLiBUaGlzIGlzICcgKyAncHJvYmFibHkgbm90IGludGVudGlvbmFsLiVzJywgZ2V0U3RhY2soKSk7XG4gIH1cbiAgIShwcm9wcy5zdHlsZSA9PSBudWxsIHx8IHR5cGVvZiBwcm9wcy5zdHlsZSA9PT0gJ29iamVjdCcpID8gaW52YXJpYW50KGZhbHNlLCAnVGhlIGBzdHlsZWAgcHJvcCBleHBlY3RzIGEgbWFwcGluZyBmcm9tIHN0eWxlIHByb3BlcnRpZXMgdG8gdmFsdWVzLCBub3QgYSBzdHJpbmcuIEZvciBleGFtcGxlLCBzdHlsZT17e21hcmdpblJpZ2h0OiBzcGFjaW5nICsgXFwnZW1cXCd9fSB3aGVuIHVzaW5nIEpTWC4lcycsIGdldFN0YWNrKCkpIDogdm9pZCAwO1xufVxuXG5mdW5jdGlvbiBpc0N1c3RvbUNvbXBvbmVudCh0YWdOYW1lLCBwcm9wcykge1xuICBpZiAodGFnTmFtZS5pbmRleE9mKCctJykgPT09IC0xKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBwcm9wcy5pcyA9PT0gJ3N0cmluZyc7XG4gIH1cbiAgc3dpdGNoICh0YWdOYW1lKSB7XG4gICAgLy8gVGhlc2UgYXJlIHJlc2VydmVkIFNWRyBhbmQgTWF0aE1MIGVsZW1lbnRzLlxuICAgIC8vIFdlIGRvbid0IG1pbmQgdGhpcyB3aGl0ZWxpc3QgdG9vIG11Y2ggYmVjYXVzZSB3ZSBleHBlY3QgaXQgdG8gbmV2ZXIgZ3Jvdy5cbiAgICAvLyBUaGUgYWx0ZXJuYXRpdmUgaXMgdG8gdHJhY2sgdGhlIG5hbWVzcGFjZSBpbiBhIGZldyBwbGFjZXMgd2hpY2ggaXMgY29udm9sdXRlZC5cbiAgICAvLyBodHRwczovL3czYy5naXRodWIuaW8vd2ViY29tcG9uZW50cy9zcGVjL2N1c3RvbS8jY3VzdG9tLWVsZW1lbnRzLWNvcmUtY29uY2VwdHNcbiAgICBjYXNlICdhbm5vdGF0aW9uLXhtbCc6XG4gICAgY2FzZSAnY29sb3ItcHJvZmlsZSc6XG4gICAgY2FzZSAnZm9udC1mYWNlJzpcbiAgICBjYXNlICdmb250LWZhY2Utc3JjJzpcbiAgICBjYXNlICdmb250LWZhY2UtdXJpJzpcbiAgICBjYXNlICdmb250LWZhY2UtZm9ybWF0JzpcbiAgICBjYXNlICdmb250LWZhY2UtbmFtZSc6XG4gICAgY2FzZSAnbWlzc2luZy1nbHlwaCc6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbnZhciBhcmlhUHJvcGVydGllcyA9IHtcbiAgJ2FyaWEtY3VycmVudCc6IDAsIC8vIHN0YXRlXG4gICdhcmlhLWRldGFpbHMnOiAwLFxuICAnYXJpYS1kaXNhYmxlZCc6IDAsIC8vIHN0YXRlXG4gICdhcmlhLWhpZGRlbic6IDAsIC8vIHN0YXRlXG4gICdhcmlhLWludmFsaWQnOiAwLCAvLyBzdGF0ZVxuICAnYXJpYS1rZXlzaG9ydGN1dHMnOiAwLFxuICAnYXJpYS1sYWJlbCc6IDAsXG4gICdhcmlhLXJvbGVkZXNjcmlwdGlvbic6IDAsXG4gIC8vIFdpZGdldCBBdHRyaWJ1dGVzXG4gICdhcmlhLWF1dG9jb21wbGV0ZSc6IDAsXG4gICdhcmlhLWNoZWNrZWQnOiAwLFxuICAnYXJpYS1leHBhbmRlZCc6IDAsXG4gICdhcmlhLWhhc3BvcHVwJzogMCxcbiAgJ2FyaWEtbGV2ZWwnOiAwLFxuICAnYXJpYS1tb2RhbCc6IDAsXG4gICdhcmlhLW11bHRpbGluZSc6IDAsXG4gICdhcmlhLW11bHRpc2VsZWN0YWJsZSc6IDAsXG4gICdhcmlhLW9yaWVudGF0aW9uJzogMCxcbiAgJ2FyaWEtcGxhY2Vob2xkZXInOiAwLFxuICAnYXJpYS1wcmVzc2VkJzogMCxcbiAgJ2FyaWEtcmVhZG9ubHknOiAwLFxuICAnYXJpYS1yZXF1aXJlZCc6IDAsXG4gICdhcmlhLXNlbGVjdGVkJzogMCxcbiAgJ2FyaWEtc29ydCc6IDAsXG4gICdhcmlhLXZhbHVlbWF4JzogMCxcbiAgJ2FyaWEtdmFsdWVtaW4nOiAwLFxuICAnYXJpYS12YWx1ZW5vdyc6IDAsXG4gICdhcmlhLXZhbHVldGV4dCc6IDAsXG4gIC8vIExpdmUgUmVnaW9uIEF0dHJpYnV0ZXNcbiAgJ2FyaWEtYXRvbWljJzogMCxcbiAgJ2FyaWEtYnVzeSc6IDAsXG4gICdhcmlhLWxpdmUnOiAwLFxuICAnYXJpYS1yZWxldmFudCc6IDAsXG4gIC8vIERyYWctYW5kLURyb3AgQXR0cmlidXRlc1xuICAnYXJpYS1kcm9wZWZmZWN0JzogMCxcbiAgJ2FyaWEtZ3JhYmJlZCc6IDAsXG4gIC8vIFJlbGF0aW9uc2hpcCBBdHRyaWJ1dGVzXG4gICdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnOiAwLFxuICAnYXJpYS1jb2xjb3VudCc6IDAsXG4gICdhcmlhLWNvbGluZGV4JzogMCxcbiAgJ2FyaWEtY29sc3Bhbic6IDAsXG4gICdhcmlhLWNvbnRyb2xzJzogMCxcbiAgJ2FyaWEtZGVzY3JpYmVkYnknOiAwLFxuICAnYXJpYS1lcnJvcm1lc3NhZ2UnOiAwLFxuICAnYXJpYS1mbG93dG8nOiAwLFxuICAnYXJpYS1sYWJlbGxlZGJ5JzogMCxcbiAgJ2FyaWEtb3ducyc6IDAsXG4gICdhcmlhLXBvc2luc2V0JzogMCxcbiAgJ2FyaWEtcm93Y291bnQnOiAwLFxuICAnYXJpYS1yb3dpbmRleCc6IDAsXG4gICdhcmlhLXJvd3NwYW4nOiAwLFxuICAnYXJpYS1zZXRzaXplJzogMFxufTtcblxudmFyIHdhcm5lZFByb3BlcnRpZXMgPSB7fTtcbnZhciByQVJJQSA9IG5ldyBSZWdFeHAoJ14oYXJpYSktWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xudmFyIHJBUklBQ2FtZWwgPSBuZXcgUmVnRXhwKCdeKGFyaWEpW0EtWl1bJyArIEFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyk7XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIGdldFN0YWNrQWRkZW5kdW0oKSB7XG4gIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuICByZXR1cm4gc3RhY2sgIT0gbnVsbCA/IHN0YWNrIDogJyc7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydHkodGFnTmFtZSwgbmFtZSkge1xuICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh3YXJuZWRQcm9wZXJ0aWVzLCBuYW1lKSAmJiB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAockFSSUFDYW1lbC50ZXN0KG5hbWUpKSB7XG4gICAgdmFyIGFyaWFOYW1lID0gJ2FyaWEtJyArIG5hbWUuc2xpY2UoNCkudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgY29ycmVjdE5hbWUgPSBhcmlhUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShhcmlhTmFtZSkgPyBhcmlhTmFtZSA6IG51bGw7XG5cbiAgICAvLyBJZiB0aGlzIGlzIGFuIGFyaWEtKiBhdHRyaWJ1dGUsIGJ1dCBpcyBub3QgbGlzdGVkIGluIHRoZSBrbm93biBET01cbiAgICAvLyBET00gcHJvcGVydGllcywgdGhlbiBpdCBpcyBhbiBpbnZhbGlkIGFyaWEtKiBhdHRyaWJ1dGUuXG4gICAgaWYgKGNvcnJlY3ROYW1lID09IG51bGwpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIEFSSUEgYXR0cmlidXRlIGAlc2AuIEFSSUEgYXR0cmlidXRlcyBmb2xsb3cgdGhlIHBhdHRlcm4gYXJpYS0qIGFuZCBtdXN0IGJlIGxvd2VyY2FzZS4lcycsIG5hbWUsIGdldFN0YWNrQWRkZW5kdW0oKSk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBhcmlhLSogYXR0cmlidXRlcyBzaG91bGQgYmUgbG93ZXJjYXNlOyBzdWdnZXN0IHRoZSBsb3dlcmNhc2UgdmVyc2lvbi5cbiAgICBpZiAobmFtZSAhPT0gY29ycmVjdE5hbWUpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIEFSSUEgYXR0cmlidXRlIGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgPyVzJywgbmFtZSwgY29ycmVjdE5hbWUsIGdldFN0YWNrQWRkZW5kdW0oKSk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChyQVJJQS50ZXN0KG5hbWUpKSB7XG4gICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciBzdGFuZGFyZE5hbWUgPSBhcmlhUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkgPyBsb3dlckNhc2VkTmFtZSA6IG51bGw7XG5cbiAgICAvLyBJZiB0aGlzIGlzIGFuIGFyaWEtKiBhdHRyaWJ1dGUsIGJ1dCBpcyBub3QgbGlzdGVkIGluIHRoZSBrbm93biBET01cbiAgICAvLyBET00gcHJvcGVydGllcywgdGhlbiBpdCBpcyBhbiBpbnZhbGlkIGFyaWEtKiBhdHRyaWJ1dGUuXG4gICAgaWYgKHN0YW5kYXJkTmFtZSA9PSBudWxsKSB7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gYXJpYS0qIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIGxvd2VyY2FzZTsgc3VnZ2VzdCB0aGUgbG93ZXJjYXNlIHZlcnNpb24uXG4gICAgaWYgKG5hbWUgIT09IHN0YW5kYXJkTmFtZSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1Vua25vd24gQVJJQSBhdHRyaWJ1dGUgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/JXMnLCBuYW1lLCBzdGFuZGFyZE5hbWUsIGdldFN0YWNrQWRkZW5kdW0oKSk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiB3YXJuSW52YWxpZEFSSUFQcm9wcyh0eXBlLCBwcm9wcykge1xuICB2YXIgaW52YWxpZFByb3BzID0gW107XG5cbiAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgdmFyIGlzVmFsaWQgPSB2YWxpZGF0ZVByb3BlcnR5KHR5cGUsIGtleSk7XG4gICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICBpbnZhbGlkUHJvcHMucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuXG4gIHZhciB1bmtub3duUHJvcFN0cmluZyA9IGludmFsaWRQcm9wcy5tYXAoZnVuY3Rpb24gKHByb3ApIHtcbiAgICByZXR1cm4gJ2AnICsgcHJvcCArICdgJztcbiAgfSkuam9pbignLCAnKTtcblxuICBpZiAoaW52YWxpZFByb3BzLmxlbmd0aCA9PT0gMSkge1xuICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGFyaWEgcHJvcCAlcyBvbiA8JXM+IHRhZy4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vZmIubWUvaW52YWxpZC1hcmlhLXByb3AlcycsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlLCBnZXRTdGFja0FkZGVuZHVtKCkpO1xuICB9IGVsc2UgaWYgKGludmFsaWRQcm9wcy5sZW5ndGggPiAxKSB7XG4gICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXJpYSBwcm9wcyAlcyBvbiA8JXM+IHRhZy4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vZmIubWUvaW52YWxpZC1hcmlhLXByb3AlcycsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlLCBnZXRTdGFja0FkZGVuZHVtKCkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydGllcyh0eXBlLCBwcm9wcykge1xuICBpZiAoaXNDdXN0b21Db21wb25lbnQodHlwZSwgcHJvcHMpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdhcm5JbnZhbGlkQVJJQVByb3BzKHR5cGUsIHByb3BzKTtcbn1cblxudmFyIGRpZFdhcm5WYWx1ZU51bGwgPSBmYWxzZTtcblxuZnVuY3Rpb24gZ2V0U3RhY2tBZGRlbmR1bSQxKCkge1xuICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcbiAgcmV0dXJuIHN0YWNrICE9IG51bGwgPyBzdGFjayA6ICcnO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnRpZXMkMSh0eXBlLCBwcm9wcykge1xuICBpZiAodHlwZSAhPT0gJ2lucHV0JyAmJiB0eXBlICE9PSAndGV4dGFyZWEnICYmIHR5cGUgIT09ICdzZWxlY3QnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHByb3BzICE9IG51bGwgJiYgcHJvcHMudmFsdWUgPT09IG51bGwgJiYgIWRpZFdhcm5WYWx1ZU51bGwpIHtcbiAgICBkaWRXYXJuVmFsdWVOdWxsID0gdHJ1ZTtcbiAgICBpZiAodHlwZSA9PT0gJ3NlbGVjdCcgJiYgcHJvcHMubXVsdGlwbGUpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdgdmFsdWVgIHByb3Agb24gYCVzYCBzaG91bGQgbm90IGJlIG51bGwuICcgKyAnQ29uc2lkZXIgdXNpbmcgYW4gZW1wdHkgYXJyYXkgd2hlbiBgbXVsdGlwbGVgIGlzIHNldCB0byBgdHJ1ZWAgJyArICd0byBjbGVhciB0aGUgY29tcG9uZW50IG9yIGB1bmRlZmluZWRgIGZvciB1bmNvbnRyb2xsZWQgY29tcG9uZW50cy4lcycsIHR5cGUsIGdldFN0YWNrQWRkZW5kdW0kMSgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ2B2YWx1ZWAgcHJvcCBvbiBgJXNgIHNob3VsZCBub3QgYmUgbnVsbC4gJyArICdDb25zaWRlciB1c2luZyBhbiBlbXB0eSBzdHJpbmcgdG8gY2xlYXIgdGhlIGNvbXBvbmVudCBvciBgdW5kZWZpbmVkYCAnICsgJ2ZvciB1bmNvbnRyb2xsZWQgY29tcG9uZW50cy4lcycsIHR5cGUsIGdldFN0YWNrQWRkZW5kdW0kMSgpKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gV2hlbiBhZGRpbmcgYXR0cmlidXRlcyB0byB0aGUgSFRNTCBvciBTVkcgd2hpdGVsaXN0LCBiZSBzdXJlIHRvXG4vLyBhbHNvIGFkZCB0aGVtIHRvIHRoaXMgbW9kdWxlIHRvIGVuc3VyZSBjYXNpbmcgYW5kIGluY29ycmVjdCBuYW1lXG4vLyB3YXJuaW5ncy5cbnZhciBwb3NzaWJsZVN0YW5kYXJkTmFtZXMgPSB7XG4gIC8vIEhUTUxcbiAgYWNjZXB0OiAnYWNjZXB0JyxcbiAgYWNjZXB0Y2hhcnNldDogJ2FjY2VwdENoYXJzZXQnLFxuICAnYWNjZXB0LWNoYXJzZXQnOiAnYWNjZXB0Q2hhcnNldCcsXG4gIGFjY2Vzc2tleTogJ2FjY2Vzc0tleScsXG4gIGFjdGlvbjogJ2FjdGlvbicsXG4gIGFsbG93ZnVsbHNjcmVlbjogJ2FsbG93RnVsbFNjcmVlbicsXG4gIGFsdDogJ2FsdCcsXG4gIGFzOiAnYXMnLFxuICBhc3luYzogJ2FzeW5jJyxcbiAgYXV0b2NhcGl0YWxpemU6ICdhdXRvQ2FwaXRhbGl6ZScsXG4gIGF1dG9jb21wbGV0ZTogJ2F1dG9Db21wbGV0ZScsXG4gIGF1dG9jb3JyZWN0OiAnYXV0b0NvcnJlY3QnLFxuICBhdXRvZm9jdXM6ICdhdXRvRm9jdXMnLFxuICBhdXRvcGxheTogJ2F1dG9QbGF5JyxcbiAgYXV0b3NhdmU6ICdhdXRvU2F2ZScsXG4gIGNhcHR1cmU6ICdjYXB0dXJlJyxcbiAgY2VsbHBhZGRpbmc6ICdjZWxsUGFkZGluZycsXG4gIGNlbGxzcGFjaW5nOiAnY2VsbFNwYWNpbmcnLFxuICBjaGFsbGVuZ2U6ICdjaGFsbGVuZ2UnLFxuICBjaGFyc2V0OiAnY2hhclNldCcsXG4gIGNoZWNrZWQ6ICdjaGVja2VkJyxcbiAgY2hpbGRyZW46ICdjaGlsZHJlbicsXG4gIGNpdGU6ICdjaXRlJyxcbiAgJ2NsYXNzJzogJ2NsYXNzTmFtZScsXG4gIGNsYXNzaWQ6ICdjbGFzc0lEJyxcbiAgY2xhc3NuYW1lOiAnY2xhc3NOYW1lJyxcbiAgY29sczogJ2NvbHMnLFxuICBjb2xzcGFuOiAnY29sU3BhbicsXG4gIGNvbnRlbnQ6ICdjb250ZW50JyxcbiAgY29udGVudGVkaXRhYmxlOiAnY29udGVudEVkaXRhYmxlJyxcbiAgY29udGV4dG1lbnU6ICdjb250ZXh0TWVudScsXG4gIGNvbnRyb2xzOiAnY29udHJvbHMnLFxuICBjb250cm9sc2xpc3Q6ICdjb250cm9sc0xpc3QnLFxuICBjb29yZHM6ICdjb29yZHMnLFxuICBjcm9zc29yaWdpbjogJ2Nyb3NzT3JpZ2luJyxcbiAgZGFuZ2Vyb3VzbHlzZXRpbm5lcmh0bWw6ICdkYW5nZXJvdXNseVNldElubmVySFRNTCcsXG4gIGRhdGE6ICdkYXRhJyxcbiAgZGF0ZXRpbWU6ICdkYXRlVGltZScsXG4gICdkZWZhdWx0JzogJ2RlZmF1bHQnLFxuICBkZWZhdWx0Y2hlY2tlZDogJ2RlZmF1bHRDaGVja2VkJyxcbiAgZGVmYXVsdHZhbHVlOiAnZGVmYXVsdFZhbHVlJyxcbiAgZGVmZXI6ICdkZWZlcicsXG4gIGRpcjogJ2RpcicsXG4gIGRpc2FibGVkOiAnZGlzYWJsZWQnLFxuICBkb3dubG9hZDogJ2Rvd25sb2FkJyxcbiAgZHJhZ2dhYmxlOiAnZHJhZ2dhYmxlJyxcbiAgZW5jdHlwZTogJ2VuY1R5cGUnLFxuICAnZm9yJzogJ2h0bWxGb3InLFxuICBmb3JtOiAnZm9ybScsXG4gIGZvcm1tZXRob2Q6ICdmb3JtTWV0aG9kJyxcbiAgZm9ybWFjdGlvbjogJ2Zvcm1BY3Rpb24nLFxuICBmb3JtZW5jdHlwZTogJ2Zvcm1FbmNUeXBlJyxcbiAgZm9ybW5vdmFsaWRhdGU6ICdmb3JtTm9WYWxpZGF0ZScsXG4gIGZvcm10YXJnZXQ6ICdmb3JtVGFyZ2V0JyxcbiAgZnJhbWVib3JkZXI6ICdmcmFtZUJvcmRlcicsXG4gIGhlYWRlcnM6ICdoZWFkZXJzJyxcbiAgaGVpZ2h0OiAnaGVpZ2h0JyxcbiAgaGlkZGVuOiAnaGlkZGVuJyxcbiAgaGlnaDogJ2hpZ2gnLFxuICBocmVmOiAnaHJlZicsXG4gIGhyZWZsYW5nOiAnaHJlZkxhbmcnLFxuICBodG1sZm9yOiAnaHRtbEZvcicsXG4gIGh0dHBlcXVpdjogJ2h0dHBFcXVpdicsXG4gICdodHRwLWVxdWl2JzogJ2h0dHBFcXVpdicsXG4gIGljb246ICdpY29uJyxcbiAgaWQ6ICdpZCcsXG4gIGlubmVyaHRtbDogJ2lubmVySFRNTCcsXG4gIGlucHV0bW9kZTogJ2lucHV0TW9kZScsXG4gIGludGVncml0eTogJ2ludGVncml0eScsXG4gIGlzOiAnaXMnLFxuICBpdGVtaWQ6ICdpdGVtSUQnLFxuICBpdGVtcHJvcDogJ2l0ZW1Qcm9wJyxcbiAgaXRlbXJlZjogJ2l0ZW1SZWYnLFxuICBpdGVtc2NvcGU6ICdpdGVtU2NvcGUnLFxuICBpdGVtdHlwZTogJ2l0ZW1UeXBlJyxcbiAga2V5cGFyYW1zOiAna2V5UGFyYW1zJyxcbiAga2V5dHlwZTogJ2tleVR5cGUnLFxuICBraW5kOiAna2luZCcsXG4gIGxhYmVsOiAnbGFiZWwnLFxuICBsYW5nOiAnbGFuZycsXG4gIGxpc3Q6ICdsaXN0JyxcbiAgbG9vcDogJ2xvb3AnLFxuICBsb3c6ICdsb3cnLFxuICBtYW5pZmVzdDogJ21hbmlmZXN0JyxcbiAgbWFyZ2lud2lkdGg6ICdtYXJnaW5XaWR0aCcsXG4gIG1hcmdpbmhlaWdodDogJ21hcmdpbkhlaWdodCcsXG4gIG1heDogJ21heCcsXG4gIG1heGxlbmd0aDogJ21heExlbmd0aCcsXG4gIG1lZGlhOiAnbWVkaWEnLFxuICBtZWRpYWdyb3VwOiAnbWVkaWFHcm91cCcsXG4gIG1ldGhvZDogJ21ldGhvZCcsXG4gIG1pbjogJ21pbicsXG4gIG1pbmxlbmd0aDogJ21pbkxlbmd0aCcsXG4gIG11bHRpcGxlOiAnbXVsdGlwbGUnLFxuICBtdXRlZDogJ211dGVkJyxcbiAgbmFtZTogJ25hbWUnLFxuICBub25jZTogJ25vbmNlJyxcbiAgbm92YWxpZGF0ZTogJ25vVmFsaWRhdGUnLFxuICBvcGVuOiAnb3BlbicsXG4gIG9wdGltdW06ICdvcHRpbXVtJyxcbiAgcGF0dGVybjogJ3BhdHRlcm4nLFxuICBwbGFjZWhvbGRlcjogJ3BsYWNlaG9sZGVyJyxcbiAgcGxheXNpbmxpbmU6ICdwbGF5c0lubGluZScsXG4gIHBvc3RlcjogJ3Bvc3RlcicsXG4gIHByZWxvYWQ6ICdwcmVsb2FkJyxcbiAgcHJvZmlsZTogJ3Byb2ZpbGUnLFxuICByYWRpb2dyb3VwOiAncmFkaW9Hcm91cCcsXG4gIHJlYWRvbmx5OiAncmVhZE9ubHknLFxuICByZWZlcnJlcnBvbGljeTogJ3JlZmVycmVyUG9saWN5JyxcbiAgcmVsOiAncmVsJyxcbiAgcmVxdWlyZWQ6ICdyZXF1aXJlZCcsXG4gIHJldmVyc2VkOiAncmV2ZXJzZWQnLFxuICByb2xlOiAncm9sZScsXG4gIHJvd3M6ICdyb3dzJyxcbiAgcm93c3BhbjogJ3Jvd1NwYW4nLFxuICBzYW5kYm94OiAnc2FuZGJveCcsXG4gIHNjb3BlOiAnc2NvcGUnLFxuICBzY29wZWQ6ICdzY29wZWQnLFxuICBzY3JvbGxpbmc6ICdzY3JvbGxpbmcnLFxuICBzZWFtbGVzczogJ3NlYW1sZXNzJyxcbiAgc2VsZWN0ZWQ6ICdzZWxlY3RlZCcsXG4gIHNoYXBlOiAnc2hhcGUnLFxuICBzaXplOiAnc2l6ZScsXG4gIHNpemVzOiAnc2l6ZXMnLFxuICBzcGFuOiAnc3BhbicsXG4gIHNwZWxsY2hlY2s6ICdzcGVsbENoZWNrJyxcbiAgc3JjOiAnc3JjJyxcbiAgc3JjZG9jOiAnc3JjRG9jJyxcbiAgc3JjbGFuZzogJ3NyY0xhbmcnLFxuICBzcmNzZXQ6ICdzcmNTZXQnLFxuICBzdGFydDogJ3N0YXJ0JyxcbiAgc3RlcDogJ3N0ZXAnLFxuICBzdHlsZTogJ3N0eWxlJyxcbiAgc3VtbWFyeTogJ3N1bW1hcnknLFxuICB0YWJpbmRleDogJ3RhYkluZGV4JyxcbiAgdGFyZ2V0OiAndGFyZ2V0JyxcbiAgdGl0bGU6ICd0aXRsZScsXG4gIHR5cGU6ICd0eXBlJyxcbiAgdXNlbWFwOiAndXNlTWFwJyxcbiAgdmFsdWU6ICd2YWx1ZScsXG4gIHdpZHRoOiAnd2lkdGgnLFxuICB3bW9kZTogJ3dtb2RlJyxcbiAgd3JhcDogJ3dyYXAnLFxuXG4gIC8vIFNWR1xuICBhYm91dDogJ2Fib3V0JyxcbiAgYWNjZW50aGVpZ2h0OiAnYWNjZW50SGVpZ2h0JyxcbiAgJ2FjY2VudC1oZWlnaHQnOiAnYWNjZW50SGVpZ2h0JyxcbiAgYWNjdW11bGF0ZTogJ2FjY3VtdWxhdGUnLFxuICBhZGRpdGl2ZTogJ2FkZGl0aXZlJyxcbiAgYWxpZ25tZW50YmFzZWxpbmU6ICdhbGlnbm1lbnRCYXNlbGluZScsXG4gICdhbGlnbm1lbnQtYmFzZWxpbmUnOiAnYWxpZ25tZW50QmFzZWxpbmUnLFxuICBhbGxvd3Jlb3JkZXI6ICdhbGxvd1Jlb3JkZXInLFxuICBhbHBoYWJldGljOiAnYWxwaGFiZXRpYycsXG4gIGFtcGxpdHVkZTogJ2FtcGxpdHVkZScsXG4gIGFyYWJpY2Zvcm06ICdhcmFiaWNGb3JtJyxcbiAgJ2FyYWJpYy1mb3JtJzogJ2FyYWJpY0Zvcm0nLFxuICBhc2NlbnQ6ICdhc2NlbnQnLFxuICBhdHRyaWJ1dGVuYW1lOiAnYXR0cmlidXRlTmFtZScsXG4gIGF0dHJpYnV0ZXR5cGU6ICdhdHRyaWJ1dGVUeXBlJyxcbiAgYXV0b3JldmVyc2U6ICdhdXRvUmV2ZXJzZScsXG4gIGF6aW11dGg6ICdhemltdXRoJyxcbiAgYmFzZWZyZXF1ZW5jeTogJ2Jhc2VGcmVxdWVuY3knLFxuICBiYXNlbGluZXNoaWZ0OiAnYmFzZWxpbmVTaGlmdCcsXG4gICdiYXNlbGluZS1zaGlmdCc6ICdiYXNlbGluZVNoaWZ0JyxcbiAgYmFzZXByb2ZpbGU6ICdiYXNlUHJvZmlsZScsXG4gIGJib3g6ICdiYm94JyxcbiAgYmVnaW46ICdiZWdpbicsXG4gIGJpYXM6ICdiaWFzJyxcbiAgYnk6ICdieScsXG4gIGNhbGNtb2RlOiAnY2FsY01vZGUnLFxuICBjYXBoZWlnaHQ6ICdjYXBIZWlnaHQnLFxuICAnY2FwLWhlaWdodCc6ICdjYXBIZWlnaHQnLFxuICBjbGlwOiAnY2xpcCcsXG4gIGNsaXBwYXRoOiAnY2xpcFBhdGgnLFxuICAnY2xpcC1wYXRoJzogJ2NsaXBQYXRoJyxcbiAgY2xpcHBhdGh1bml0czogJ2NsaXBQYXRoVW5pdHMnLFxuICBjbGlwcnVsZTogJ2NsaXBSdWxlJyxcbiAgJ2NsaXAtcnVsZSc6ICdjbGlwUnVsZScsXG4gIGNvbG9yOiAnY29sb3InLFxuICBjb2xvcmludGVycG9sYXRpb246ICdjb2xvckludGVycG9sYXRpb24nLFxuICAnY29sb3ItaW50ZXJwb2xhdGlvbic6ICdjb2xvckludGVycG9sYXRpb24nLFxuICBjb2xvcmludGVycG9sYXRpb25maWx0ZXJzOiAnY29sb3JJbnRlcnBvbGF0aW9uRmlsdGVycycsXG4gICdjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMnOiAnY29sb3JJbnRlcnBvbGF0aW9uRmlsdGVycycsXG4gIGNvbG9ycHJvZmlsZTogJ2NvbG9yUHJvZmlsZScsXG4gICdjb2xvci1wcm9maWxlJzogJ2NvbG9yUHJvZmlsZScsXG4gIGNvbG9ycmVuZGVyaW5nOiAnY29sb3JSZW5kZXJpbmcnLFxuICAnY29sb3ItcmVuZGVyaW5nJzogJ2NvbG9yUmVuZGVyaW5nJyxcbiAgY29udGVudHNjcmlwdHR5cGU6ICdjb250ZW50U2NyaXB0VHlwZScsXG4gIGNvbnRlbnRzdHlsZXR5cGU6ICdjb250ZW50U3R5bGVUeXBlJyxcbiAgY3Vyc29yOiAnY3Vyc29yJyxcbiAgY3g6ICdjeCcsXG4gIGN5OiAnY3knLFxuICBkOiAnZCcsXG4gIGRhdGF0eXBlOiAnZGF0YXR5cGUnLFxuICBkZWNlbGVyYXRlOiAnZGVjZWxlcmF0ZScsXG4gIGRlc2NlbnQ6ICdkZXNjZW50JyxcbiAgZGlmZnVzZWNvbnN0YW50OiAnZGlmZnVzZUNvbnN0YW50JyxcbiAgZGlyZWN0aW9uOiAnZGlyZWN0aW9uJyxcbiAgZGlzcGxheTogJ2Rpc3BsYXknLFxuICBkaXZpc29yOiAnZGl2aXNvcicsXG4gIGRvbWluYW50YmFzZWxpbmU6ICdkb21pbmFudEJhc2VsaW5lJyxcbiAgJ2RvbWluYW50LWJhc2VsaW5lJzogJ2RvbWluYW50QmFzZWxpbmUnLFxuICBkdXI6ICdkdXInLFxuICBkeDogJ2R4JyxcbiAgZHk6ICdkeScsXG4gIGVkZ2Vtb2RlOiAnZWRnZU1vZGUnLFxuICBlbGV2YXRpb246ICdlbGV2YXRpb24nLFxuICBlbmFibGViYWNrZ3JvdW5kOiAnZW5hYmxlQmFja2dyb3VuZCcsXG4gICdlbmFibGUtYmFja2dyb3VuZCc6ICdlbmFibGVCYWNrZ3JvdW5kJyxcbiAgZW5kOiAnZW5kJyxcbiAgZXhwb25lbnQ6ICdleHBvbmVudCcsXG4gIGV4dGVybmFscmVzb3VyY2VzcmVxdWlyZWQ6ICdleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkJyxcbiAgZmlsbDogJ2ZpbGwnLFxuICBmaWxsb3BhY2l0eTogJ2ZpbGxPcGFjaXR5JyxcbiAgJ2ZpbGwtb3BhY2l0eSc6ICdmaWxsT3BhY2l0eScsXG4gIGZpbGxydWxlOiAnZmlsbFJ1bGUnLFxuICAnZmlsbC1ydWxlJzogJ2ZpbGxSdWxlJyxcbiAgZmlsdGVyOiAnZmlsdGVyJyxcbiAgZmlsdGVycmVzOiAnZmlsdGVyUmVzJyxcbiAgZmlsdGVydW5pdHM6ICdmaWx0ZXJVbml0cycsXG4gIGZsb29kb3BhY2l0eTogJ2Zsb29kT3BhY2l0eScsXG4gICdmbG9vZC1vcGFjaXR5JzogJ2Zsb29kT3BhY2l0eScsXG4gIGZsb29kY29sb3I6ICdmbG9vZENvbG9yJyxcbiAgJ2Zsb29kLWNvbG9yJzogJ2Zsb29kQ29sb3InLFxuICBmb2N1c2FibGU6ICdmb2N1c2FibGUnLFxuICBmb250ZmFtaWx5OiAnZm9udEZhbWlseScsXG4gICdmb250LWZhbWlseSc6ICdmb250RmFtaWx5JyxcbiAgZm9udHNpemU6ICdmb250U2l6ZScsXG4gICdmb250LXNpemUnOiAnZm9udFNpemUnLFxuICBmb250c2l6ZWFkanVzdDogJ2ZvbnRTaXplQWRqdXN0JyxcbiAgJ2ZvbnQtc2l6ZS1hZGp1c3QnOiAnZm9udFNpemVBZGp1c3QnLFxuICBmb250c3RyZXRjaDogJ2ZvbnRTdHJldGNoJyxcbiAgJ2ZvbnQtc3RyZXRjaCc6ICdmb250U3RyZXRjaCcsXG4gIGZvbnRzdHlsZTogJ2ZvbnRTdHlsZScsXG4gICdmb250LXN0eWxlJzogJ2ZvbnRTdHlsZScsXG4gIGZvbnR2YXJpYW50OiAnZm9udFZhcmlhbnQnLFxuICAnZm9udC12YXJpYW50JzogJ2ZvbnRWYXJpYW50JyxcbiAgZm9udHdlaWdodDogJ2ZvbnRXZWlnaHQnLFxuICAnZm9udC13ZWlnaHQnOiAnZm9udFdlaWdodCcsXG4gIGZvcm1hdDogJ2Zvcm1hdCcsXG4gIGZyb206ICdmcm9tJyxcbiAgZng6ICdmeCcsXG4gIGZ5OiAnZnknLFxuICBnMTogJ2cxJyxcbiAgZzI6ICdnMicsXG4gIGdseXBobmFtZTogJ2dseXBoTmFtZScsXG4gICdnbHlwaC1uYW1lJzogJ2dseXBoTmFtZScsXG4gIGdseXBob3JpZW50YXRpb25ob3Jpem9udGFsOiAnZ2x5cGhPcmllbnRhdGlvbkhvcml6b250YWwnLFxuICAnZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbCc6ICdnbHlwaE9yaWVudGF0aW9uSG9yaXpvbnRhbCcsXG4gIGdseXBob3JpZW50YXRpb252ZXJ0aWNhbDogJ2dseXBoT3JpZW50YXRpb25WZXJ0aWNhbCcsXG4gICdnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbCc6ICdnbHlwaE9yaWVudGF0aW9uVmVydGljYWwnLFxuICBnbHlwaHJlZjogJ2dseXBoUmVmJyxcbiAgZ3JhZGllbnR0cmFuc2Zvcm06ICdncmFkaWVudFRyYW5zZm9ybScsXG4gIGdyYWRpZW50dW5pdHM6ICdncmFkaWVudFVuaXRzJyxcbiAgaGFuZ2luZzogJ2hhbmdpbmcnLFxuICBob3JpemFkdng6ICdob3JpekFkdlgnLFxuICAnaG9yaXotYWR2LXgnOiAnaG9yaXpBZHZYJyxcbiAgaG9yaXpvcmlnaW54OiAnaG9yaXpPcmlnaW5YJyxcbiAgJ2hvcml6LW9yaWdpbi14JzogJ2hvcml6T3JpZ2luWCcsXG4gIGlkZW9ncmFwaGljOiAnaWRlb2dyYXBoaWMnLFxuICBpbWFnZXJlbmRlcmluZzogJ2ltYWdlUmVuZGVyaW5nJyxcbiAgJ2ltYWdlLXJlbmRlcmluZyc6ICdpbWFnZVJlbmRlcmluZycsXG4gIGluMjogJ2luMicsXG4gICdpbic6ICdpbicsXG4gIGlubGlzdDogJ2lubGlzdCcsXG4gIGludGVyY2VwdDogJ2ludGVyY2VwdCcsXG4gIGsxOiAnazEnLFxuICBrMjogJ2syJyxcbiAgazM6ICdrMycsXG4gIGs0OiAnazQnLFxuICBrOiAnaycsXG4gIGtlcm5lbG1hdHJpeDogJ2tlcm5lbE1hdHJpeCcsXG4gIGtlcm5lbHVuaXRsZW5ndGg6ICdrZXJuZWxVbml0TGVuZ3RoJyxcbiAga2VybmluZzogJ2tlcm5pbmcnLFxuICBrZXlwb2ludHM6ICdrZXlQb2ludHMnLFxuICBrZXlzcGxpbmVzOiAna2V5U3BsaW5lcycsXG4gIGtleXRpbWVzOiAna2V5VGltZXMnLFxuICBsZW5ndGhhZGp1c3Q6ICdsZW5ndGhBZGp1c3QnLFxuICBsZXR0ZXJzcGFjaW5nOiAnbGV0dGVyU3BhY2luZycsXG4gICdsZXR0ZXItc3BhY2luZyc6ICdsZXR0ZXJTcGFjaW5nJyxcbiAgbGlnaHRpbmdjb2xvcjogJ2xpZ2h0aW5nQ29sb3InLFxuICAnbGlnaHRpbmctY29sb3InOiAnbGlnaHRpbmdDb2xvcicsXG4gIGxpbWl0aW5nY29uZWFuZ2xlOiAnbGltaXRpbmdDb25lQW5nbGUnLFxuICBsb2NhbDogJ2xvY2FsJyxcbiAgbWFya2VyZW5kOiAnbWFya2VyRW5kJyxcbiAgJ21hcmtlci1lbmQnOiAnbWFya2VyRW5kJyxcbiAgbWFya2VyaGVpZ2h0OiAnbWFya2VySGVpZ2h0JyxcbiAgbWFya2VybWlkOiAnbWFya2VyTWlkJyxcbiAgJ21hcmtlci1taWQnOiAnbWFya2VyTWlkJyxcbiAgbWFya2Vyc3RhcnQ6ICdtYXJrZXJTdGFydCcsXG4gICdtYXJrZXItc3RhcnQnOiAnbWFya2VyU3RhcnQnLFxuICBtYXJrZXJ1bml0czogJ21hcmtlclVuaXRzJyxcbiAgbWFya2Vyd2lkdGg6ICdtYXJrZXJXaWR0aCcsXG4gIG1hc2s6ICdtYXNrJyxcbiAgbWFza2NvbnRlbnR1bml0czogJ21hc2tDb250ZW50VW5pdHMnLFxuICBtYXNrdW5pdHM6ICdtYXNrVW5pdHMnLFxuICBtYXRoZW1hdGljYWw6ICdtYXRoZW1hdGljYWwnLFxuICBtb2RlOiAnbW9kZScsXG4gIG51bW9jdGF2ZXM6ICdudW1PY3RhdmVzJyxcbiAgb2Zmc2V0OiAnb2Zmc2V0JyxcbiAgb3BhY2l0eTogJ29wYWNpdHknLFxuICBvcGVyYXRvcjogJ29wZXJhdG9yJyxcbiAgb3JkZXI6ICdvcmRlcicsXG4gIG9yaWVudDogJ29yaWVudCcsXG4gIG9yaWVudGF0aW9uOiAnb3JpZW50YXRpb24nLFxuICBvcmlnaW46ICdvcmlnaW4nLFxuICBvdmVyZmxvdzogJ292ZXJmbG93JyxcbiAgb3ZlcmxpbmVwb3NpdGlvbjogJ292ZXJsaW5lUG9zaXRpb24nLFxuICAnb3ZlcmxpbmUtcG9zaXRpb24nOiAnb3ZlcmxpbmVQb3NpdGlvbicsXG4gIG92ZXJsaW5ldGhpY2tuZXNzOiAnb3ZlcmxpbmVUaGlja25lc3MnLFxuICAnb3ZlcmxpbmUtdGhpY2tuZXNzJzogJ292ZXJsaW5lVGhpY2tuZXNzJyxcbiAgcGFpbnRvcmRlcjogJ3BhaW50T3JkZXInLFxuICAncGFpbnQtb3JkZXInOiAncGFpbnRPcmRlcicsXG4gIHBhbm9zZTE6ICdwYW5vc2UxJyxcbiAgJ3Bhbm9zZS0xJzogJ3Bhbm9zZTEnLFxuICBwYXRobGVuZ3RoOiAncGF0aExlbmd0aCcsXG4gIHBhdHRlcm5jb250ZW50dW5pdHM6ICdwYXR0ZXJuQ29udGVudFVuaXRzJyxcbiAgcGF0dGVybnRyYW5zZm9ybTogJ3BhdHRlcm5UcmFuc2Zvcm0nLFxuICBwYXR0ZXJudW5pdHM6ICdwYXR0ZXJuVW5pdHMnLFxuICBwb2ludGVyZXZlbnRzOiAncG9pbnRlckV2ZW50cycsXG4gICdwb2ludGVyLWV2ZW50cyc6ICdwb2ludGVyRXZlbnRzJyxcbiAgcG9pbnRzOiAncG9pbnRzJyxcbiAgcG9pbnRzYXR4OiAncG9pbnRzQXRYJyxcbiAgcG9pbnRzYXR5OiAncG9pbnRzQXRZJyxcbiAgcG9pbnRzYXR6OiAncG9pbnRzQXRaJyxcbiAgcHJlZml4OiAncHJlZml4JyxcbiAgcHJlc2VydmVhbHBoYTogJ3ByZXNlcnZlQWxwaGEnLFxuICBwcmVzZXJ2ZWFzcGVjdHJhdGlvOiAncHJlc2VydmVBc3BlY3RSYXRpbycsXG4gIHByaW1pdGl2ZXVuaXRzOiAncHJpbWl0aXZlVW5pdHMnLFxuICBwcm9wZXJ0eTogJ3Byb3BlcnR5JyxcbiAgcjogJ3InLFxuICByYWRpdXM6ICdyYWRpdXMnLFxuICByZWZ4OiAncmVmWCcsXG4gIHJlZnk6ICdyZWZZJyxcbiAgcmVuZGVyaW5naW50ZW50OiAncmVuZGVyaW5nSW50ZW50JyxcbiAgJ3JlbmRlcmluZy1pbnRlbnQnOiAncmVuZGVyaW5nSW50ZW50JyxcbiAgcmVwZWF0Y291bnQ6ICdyZXBlYXRDb3VudCcsXG4gIHJlcGVhdGR1cjogJ3JlcGVhdER1cicsXG4gIHJlcXVpcmVkZXh0ZW5zaW9uczogJ3JlcXVpcmVkRXh0ZW5zaW9ucycsXG4gIHJlcXVpcmVkZmVhdHVyZXM6ICdyZXF1aXJlZEZlYXR1cmVzJyxcbiAgcmVzb3VyY2U6ICdyZXNvdXJjZScsXG4gIHJlc3RhcnQ6ICdyZXN0YXJ0JyxcbiAgcmVzdWx0OiAncmVzdWx0JyxcbiAgcmVzdWx0czogJ3Jlc3VsdHMnLFxuICByb3RhdGU6ICdyb3RhdGUnLFxuICByeDogJ3J4JyxcbiAgcnk6ICdyeScsXG4gIHNjYWxlOiAnc2NhbGUnLFxuICBzZWN1cml0eTogJ3NlY3VyaXR5JyxcbiAgc2VlZDogJ3NlZWQnLFxuICBzaGFwZXJlbmRlcmluZzogJ3NoYXBlUmVuZGVyaW5nJyxcbiAgJ3NoYXBlLXJlbmRlcmluZyc6ICdzaGFwZVJlbmRlcmluZycsXG4gIHNsb3BlOiAnc2xvcGUnLFxuICBzcGFjaW5nOiAnc3BhY2luZycsXG4gIHNwZWN1bGFyY29uc3RhbnQ6ICdzcGVjdWxhckNvbnN0YW50JyxcbiAgc3BlY3VsYXJleHBvbmVudDogJ3NwZWN1bGFyRXhwb25lbnQnLFxuICBzcGVlZDogJ3NwZWVkJyxcbiAgc3ByZWFkbWV0aG9kOiAnc3ByZWFkTWV0aG9kJyxcbiAgc3RhcnRvZmZzZXQ6ICdzdGFydE9mZnNldCcsXG4gIHN0ZGRldmlhdGlvbjogJ3N0ZERldmlhdGlvbicsXG4gIHN0ZW1oOiAnc3RlbWgnLFxuICBzdGVtdjogJ3N0ZW12JyxcbiAgc3RpdGNodGlsZXM6ICdzdGl0Y2hUaWxlcycsXG4gIHN0b3Bjb2xvcjogJ3N0b3BDb2xvcicsXG4gICdzdG9wLWNvbG9yJzogJ3N0b3BDb2xvcicsXG4gIHN0b3BvcGFjaXR5OiAnc3RvcE9wYWNpdHknLFxuICAnc3RvcC1vcGFjaXR5JzogJ3N0b3BPcGFjaXR5JyxcbiAgc3RyaWtldGhyb3VnaHBvc2l0aW9uOiAnc3RyaWtldGhyb3VnaFBvc2l0aW9uJyxcbiAgJ3N0cmlrZXRocm91Z2gtcG9zaXRpb24nOiAnc3RyaWtldGhyb3VnaFBvc2l0aW9uJyxcbiAgc3RyaWtldGhyb3VnaHRoaWNrbmVzczogJ3N0cmlrZXRocm91Z2hUaGlja25lc3MnLFxuICAnc3RyaWtldGhyb3VnaC10aGlja25lc3MnOiAnc3RyaWtldGhyb3VnaFRoaWNrbmVzcycsXG4gIHN0cmluZzogJ3N0cmluZycsXG4gIHN0cm9rZTogJ3N0cm9rZScsXG4gIHN0cm9rZWRhc2hhcnJheTogJ3N0cm9rZURhc2hhcnJheScsXG4gICdzdHJva2UtZGFzaGFycmF5JzogJ3N0cm9rZURhc2hhcnJheScsXG4gIHN0cm9rZWRhc2hvZmZzZXQ6ICdzdHJva2VEYXNob2Zmc2V0JyxcbiAgJ3N0cm9rZS1kYXNob2Zmc2V0JzogJ3N0cm9rZURhc2hvZmZzZXQnLFxuICBzdHJva2VsaW5lY2FwOiAnc3Ryb2tlTGluZWNhcCcsXG4gICdzdHJva2UtbGluZWNhcCc6ICdzdHJva2VMaW5lY2FwJyxcbiAgc3Ryb2tlbGluZWpvaW46ICdzdHJva2VMaW5lam9pbicsXG4gICdzdHJva2UtbGluZWpvaW4nOiAnc3Ryb2tlTGluZWpvaW4nLFxuICBzdHJva2VtaXRlcmxpbWl0OiAnc3Ryb2tlTWl0ZXJsaW1pdCcsXG4gICdzdHJva2UtbWl0ZXJsaW1pdCc6ICdzdHJva2VNaXRlcmxpbWl0JyxcbiAgc3Ryb2tld2lkdGg6ICdzdHJva2VXaWR0aCcsXG4gICdzdHJva2Utd2lkdGgnOiAnc3Ryb2tlV2lkdGgnLFxuICBzdHJva2VvcGFjaXR5OiAnc3Ryb2tlT3BhY2l0eScsXG4gICdzdHJva2Utb3BhY2l0eSc6ICdzdHJva2VPcGFjaXR5JyxcbiAgc3VwcHJlc3Njb250ZW50ZWRpdGFibGV3YXJuaW5nOiAnc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nJyxcbiAgc3VwcHJlc3NoeWRyYXRpb253YXJuaW5nOiAnc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJyxcbiAgc3VyZmFjZXNjYWxlOiAnc3VyZmFjZVNjYWxlJyxcbiAgc3lzdGVtbGFuZ3VhZ2U6ICdzeXN0ZW1MYW5ndWFnZScsXG4gIHRhYmxldmFsdWVzOiAndGFibGVWYWx1ZXMnLFxuICB0YXJnZXR4OiAndGFyZ2V0WCcsXG4gIHRhcmdldHk6ICd0YXJnZXRZJyxcbiAgdGV4dGFuY2hvcjogJ3RleHRBbmNob3InLFxuICAndGV4dC1hbmNob3InOiAndGV4dEFuY2hvcicsXG4gIHRleHRkZWNvcmF0aW9uOiAndGV4dERlY29yYXRpb24nLFxuICAndGV4dC1kZWNvcmF0aW9uJzogJ3RleHREZWNvcmF0aW9uJyxcbiAgdGV4dGxlbmd0aDogJ3RleHRMZW5ndGgnLFxuICB0ZXh0cmVuZGVyaW5nOiAndGV4dFJlbmRlcmluZycsXG4gICd0ZXh0LXJlbmRlcmluZyc6ICd0ZXh0UmVuZGVyaW5nJyxcbiAgdG86ICd0bycsXG4gIHRyYW5zZm9ybTogJ3RyYW5zZm9ybScsXG4gICd0eXBlb2YnOiAndHlwZW9mJyxcbiAgdTE6ICd1MScsXG4gIHUyOiAndTInLFxuICB1bmRlcmxpbmVwb3NpdGlvbjogJ3VuZGVybGluZVBvc2l0aW9uJyxcbiAgJ3VuZGVybGluZS1wb3NpdGlvbic6ICd1bmRlcmxpbmVQb3NpdGlvbicsXG4gIHVuZGVybGluZXRoaWNrbmVzczogJ3VuZGVybGluZVRoaWNrbmVzcycsXG4gICd1bmRlcmxpbmUtdGhpY2tuZXNzJzogJ3VuZGVybGluZVRoaWNrbmVzcycsXG4gIHVuaWNvZGU6ICd1bmljb2RlJyxcbiAgdW5pY29kZWJpZGk6ICd1bmljb2RlQmlkaScsXG4gICd1bmljb2RlLWJpZGknOiAndW5pY29kZUJpZGknLFxuICB1bmljb2RlcmFuZ2U6ICd1bmljb2RlUmFuZ2UnLFxuICAndW5pY29kZS1yYW5nZSc6ICd1bmljb2RlUmFuZ2UnLFxuICB1bml0c3BlcmVtOiAndW5pdHNQZXJFbScsXG4gICd1bml0cy1wZXItZW0nOiAndW5pdHNQZXJFbScsXG4gIHVuc2VsZWN0YWJsZTogJ3Vuc2VsZWN0YWJsZScsXG4gIHZhbHBoYWJldGljOiAndkFscGhhYmV0aWMnLFxuICAndi1hbHBoYWJldGljJzogJ3ZBbHBoYWJldGljJyxcbiAgdmFsdWVzOiAndmFsdWVzJyxcbiAgdmVjdG9yZWZmZWN0OiAndmVjdG9yRWZmZWN0JyxcbiAgJ3ZlY3Rvci1lZmZlY3QnOiAndmVjdG9yRWZmZWN0JyxcbiAgdmVyc2lvbjogJ3ZlcnNpb24nLFxuICB2ZXJ0YWR2eTogJ3ZlcnRBZHZZJyxcbiAgJ3ZlcnQtYWR2LXknOiAndmVydEFkdlknLFxuICB2ZXJ0b3JpZ2lueDogJ3ZlcnRPcmlnaW5YJyxcbiAgJ3ZlcnQtb3JpZ2luLXgnOiAndmVydE9yaWdpblgnLFxuICB2ZXJ0b3JpZ2lueTogJ3ZlcnRPcmlnaW5ZJyxcbiAgJ3ZlcnQtb3JpZ2luLXknOiAndmVydE9yaWdpblknLFxuICB2aGFuZ2luZzogJ3ZIYW5naW5nJyxcbiAgJ3YtaGFuZ2luZyc6ICd2SGFuZ2luZycsXG4gIHZpZGVvZ3JhcGhpYzogJ3ZJZGVvZ3JhcGhpYycsXG4gICd2LWlkZW9ncmFwaGljJzogJ3ZJZGVvZ3JhcGhpYycsXG4gIHZpZXdib3g6ICd2aWV3Qm94JyxcbiAgdmlld3RhcmdldDogJ3ZpZXdUYXJnZXQnLFxuICB2aXNpYmlsaXR5OiAndmlzaWJpbGl0eScsXG4gIHZtYXRoZW1hdGljYWw6ICd2TWF0aGVtYXRpY2FsJyxcbiAgJ3YtbWF0aGVtYXRpY2FsJzogJ3ZNYXRoZW1hdGljYWwnLFxuICB2b2NhYjogJ3ZvY2FiJyxcbiAgd2lkdGhzOiAnd2lkdGhzJyxcbiAgd29yZHNwYWNpbmc6ICd3b3JkU3BhY2luZycsXG4gICd3b3JkLXNwYWNpbmcnOiAnd29yZFNwYWNpbmcnLFxuICB3cml0aW5nbW9kZTogJ3dyaXRpbmdNb2RlJyxcbiAgJ3dyaXRpbmctbW9kZSc6ICd3cml0aW5nTW9kZScsXG4gIHgxOiAneDEnLFxuICB4MjogJ3gyJyxcbiAgeDogJ3gnLFxuICB4Y2hhbm5lbHNlbGVjdG9yOiAneENoYW5uZWxTZWxlY3RvcicsXG4gIHhoZWlnaHQ6ICd4SGVpZ2h0JyxcbiAgJ3gtaGVpZ2h0JzogJ3hIZWlnaHQnLFxuICB4bGlua2FjdHVhdGU6ICd4bGlua0FjdHVhdGUnLFxuICAneGxpbms6YWN0dWF0ZSc6ICd4bGlua0FjdHVhdGUnLFxuICB4bGlua2FyY3JvbGU6ICd4bGlua0FyY3JvbGUnLFxuICAneGxpbms6YXJjcm9sZSc6ICd4bGlua0FyY3JvbGUnLFxuICB4bGlua2hyZWY6ICd4bGlua0hyZWYnLFxuICAneGxpbms6aHJlZic6ICd4bGlua0hyZWYnLFxuICB4bGlua3JvbGU6ICd4bGlua1JvbGUnLFxuICAneGxpbms6cm9sZSc6ICd4bGlua1JvbGUnLFxuICB4bGlua3Nob3c6ICd4bGlua1Nob3cnLFxuICAneGxpbms6c2hvdyc6ICd4bGlua1Nob3cnLFxuICB4bGlua3RpdGxlOiAneGxpbmtUaXRsZScsXG4gICd4bGluazp0aXRsZSc6ICd4bGlua1RpdGxlJyxcbiAgeGxpbmt0eXBlOiAneGxpbmtUeXBlJyxcbiAgJ3hsaW5rOnR5cGUnOiAneGxpbmtUeXBlJyxcbiAgeG1sYmFzZTogJ3htbEJhc2UnLFxuICAneG1sOmJhc2UnOiAneG1sQmFzZScsXG4gIHhtbGxhbmc6ICd4bWxMYW5nJyxcbiAgJ3htbDpsYW5nJzogJ3htbExhbmcnLFxuICB4bWxuczogJ3htbG5zJyxcbiAgJ3htbDpzcGFjZSc6ICd4bWxTcGFjZScsXG4gIHhtbG5zeGxpbms6ICd4bWxuc1hsaW5rJyxcbiAgJ3htbG5zOnhsaW5rJzogJ3htbG5zWGxpbmsnLFxuICB4bWxzcGFjZTogJ3htbFNwYWNlJyxcbiAgeTE6ICd5MScsXG4gIHkyOiAneTInLFxuICB5OiAneScsXG4gIHljaGFubmVsc2VsZWN0b3I6ICd5Q2hhbm5lbFNlbGVjdG9yJyxcbiAgejogJ3onLFxuICB6b29tYW5kcGFuOiAnem9vbUFuZFBhbidcbn07XG5cbmZ1bmN0aW9uIGdldFN0YWNrQWRkZW5kdW0kMigpIHtcbiAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG4gIHJldHVybiBzdGFjayAhPSBudWxsID8gc3RhY2sgOiAnJztcbn1cblxue1xuICB2YXIgd2FybmVkUHJvcGVydGllcyQxID0ge307XG4gIHZhciBoYXNPd25Qcm9wZXJ0eSQxID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIEVWRU5UX05BTUVfUkVHRVggPSAvXm9uLi87XG4gIHZhciBJTlZBTElEX0VWRU5UX05BTUVfUkVHRVggPSAvXm9uW15BLVpdLztcbiAgdmFyIHJBUklBJDEgPSBuZXcgUmVnRXhwKCdeKGFyaWEpLVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcbiAgdmFyIHJBUklBQ2FtZWwkMSA9IG5ldyBSZWdFeHAoJ14oYXJpYSlbQS1aXVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcblxuICB2YXIgdmFsaWRhdGVQcm9wZXJ0eSQxID0gZnVuY3Rpb24gKHRhZ05hbWUsIG5hbWUsIHZhbHVlLCBjYW5Vc2VFdmVudFN5c3RlbSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSQxLmNhbGwod2FybmVkUHJvcGVydGllcyQxLCBuYW1lKSAmJiB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAobG93ZXJDYXNlZE5hbWUgPT09ICdvbmZvY3VzaW4nIHx8IGxvd2VyQ2FzZWROYW1lID09PSAnb25mb2N1c291dCcpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdSZWFjdCB1c2VzIG9uRm9jdXMgYW5kIG9uQmx1ciBpbnN0ZWFkIG9mIG9uRm9jdXNJbiBhbmQgb25Gb2N1c091dC4gJyArICdBbGwgUmVhY3QgZXZlbnRzIGFyZSBub3JtYWxpemVkIHRvIGJ1YmJsZSwgc28gb25Gb2N1c0luIGFuZCBvbkZvY3VzT3V0ICcgKyAnYXJlIG5vdCBuZWVkZWQvc3VwcG9ydGVkIGJ5IFJlYWN0LicpO1xuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIFdlIGNhbid0IHJlbHkgb24gdGhlIGV2ZW50IHN5c3RlbSBiZWluZyBpbmplY3RlZCBvbiB0aGUgc2VydmVyLlxuICAgIGlmIChjYW5Vc2VFdmVudFN5c3RlbSkge1xuICAgICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSA/IHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXNbbG93ZXJDYXNlZE5hbWVdIDogbnVsbDtcbiAgICAgIGlmIChyZWdpc3RyYXRpb25OYW1lICE9IG51bGwpIHtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgZXZlbnQgaGFuZGxlciBwcm9wZXJ0eSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8lcycsIG5hbWUsIHJlZ2lzdHJhdGlvbk5hbWUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdVbmtub3duIGV2ZW50IGhhbmRsZXIgcHJvcGVydHkgYCVzYC4gSXQgd2lsbCBiZSBpZ25vcmVkLiVzJywgbmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKCkpO1xuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKEVWRU5UX05BTUVfUkVHRVgudGVzdChuYW1lKSkge1xuICAgICAgLy8gSWYgbm8gZXZlbnQgcGx1Z2lucyBoYXZlIGJlZW4gaW5qZWN0ZWQsIHdlIGFyZSBpbiBhIHNlcnZlciBlbnZpcm9ubWVudC5cbiAgICAgIC8vIFNvIHdlIGNhbid0IHRlbGwgaWYgdGhlIGV2ZW50IG5hbWUgaXMgY29ycmVjdCBmb3Igc3VyZSwgYnV0IHdlIGNhbiBmaWx0ZXJcbiAgICAgIC8vIG91dCBrbm93biBiYWQgb25lcyBsaWtlIGBvbmNsaWNrYC4gV2UgY2FuJ3Qgc3VnZ2VzdCBhIHNwZWNpZmljIHJlcGxhY2VtZW50IHRob3VnaC5cbiAgICAgIGlmIChJTlZBTElEX0VWRU5UX05BTUVfUkVHRVgudGVzdChuYW1lKSkge1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBldmVudCBoYW5kbGVyIHByb3BlcnR5IGAlc2AuICcgKyAnUmVhY3QgZXZlbnRzIHVzZSB0aGUgY2FtZWxDYXNlIG5hbWluZyBjb252ZW50aW9uLCBmb3IgZXhhbXBsZSBgb25DbGlja2AuJXMnLCBuYW1lLCBnZXRTdGFja0FkZGVuZHVtJDIoKSk7XG4gICAgICB9XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gTGV0IHRoZSBBUklBIGF0dHJpYnV0ZSBob29rIHZhbGlkYXRlIEFSSUEgYXR0cmlidXRlc1xuICAgIGlmIChyQVJJQSQxLnRlc3QobmFtZSkgfHwgckFSSUFDYW1lbCQxLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChsb3dlckNhc2VkTmFtZSA9PT0gJ2lubmVyaHRtbCcpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdEaXJlY3RseSBzZXR0aW5nIHByb3BlcnR5IGBpbm5lckhUTUxgIGlzIG5vdCBwZXJtaXR0ZWQuICcgKyAnRm9yIG1vcmUgaW5mb3JtYXRpb24sIGxvb2t1cCBkb2N1bWVudGF0aW9uIG9uIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuJyk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGxvd2VyQ2FzZWROYW1lID09PSAnYXJpYScpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdUaGUgYGFyaWFgIGF0dHJpYnV0ZSBpcyByZXNlcnZlZCBmb3IgZnV0dXJlIHVzZSBpbiBSZWFjdC4gJyArICdQYXNzIGluZGl2aWR1YWwgYGFyaWEtYCBhdHRyaWJ1dGVzIGluc3RlYWQuJyk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGxvd2VyQ2FzZWROYW1lID09PSAnaXMnICYmIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1JlY2VpdmVkIGEgYCVzYCBmb3IgYSBzdHJpbmcgYXR0cmlidXRlIGBpc2AuIElmIHRoaXMgaXMgZXhwZWN0ZWQsIGNhc3QgJyArICd0aGUgdmFsdWUgdG8gYSBzdHJpbmcuJXMnLCB0eXBlb2YgdmFsdWUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWx1ZSkpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdSZWNlaXZlZCBOYU4gZm9yIHRoZSBgJXNgIGF0dHJpYnV0ZS4gSWYgdGhpcyBpcyBleHBlY3RlZCwgY2FzdCAnICsgJ3RoZSB2YWx1ZSB0byBhIHN0cmluZy4lcycsIG5hbWUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgaXNSZXNlcnZlZCA9IGlzUmVzZXJ2ZWRQcm9wKG5hbWUpO1xuXG4gICAgLy8gS25vd24gYXR0cmlidXRlcyBzaG91bGQgbWF0Y2ggdGhlIGNhc2luZyBzcGVjaWZpZWQgaW4gdGhlIHByb3BlcnR5IGNvbmZpZy5cbiAgICBpZiAocG9zc2libGVTdGFuZGFyZE5hbWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSkge1xuICAgICAgdmFyIHN0YW5kYXJkTmFtZSA9IHBvc3NpYmxlU3RhbmRhcmROYW1lc1tsb3dlckNhc2VkTmFtZV07XG4gICAgICBpZiAoc3RhbmRhcmROYW1lICE9PSBuYW1lKSB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIERPTSBwcm9wZXJ0eSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8lcycsIG5hbWUsIHN0YW5kYXJkTmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKCkpO1xuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFpc1Jlc2VydmVkICYmIG5hbWUgIT09IGxvd2VyQ2FzZWROYW1lKSB7XG4gICAgICAvLyBVbmtub3duIGF0dHJpYnV0ZXMgc2hvdWxkIGhhdmUgbG93ZXJjYXNlIGNhc2luZyBzaW5jZSB0aGF0J3MgaG93IHRoZXlcbiAgICAgIC8vIHdpbGwgYmUgY2FzZWQgYW55d2F5IHdpdGggc2VydmVyIHJlbmRlcmluZy5cbiAgICAgIHdhcm5pbmcoZmFsc2UsICdSZWFjdCBkb2VzIG5vdCByZWNvZ25pemUgdGhlIGAlc2AgcHJvcCBvbiBhIERPTSBlbGVtZW50LiBJZiB5b3UgJyArICdpbnRlbnRpb25hbGx5IHdhbnQgaXQgdG8gYXBwZWFyIGluIHRoZSBET00gYXMgYSBjdXN0b20gJyArICdhdHRyaWJ1dGUsIHNwZWxsIGl0IGFzIGxvd2VyY2FzZSBgJXNgIGluc3RlYWQuICcgKyAnSWYgeW91IGFjY2lkZW50YWxseSBwYXNzZWQgaXQgZnJvbSBhIHBhcmVudCBjb21wb25lbnQsIHJlbW92ZSAnICsgJ2l0IGZyb20gdGhlIERPTSBlbGVtZW50LiVzJywgbmFtZSwgbG93ZXJDYXNlZE5hbWUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgJiYgIXNob3VsZEF0dHJpYnV0ZUFjY2VwdEJvb2xlYW5WYWx1ZShuYW1lKSkge1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdSZWNlaXZlZCBgJXNgIGZvciBhIG5vbi1ib29sZWFuIGF0dHJpYnV0ZSBgJXNgLlxcblxcbicgKyAnSWYgeW91IHdhbnQgdG8gd3JpdGUgaXQgdG8gdGhlIERPTSwgcGFzcyBhIHN0cmluZyBpbnN0ZWFkOiAnICsgJyVzPVwiJXNcIiBvciAlcz17dmFsdWUudG9TdHJpbmcoKX0uJXMnLCB2YWx1ZSwgbmFtZSwgbmFtZSwgdmFsdWUsIG5hbWUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdSZWNlaXZlZCBgJXNgIGZvciBhIG5vbi1ib29sZWFuIGF0dHJpYnV0ZSBgJXNgLlxcblxcbicgKyAnSWYgeW91IHdhbnQgdG8gd3JpdGUgaXQgdG8gdGhlIERPTSwgcGFzcyBhIHN0cmluZyBpbnN0ZWFkOiAnICsgJyVzPVwiJXNcIiBvciAlcz17dmFsdWUudG9TdHJpbmcoKX0uXFxuXFxuJyArICdJZiB5b3UgdXNlZCB0byBjb25kaXRpb25hbGx5IG9taXQgaXQgd2l0aCAlcz17Y29uZGl0aW9uICYmIHZhbHVlfSwgJyArICdwYXNzICVzPXtjb25kaXRpb24gPyB2YWx1ZSA6IHVuZGVmaW5lZH0gaW5zdGVhZC4lcycsIHZhbHVlLCBuYW1lLCBuYW1lLCB2YWx1ZSwgbmFtZSwgbmFtZSwgbmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKCkpO1xuICAgICAgfVxuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIE5vdyB0aGF0IHdlJ3ZlIHZhbGlkYXRlZCBjYXNpbmcsIGRvIG5vdCB2YWxpZGF0ZVxuICAgIC8vIGRhdGEgdHlwZXMgZm9yIHJlc2VydmVkIHByb3BzXG4gICAgaWYgKGlzUmVzZXJ2ZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIFdhcm4gd2hlbiBhIGtub3duIGF0dHJpYnV0ZSBpcyBhIGJhZCB0eXBlXG4gICAgaWYgKCFzaG91bGRTZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpKSB7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xufVxuXG52YXIgd2FyblVua25vd25Qcm9wZXJ0aWVzID0gZnVuY3Rpb24gKHR5cGUsIHByb3BzLCBjYW5Vc2VFdmVudFN5c3RlbSkge1xuICB2YXIgdW5rbm93blByb3BzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgIHZhciBpc1ZhbGlkID0gdmFsaWRhdGVQcm9wZXJ0eSQxKHR5cGUsIGtleSwgcHJvcHNba2V5XSwgY2FuVXNlRXZlbnRTeXN0ZW0pO1xuICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgdW5rbm93blByb3BzLnB1c2goa2V5KTtcbiAgICB9XG4gIH1cblxuICB2YXIgdW5rbm93blByb3BTdHJpbmcgPSB1bmtub3duUHJvcHMubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgcmV0dXJuICdgJyArIHByb3AgKyAnYCc7XG4gIH0pLmpvaW4oJywgJyk7XG4gIGlmICh1bmtub3duUHJvcHMubGVuZ3RoID09PSAxKSB7XG4gICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgdmFsdWUgZm9yIHByb3AgJXMgb24gPCVzPiB0YWcuIEVpdGhlciByZW1vdmUgaXQgZnJvbSB0aGUgZWxlbWVudCwgJyArICdvciBwYXNzIGEgc3RyaW5nIG9yIG51bWJlciB2YWx1ZSB0byBrZWVwIGl0IGluIHRoZSBET00uICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL2ZiLm1lL3JlYWN0LWF0dHJpYnV0ZS1iZWhhdmlvciVzJywgdW5rbm93blByb3BTdHJpbmcsIHR5cGUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgfSBlbHNlIGlmICh1bmtub3duUHJvcHMubGVuZ3RoID4gMSkge1xuICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIHZhbHVlcyBmb3IgcHJvcHMgJXMgb24gPCVzPiB0YWcuIEVpdGhlciByZW1vdmUgdGhlbSBmcm9tIHRoZSBlbGVtZW50LCAnICsgJ29yIHBhc3MgYSBzdHJpbmcgb3IgbnVtYmVyIHZhbHVlIHRvIGtlZXAgdGhlbSBpbiB0aGUgRE9NLiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC1hdHRyaWJ1dGUtYmVoYXZpb3IlcycsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlLCBnZXRTdGFja0FkZGVuZHVtJDIoKSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydGllcyQyKHR5cGUsIHByb3BzLCBjYW5Vc2VFdmVudFN5c3RlbSkge1xuICBpZiAoaXNDdXN0b21Db21wb25lbnQodHlwZSwgcHJvcHMpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdhcm5Vbmtub3duUHJvcGVydGllcyh0eXBlLCBwcm9wcywgY2FuVXNlRXZlbnRTeXN0ZW0pO1xufVxuXG4vLyBUT0RPOiBkaXJlY3QgaW1wb3J0cyBsaWtlIHNvbWUtcGFja2FnZS9zcmMvKiBhcmUgYmFkLiBGaXggbWUuXG52YXIgZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lJDEgPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmdldEN1cnJlbnRGaWJlck93bmVyTmFtZTtcbnZhciBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDIgPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW07XG5cbnZhciBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IGZhbHNlO1xudmFyIGRpZFdhcm5TaGFkeURPTSA9IGZhbHNlO1xuXG52YXIgREFOR0VST1VTTFlfU0VUX0lOTkVSX0hUTUwgPSAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnO1xudmFyIFNVUFBSRVNTX0NPTlRFTlRfRURJVEFCTEVfV0FSTklORyA9ICdzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcnO1xudmFyIFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDEgPSAnc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJztcbnZhciBBVVRPRk9DVVMgPSAnYXV0b0ZvY3VzJztcbnZhciBDSElMRFJFTiA9ICdjaGlsZHJlbic7XG52YXIgU1RZTEUgPSAnc3R5bGUnO1xudmFyIEhUTUwgPSAnX19odG1sJztcblxudmFyIEhUTUxfTkFNRVNQQUNFID0gTmFtZXNwYWNlcy5odG1sO1xuXG5cbnZhciBnZXRTdGFjayA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnMoJycpO1xuXG57XG4gIGdldFN0YWNrID0gZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQyO1xuXG4gIHZhciB3YXJuZWRVbmtub3duVGFncyA9IHtcbiAgICAvLyBDaHJvbWUgaXMgdGhlIG9ubHkgbWFqb3IgYnJvd3NlciBub3Qgc2hpcHBpbmcgPHRpbWU+LiBCdXQgYXMgb2YgSnVseVxuICAgIC8vIDIwMTcgaXQgaW50ZW5kcyB0byBzaGlwIGl0IGR1ZSB0byB3aWRlc3ByZWFkIHVzYWdlLiBXZSBpbnRlbnRpb25hbGx5XG4gICAgLy8gKmRvbid0KiB3YXJuIGZvciA8dGltZT4gZXZlbiBpZiBpdCdzIHVucmVjb2duaXplZCBieSBDaHJvbWUgYmVjYXVzZVxuICAgIC8vIGl0IHNvb24gd2lsbCBiZSwgYW5kIG1hbnkgYXBwcyBoYXZlIGJlZW4gdXNpbmcgaXQgYW55d2F5LlxuICAgIHRpbWU6IHRydWUsXG4gICAgLy8gVGhlcmUgYXJlIHdvcmtpbmcgcG9seWZpbGxzIGZvciA8ZGlhbG9nPi4gTGV0IHBlb3BsZSB1c2UgaXQuXG4gICAgZGlhbG9nOiB0cnVlXG4gIH07XG5cbiAgdmFyIHZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQgPSBmdW5jdGlvbiAodHlwZSwgcHJvcHMpIHtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXModHlwZSwgcHJvcHMpO1xuICAgIHZhbGlkYXRlUHJvcGVydGllcyQxKHR5cGUsIHByb3BzKTtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXMkMih0eXBlLCBwcm9wcywgLyogY2FuVXNlRXZlbnRTeXN0ZW0gKi90cnVlKTtcbiAgfTtcblxuICAvLyBIVE1MIHBhcnNpbmcgbm9ybWFsaXplcyBDUiBhbmQgQ1JMRiB0byBMRi5cbiAgLy8gSXQgYWxzbyBjYW4gdHVybiBcXHUwMDAwIGludG8gXFx1RkZGRCBpbnNpZGUgYXR0cmlidXRlcy5cbiAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L3NpbmdsZS1wYWdlLmh0bWwjcHJlcHJvY2Vzc2luZy10aGUtaW5wdXQtc3RyZWFtXG4gIC8vIElmIHdlIGhhdmUgYSBtaXNtYXRjaCwgaXQgbWlnaHQgYmUgY2F1c2VkIGJ5IHRoYXQuXG4gIC8vIFdlIHdpbGwgc3RpbGwgcGF0Y2ggdXAgaW4gdGhpcyBjYXNlIGJ1dCBub3QgZmlyZSB0aGUgd2FybmluZy5cbiAgdmFyIE5PUk1BTElaRV9ORVdMSU5FU19SRUdFWCA9IC9cXHJcXG4/L2c7XG4gIHZhciBOT1JNQUxJWkVfTlVMTF9BTkRfUkVQTEFDRU1FTlRfUkVHRVggPSAvXFx1MDAwMHxcXHVGRkZEL2c7XG5cbiAgdmFyIG5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChtYXJrdXApIHtcbiAgICB2YXIgbWFya3VwU3RyaW5nID0gdHlwZW9mIG1hcmt1cCA9PT0gJ3N0cmluZycgPyBtYXJrdXAgOiAnJyArIG1hcmt1cDtcbiAgICByZXR1cm4gbWFya3VwU3RyaW5nLnJlcGxhY2UoTk9STUFMSVpFX05FV0xJTkVTX1JFR0VYLCAnXFxuJykucmVwbGFjZShOT1JNQUxJWkVfTlVMTF9BTkRfUkVQTEFDRU1FTlRfUkVHRVgsICcnKTtcbiAgfTtcblxuICB2YXIgd2FybkZvclRleHREaWZmZXJlbmNlID0gZnVuY3Rpb24gKHNlcnZlclRleHQsIGNsaWVudFRleHQpIHtcbiAgICBpZiAoZGlkV2FybkludmFsaWRIeWRyYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG5vcm1hbGl6ZWRDbGllbnRUZXh0ID0gbm9ybWFsaXplTWFya3VwRm9yVGV4dE9yQXR0cmlidXRlKGNsaWVudFRleHQpO1xuICAgIHZhciBub3JtYWxpemVkU2VydmVyVGV4dCA9IG5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZShzZXJ2ZXJUZXh0KTtcbiAgICBpZiAobm9ybWFsaXplZFNlcnZlclRleHQgPT09IG5vcm1hbGl6ZWRDbGllbnRUZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcbiAgICB3YXJuaW5nKGZhbHNlLCAnVGV4dCBjb250ZW50IGRpZCBub3QgbWF0Y2guIFNlcnZlcjogXCIlc1wiIENsaWVudDogXCIlc1wiJywgbm9ybWFsaXplZFNlcnZlclRleHQsIG5vcm1hbGl6ZWRDbGllbnRUZXh0KTtcbiAgfTtcblxuICB2YXIgd2FybkZvclByb3BEaWZmZXJlbmNlID0gZnVuY3Rpb24gKHByb3BOYW1lLCBzZXJ2ZXJWYWx1ZSwgY2xpZW50VmFsdWUpIHtcbiAgICBpZiAoZGlkV2FybkludmFsaWRIeWRyYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG5vcm1hbGl6ZWRDbGllbnRWYWx1ZSA9IG5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZShjbGllbnRWYWx1ZSk7XG4gICAgdmFyIG5vcm1hbGl6ZWRTZXJ2ZXJWYWx1ZSA9IG5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZShzZXJ2ZXJWYWx1ZSk7XG4gICAgaWYgKG5vcm1hbGl6ZWRTZXJ2ZXJWYWx1ZSA9PT0gbm9ybWFsaXplZENsaWVudFZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcbiAgICB3YXJuaW5nKGZhbHNlLCAnUHJvcCBgJXNgIGRpZCBub3QgbWF0Y2guIFNlcnZlcjogJXMgQ2xpZW50OiAlcycsIHByb3BOYW1lLCBKU09OLnN0cmluZ2lmeShub3JtYWxpemVkU2VydmVyVmFsdWUpLCBKU09OLnN0cmluZ2lmeShub3JtYWxpemVkQ2xpZW50VmFsdWUpKTtcbiAgfTtcblxuICB2YXIgd2FybkZvckV4dHJhQXR0cmlidXRlcyA9IGZ1bmN0aW9uIChhdHRyaWJ1dGVOYW1lcykge1xuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG4gICAgdmFyIG5hbWVzID0gW107XG4gICAgYXR0cmlidXRlTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgbmFtZXMucHVzaChuYW1lKTtcbiAgICB9KTtcbiAgICB3YXJuaW5nKGZhbHNlLCAnRXh0cmEgYXR0cmlidXRlcyBmcm9tIHRoZSBzZXJ2ZXI6ICVzJywgbmFtZXMpO1xuICB9O1xuXG4gIHZhciB3YXJuRm9ySW52YWxpZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAocmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIgPT09IGZhbHNlKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnRXhwZWN0ZWQgYCVzYCBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLCBpbnN0ZWFkIGdvdCBgZmFsc2VgLlxcblxcbicgKyAnSWYgeW91IHVzZWQgdG8gY29uZGl0aW9uYWxseSBvbWl0IGl0IHdpdGggJXM9e2NvbmRpdGlvbiAmJiB2YWx1ZX0sICcgKyAncGFzcyAlcz17Y29uZGl0aW9uID8gdmFsdWUgOiB1bmRlZmluZWR9IGluc3RlYWQuJXMnLCByZWdpc3RyYXRpb25OYW1lLCByZWdpc3RyYXRpb25OYW1lLCByZWdpc3RyYXRpb25OYW1lLCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDIoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdFeHBlY3RlZCBgJXNgIGxpc3RlbmVyIHRvIGJlIGEgZnVuY3Rpb24sIGluc3RlYWQgZ290IGEgdmFsdWUgb2YgYCVzYCB0eXBlLiVzJywgcmVnaXN0cmF0aW9uTmFtZSwgdHlwZW9mIGxpc3RlbmVyLCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDIoKSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFBhcnNlIHRoZSBIVE1MIGFuZCByZWFkIGl0IGJhY2sgdG8gbm9ybWFsaXplIHRoZSBIVE1MIHN0cmluZyBzbyB0aGF0IGl0XG4gIC8vIGNhbiBiZSB1c2VkIGZvciBjb21wYXJpc29uLlxuICB2YXIgbm9ybWFsaXplSFRNTCA9IGZ1bmN0aW9uIChwYXJlbnQsIGh0bWwpIHtcbiAgICAvLyBXZSBjb3VsZCBoYXZlIGNyZWF0ZWQgYSBzZXBhcmF0ZSBkb2N1bWVudCBoZXJlIHRvIGF2b2lkXG4gICAgLy8gcmUtaW5pdGlhbGl6aW5nIGN1c3RvbSBlbGVtZW50cyBpZiB0aGV5IGV4aXN0LiBCdXQgdGhpcyBicmVha3NcbiAgICAvLyBob3cgPG5vc2NyaXB0PiBpcyBiZWluZyBoYW5kbGVkLiBTbyB3ZSB1c2UgdGhlIHNhbWUgZG9jdW1lbnQuXG4gICAgLy8gU2VlIHRoZSBkaXNjdXNzaW9uIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzExMTU3LlxuICAgIHZhciB0ZXN0RWxlbWVudCA9IHBhcmVudC5uYW1lc3BhY2VVUkkgPT09IEhUTUxfTkFNRVNQQUNFID8gcGFyZW50Lm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChwYXJlbnQudGFnTmFtZSkgOiBwYXJlbnQub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50TlMocGFyZW50Lm5hbWVzcGFjZVVSSSwgcGFyZW50LnRhZ05hbWUpO1xuICAgIHRlc3RFbGVtZW50LmlubmVySFRNTCA9IGh0bWw7XG4gICAgcmV0dXJuIHRlc3RFbGVtZW50LmlubmVySFRNTDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsIHJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgdmFyIGlzRG9jdW1lbnRPckZyYWdtZW50ID0gcm9vdENvbnRhaW5lckVsZW1lbnQubm9kZVR5cGUgPT09IERPQ1VNRU5UX05PREUgfHwgcm9vdENvbnRhaW5lckVsZW1lbnQubm9kZVR5cGUgPT09IERPQ1VNRU5UX0ZSQUdNRU5UX05PREU7XG4gIHZhciBkb2MgPSBpc0RvY3VtZW50T3JGcmFnbWVudCA/IHJvb3RDb250YWluZXJFbGVtZW50IDogcm9vdENvbnRhaW5lckVsZW1lbnQub3duZXJEb2N1bWVudDtcbiAgbGlzdGVuVG8ocmVnaXN0cmF0aW9uTmFtZSwgZG9jKTtcbn1cblxuZnVuY3Rpb24gZ2V0T3duZXJEb2N1bWVudEZyb21Sb290Q29udGFpbmVyKHJvb3RDb250YWluZXJFbGVtZW50KSB7XG4gIHJldHVybiByb290Q29udGFpbmVyRWxlbWVudC5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfTk9ERSA/IHJvb3RDb250YWluZXJFbGVtZW50IDogcm9vdENvbnRhaW5lckVsZW1lbnQub3duZXJEb2N1bWVudDtcbn1cblxuLy8gVGhlcmUgYXJlIHNvIG1hbnkgbWVkaWEgZXZlbnRzLCBpdCBtYWtlcyBzZW5zZSB0byBqdXN0XG4vLyBtYWludGFpbiBhIGxpc3QgcmF0aGVyIHRoYW4gY3JlYXRlIGEgYHRyYXBCdWJibGVkRXZlbnRgIGZvciBlYWNoXG52YXIgbWVkaWFFdmVudHMgPSB7XG4gIHRvcEFib3J0OiAnYWJvcnQnLFxuICB0b3BDYW5QbGF5OiAnY2FucGxheScsXG4gIHRvcENhblBsYXlUaHJvdWdoOiAnY2FucGxheXRocm91Z2gnLFxuICB0b3BEdXJhdGlvbkNoYW5nZTogJ2R1cmF0aW9uY2hhbmdlJyxcbiAgdG9wRW1wdGllZDogJ2VtcHRpZWQnLFxuICB0b3BFbmNyeXB0ZWQ6ICdlbmNyeXB0ZWQnLFxuICB0b3BFbmRlZDogJ2VuZGVkJyxcbiAgdG9wRXJyb3I6ICdlcnJvcicsXG4gIHRvcExvYWRlZERhdGE6ICdsb2FkZWRkYXRhJyxcbiAgdG9wTG9hZGVkTWV0YWRhdGE6ICdsb2FkZWRtZXRhZGF0YScsXG4gIHRvcExvYWRTdGFydDogJ2xvYWRzdGFydCcsXG4gIHRvcFBhdXNlOiAncGF1c2UnLFxuICB0b3BQbGF5OiAncGxheScsXG4gIHRvcFBsYXlpbmc6ICdwbGF5aW5nJyxcbiAgdG9wUHJvZ3Jlc3M6ICdwcm9ncmVzcycsXG4gIHRvcFJhdGVDaGFuZ2U6ICdyYXRlY2hhbmdlJyxcbiAgdG9wU2Vla2VkOiAnc2Vla2VkJyxcbiAgdG9wU2Vla2luZzogJ3NlZWtpbmcnLFxuICB0b3BTdGFsbGVkOiAnc3RhbGxlZCcsXG4gIHRvcFN1c3BlbmQ6ICdzdXNwZW5kJyxcbiAgdG9wVGltZVVwZGF0ZTogJ3RpbWV1cGRhdGUnLFxuICB0b3BWb2x1bWVDaGFuZ2U6ICd2b2x1bWVjaGFuZ2UnLFxuICB0b3BXYWl0aW5nOiAnd2FpdGluZydcbn07XG5cbmZ1bmN0aW9uIHRyYXBDbGlja09uTm9uSW50ZXJhY3RpdmVFbGVtZW50KG5vZGUpIHtcbiAgLy8gTW9iaWxlIFNhZmFyaSBkb2VzIG5vdCBmaXJlIHByb3Blcmx5IGJ1YmJsZSBjbGljayBldmVudHMgb25cbiAgLy8gbm9uLWludGVyYWN0aXZlIGVsZW1lbnRzLCB3aGljaCBtZWFucyBkZWxlZ2F0ZWQgY2xpY2sgbGlzdGVuZXJzIGRvIG5vdFxuICAvLyBmaXJlLiBUaGUgd29ya2Fyb3VuZCBmb3IgdGhpcyBidWcgaW52b2x2ZXMgYXR0YWNoaW5nIGFuIGVtcHR5IGNsaWNrXG4gIC8vIGxpc3RlbmVyIG9uIHRoZSB0YXJnZXQgbm9kZS5cbiAgLy8gaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMTAvMDkvY2xpY2tfZXZlbnRfZGVsLmh0bWxcbiAgLy8gSnVzdCBzZXQgaXQgdXNpbmcgdGhlIG9uY2xpY2sgcHJvcGVydHkgc28gdGhhdCB3ZSBkb24ndCBoYXZlIHRvIG1hbmFnZSBhbnlcbiAgLy8gYm9va2tlZXBpbmcgZm9yIGl0LiBOb3Qgc3VyZSBpZiB3ZSBuZWVkIHRvIGNsZWFyIGl0IHdoZW4gdGhlIGxpc3RlbmVyIGlzXG4gIC8vIHJlbW92ZWQuXG4gIC8vIFRPRE86IE9ubHkgZG8gdGhpcyBmb3IgdGhlIHJlbGV2YW50IFNhZmFyaXMgbWF5YmU/XG4gIG5vZGUub25jbGljayA9IGVtcHR5RnVuY3Rpb247XG59XG5cbmZ1bmN0aW9uIHNldEluaXRpYWxET01Qcm9wZXJ0aWVzKHRhZywgZG9tRWxlbWVudCwgcm9vdENvbnRhaW5lckVsZW1lbnQsIG5leHRQcm9wcywgaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgZm9yICh2YXIgcHJvcEtleSBpbiBuZXh0UHJvcHMpIHtcbiAgICBpZiAoIW5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBuZXh0UHJvcCA9IG5leHRQcm9wc1twcm9wS2V5XTtcbiAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKG5leHRQcm9wKSB7XG4gICAgICAgICAgLy8gRnJlZXplIHRoZSBuZXh0IHN0eWxlIG9iamVjdCBzbyB0aGF0IHdlIGNhbiBhc3N1bWUgaXQgd29uJ3QgYmVcbiAgICAgICAgICAvLyBtdXRhdGVkLiBXZSBoYXZlIGFscmVhZHkgd2FybmVkIGZvciB0aGlzIGluIHRoZSBwYXN0LlxuICAgICAgICAgIE9iamVjdC5mcmVlemUobmV4dFByb3ApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBSZWxpZXMgb24gYHVwZGF0ZVN0eWxlc0J5SURgIG5vdCBtdXRhdGluZyBgc3R5bGVVcGRhdGVzYC5cbiAgICAgIHNldFZhbHVlRm9yU3R5bGVzKGRvbUVsZW1lbnQsIG5leHRQcm9wLCBnZXRTdGFjayk7XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCkge1xuICAgICAgdmFyIG5leHRIdG1sID0gbmV4dFByb3AgPyBuZXh0UHJvcFtIVE1MXSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChuZXh0SHRtbCAhPSBudWxsKSB7XG4gICAgICAgIHNldElubmVySFRNTChkb21FbGVtZW50LCBuZXh0SHRtbCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBDSElMRFJFTikge1xuICAgICAgaWYgKHR5cGVvZiBuZXh0UHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gQXZvaWQgc2V0dGluZyBpbml0aWFsIHRleHRDb250ZW50IHdoZW4gdGhlIHRleHQgaXMgZW1wdHkuIEluIElFMTEgc2V0dGluZ1xuICAgICAgICAvLyB0ZXh0Q29udGVudCBvbiBhIDx0ZXh0YXJlYT4gd2lsbCBjYXVzZSB0aGUgcGxhY2Vob2xkZXIgdG8gbm90XG4gICAgICAgIC8vIHNob3cgd2l0aGluIHRoZSA8dGV4dGFyZWE+IHVudGlsIGl0IGhhcyBiZWVuIGZvY3VzZWQgYW5kIGJsdXJyZWQgYWdhaW4uXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNjczMSNpc3N1ZWNvbW1lbnQtMjU0ODc0NTUzXG4gICAgICAgIHZhciBjYW5TZXRUZXh0Q29udGVudCA9IHRhZyAhPT0gJ3RleHRhcmVhJyB8fCBuZXh0UHJvcCAhPT0gJyc7XG4gICAgICAgIGlmIChjYW5TZXRUZXh0Q29udGVudCkge1xuICAgICAgICAgIHNldFRleHRDb250ZW50KGRvbUVsZW1lbnQsIG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbmV4dFByb3AgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHNldFRleHRDb250ZW50KGRvbUVsZW1lbnQsICcnICsgbmV4dFByb3ApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gU1VQUFJFU1NfQ09OVEVOVF9FRElUQUJMRV9XQVJOSU5HIHx8IHByb3BLZXkgPT09IFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDEpIHtcbiAgICAgIC8vIE5vb3BcbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IEFVVE9GT0NVUykge1xuICAgICAgLy8gV2UgcG9seWZpbGwgaXQgc2VwYXJhdGVseSBvbiB0aGUgY2xpZW50IGR1cmluZyBjb21taXQuXG4gICAgICAvLyBXZSBibGFja2xpc3QgaXQgaGVyZSByYXRoZXIgdGhhbiBpbiB0aGUgcHJvcGVydHkgbGlzdCBiZWNhdXNlIHdlIGVtaXQgaXQgaW4gU1NSLlxuICAgIH0gZWxzZSBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgIGlmIChuZXh0UHJvcCAhPSBudWxsKSB7XG4gICAgICAgIGlmICh0cnVlICYmIHR5cGVvZiBuZXh0UHJvcCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHdhcm5Gb3JJbnZhbGlkRXZlbnRMaXN0ZW5lcihwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgICAgZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsIHByb3BLZXkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgICAgIHNldFZhbHVlRm9yQXR0cmlidXRlKGRvbUVsZW1lbnQsIHByb3BLZXksIG5leHRQcm9wKTtcbiAgICB9IGVsc2UgaWYgKG5leHRQcm9wICE9IG51bGwpIHtcbiAgICAgIC8vIElmIHdlJ3JlIHVwZGF0aW5nIHRvIG51bGwgb3IgdW5kZWZpbmVkLCB3ZSBzaG91bGQgcmVtb3ZlIHRoZSBwcm9wZXJ0eVxuICAgICAgLy8gZnJvbSB0aGUgRE9NIG5vZGUgaW5zdGVhZCBvZiBpbmFkdmVydGVudGx5IHNldHRpbmcgdG8gYSBzdHJpbmcuIFRoaXNcbiAgICAgIC8vIGJyaW5ncyB1cyBpbiBsaW5lIHdpdGggdGhlIHNhbWUgYmVoYXZpb3Igd2UgaGF2ZSBvbiBpbml0aWFsIHJlbmRlci5cbiAgICAgIHNldFZhbHVlRm9yUHJvcGVydHkoZG9tRWxlbWVudCwgcHJvcEtleSwgbmV4dFByb3ApO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVET01Qcm9wZXJ0aWVzKGRvbUVsZW1lbnQsIHVwZGF0ZVBheWxvYWQsIHdhc0N1c3RvbUNvbXBvbmVudFRhZywgaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgLy8gVE9ETzogSGFuZGxlIHdhc0N1c3RvbUNvbXBvbmVudFRhZ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHVwZGF0ZVBheWxvYWQubGVuZ3RoOyBpICs9IDIpIHtcbiAgICB2YXIgcHJvcEtleSA9IHVwZGF0ZVBheWxvYWRbaV07XG4gICAgdmFyIHByb3BWYWx1ZSA9IHVwZGF0ZVBheWxvYWRbaSArIDFdO1xuICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgc2V0VmFsdWVGb3JTdHlsZXMoZG9tRWxlbWVudCwgcHJvcFZhbHVlLCBnZXRTdGFjayk7XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCkge1xuICAgICAgc2V0SW5uZXJIVE1MKGRvbUVsZW1lbnQsIHByb3BWYWx1ZSk7XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBDSElMRFJFTikge1xuICAgICAgc2V0VGV4dENvbnRlbnQoZG9tRWxlbWVudCwgcHJvcFZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gICAgICBpZiAocHJvcFZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVGb3JBdHRyaWJ1dGUoZG9tRWxlbWVudCwgcHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZVZhbHVlRm9yQXR0cmlidXRlKGRvbUVsZW1lbnQsIHByb3BLZXkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcFZhbHVlICE9IG51bGwpIHtcbiAgICAgIHNldFZhbHVlRm9yUHJvcGVydHkoZG9tRWxlbWVudCwgcHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgd2UncmUgdXBkYXRpbmcgdG8gbnVsbCBvciB1bmRlZmluZWQsIHdlIHNob3VsZCByZW1vdmUgdGhlIHByb3BlcnR5XG4gICAgICAvLyBmcm9tIHRoZSBET00gbm9kZSBpbnN0ZWFkIG9mIGluYWR2ZXJ0ZW50bHkgc2V0dGluZyB0byBhIHN0cmluZy4gVGhpc1xuICAgICAgLy8gYnJpbmdzIHVzIGluIGxpbmUgd2l0aCB0aGUgc2FtZSBiZWhhdmlvciB3ZSBoYXZlIG9uIGluaXRpYWwgcmVuZGVyLlxuICAgICAgZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eShkb21FbGVtZW50LCBwcm9wS2V5KTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCQxKHR5cGUsIHByb3BzLCByb290Q29udGFpbmVyRWxlbWVudCwgcGFyZW50TmFtZXNwYWNlKSB7XG4gIC8vIFdlIGNyZWF0ZSB0YWdzIGluIHRoZSBuYW1lc3BhY2Ugb2YgdGhlaXIgcGFyZW50IGNvbnRhaW5lciwgZXhjZXB0IEhUTUxcbiAgdmFyIG93bmVyRG9jdW1lbnQgPSBnZXRPd25lckRvY3VtZW50RnJvbVJvb3RDb250YWluZXIocm9vdENvbnRhaW5lckVsZW1lbnQpO1xuICB2YXIgZG9tRWxlbWVudDtcbiAgdmFyIG5hbWVzcGFjZVVSSSA9IHBhcmVudE5hbWVzcGFjZTtcbiAgaWYgKG5hbWVzcGFjZVVSSSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICBuYW1lc3BhY2VVUkkgPSBnZXRJbnRyaW5zaWNOYW1lc3BhY2UodHlwZSk7XG4gIH1cbiAgaWYgKG5hbWVzcGFjZVVSSSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICB7XG4gICAgICB2YXIgaXNDdXN0b21Db21wb25lbnRUYWcgPSBpc0N1c3RvbUNvbXBvbmVudCh0eXBlLCBwcm9wcyk7XG4gICAgICAvLyBTaG91bGQgdGhpcyBjaGVjayBiZSBnYXRlZCBieSBwYXJlbnQgbmFtZXNwYWNlPyBOb3Qgc3VyZSB3ZSB3YW50IHRvXG4gICAgICAvLyBhbGxvdyA8U1ZHPiBvciA8bUFUSD4uXG4gICAgICB3YXJuaW5nKGlzQ3VzdG9tQ29tcG9uZW50VGFnIHx8IHR5cGUgPT09IHR5cGUudG9Mb3dlckNhc2UoKSwgJzwlcyAvPiBpcyB1c2luZyB1cHBlcmNhc2UgSFRNTC4gQWx3YXlzIHVzZSBsb3dlcmNhc2UgSFRNTCB0YWdzICcgKyAnaW4gUmVhY3QuJywgdHlwZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09ICdzY3JpcHQnKSB7XG4gICAgICAvLyBDcmVhdGUgdGhlIHNjcmlwdCB2aWEgLmlubmVySFRNTCBzbyBpdHMgXCJwYXJzZXItaW5zZXJ0ZWRcIiBmbGFnIGlzXG4gICAgICAvLyBzZXQgdG8gdHJ1ZSBhbmQgaXQgZG9lcyBub3QgZXhlY3V0ZVxuICAgICAgdmFyIGRpdiA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBkaXYuaW5uZXJIVE1MID0gJzxzY3JpcHQ+PCcgKyAnL3NjcmlwdD4nOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAvLyBUaGlzIGlzIGd1YXJhbnRlZWQgdG8geWllbGQgYSBzY3JpcHQgZWxlbWVudC5cbiAgICAgIHZhciBmaXJzdENoaWxkID0gZGl2LmZpcnN0Q2hpbGQ7XG4gICAgICBkb21FbGVtZW50ID0gZGl2LnJlbW92ZUNoaWxkKGZpcnN0Q2hpbGQpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHByb3BzLmlzID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gJEZsb3dJc3N1ZSBgY3JlYXRlRWxlbWVudGAgc2hvdWxkIGJlIHVwZGF0ZWQgZm9yIFdlYiBDb21wb25lbnRzXG4gICAgICBkb21FbGVtZW50ID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KHR5cGUsIHsgaXM6IHByb3BzLmlzIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTZXBhcmF0ZSBlbHNlIGJyYW5jaCBpbnN0ZWFkIG9mIHVzaW5nIGBwcm9wcy5pcyB8fCB1bmRlZmluZWRgIGFib3ZlIGJlY2F1c2Ugb2YgYSBGaXJlZm94IGJ1Zy5cbiAgICAgIC8vIFNlZSBkaXNjdXNzaW9uIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzY4OTZcbiAgICAgIC8vIGFuZCBkaXNjdXNzaW9uIGluIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEyNzYyNDBcbiAgICAgIGRvbUVsZW1lbnQgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodHlwZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGRvbUVsZW1lbnQgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VVUkksIHR5cGUpO1xuICB9XG5cbiAge1xuICAgIGlmIChuYW1lc3BhY2VVUkkgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgICBpZiAoIWlzQ3VzdG9tQ29tcG9uZW50VGFnICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkb21FbGVtZW50KSA9PT0gJ1tvYmplY3QgSFRNTFVua25vd25FbGVtZW50XScgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh3YXJuZWRVbmtub3duVGFncywgdHlwZSkpIHtcbiAgICAgICAgd2FybmVkVW5rbm93blRhZ3NbdHlwZV0gPSB0cnVlO1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnVGhlIHRhZyA8JXM+IGlzIHVucmVjb2duaXplZCBpbiB0aGlzIGJyb3dzZXIuICcgKyAnSWYgeW91IG1lYW50IHRvIHJlbmRlciBhIFJlYWN0IGNvbXBvbmVudCwgc3RhcnQgaXRzIG5hbWUgd2l0aCAnICsgJ2FuIHVwcGVyY2FzZSBsZXR0ZXIuJywgdHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRvbUVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHROb2RlJDEodGV4dCwgcm9vdENvbnRhaW5lckVsZW1lbnQpIHtcbiAgcmV0dXJuIGdldE93bmVyRG9jdW1lbnRGcm9tUm9vdENvbnRhaW5lcihyb290Q29udGFpbmVyRWxlbWVudCkuY3JlYXRlVGV4dE5vZGUodGV4dCk7XG59XG5cbmZ1bmN0aW9uIHNldEluaXRpYWxQcm9wZXJ0aWVzJDEoZG9tRWxlbWVudCwgdGFnLCByYXdQcm9wcywgcm9vdENvbnRhaW5lckVsZW1lbnQpIHtcbiAgdmFyIGlzQ3VzdG9tQ29tcG9uZW50VGFnID0gaXNDdXN0b21Db21wb25lbnQodGFnLCByYXdQcm9wcyk7XG4gIHtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50KHRhZywgcmF3UHJvcHMpO1xuICAgIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZyAmJiAhZGlkV2FyblNoYWR5RE9NICYmIGRvbUVsZW1lbnQuc2hhZHlSb290KSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnJXMgaXMgdXNpbmcgc2hhZHkgRE9NLiBVc2luZyBzaGFkeSBET00gd2l0aCBSZWFjdCBjYW4gJyArICdjYXVzZSB0aGluZ3MgdG8gYnJlYWsgc3VidGx5LicsIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZSQxKCkgfHwgJ0EgY29tcG9uZW50Jyk7XG4gICAgICBkaWRXYXJuU2hhZHlET00gPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRPRE86IE1ha2Ugc3VyZSB0aGF0IHdlIGNoZWNrIGlzTW91bnRlZCBiZWZvcmUgZmlyaW5nIGFueSBvZiB0aGVzZSBldmVudHMuXG4gIHZhciBwcm9wcztcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpZnJhbWUnOlxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BMb2FkJywgJ2xvYWQnLCBkb21FbGVtZW50KTtcbiAgICAgIHByb3BzID0gcmF3UHJvcHM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd2aWRlbyc6XG4gICAgY2FzZSAnYXVkaW8nOlxuICAgICAgLy8gQ3JlYXRlIGxpc3RlbmVyIGZvciBlYWNoIG1lZGlhIGV2ZW50XG4gICAgICBmb3IgKHZhciBldmVudCBpbiBtZWRpYUV2ZW50cykge1xuICAgICAgICBpZiAobWVkaWFFdmVudHMuaGFzT3duUHJvcGVydHkoZXZlbnQpKSB7XG4gICAgICAgICAgdHJhcEJ1YmJsZWRFdmVudChldmVudCwgbWVkaWFFdmVudHNbZXZlbnRdLCBkb21FbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NvdXJjZSc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BFcnJvcicsICdlcnJvcicsIGRvbUVsZW1lbnQpO1xuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2ltZyc6XG4gICAgY2FzZSAnaW1hZ2UnOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wRXJyb3InLCAnZXJyb3InLCBkb21FbGVtZW50KTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcExvYWQnLCAnbG9hZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Zvcm0nOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wUmVzZXQnLCAncmVzZXQnLCBkb21FbGVtZW50KTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcFN1Ym1pdCcsICdzdWJtaXQnLCBkb21FbGVtZW50KTtcbiAgICAgIHByb3BzID0gcmF3UHJvcHM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdkZXRhaWxzJzpcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcFRvZ2dsZScsICd0b2dnbGUnLCBkb21FbGVtZW50KTtcbiAgICAgIHByb3BzID0gcmF3UHJvcHM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICBpbml0V3JhcHBlclN0YXRlKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHByb3BzID0gZ2V0SG9zdFByb3BzKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcEludmFsaWQnLCAnaW52YWxpZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgLy8gRm9yIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3ZSBhbHdheXMgbmVlZCB0byBlbnN1cmUgd2UncmUgbGlzdGVuaW5nXG4gICAgICAvLyB0byBvbkNoYW5nZS4gRXZlbiBpZiB0aGVyZSBpcyBubyBsaXN0ZW5lci5cbiAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCAnb25DaGFuZ2UnKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICB2YWxpZGF0ZVByb3BzKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHByb3BzID0gZ2V0SG9zdFByb3BzJDEoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIGluaXRXcmFwcGVyU3RhdGUkMShkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBwcm9wcyA9IGdldEhvc3RQcm9wcyQyKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcEludmFsaWQnLCAnaW52YWxpZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgLy8gRm9yIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3ZSBhbHdheXMgbmVlZCB0byBlbnN1cmUgd2UncmUgbGlzdGVuaW5nXG4gICAgICAvLyB0byBvbkNoYW5nZS4gRXZlbiBpZiB0aGVyZSBpcyBubyBsaXN0ZW5lci5cbiAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCAnb25DaGFuZ2UnKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIGluaXRXcmFwcGVyU3RhdGUkMihkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBwcm9wcyA9IGdldEhvc3RQcm9wcyQzKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcEludmFsaWQnLCAnaW52YWxpZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgLy8gRm9yIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3ZSBhbHdheXMgbmVlZCB0byBlbnN1cmUgd2UncmUgbGlzdGVuaW5nXG4gICAgICAvLyB0byBvbkNoYW5nZS4gRXZlbiBpZiB0aGVyZSBpcyBubyBsaXN0ZW5lci5cbiAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCAnb25DaGFuZ2UnKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBwcm9wcyA9IHJhd1Byb3BzO1xuICB9XG5cbiAgYXNzZXJ0VmFsaWRQcm9wcyh0YWcsIHByb3BzLCBnZXRTdGFjayk7XG5cbiAgc2V0SW5pdGlhbERPTVByb3BlcnRpZXModGFnLCBkb21FbGVtZW50LCByb290Q29udGFpbmVyRWxlbWVudCwgcHJvcHMsIGlzQ3VzdG9tQ29tcG9uZW50VGFnKTtcblxuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIC8vIFRPRE86IE1ha2Ugc3VyZSB3ZSBjaGVjayBpZiB0aGlzIGlzIHN0aWxsIHVubW91bnRlZCBvciBkbyBhbnkgY2xlYW5cbiAgICAgIC8vIHVwIG5lY2Vzc2FyeSBzaW5jZSB3ZSBuZXZlciBzdG9wIHRyYWNraW5nIGFueW1vcmUuXG4gICAgICB0cmFjayhkb21FbGVtZW50KTtcbiAgICAgIHBvc3RNb3VudFdyYXBwZXIoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgLy8gVE9ETzogTWFrZSBzdXJlIHdlIGNoZWNrIGlmIHRoaXMgaXMgc3RpbGwgdW5tb3VudGVkIG9yIGRvIGFueSBjbGVhblxuICAgICAgLy8gdXAgbmVjZXNzYXJ5IHNpbmNlIHdlIG5ldmVyIHN0b3AgdHJhY2tpbmcgYW55bW9yZS5cbiAgICAgIHRyYWNrKGRvbUVsZW1lbnQpO1xuICAgICAgcG9zdE1vdW50V3JhcHBlciQzKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICBwb3N0TW91bnRXcmFwcGVyJDEoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIHBvc3RNb3VudFdyYXBwZXIkMihkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKHR5cGVvZiBwcm9wcy5vbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgY2FzdCBtYXkgbm90IGJlIHNvdW5kIGZvciBTVkcsIE1hdGhNTCBvciBjdXN0b20gZWxlbWVudHMuXG4gICAgICAgIHRyYXBDbGlja09uTm9uSW50ZXJhY3RpdmVFbGVtZW50KGRvbUVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH1cbn1cblxuLy8gQ2FsY3VsYXRlIHRoZSBkaWZmIGJldHdlZW4gdGhlIHR3byBvYmplY3RzLlxuZnVuY3Rpb24gZGlmZlByb3BlcnRpZXMkMShkb21FbGVtZW50LCB0YWcsIGxhc3RSYXdQcm9wcywgbmV4dFJhd1Byb3BzLCByb290Q29udGFpbmVyRWxlbWVudCkge1xuICB7XG4gICAgdmFsaWRhdGVQcm9wZXJ0aWVzSW5EZXZlbG9wbWVudCh0YWcsIG5leHRSYXdQcm9wcyk7XG4gIH1cblxuICB2YXIgdXBkYXRlUGF5bG9hZCA9IG51bGw7XG5cbiAgdmFyIGxhc3RQcm9wcztcbiAgdmFyIG5leHRQcm9wcztcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICBsYXN0UHJvcHMgPSBnZXRIb3N0UHJvcHMoZG9tRWxlbWVudCwgbGFzdFJhd1Byb3BzKTtcbiAgICAgIG5leHRQcm9wcyA9IGdldEhvc3RQcm9wcyhkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICAgICAgdXBkYXRlUGF5bG9hZCA9IFtdO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgIGxhc3RQcm9wcyA9IGdldEhvc3RQcm9wcyQxKGRvbUVsZW1lbnQsIGxhc3RSYXdQcm9wcyk7XG4gICAgICBuZXh0UHJvcHMgPSBnZXRIb3N0UHJvcHMkMShkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICAgICAgdXBkYXRlUGF5bG9hZCA9IFtdO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIGxhc3RQcm9wcyA9IGdldEhvc3RQcm9wcyQyKGRvbUVsZW1lbnQsIGxhc3RSYXdQcm9wcyk7XG4gICAgICBuZXh0UHJvcHMgPSBnZXRIb3N0UHJvcHMkMihkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICAgICAgdXBkYXRlUGF5bG9hZCA9IFtdO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgbGFzdFByb3BzID0gZ2V0SG9zdFByb3BzJDMoZG9tRWxlbWVudCwgbGFzdFJhd1Byb3BzKTtcbiAgICAgIG5leHRQcm9wcyA9IGdldEhvc3RQcm9wcyQzKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgbGFzdFByb3BzID0gbGFzdFJhd1Byb3BzO1xuICAgICAgbmV4dFByb3BzID0gbmV4dFJhd1Byb3BzO1xuICAgICAgaWYgKHR5cGVvZiBsYXN0UHJvcHMub25DbGljayAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgbmV4dFByb3BzLm9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBjYXN0IG1heSBub3QgYmUgc291bmQgZm9yIFNWRywgTWF0aE1MIG9yIGN1c3RvbSBlbGVtZW50cy5cbiAgICAgICAgdHJhcENsaWNrT25Ob25JbnRlcmFjdGl2ZUVsZW1lbnQoZG9tRWxlbWVudCk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfVxuXG4gIGFzc2VydFZhbGlkUHJvcHModGFnLCBuZXh0UHJvcHMsIGdldFN0YWNrKTtcblxuICB2YXIgcHJvcEtleTtcbiAgdmFyIHN0eWxlTmFtZTtcbiAgdmFyIHN0eWxlVXBkYXRlcyA9IG51bGw7XG4gIGZvciAocHJvcEtleSBpbiBsYXN0UHJvcHMpIHtcbiAgICBpZiAobmV4dFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpIHx8ICFsYXN0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkgfHwgbGFzdFByb3BzW3Byb3BLZXldID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgIHZhciBsYXN0U3R5bGUgPSBsYXN0UHJvcHNbcHJvcEtleV07XG4gICAgICBmb3IgKHN0eWxlTmFtZSBpbiBsYXN0U3R5bGUpIHtcbiAgICAgICAgaWYgKGxhc3RTdHlsZS5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSB7XG4gICAgICAgICAgaWYgKCFzdHlsZVVwZGF0ZXMpIHtcbiAgICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdHlsZVVwZGF0ZXNbc3R5bGVOYW1lXSA9ICcnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCB8fCBwcm9wS2V5ID09PSBDSElMRFJFTikge1xuICAgICAgLy8gTm9vcC4gVGhpcyBpcyBoYW5kbGVkIGJ5IHRoZSBjbGVhciB0ZXh0IG1lY2hhbmlzbS5cbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IFNVUFBSRVNTX0NPTlRFTlRfRURJVEFCTEVfV0FSTklORyB8fCBwcm9wS2V5ID09PSBTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyQxKSB7XG4gICAgICAvLyBOb29wXG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBBVVRPRk9DVVMpIHtcbiAgICAgIC8vIE5vb3AuIEl0IGRvZXNuJ3Qgd29yayBvbiB1cGRhdGVzIGFueXdheS5cbiAgICB9IGVsc2UgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgc3BlY2lhbCBjYXNlLiBJZiBhbnkgbGlzdGVuZXIgdXBkYXRlcyB3ZSBuZWVkIHRvIGVuc3VyZVxuICAgICAgLy8gdGhhdCB0aGUgXCJjdXJyZW50XCIgZmliZXIgcG9pbnRlciBnZXRzIHVwZGF0ZWQgc28gd2UgbmVlZCBhIGNvbW1pdFxuICAgICAgLy8gdG8gdXBkYXRlIHRoaXMgZWxlbWVudC5cbiAgICAgIGlmICghdXBkYXRlUGF5bG9hZCkge1xuICAgICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZvciBhbGwgb3RoZXIgZGVsZXRlZCBwcm9wZXJ0aWVzIHdlIGFkZCBpdCB0byB0aGUgcXVldWUuIFdlIHVzZVxuICAgICAgLy8gdGhlIHdoaXRlbGlzdCBpbiB0aGUgY29tbWl0IHBoYXNlIGluc3RlYWQuXG4gICAgICAodXBkYXRlUGF5bG9hZCA9IHVwZGF0ZVBheWxvYWQgfHwgW10pLnB1c2gocHJvcEtleSwgbnVsbCk7XG4gICAgfVxuICB9XG4gIGZvciAocHJvcEtleSBpbiBuZXh0UHJvcHMpIHtcbiAgICB2YXIgbmV4dFByb3AgPSBuZXh0UHJvcHNbcHJvcEtleV07XG4gICAgdmFyIGxhc3RQcm9wID0gbGFzdFByb3BzICE9IG51bGwgPyBsYXN0UHJvcHNbcHJvcEtleV0gOiB1bmRlZmluZWQ7XG4gICAgaWYgKCFuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkgfHwgbmV4dFByb3AgPT09IGxhc3RQcm9wIHx8IG5leHRQcm9wID09IG51bGwgJiYgbGFzdFByb3AgPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAge1xuICAgICAgICBpZiAobmV4dFByb3ApIHtcbiAgICAgICAgICAvLyBGcmVlemUgdGhlIG5leHQgc3R5bGUgb2JqZWN0IHNvIHRoYXQgd2UgY2FuIGFzc3VtZSBpdCB3b24ndCBiZVxuICAgICAgICAgIC8vIG11dGF0ZWQuIFdlIGhhdmUgYWxyZWFkeSB3YXJuZWQgZm9yIHRoaXMgaW4gdGhlIHBhc3QuXG4gICAgICAgICAgT2JqZWN0LmZyZWV6ZShuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChsYXN0UHJvcCkge1xuICAgICAgICAvLyBVbnNldCBzdHlsZXMgb24gYGxhc3RQcm9wYCBidXQgbm90IG9uIGBuZXh0UHJvcGAuXG4gICAgICAgIGZvciAoc3R5bGVOYW1lIGluIGxhc3RQcm9wKSB7XG4gICAgICAgICAgaWYgKGxhc3RQcm9wLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkgJiYgKCFuZXh0UHJvcCB8fCAhbmV4dFByb3AuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkpIHtcbiAgICAgICAgICAgIGlmICghc3R5bGVVcGRhdGVzKSB7XG4gICAgICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3R5bGVVcGRhdGVzW3N0eWxlTmFtZV0gPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXBkYXRlIHN0eWxlcyB0aGF0IGNoYW5nZWQgc2luY2UgYGxhc3RQcm9wYC5cbiAgICAgICAgZm9yIChzdHlsZU5hbWUgaW4gbmV4dFByb3ApIHtcbiAgICAgICAgICBpZiAobmV4dFByb3AuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSAmJiBsYXN0UHJvcFtzdHlsZU5hbWVdICE9PSBuZXh0UHJvcFtzdHlsZU5hbWVdKSB7XG4gICAgICAgICAgICBpZiAoIXN0eWxlVXBkYXRlcykge1xuICAgICAgICAgICAgICBzdHlsZVVwZGF0ZXMgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0eWxlVXBkYXRlc1tzdHlsZU5hbWVdID0gbmV4dFByb3Bbc3R5bGVOYW1lXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJlbGllcyBvbiBgdXBkYXRlU3R5bGVzQnlJRGAgbm90IG11dGF0aW5nIGBzdHlsZVVwZGF0ZXNgLlxuICAgICAgICBpZiAoIXN0eWxlVXBkYXRlcykge1xuICAgICAgICAgIGlmICghdXBkYXRlUGF5bG9hZCkge1xuICAgICAgICAgICAgdXBkYXRlUGF5bG9hZCA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB1cGRhdGVQYXlsb2FkLnB1c2gocHJvcEtleSwgc3R5bGVVcGRhdGVzKTtcbiAgICAgICAgfVxuICAgICAgICBzdHlsZVVwZGF0ZXMgPSBuZXh0UHJvcDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IERBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MKSB7XG4gICAgICB2YXIgbmV4dEh0bWwgPSBuZXh0UHJvcCA/IG5leHRQcm9wW0hUTUxdIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIGxhc3RIdG1sID0gbGFzdFByb3AgPyBsYXN0UHJvcFtIVE1MXSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChuZXh0SHRtbCAhPSBudWxsKSB7XG4gICAgICAgIGlmIChsYXN0SHRtbCAhPT0gbmV4dEh0bWwpIHtcbiAgICAgICAgICAodXBkYXRlUGF5bG9hZCA9IHVwZGF0ZVBheWxvYWQgfHwgW10pLnB1c2gocHJvcEtleSwgJycgKyBuZXh0SHRtbCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRPRE86IEl0IG1pZ2h0IGJlIHRvbyBsYXRlIHRvIGNsZWFyIHRoaXMgaWYgd2UgaGF2ZSBjaGlsZHJlblxuICAgICAgICAvLyBpbnNlcnRlZCBhbHJlYWR5LlxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gQ0hJTERSRU4pIHtcbiAgICAgIGlmIChsYXN0UHJvcCAhPT0gbmV4dFByb3AgJiYgKHR5cGVvZiBuZXh0UHJvcCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG5leHRQcm9wID09PSAnbnVtYmVyJykpIHtcbiAgICAgICAgKHVwZGF0ZVBheWxvYWQgPSB1cGRhdGVQYXlsb2FkIHx8IFtdKS5wdXNoKHByb3BLZXksICcnICsgbmV4dFByb3ApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gU1VQUFJFU1NfQ09OVEVOVF9FRElUQUJMRV9XQVJOSU5HIHx8IHByb3BLZXkgPT09IFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDEpIHtcbiAgICAgIC8vIE5vb3BcbiAgICB9IGVsc2UgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICBpZiAobmV4dFByb3AgIT0gbnVsbCkge1xuICAgICAgICAvLyBXZSBlYWdlcmx5IGxpc3RlbiB0byB0aGlzIGV2ZW4gdGhvdWdoIHdlIGhhdmVuJ3QgY29tbWl0dGVkIHlldC5cbiAgICAgICAgaWYgKHRydWUgJiYgdHlwZW9mIG5leHRQcm9wICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgd2FybkZvckludmFsaWRFdmVudExpc3RlbmVyKHByb3BLZXksIG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgICBlbnN1cmVMaXN0ZW5pbmdUbyhyb290Q29udGFpbmVyRWxlbWVudCwgcHJvcEtleSk7XG4gICAgICB9XG4gICAgICBpZiAoIXVwZGF0ZVBheWxvYWQgJiYgbGFzdFByb3AgIT09IG5leHRQcm9wKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBzcGVjaWFsIGNhc2UuIElmIGFueSBsaXN0ZW5lciB1cGRhdGVzIHdlIG5lZWQgdG8gZW5zdXJlXG4gICAgICAgIC8vIHRoYXQgdGhlIFwiY3VycmVudFwiIHByb3BzIHBvaW50ZXIgZ2V0cyB1cGRhdGVkIHNvIHdlIG5lZWQgYSBjb21taXRcbiAgICAgICAgLy8gdG8gdXBkYXRlIHRoaXMgZWxlbWVudC5cbiAgICAgICAgdXBkYXRlUGF5bG9hZCA9IFtdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGb3IgYW55IG90aGVyIHByb3BlcnR5IHdlIGFsd2F5cyBhZGQgaXQgdG8gdGhlIHF1ZXVlIGFuZCB0aGVuIHdlXG4gICAgICAvLyBmaWx0ZXIgaXQgb3V0IHVzaW5nIHRoZSB3aGl0ZWxpc3QgZHVyaW5nIHRoZSBjb21taXQuXG4gICAgICAodXBkYXRlUGF5bG9hZCA9IHVwZGF0ZVBheWxvYWQgfHwgW10pLnB1c2gocHJvcEtleSwgbmV4dFByb3ApO1xuICAgIH1cbiAgfVxuICBpZiAoc3R5bGVVcGRhdGVzKSB7XG4gICAgKHVwZGF0ZVBheWxvYWQgPSB1cGRhdGVQYXlsb2FkIHx8IFtdKS5wdXNoKFNUWUxFLCBzdHlsZVVwZGF0ZXMpO1xuICB9XG4gIHJldHVybiB1cGRhdGVQYXlsb2FkO1xufVxuXG4vLyBBcHBseSB0aGUgZGlmZi5cbmZ1bmN0aW9uIHVwZGF0ZVByb3BlcnRpZXMkMShkb21FbGVtZW50LCB1cGRhdGVQYXlsb2FkLCB0YWcsIGxhc3RSYXdQcm9wcywgbmV4dFJhd1Byb3BzKSB7XG4gIC8vIFVwZGF0ZSBjaGVja2VkICpiZWZvcmUqIG5hbWUuXG4gIC8vIEluIHRoZSBtaWRkbGUgb2YgYW4gdXBkYXRlLCBpdCBpcyBwb3NzaWJsZSB0byBoYXZlIG11bHRpcGxlIGNoZWNrZWQuXG4gIC8vIFdoZW4gYSBjaGVja2VkIHJhZGlvIHRyaWVzIHRvIGNoYW5nZSBuYW1lLCBicm93c2VyIG1ha2VzIGFub3RoZXIgcmFkaW8ncyBjaGVja2VkIGZhbHNlLlxuICBpZiAodGFnID09PSAnaW5wdXQnICYmIG5leHRSYXdQcm9wcy50eXBlID09PSAncmFkaW8nICYmIG5leHRSYXdQcm9wcy5uYW1lICE9IG51bGwpIHtcbiAgICB1cGRhdGVDaGVja2VkKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gIH1cblxuICB2YXIgd2FzQ3VzdG9tQ29tcG9uZW50VGFnID0gaXNDdXN0b21Db21wb25lbnQodGFnLCBsYXN0UmF3UHJvcHMpO1xuICB2YXIgaXNDdXN0b21Db21wb25lbnRUYWcgPSBpc0N1c3RvbUNvbXBvbmVudCh0YWcsIG5leHRSYXdQcm9wcyk7XG4gIC8vIEFwcGx5IHRoZSBkaWZmLlxuICB1cGRhdGVET01Qcm9wZXJ0aWVzKGRvbUVsZW1lbnQsIHVwZGF0ZVBheWxvYWQsIHdhc0N1c3RvbUNvbXBvbmVudFRhZywgaXNDdXN0b21Db21wb25lbnRUYWcpO1xuXG4gIC8vIFRPRE86IEVuc3VyZSB0aGF0IGFuIHVwZGF0ZSBnZXRzIHNjaGVkdWxlZCBpZiBhbnkgb2YgdGhlIHNwZWNpYWwgcHJvcHNcbiAgLy8gY2hhbmdlZC5cbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICAvLyBVcGRhdGUgdGhlIHdyYXBwZXIgYXJvdW5kIGlucHV0cyAqYWZ0ZXIqIHVwZGF0aW5nIHByb3BzLiBUaGlzIGhhcyB0b1xuICAgICAgLy8gaGFwcGVuIGFmdGVyIGB1cGRhdGVET01Qcm9wZXJ0aWVzYC4gT3RoZXJ3aXNlIEhUTUw1IGlucHV0IHZhbGlkYXRpb25zXG4gICAgICAvLyByYWlzZSB3YXJuaW5ncyBhbmQgcHJldmVudCB0aGUgbmV3IHZhbHVlIGZyb20gYmVpbmcgYXNzaWduZWQuXG4gICAgICB1cGRhdGVXcmFwcGVyKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICB1cGRhdGVXcmFwcGVyJDEoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAvLyA8c2VsZWN0PiB2YWx1ZSB1cGRhdGUgbmVlZHMgdG8gb2NjdXIgYWZ0ZXIgPG9wdGlvbj4gY2hpbGRyZW5cbiAgICAgIC8vIHJlY29uY2lsaWF0aW9uXG4gICAgICBwb3N0VXBkYXRlV3JhcHBlcihkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGlmZkh5ZHJhdGVkUHJvcGVydGllcyQxKGRvbUVsZW1lbnQsIHRhZywgcmF3UHJvcHMsIHBhcmVudE5hbWVzcGFjZSwgcm9vdENvbnRhaW5lckVsZW1lbnQpIHtcbiAge1xuICAgIHZhciBzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcgPSByYXdQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyQxXSA9PT0gdHJ1ZTtcbiAgICB2YXIgaXNDdXN0b21Db21wb25lbnRUYWcgPSBpc0N1c3RvbUNvbXBvbmVudCh0YWcsIHJhd1Byb3BzKTtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50KHRhZywgcmF3UHJvcHMpO1xuICAgIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZyAmJiAhZGlkV2FyblNoYWR5RE9NICYmIGRvbUVsZW1lbnQuc2hhZHlSb290KSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnJXMgaXMgdXNpbmcgc2hhZHkgRE9NLiBVc2luZyBzaGFkeSBET00gd2l0aCBSZWFjdCBjYW4gJyArICdjYXVzZSB0aGluZ3MgdG8gYnJlYWsgc3VidGx5LicsIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZSQxKCkgfHwgJ0EgY29tcG9uZW50Jyk7XG4gICAgICBkaWRXYXJuU2hhZHlET00gPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRPRE86IE1ha2Ugc3VyZSB0aGF0IHdlIGNoZWNrIGlzTW91bnRlZCBiZWZvcmUgZmlyaW5nIGFueSBvZiB0aGVzZSBldmVudHMuXG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSAnaWZyYW1lJzpcbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wTG9hZCcsICdsb2FkJywgZG9tRWxlbWVudCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd2aWRlbyc6XG4gICAgY2FzZSAnYXVkaW8nOlxuICAgICAgLy8gQ3JlYXRlIGxpc3RlbmVyIGZvciBlYWNoIG1lZGlhIGV2ZW50XG4gICAgICBmb3IgKHZhciBldmVudCBpbiBtZWRpYUV2ZW50cykge1xuICAgICAgICBpZiAobWVkaWFFdmVudHMuaGFzT3duUHJvcGVydHkoZXZlbnQpKSB7XG4gICAgICAgICAgdHJhcEJ1YmJsZWRFdmVudChldmVudCwgbWVkaWFFdmVudHNbZXZlbnRdLCBkb21FbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc291cmNlJzpcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcEVycm9yJywgJ2Vycm9yJywgZG9tRWxlbWVudCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdpbWcnOlxuICAgIGNhc2UgJ2ltYWdlJzpcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcEVycm9yJywgJ2Vycm9yJywgZG9tRWxlbWVudCk7XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BMb2FkJywgJ2xvYWQnLCBkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Zvcm0nOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wUmVzZXQnLCAncmVzZXQnLCBkb21FbGVtZW50KTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcFN1Ym1pdCcsICdzdWJtaXQnLCBkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2RldGFpbHMnOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wVG9nZ2xlJywgJ3RvZ2dsZScsIGRvbUVsZW1lbnQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgICAgaW5pdFdyYXBwZXJTdGF0ZShkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BJbnZhbGlkJywgJ2ludmFsaWQnLCBkb21FbGVtZW50KTtcbiAgICAgIC8vIEZvciBjb250cm9sbGVkIGNvbXBvbmVudHMgd2UgYWx3YXlzIG5lZWQgdG8gZW5zdXJlIHdlJ3JlIGxpc3RlbmluZ1xuICAgICAgLy8gdG8gb25DaGFuZ2UuIEV2ZW4gaWYgdGhlcmUgaXMgbm8gbGlzdGVuZXIuXG4gICAgICBlbnN1cmVMaXN0ZW5pbmdUbyhyb290Q29udGFpbmVyRWxlbWVudCwgJ29uQ2hhbmdlJyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdvcHRpb24nOlxuICAgICAgdmFsaWRhdGVQcm9wcyhkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgaW5pdFdyYXBwZXJTdGF0ZSQxKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcEludmFsaWQnLCAnaW52YWxpZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgLy8gRm9yIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3ZSBhbHdheXMgbmVlZCB0byBlbnN1cmUgd2UncmUgbGlzdGVuaW5nXG4gICAgICAvLyB0byBvbkNoYW5nZS4gRXZlbiBpZiB0aGVyZSBpcyBubyBsaXN0ZW5lci5cbiAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCAnb25DaGFuZ2UnKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIGluaXRXcmFwcGVyU3RhdGUkMihkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BJbnZhbGlkJywgJ2ludmFsaWQnLCBkb21FbGVtZW50KTtcbiAgICAgIC8vIEZvciBjb250cm9sbGVkIGNvbXBvbmVudHMgd2UgYWx3YXlzIG5lZWQgdG8gZW5zdXJlIHdlJ3JlIGxpc3RlbmluZ1xuICAgICAgLy8gdG8gb25DaGFuZ2UuIEV2ZW4gaWYgdGhlcmUgaXMgbm8gbGlzdGVuZXIuXG4gICAgICBlbnN1cmVMaXN0ZW5pbmdUbyhyb290Q29udGFpbmVyRWxlbWVudCwgJ29uQ2hhbmdlJyk7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIGFzc2VydFZhbGlkUHJvcHModGFnLCByYXdQcm9wcywgZ2V0U3RhY2spO1xuXG4gIHtcbiAgICB2YXIgZXh0cmFBdHRyaWJ1dGVOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICB2YXIgYXR0cmlidXRlcyA9IGRvbUVsZW1lbnQuYXR0cmlidXRlcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBuYW1lID0gYXR0cmlidXRlc1tpXS5uYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgLy8gQnVpbHQtaW4gU1NSIGF0dHJpYnV0ZSBpcyB3aGl0ZWxpc3RlZFxuICAgICAgICBjYXNlICdkYXRhLXJlYWN0cm9vdCc6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIENvbnRyb2xsZWQgYXR0cmlidXRlcyBhcmUgbm90IHZhbGlkYXRlZFxuICAgICAgICAvLyBUT0RPOiBPbmx5IGlnbm9yZSB0aGVtIG9uIGNvbnRyb2xsZWQgdGFncy5cbiAgICAgICAgY2FzZSAndmFsdWUnOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdjaGVja2VkJzpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc2VsZWN0ZWQnOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIEludGVudGlvbmFsbHkgdXNlIHRoZSBvcmlnaW5hbCBuYW1lLlxuICAgICAgICAgIC8vIFNlZSBkaXNjdXNzaW9uIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzEwNjc2LlxuICAgICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXMuYWRkKGF0dHJpYnV0ZXNbaV0ubmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHVwZGF0ZVBheWxvYWQgPSBudWxsO1xuICBmb3IgKHZhciBwcm9wS2V5IGluIHJhd1Byb3BzKSB7XG4gICAgaWYgKCFyYXdQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBuZXh0UHJvcCA9IHJhd1Byb3BzW3Byb3BLZXldO1xuICAgIGlmIChwcm9wS2V5ID09PSBDSElMRFJFTikge1xuICAgICAgLy8gRm9yIHRleHQgY29udGVudCBjaGlsZHJlbiB3ZSBjb21wYXJlIGFnYWluc3QgdGV4dENvbnRlbnQuIFRoaXNcbiAgICAgIC8vIG1pZ2h0IG1hdGNoIGFkZGl0aW9uYWwgSFRNTCB0aGF0IGlzIGhpZGRlbiB3aGVuIHdlIHJlYWQgaXQgdXNpbmdcbiAgICAgIC8vIHRleHRDb250ZW50LiBFLmcuIFwiZm9vXCIgd2lsbCBtYXRjaCBcImY8c3Bhbj5vbzwvc3Bhbj5cIiBidXQgdGhhdCBzdGlsbFxuICAgICAgLy8gc2F0aXNmaWVzIG91ciByZXF1aXJlbWVudC4gT3VyIHJlcXVpcmVtZW50IGlzIG5vdCB0byBwcm9kdWNlIHBlcmZlY3RcbiAgICAgIC8vIEhUTUwgYW5kIGF0dHJpYnV0ZXMuIElkZWFsbHkgd2Ugc2hvdWxkIHByZXNlcnZlIHN0cnVjdHVyZSBidXQgaXQnc1xuICAgICAgLy8gb2sgbm90IHRvIGlmIHRoZSB2aXNpYmxlIGNvbnRlbnQgaXMgc3RpbGwgZW5vdWdoIHRvIGluZGljYXRlIHdoYXRcbiAgICAgIC8vIGV2ZW4gbGlzdGVuZXJzIHRoZXNlIG5vZGVzIG1pZ2h0IGJlIHdpcmVkIHVwIHRvLlxuICAgICAgLy8gVE9ETzogV2FybiBpZiB0aGVyZSBpcyBtb3JlIHRoYW4gYSBzaW5nbGUgdGV4dE5vZGUgYXMgYSBjaGlsZC5cbiAgICAgIC8vIFRPRE86IFNob3VsZCB3ZSB1c2UgZG9tRWxlbWVudC5maXJzdENoaWxkLm5vZGVWYWx1ZSB0byBjb21wYXJlP1xuICAgICAgaWYgKHR5cGVvZiBuZXh0UHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKGRvbUVsZW1lbnQudGV4dENvbnRlbnQgIT09IG5leHRQcm9wKSB7XG4gICAgICAgICAgaWYgKHRydWUgJiYgIXN1cHByZXNzSHlkcmF0aW9uV2FybmluZykge1xuICAgICAgICAgICAgd2FybkZvclRleHREaWZmZXJlbmNlKGRvbUVsZW1lbnQudGV4dENvbnRlbnQsIG5leHRQcm9wKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdXBkYXRlUGF5bG9hZCA9IFtDSElMRFJFTiwgbmV4dFByb3BdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBuZXh0UHJvcCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaWYgKGRvbUVsZW1lbnQudGV4dENvbnRlbnQgIT09ICcnICsgbmV4dFByb3ApIHtcbiAgICAgICAgICBpZiAodHJ1ZSAmJiAhc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nKSB7XG4gICAgICAgICAgICB3YXJuRm9yVGV4dERpZmZlcmVuY2UoZG9tRWxlbWVudC50ZXh0Q29udGVudCwgbmV4dFByb3ApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB1cGRhdGVQYXlsb2FkID0gW0NISUxEUkVOLCAnJyArIG5leHRQcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgIGlmIChuZXh0UHJvcCAhPSBudWxsKSB7XG4gICAgICAgIGlmICh0cnVlICYmIHR5cGVvZiBuZXh0UHJvcCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHdhcm5Gb3JJbnZhbGlkRXZlbnRMaXN0ZW5lcihwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgICAgZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsIHByb3BLZXkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBWYWxpZGF0ZSB0aGF0IHRoZSBwcm9wZXJ0aWVzIGNvcnJlc3BvbmQgdG8gdGhlaXIgZXhwZWN0ZWQgdmFsdWVzLlxuICAgICAgdmFyIHNlcnZlclZhbHVlO1xuICAgICAgdmFyIHByb3BlcnR5SW5mbztcbiAgICAgIGlmIChzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcpIHtcbiAgICAgICAgLy8gRG9uJ3QgYm90aGVyIGNvbXBhcmluZy4gV2UncmUgaWdub3JpbmcgYWxsIHRoZXNlIHdhcm5pbmdzLlxuICAgICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBTVVBQUkVTU19DT05URU5UX0VESVRBQkxFX1dBUk5JTkcgfHwgcHJvcEtleSA9PT0gU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkckMSB8fFxuICAgICAgLy8gQ29udHJvbGxlZCBhdHRyaWJ1dGVzIGFyZSBub3QgdmFsaWRhdGVkXG4gICAgICAvLyBUT0RPOiBPbmx5IGlnbm9yZSB0aGVtIG9uIGNvbnRyb2xsZWQgdGFncy5cbiAgICAgIHByb3BLZXkgPT09ICd2YWx1ZScgfHwgcHJvcEtleSA9PT0gJ2NoZWNrZWQnIHx8IHByb3BLZXkgPT09ICdzZWxlY3RlZCcpIHtcbiAgICAgICAgLy8gTm9vcFxuICAgICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCkge1xuICAgICAgICB2YXIgcmF3SHRtbCA9IG5leHRQcm9wID8gbmV4dFByb3BbSFRNTF0gfHwgJycgOiAnJztcbiAgICAgICAgdmFyIHNlcnZlckhUTUwgPSBkb21FbGVtZW50LmlubmVySFRNTDtcbiAgICAgICAgdmFyIGV4cGVjdGVkSFRNTCA9IG5vcm1hbGl6ZUhUTUwoZG9tRWxlbWVudCwgcmF3SHRtbCk7XG4gICAgICAgIGlmIChleHBlY3RlZEhUTUwgIT09IHNlcnZlckhUTUwpIHtcbiAgICAgICAgICB3YXJuRm9yUHJvcERpZmZlcmVuY2UocHJvcEtleSwgc2VydmVySFRNTCwgZXhwZWN0ZWRIVE1MKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXNbJ2RlbGV0ZSddKHByb3BLZXkpO1xuICAgICAgICB2YXIgZXhwZWN0ZWRTdHlsZSA9IGNyZWF0ZURhbmdlcm91c1N0cmluZ0ZvclN0eWxlcyhuZXh0UHJvcCk7XG4gICAgICAgIHNlcnZlclZhbHVlID0gZG9tRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgICAgIGlmIChleHBlY3RlZFN0eWxlICE9PSBzZXJ2ZXJWYWx1ZSkge1xuICAgICAgICAgIHdhcm5Gb3JQcm9wRGlmZmVyZW5jZShwcm9wS2V5LCBzZXJ2ZXJWYWx1ZSwgZXhwZWN0ZWRTdHlsZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICBleHRyYUF0dHJpYnV0ZU5hbWVzWydkZWxldGUnXShwcm9wS2V5LnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICBzZXJ2ZXJWYWx1ZSA9IGdldFZhbHVlRm9yQXR0cmlidXRlKGRvbUVsZW1lbnQsIHByb3BLZXksIG5leHRQcm9wKTtcblxuICAgICAgICBpZiAobmV4dFByb3AgIT09IHNlcnZlclZhbHVlKSB7XG4gICAgICAgICAgd2FybkZvclByb3BEaWZmZXJlbmNlKHByb3BLZXksIHNlcnZlclZhbHVlLCBuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc2hvdWxkU2V0QXR0cmlidXRlKHByb3BLZXksIG5leHRQcm9wKSkge1xuICAgICAgICBpZiAocHJvcGVydHlJbmZvID0gZ2V0UHJvcGVydHlJbmZvKHByb3BLZXkpKSB7XG4gICAgICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXNbJ2RlbGV0ZSddKHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgICBzZXJ2ZXJWYWx1ZSA9IGdldFZhbHVlRm9yUHJvcGVydHkoZG9tRWxlbWVudCwgcHJvcEtleSwgbmV4dFByb3ApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBvd25OYW1lc3BhY2UgPSBwYXJlbnROYW1lc3BhY2U7XG4gICAgICAgICAgaWYgKG93bk5hbWVzcGFjZSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICAgICAgICAgIG93bk5hbWVzcGFjZSA9IGdldEludHJpbnNpY05hbWVzcGFjZSh0YWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3duTmFtZXNwYWNlID09PSBIVE1MX05BTUVTUEFDRSkge1xuICAgICAgICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICAgICAgZXh0cmFBdHRyaWJ1dGVOYW1lc1snZGVsZXRlJ10ocHJvcEtleS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICAgICAgZXh0cmFBdHRyaWJ1dGVOYW1lc1snZGVsZXRlJ10ocHJvcEtleSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlcnZlclZhbHVlID0gZ2V0VmFsdWVGb3JBdHRyaWJ1dGUoZG9tRWxlbWVudCwgcHJvcEtleSwgbmV4dFByb3ApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5leHRQcm9wICE9PSBzZXJ2ZXJWYWx1ZSkge1xuICAgICAgICAgIHdhcm5Gb3JQcm9wRGlmZmVyZW5jZShwcm9wS2V5LCBzZXJ2ZXJWYWx1ZSwgbmV4dFByb3ApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAge1xuICAgIC8vICRGbG93Rml4TWUgLSBTaG91bGQgYmUgaW5mZXJyZWQgYXMgbm90IHVuZGVmaW5lZC5cbiAgICBpZiAoZXh0cmFBdHRyaWJ1dGVOYW1lcy5zaXplID4gMCAmJiAhc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nKSB7XG4gICAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgICB3YXJuRm9yRXh0cmFBdHRyaWJ1dGVzKGV4dHJhQXR0cmlidXRlTmFtZXMpO1xuICAgIH1cbiAgfVxuXG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgICAgLy8gVE9ETzogTWFrZSBzdXJlIHdlIGNoZWNrIGlmIHRoaXMgaXMgc3RpbGwgdW5tb3VudGVkIG9yIGRvIGFueSBjbGVhblxuICAgICAgLy8gdXAgbmVjZXNzYXJ5IHNpbmNlIHdlIG5ldmVyIHN0b3AgdHJhY2tpbmcgYW55bW9yZS5cbiAgICAgIHRyYWNrKGRvbUVsZW1lbnQpO1xuICAgICAgcG9zdE1vdW50V3JhcHBlcihkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICAvLyBUT0RPOiBNYWtlIHN1cmUgd2UgY2hlY2sgaWYgdGhpcyBpcyBzdGlsbCB1bm1vdW50ZWQgb3IgZG8gYW55IGNsZWFuXG4gICAgICAvLyB1cCBuZWNlc3Nhcnkgc2luY2Ugd2UgbmV2ZXIgc3RvcCB0cmFja2luZyBhbnltb3JlLlxuICAgICAgdHJhY2soZG9tRWxlbWVudCk7XG4gICAgICBwb3N0TW91bnRXcmFwcGVyJDMoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICBjYXNlICdvcHRpb24nOlxuICAgICAgLy8gRm9yIGlucHV0IGFuZCB0ZXh0YXJlYSB3ZSBjdXJyZW50IGFsd2F5cyBzZXQgdGhlIHZhbHVlIHByb3BlcnR5IGF0XG4gICAgICAvLyBwb3N0IG1vdW50IHRvIGZvcmNlIGl0IHRvIGRpdmVyZ2UgZnJvbSBhdHRyaWJ1dGVzLiBIb3dldmVyLCBmb3JcbiAgICAgIC8vIG9wdGlvbiBhbmQgc2VsZWN0IHdlIGRvbid0IHF1aXRlIGRvIHRoZSBzYW1lIHRoaW5nIGFuZCBzZWxlY3RcbiAgICAgIC8vIGlzIG5vdCByZXNpbGllbnQgdG8gdGhlIERPTSBzdGF0ZSBjaGFuZ2luZyBzbyB3ZSBkb24ndCBkbyB0aGF0IGhlcmUuXG4gICAgICAvLyBUT0RPOiBDb25zaWRlciBub3QgZG9pbmcgdGhpcyBmb3IgaW5wdXQgYW5kIHRleHRhcmVhLlxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGlmICh0eXBlb2YgcmF3UHJvcHMub25DbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBUT0RPOiBUaGlzIGNhc3QgbWF5IG5vdCBiZSBzb3VuZCBmb3IgU1ZHLCBNYXRoTUwgb3IgY3VzdG9tIGVsZW1lbnRzLlxuICAgICAgICB0cmFwQ2xpY2tPbk5vbkludGVyYWN0aXZlRWxlbWVudChkb21FbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIHVwZGF0ZVBheWxvYWQ7XG59XG5cbmZ1bmN0aW9uIGRpZmZIeWRyYXRlZFRleHQkMSh0ZXh0Tm9kZSwgdGV4dCkge1xuICB2YXIgaXNEaWZmZXJlbnQgPSB0ZXh0Tm9kZS5ub2RlVmFsdWUgIT09IHRleHQ7XG4gIHJldHVybiBpc0RpZmZlcmVudDtcbn1cblxuZnVuY3Rpb24gd2FybkZvclVubWF0Y2hlZFRleHQkMSh0ZXh0Tm9kZSwgdGV4dCkge1xuICB7XG4gICAgd2FybkZvclRleHREaWZmZXJlbmNlKHRleHROb2RlLm5vZGVWYWx1ZSwgdGV4dCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudCQxKHBhcmVudE5vZGUsIGNoaWxkKSB7XG4gIHtcbiAgICBpZiAoZGlkV2FybkludmFsaWRIeWRyYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGlkV2FybkludmFsaWRIeWRyYXRpb24gPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsICdEaWQgbm90IGV4cGVjdCBzZXJ2ZXIgSFRNTCB0byBjb250YWluIGEgPCVzPiBpbiA8JXM+LicsIGNoaWxkLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksIHBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dCQxKHBhcmVudE5vZGUsIGNoaWxkKSB7XG4gIHtcbiAgICBpZiAoZGlkV2FybkludmFsaWRIeWRyYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGlkV2FybkludmFsaWRIeWRyYXRpb24gPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsICdEaWQgbm90IGV4cGVjdCBzZXJ2ZXIgSFRNTCB0byBjb250YWluIHRoZSB0ZXh0IG5vZGUgXCIlc1wiIGluIDwlcz4uJywgY2hpbGQubm9kZVZhbHVlLCBwYXJlbnROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkRWxlbWVudCQxKHBhcmVudE5vZGUsIHRhZywgcHJvcHMpIHtcbiAge1xuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ0V4cGVjdGVkIHNlcnZlciBIVE1MIHRvIGNvbnRhaW4gYSBtYXRjaGluZyA8JXM+IGluIDwlcz4uJywgdGFnLCBwYXJlbnROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dCQxKHBhcmVudE5vZGUsIHRleHQpIHtcbiAge1xuICAgIGlmICh0ZXh0ID09PSAnJykge1xuICAgICAgLy8gV2UgZXhwZWN0IHRvIGluc2VydCBlbXB0eSB0ZXh0IG5vZGVzIHNpbmNlIHRoZXkncmUgbm90IHJlcHJlc2VudGVkIGluXG4gICAgICAvLyB0aGUgSFRNTC5cbiAgICAgIC8vIFRPRE86IFJlbW92ZSB0aGlzIHNwZWNpYWwgY2FzZSBpZiB3ZSBjYW4ganVzdCBhdm9pZCBpbnNlcnRpbmcgZW1wdHlcbiAgICAgIC8vIHRleHQgbm9kZXMuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ0V4cGVjdGVkIHNlcnZlciBIVE1MIHRvIGNvbnRhaW4gYSBtYXRjaGluZyB0ZXh0IG5vZGUgZm9yIFwiJXNcIiBpbiA8JXM+LicsIHRleHQsIHBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdG9yZUNvbnRyb2xsZWRTdGF0ZShkb21FbGVtZW50LCB0YWcsIHByb3BzKSB7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgICAgcmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSQxKGRvbUVsZW1lbnQsIHByb3BzKTtcbiAgICAgIHJldHVybjtcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICByZXN0b3JlQ29udHJvbGxlZFN0YXRlJDMoZG9tRWxlbWVudCwgcHJvcHMpO1xuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICByZXN0b3JlQ29udHJvbGxlZFN0YXRlJDIoZG9tRWxlbWVudCwgcHJvcHMpO1xuICAgICAgcmV0dXJuO1xuICB9XG59XG5cbnZhciBSZWFjdERPTUZpYmVyQ29tcG9uZW50ID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnQkMSxcblx0Y3JlYXRlVGV4dE5vZGU6IGNyZWF0ZVRleHROb2RlJDEsXG5cdHNldEluaXRpYWxQcm9wZXJ0aWVzOiBzZXRJbml0aWFsUHJvcGVydGllcyQxLFxuXHRkaWZmUHJvcGVydGllczogZGlmZlByb3BlcnRpZXMkMSxcblx0dXBkYXRlUHJvcGVydGllczogdXBkYXRlUHJvcGVydGllcyQxLFxuXHRkaWZmSHlkcmF0ZWRQcm9wZXJ0aWVzOiBkaWZmSHlkcmF0ZWRQcm9wZXJ0aWVzJDEsXG5cdGRpZmZIeWRyYXRlZFRleHQ6IGRpZmZIeWRyYXRlZFRleHQkMSxcblx0d2FybkZvclVubWF0Y2hlZFRleHQ6IHdhcm5Gb3JVbm1hdGNoZWRUZXh0JDEsXG5cdHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZUVsZW1lbnQ6IHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZUVsZW1lbnQkMSxcblx0d2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dDogd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dCQxLFxuXHR3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZEVsZW1lbnQ6IHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkRWxlbWVudCQxLFxuXHR3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZFRleHQ6IHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dCQxLFxuXHRyZXN0b3JlQ29udHJvbGxlZFN0YXRlOiByZXN0b3JlQ29udHJvbGxlZFN0YXRlXG59KTtcblxuLy8gVE9ETzogZGlyZWN0IGltcG9ydHMgbGlrZSBzb21lLXBhY2thZ2Uvc3JjLyogYXJlIGJhZC4gRml4IG1lLlxudmFyIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kNiA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bTtcblxudmFyIHZhbGlkYXRlRE9NTmVzdGluZyA9IGVtcHR5RnVuY3Rpb247XG5cbntcbiAgLy8gVGhpcyB2YWxpZGF0aW9uIGNvZGUgd2FzIHdyaXR0ZW4gYmFzZWQgb24gdGhlIEhUTUw1IHBhcnNpbmcgc3BlYzpcbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaGFzLWFuLWVsZW1lbnQtaW4tc2NvcGVcbiAgLy9cbiAgLy8gTm90ZTogdGhpcyBkb2VzIG5vdCBjYXRjaCBhbGwgaW52YWxpZCBuZXN0aW5nLCBub3IgZG9lcyBpdCB0cnkgdG8gKGFzIGl0J3NcbiAgLy8gbm90IGNsZWFyIHdoYXQgcHJhY3RpY2FsIGJlbmVmaXQgZG9pbmcgc28gcHJvdmlkZXMpOyBpbnN0ZWFkLCB3ZSB3YXJuIG9ubHlcbiAgLy8gZm9yIGNhc2VzIHdoZXJlIHRoZSBwYXJzZXIgd2lsbCBnaXZlIGEgcGFyc2UgdHJlZSBkaWZmZXJpbmcgZnJvbSB3aGF0IFJlYWN0XG4gIC8vIGludGVuZGVkLiBGb3IgZXhhbXBsZSwgPGI+PGRpdj48L2Rpdj48L2I+IGlzIGludmFsaWQgYnV0IHdlIGRvbid0IHdhcm5cbiAgLy8gYmVjYXVzZSBpdCBzdGlsbCBwYXJzZXMgY29ycmVjdGx5OyB3ZSBkbyB3YXJuIGZvciBvdGhlciBjYXNlcyBsaWtlIG5lc3RlZFxuICAvLyA8cD4gdGFncyB3aGVyZSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzZWNvbmQgZWxlbWVudCBpbXBsaWNpdGx5IGNsb3NlcyB0aGVcbiAgLy8gZmlyc3QsIGNhdXNpbmcgYSBjb25mdXNpbmcgbWVzcy5cblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNzcGVjaWFsXG4gIHZhciBzcGVjaWFsVGFncyA9IFsnYWRkcmVzcycsICdhcHBsZXQnLCAnYXJlYScsICdhcnRpY2xlJywgJ2FzaWRlJywgJ2Jhc2UnLCAnYmFzZWZvbnQnLCAnYmdzb3VuZCcsICdibG9ja3F1b3RlJywgJ2JvZHknLCAnYnInLCAnYnV0dG9uJywgJ2NhcHRpb24nLCAnY2VudGVyJywgJ2NvbCcsICdjb2xncm91cCcsICdkZCcsICdkZXRhaWxzJywgJ2RpcicsICdkaXYnLCAnZGwnLCAnZHQnLCAnZW1iZWQnLCAnZmllbGRzZXQnLCAnZmlnY2FwdGlvbicsICdmaWd1cmUnLCAnZm9vdGVyJywgJ2Zvcm0nLCAnZnJhbWUnLCAnZnJhbWVzZXQnLCAnaDEnLCAnaDInLCAnaDMnLCAnaDQnLCAnaDUnLCAnaDYnLCAnaGVhZCcsICdoZWFkZXInLCAnaGdyb3VwJywgJ2hyJywgJ2h0bWwnLCAnaWZyYW1lJywgJ2ltZycsICdpbnB1dCcsICdpc2luZGV4JywgJ2xpJywgJ2xpbmsnLCAnbGlzdGluZycsICdtYWluJywgJ21hcnF1ZWUnLCAnbWVudScsICdtZW51aXRlbScsICdtZXRhJywgJ25hdicsICdub2VtYmVkJywgJ25vZnJhbWVzJywgJ25vc2NyaXB0JywgJ29iamVjdCcsICdvbCcsICdwJywgJ3BhcmFtJywgJ3BsYWludGV4dCcsICdwcmUnLCAnc2NyaXB0JywgJ3NlY3Rpb24nLCAnc2VsZWN0JywgJ3NvdXJjZScsICdzdHlsZScsICdzdW1tYXJ5JywgJ3RhYmxlJywgJ3Rib2R5JywgJ3RkJywgJ3RlbXBsYXRlJywgJ3RleHRhcmVhJywgJ3Rmb290JywgJ3RoJywgJ3RoZWFkJywgJ3RpdGxlJywgJ3RyJywgJ3RyYWNrJywgJ3VsJywgJ3dicicsICd4bXAnXTtcblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNoYXMtYW4tZWxlbWVudC1pbi1zY29wZVxuICB2YXIgaW5TY29wZVRhZ3MgPSBbJ2FwcGxldCcsICdjYXB0aW9uJywgJ2h0bWwnLCAndGFibGUnLCAndGQnLCAndGgnLCAnbWFycXVlZScsICdvYmplY3QnLCAndGVtcGxhdGUnLFxuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2h0bWwtaW50ZWdyYXRpb24tcG9pbnRcbiAgLy8gVE9ETzogRGlzdGluZ3Vpc2ggYnkgbmFtZXNwYWNlIGhlcmUgLS0gZm9yIDx0aXRsZT4sIGluY2x1ZGluZyBpdCBoZXJlXG4gIC8vIGVycnMgb24gdGhlIHNpZGUgb2YgZmV3ZXIgd2FybmluZ3NcbiAgJ2ZvcmVpZ25PYmplY3QnLCAnZGVzYycsICd0aXRsZSddO1xuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2hhcy1hbi1lbGVtZW50LWluLWJ1dHRvbi1zY29wZVxuICB2YXIgYnV0dG9uU2NvcGVUYWdzID0gaW5TY29wZVRhZ3MuY29uY2F0KFsnYnV0dG9uJ10pO1xuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2dlbmVyYXRlLWltcGxpZWQtZW5kLXRhZ3NcbiAgdmFyIGltcGxpZWRFbmRUYWdzID0gWydkZCcsICdkdCcsICdsaScsICdvcHRpb24nLCAnb3B0Z3JvdXAnLCAncCcsICdycCcsICdydCddO1xuXG4gIHZhciBlbXB0eUFuY2VzdG9ySW5mbyA9IHtcbiAgICBjdXJyZW50OiBudWxsLFxuXG4gICAgZm9ybVRhZzogbnVsbCxcbiAgICBhVGFnSW5TY29wZTogbnVsbCxcbiAgICBidXR0b25UYWdJblNjb3BlOiBudWxsLFxuICAgIG5vYnJUYWdJblNjb3BlOiBudWxsLFxuICAgIHBUYWdJbkJ1dHRvblNjb3BlOiBudWxsLFxuXG4gICAgbGlzdEl0ZW1UYWdBdXRvY2xvc2luZzogbnVsbCxcbiAgICBkbEl0ZW1UYWdBdXRvY2xvc2luZzogbnVsbFxuICB9O1xuXG4gIHZhciB1cGRhdGVkQW5jZXN0b3JJbmZvJDEgPSBmdW5jdGlvbiAob2xkSW5mbywgdGFnLCBpbnN0YW5jZSkge1xuICAgIHZhciBhbmNlc3RvckluZm8gPSBfYXNzaWduKHt9LCBvbGRJbmZvIHx8IGVtcHR5QW5jZXN0b3JJbmZvKTtcbiAgICB2YXIgaW5mbyA9IHsgdGFnOiB0YWcsIGluc3RhbmNlOiBpbnN0YW5jZSB9O1xuXG4gICAgaWYgKGluU2NvcGVUYWdzLmluZGV4T2YodGFnKSAhPT0gLTEpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5hVGFnSW5TY29wZSA9IG51bGw7XG4gICAgICBhbmNlc3RvckluZm8uYnV0dG9uVGFnSW5TY29wZSA9IG51bGw7XG4gICAgICBhbmNlc3RvckluZm8ubm9iclRhZ0luU2NvcGUgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoYnV0dG9uU2NvcGVUYWdzLmluZGV4T2YodGFnKSAhPT0gLTEpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gU2VlIHJ1bGVzIGZvciAnbGknLCAnZGQnLCAnZHQnIHN0YXJ0IHRhZ3MgaW5cbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5ib2R5XG4gICAgaWYgKHNwZWNpYWxUYWdzLmluZGV4T2YodGFnKSAhPT0gLTEgJiYgdGFnICE9PSAnYWRkcmVzcycgJiYgdGFnICE9PSAnZGl2JyAmJiB0YWcgIT09ICdwJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmxpc3RJdGVtVGFnQXV0b2Nsb3NpbmcgPSBudWxsO1xuICAgICAgYW5jZXN0b3JJbmZvLmRsSXRlbVRhZ0F1dG9jbG9zaW5nID0gbnVsbDtcbiAgICB9XG5cbiAgICBhbmNlc3RvckluZm8uY3VycmVudCA9IGluZm87XG5cbiAgICBpZiAodGFnID09PSAnZm9ybScpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5mb3JtVGFnID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ2EnKSB7XG4gICAgICBhbmNlc3RvckluZm8uYVRhZ0luU2NvcGUgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnYnV0dG9uJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmJ1dHRvblRhZ0luU2NvcGUgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnbm9icicpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5ub2JyVGFnSW5TY29wZSA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdwJykge1xuICAgICAgYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ2xpJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmxpc3RJdGVtVGFnQXV0b2Nsb3NpbmcgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnZGQnIHx8IHRhZyA9PT0gJ2R0Jykge1xuICAgICAgYW5jZXN0b3JJbmZvLmRsSXRlbVRhZ0F1dG9jbG9zaW5nID0gaW5mbztcbiAgICB9XG5cbiAgICByZXR1cm4gYW5jZXN0b3JJbmZvO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXJcbiAgICovXG4gIHZhciBpc1RhZ1ZhbGlkV2l0aFBhcmVudCA9IGZ1bmN0aW9uICh0YWcsIHBhcmVudFRhZykge1xuICAgIC8vIEZpcnN0LCBsZXQncyBjaGVjayBpZiB3ZSdyZSBpbiBhbiB1bnVzdWFsIHBhcnNpbmcgbW9kZS4uLlxuICAgIHN3aXRjaCAocGFyZW50VGFnKSB7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5zZWxlY3RcbiAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdvcHRpb24nIHx8IHRhZyA9PT0gJ29wdGdyb3VwJyB8fCB0YWcgPT09ICcjdGV4dCc7XG4gICAgICBjYXNlICdvcHRncm91cCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdvcHRpb24nIHx8IHRhZyA9PT0gJyN0ZXh0JztcbiAgICAgIC8vIFN0cmljdGx5IHNwZWFraW5nLCBzZWVpbmcgYW4gPG9wdGlvbj4gZG9lc24ndCBtZWFuIHdlJ3JlIGluIGEgPHNlbGVjdD5cbiAgICAgIC8vIGJ1dFxuICAgICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJyN0ZXh0JztcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRkXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5jYXB0aW9uXG4gICAgICAvLyBObyBzcGVjaWFsIGJlaGF2aW9yIHNpbmNlIHRoZXNlIHJ1bGVzIGZhbGwgYmFjayB0byBcImluIGJvZHlcIiBtb2RlIGZvclxuICAgICAgLy8gYWxsIGV4Y2VwdCBzcGVjaWFsIHRhYmxlIG5vZGVzIHdoaWNoIGNhdXNlIGJhZCBwYXJzaW5nIGJlaGF2aW9yIGFueXdheS5cblxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludHJcbiAgICAgIGNhc2UgJ3RyJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ3RoJyB8fCB0YWcgPT09ICd0ZCcgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludGJvZHlcbiAgICAgIGNhc2UgJ3Rib2R5JzpcbiAgICAgIGNhc2UgJ3RoZWFkJzpcbiAgICAgIGNhc2UgJ3Rmb290JzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ3RyJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5jb2xncm91cFxuICAgICAgY2FzZSAnY29sZ3JvdXAnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnY29sJyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50YWJsZVxuICAgICAgY2FzZSAndGFibGUnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnY2FwdGlvbicgfHwgdGFnID09PSAnY29sZ3JvdXAnIHx8IHRhZyA9PT0gJ3Rib2R5JyB8fCB0YWcgPT09ICd0Zm9vdCcgfHwgdGFnID09PSAndGhlYWQnIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmhlYWRcbiAgICAgIGNhc2UgJ2hlYWQnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnYmFzZScgfHwgdGFnID09PSAnYmFzZWZvbnQnIHx8IHRhZyA9PT0gJ2Jnc291bmQnIHx8IHRhZyA9PT0gJ2xpbmsnIHx8IHRhZyA9PT0gJ21ldGEnIHx8IHRhZyA9PT0gJ3RpdGxlJyB8fCB0YWcgPT09ICdub3NjcmlwdCcgfHwgdGFnID09PSAnbm9mcmFtZXMnIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NlbWFudGljcy5odG1sI3RoZS1odG1sLWVsZW1lbnRcbiAgICAgIGNhc2UgJ2h0bWwnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnaGVhZCcgfHwgdGFnID09PSAnYm9keSc7XG4gICAgICBjYXNlICcjZG9jdW1lbnQnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnaHRtbCc7XG4gICAgfVxuXG4gICAgLy8gUHJvYmFibHkgaW4gdGhlIFwiaW4gYm9keVwiIHBhcnNpbmcgbW9kZSwgc28gd2Ugb3V0bGF3IG9ubHkgdGFnIGNvbWJvc1xuICAgIC8vIHdoZXJlIHRoZSBwYXJzaW5nIHJ1bGVzIGNhdXNlIGltcGxpY2l0IG9wZW5zIG9yIGNsb3NlcyB0byBiZSBhZGRlZC5cbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5ib2R5XG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgJ2gxJzpcbiAgICAgIGNhc2UgJ2gyJzpcbiAgICAgIGNhc2UgJ2gzJzpcbiAgICAgIGNhc2UgJ2g0JzpcbiAgICAgIGNhc2UgJ2g1JzpcbiAgICAgIGNhc2UgJ2g2JzpcbiAgICAgICAgcmV0dXJuIHBhcmVudFRhZyAhPT0gJ2gxJyAmJiBwYXJlbnRUYWcgIT09ICdoMicgJiYgcGFyZW50VGFnICE9PSAnaDMnICYmIHBhcmVudFRhZyAhPT0gJ2g0JyAmJiBwYXJlbnRUYWcgIT09ICdoNScgJiYgcGFyZW50VGFnICE9PSAnaDYnO1xuXG4gICAgICBjYXNlICdycCc6XG4gICAgICBjYXNlICdydCc6XG4gICAgICAgIHJldHVybiBpbXBsaWVkRW5kVGFncy5pbmRleE9mKHBhcmVudFRhZykgPT09IC0xO1xuXG4gICAgICBjYXNlICdib2R5JzpcbiAgICAgIGNhc2UgJ2NhcHRpb24nOlxuICAgICAgY2FzZSAnY29sJzpcbiAgICAgIGNhc2UgJ2NvbGdyb3VwJzpcbiAgICAgIGNhc2UgJ2ZyYW1lJzpcbiAgICAgIGNhc2UgJ2hlYWQnOlxuICAgICAgY2FzZSAnaHRtbCc6XG4gICAgICBjYXNlICd0Ym9keSc6XG4gICAgICBjYXNlICd0ZCc6XG4gICAgICBjYXNlICd0Zm9vdCc6XG4gICAgICBjYXNlICd0aCc6XG4gICAgICBjYXNlICd0aGVhZCc6XG4gICAgICBjYXNlICd0cic6XG4gICAgICAgIC8vIFRoZXNlIHRhZ3MgYXJlIG9ubHkgdmFsaWQgd2l0aCBhIGZldyBwYXJlbnRzIHRoYXQgaGF2ZSBzcGVjaWFsIGNoaWxkXG4gICAgICAgIC8vIHBhcnNpbmcgcnVsZXMgLS0gaWYgd2UncmUgZG93biBoZXJlLCB0aGVuIG5vbmUgb2YgdGhvc2UgbWF0Y2hlZCBhbmRcbiAgICAgICAgLy8gc28gd2UgYWxsb3cgaXQgb25seSBpZiB3ZSBkb24ndCBrbm93IHdoYXQgdGhlIHBhcmVudCBpcywgYXMgYWxsIG90aGVyXG4gICAgICAgIC8vIGNhc2VzIGFyZSBpbnZhbGlkLlxuICAgICAgICByZXR1cm4gcGFyZW50VGFnID09IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlclxuICAgKi9cbiAgdmFyIGZpbmRJbnZhbGlkQW5jZXN0b3JGb3JUYWcgPSBmdW5jdGlvbiAodGFnLCBhbmNlc3RvckluZm8pIHtcbiAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgY2FzZSAnYWRkcmVzcyc6XG4gICAgICBjYXNlICdhcnRpY2xlJzpcbiAgICAgIGNhc2UgJ2FzaWRlJzpcbiAgICAgIGNhc2UgJ2Jsb2NrcXVvdGUnOlxuICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgIGNhc2UgJ2RldGFpbHMnOlxuICAgICAgY2FzZSAnZGlhbG9nJzpcbiAgICAgIGNhc2UgJ2Rpcic6XG4gICAgICBjYXNlICdkaXYnOlxuICAgICAgY2FzZSAnZGwnOlxuICAgICAgY2FzZSAnZmllbGRzZXQnOlxuICAgICAgY2FzZSAnZmlnY2FwdGlvbic6XG4gICAgICBjYXNlICdmaWd1cmUnOlxuICAgICAgY2FzZSAnZm9vdGVyJzpcbiAgICAgIGNhc2UgJ2hlYWRlcic6XG4gICAgICBjYXNlICdoZ3JvdXAnOlxuICAgICAgY2FzZSAnbWFpbic6XG4gICAgICBjYXNlICdtZW51JzpcbiAgICAgIGNhc2UgJ25hdic6XG4gICAgICBjYXNlICdvbCc6XG4gICAgICBjYXNlICdwJzpcbiAgICAgIGNhc2UgJ3NlY3Rpb24nOlxuICAgICAgY2FzZSAnc3VtbWFyeSc6XG4gICAgICBjYXNlICd1bCc6XG4gICAgICBjYXNlICdwcmUnOlxuICAgICAgY2FzZSAnbGlzdGluZyc6XG4gICAgICBjYXNlICd0YWJsZSc6XG4gICAgICBjYXNlICdocic6XG4gICAgICBjYXNlICd4bXAnOlxuICAgICAgY2FzZSAnaDEnOlxuICAgICAgY2FzZSAnaDInOlxuICAgICAgY2FzZSAnaDMnOlxuICAgICAgY2FzZSAnaDQnOlxuICAgICAgY2FzZSAnaDUnOlxuICAgICAgY2FzZSAnaDYnOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlO1xuXG4gICAgICBjYXNlICdmb3JtJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5mb3JtVGFnIHx8IGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZTtcblxuICAgICAgY2FzZSAnbGknOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmxpc3RJdGVtVGFnQXV0b2Nsb3Npbmc7XG5cbiAgICAgIGNhc2UgJ2RkJzpcbiAgICAgIGNhc2UgJ2R0JzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZztcblxuICAgICAgY2FzZSAnYnV0dG9uJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5idXR0b25UYWdJblNjb3BlO1xuXG4gICAgICBjYXNlICdhJzpcbiAgICAgICAgLy8gU3BlYyBzYXlzIHNvbWV0aGluZyBhYm91dCBzdG9yaW5nIGEgbGlzdCBvZiBtYXJrZXJzLCBidXQgaXQgc291bmRzXG4gICAgICAgIC8vIGVxdWl2YWxlbnQgdG8gdGhpcyBjaGVjay5cbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5hVGFnSW5TY29wZTtcblxuICAgICAgY2FzZSAnbm9icic6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8ubm9iclRhZ0luU2NvcGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgdmFyIGRpZFdhcm4gPSB7fTtcblxuICB2YWxpZGF0ZURPTU5lc3RpbmcgPSBmdW5jdGlvbiAoY2hpbGRUYWcsIGNoaWxkVGV4dCwgYW5jZXN0b3JJbmZvKSB7XG4gICAgYW5jZXN0b3JJbmZvID0gYW5jZXN0b3JJbmZvIHx8IGVtcHR5QW5jZXN0b3JJbmZvO1xuICAgIHZhciBwYXJlbnRJbmZvID0gYW5jZXN0b3JJbmZvLmN1cnJlbnQ7XG4gICAgdmFyIHBhcmVudFRhZyA9IHBhcmVudEluZm8gJiYgcGFyZW50SW5mby50YWc7XG5cbiAgICBpZiAoY2hpbGRUZXh0ICE9IG51bGwpIHtcbiAgICAgIHdhcm5pbmcoY2hpbGRUYWcgPT0gbnVsbCwgJ3ZhbGlkYXRlRE9NTmVzdGluZzogd2hlbiBjaGlsZFRleHQgaXMgcGFzc2VkLCBjaGlsZFRhZyBzaG91bGQgYmUgbnVsbCcpO1xuICAgICAgY2hpbGRUYWcgPSAnI3RleHQnO1xuICAgIH1cblxuICAgIHZhciBpbnZhbGlkUGFyZW50ID0gaXNUYWdWYWxpZFdpdGhQYXJlbnQoY2hpbGRUYWcsIHBhcmVudFRhZykgPyBudWxsIDogcGFyZW50SW5mbztcbiAgICB2YXIgaW52YWxpZEFuY2VzdG9yID0gaW52YWxpZFBhcmVudCA/IG51bGwgOiBmaW5kSW52YWxpZEFuY2VzdG9yRm9yVGFnKGNoaWxkVGFnLCBhbmNlc3RvckluZm8pO1xuICAgIHZhciBpbnZhbGlkUGFyZW50T3JBbmNlc3RvciA9IGludmFsaWRQYXJlbnQgfHwgaW52YWxpZEFuY2VzdG9yO1xuICAgIGlmICghaW52YWxpZFBhcmVudE9yQW5jZXN0b3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYW5jZXN0b3JUYWcgPSBpbnZhbGlkUGFyZW50T3JBbmNlc3Rvci50YWc7XG4gICAgdmFyIGFkZGVuZHVtID0gZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQ2KCk7XG5cbiAgICB2YXIgd2FybktleSA9ICEhaW52YWxpZFBhcmVudCArICd8JyArIGNoaWxkVGFnICsgJ3wnICsgYW5jZXN0b3JUYWcgKyAnfCcgKyBhZGRlbmR1bTtcbiAgICBpZiAoZGlkV2Fyblt3YXJuS2V5XSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRXYXJuW3dhcm5LZXldID0gdHJ1ZTtcblxuICAgIHZhciB0YWdEaXNwbGF5TmFtZSA9IGNoaWxkVGFnO1xuICAgIHZhciB3aGl0ZXNwYWNlSW5mbyA9ICcnO1xuICAgIGlmIChjaGlsZFRhZyA9PT0gJyN0ZXh0Jykge1xuICAgICAgaWYgKC9cXFMvLnRlc3QoY2hpbGRUZXh0KSkge1xuICAgICAgICB0YWdEaXNwbGF5TmFtZSA9ICdUZXh0IG5vZGVzJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhZ0Rpc3BsYXlOYW1lID0gJ1doaXRlc3BhY2UgdGV4dCBub2Rlcyc7XG4gICAgICAgIHdoaXRlc3BhY2VJbmZvID0gXCIgTWFrZSBzdXJlIHlvdSBkb24ndCBoYXZlIGFueSBleHRyYSB3aGl0ZXNwYWNlIGJldHdlZW4gdGFncyBvbiBcIiArICdlYWNoIGxpbmUgb2YgeW91ciBzb3VyY2UgY29kZS4nO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0YWdEaXNwbGF5TmFtZSA9ICc8JyArIGNoaWxkVGFnICsgJz4nO1xuICAgIH1cblxuICAgIGlmIChpbnZhbGlkUGFyZW50KSB7XG4gICAgICB2YXIgaW5mbyA9ICcnO1xuICAgICAgaWYgKGFuY2VzdG9yVGFnID09PSAndGFibGUnICYmIGNoaWxkVGFnID09PSAndHInKSB7XG4gICAgICAgIGluZm8gKz0gJyBBZGQgYSA8dGJvZHk+IHRvIHlvdXIgY29kZSB0byBtYXRjaCB0aGUgRE9NIHRyZWUgZ2VuZXJhdGVkIGJ5ICcgKyAndGhlIGJyb3dzZXIuJztcbiAgICAgIH1cbiAgICAgIHdhcm5pbmcoZmFsc2UsICd2YWxpZGF0ZURPTU5lc3RpbmcoLi4uKTogJXMgY2Fubm90IGFwcGVhciBhcyBhIGNoaWxkIG9mIDwlcz4uJXMlcyVzJywgdGFnRGlzcGxheU5hbWUsIGFuY2VzdG9yVGFnLCB3aGl0ZXNwYWNlSW5mbywgaW5mbywgYWRkZW5kdW0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAndmFsaWRhdGVET01OZXN0aW5nKC4uLik6ICVzIGNhbm5vdCBhcHBlYXIgYXMgYSBkZXNjZW5kYW50IG9mICcgKyAnPCVzPi4lcycsIHRhZ0Rpc3BsYXlOYW1lLCBhbmNlc3RvclRhZywgYWRkZW5kdW0pO1xuICAgIH1cbiAgfTtcblxuICAvLyBUT0RPOiB0dXJuIHRoaXMgaW50byBhIG5hbWVkIGV4cG9ydFxuICB2YWxpZGF0ZURPTU5lc3RpbmcudXBkYXRlZEFuY2VzdG9ySW5mbyA9IHVwZGF0ZWRBbmNlc3RvckluZm8kMTtcblxuICAvLyBGb3IgdGVzdGluZ1xuICB2YWxpZGF0ZURPTU5lc3RpbmcuaXNUYWdWYWxpZEluQ29udGV4dCA9IGZ1bmN0aW9uICh0YWcsIGFuY2VzdG9ySW5mbykge1xuICAgIGFuY2VzdG9ySW5mbyA9IGFuY2VzdG9ySW5mbyB8fCBlbXB0eUFuY2VzdG9ySW5mbztcbiAgICB2YXIgcGFyZW50SW5mbyA9IGFuY2VzdG9ySW5mby5jdXJyZW50O1xuICAgIHZhciBwYXJlbnRUYWcgPSBwYXJlbnRJbmZvICYmIHBhcmVudEluZm8udGFnO1xuICAgIHJldHVybiBpc1RhZ1ZhbGlkV2l0aFBhcmVudCh0YWcsIHBhcmVudFRhZykgJiYgIWZpbmRJbnZhbGlkQW5jZXN0b3JGb3JUYWcodGFnLCBhbmNlc3RvckluZm8pO1xuICB9O1xufVxuXG52YXIgdmFsaWRhdGVET01OZXN0aW5nJDEgPSB2YWxpZGF0ZURPTU5lc3Rpbmc7XG5cbi8vIFRPRE86IGRpcmVjdCBpbXBvcnRzIGxpa2Ugc29tZS1wYWNrYWdlL3NyYy8qIGFyZSBiYWQuIEZpeCBtZS5cbnZhciBjcmVhdGVFbGVtZW50ID0gY3JlYXRlRWxlbWVudCQxO1xudmFyIGNyZWF0ZVRleHROb2RlID0gY3JlYXRlVGV4dE5vZGUkMTtcbnZhciBzZXRJbml0aWFsUHJvcGVydGllcyA9IHNldEluaXRpYWxQcm9wZXJ0aWVzJDE7XG52YXIgZGlmZlByb3BlcnRpZXMgPSBkaWZmUHJvcGVydGllcyQxO1xudmFyIHVwZGF0ZVByb3BlcnRpZXMgPSB1cGRhdGVQcm9wZXJ0aWVzJDE7XG52YXIgZGlmZkh5ZHJhdGVkUHJvcGVydGllcyA9IGRpZmZIeWRyYXRlZFByb3BlcnRpZXMkMTtcbnZhciBkaWZmSHlkcmF0ZWRUZXh0ID0gZGlmZkh5ZHJhdGVkVGV4dCQxO1xudmFyIHdhcm5Gb3JVbm1hdGNoZWRUZXh0ID0gd2FybkZvclVubWF0Y2hlZFRleHQkMTtcbnZhciB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50ID0gd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudCQxO1xudmFyIHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZVRleHQgPSB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0JDE7XG52YXIgd2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50ID0gd2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50JDE7XG52YXIgd2FybkZvckluc2VydGVkSHlkcmF0ZWRUZXh0ID0gd2FybkZvckluc2VydGVkSHlkcmF0ZWRUZXh0JDE7XG52YXIgdXBkYXRlZEFuY2VzdG9ySW5mbyA9IHZhbGlkYXRlRE9NTmVzdGluZyQxLnVwZGF0ZWRBbmNlc3RvckluZm87XG52YXIgcHJlY2FjaGVGaWJlck5vZGUgPSBwcmVjYWNoZUZpYmVyTm9kZSQxO1xudmFyIHVwZGF0ZUZpYmVyUHJvcHMgPSB1cGRhdGVGaWJlclByb3BzJDE7XG5cblxue1xuICB2YXIgU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkcgPSAnc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJztcbiAgaWYgKHR5cGVvZiBNYXAgIT09ICdmdW5jdGlvbicgfHwgTWFwLnByb3RvdHlwZSA9PSBudWxsIHx8IHR5cGVvZiBNYXAucHJvdG90eXBlLmZvckVhY2ggIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIFNldCAhPT0gJ2Z1bmN0aW9uJyB8fCBTZXQucHJvdG90eXBlID09IG51bGwgfHwgdHlwZW9mIFNldC5wcm90b3R5cGUuY2xlYXIgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIFNldC5wcm90b3R5cGUuZm9yRWFjaCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHdhcm5pbmcoZmFsc2UsICdSZWFjdCBkZXBlbmRzIG9uIE1hcCBhbmQgU2V0IGJ1aWx0LWluIHR5cGVzLiBNYWtlIHN1cmUgdGhhdCB5b3UgbG9hZCBhICcgKyAncG9seWZpbGwgaW4gb2xkZXIgYnJvd3NlcnMuIGh0dHA6Ly9mYi5tZS9yZWFjdC1wb2x5ZmlsbHMnKTtcbiAgfVxufVxuXG5pbmplY3Rpb24kMy5pbmplY3RGaWJlckNvbnRyb2xsZWRIb3N0Q29tcG9uZW50KFJlYWN0RE9NRmliZXJDb21wb25lbnQpO1xuXG52YXIgZXZlbnRzRW5hYmxlZCA9IG51bGw7XG52YXIgc2VsZWN0aW9uSW5mb3JtYXRpb24gPSBudWxsO1xuXG4vKipcbiAqIFRydWUgaWYgdGhlIHN1cHBsaWVkIERPTSBub2RlIGlzIGEgdmFsaWQgbm9kZSBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7P0RPTUVsZW1lbnR9IG5vZGUgVGhlIGNhbmRpZGF0ZSBET00gbm9kZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIERPTSBpcyBhIHZhbGlkIERPTSBub2RlLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRDb250YWluZXIobm9kZSkge1xuICByZXR1cm4gISEobm9kZSAmJiAobm9kZS5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFIHx8IG5vZGUubm9kZVR5cGUgPT09IERPQ1VNRU5UX05PREUgfHwgbm9kZS5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERSB8fCBub2RlLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUgJiYgbm9kZS5ub2RlVmFsdWUgPT09ICcgcmVhY3QtbW91bnQtcG9pbnQtdW5zdGFibGUgJykpO1xufVxuXG5mdW5jdGlvbiBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKSB7XG4gIGlmICghY29udGFpbmVyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBET0NVTUVOVF9OT0RFKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5kb2N1bWVudEVsZW1lbnQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5maXJzdENoaWxkO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZEh5ZHJhdGVEdWVUb0xlZ2FjeUhldXJpc3RpYyhjb250YWluZXIpIHtcbiAgdmFyIHJvb3RFbGVtZW50ID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gIHJldHVybiAhIShyb290RWxlbWVudCAmJiByb290RWxlbWVudC5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFICYmIHJvb3RFbGVtZW50Lmhhc0F0dHJpYnV0ZShST09UX0FUVFJJQlVURV9OQU1FKSk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZEF1dG9Gb2N1c0hvc3RDb21wb25lbnQodHlwZSwgcHJvcHMpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnYnV0dG9uJzpcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICByZXR1cm4gISFwcm9wcy5hdXRvRm9jdXM7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgRE9NUmVuZGVyZXIgPSByZWFjdFJlY29uY2lsZXIoe1xuICBnZXRSb290SG9zdENvbnRleHQ6IGZ1bmN0aW9uIChyb290Q29udGFpbmVySW5zdGFuY2UpIHtcbiAgICB2YXIgdHlwZSA9IHZvaWQgMDtcbiAgICB2YXIgbmFtZXNwYWNlID0gdm9pZCAwO1xuICAgIHZhciBub2RlVHlwZSA9IHJvb3RDb250YWluZXJJbnN0YW5jZS5ub2RlVHlwZTtcbiAgICBzd2l0Y2ggKG5vZGVUeXBlKSB7XG4gICAgICBjYXNlIERPQ1VNRU5UX05PREU6XG4gICAgICBjYXNlIERPQ1VNRU5UX0ZSQUdNRU5UX05PREU6XG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlID0gbm9kZVR5cGUgPT09IERPQ1VNRU5UX05PREUgPyAnI2RvY3VtZW50JyA6ICcjZnJhZ21lbnQnO1xuICAgICAgICAgIHZhciByb290ID0gcm9vdENvbnRhaW5lckluc3RhbmNlLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgICBuYW1lc3BhY2UgPSByb290ID8gcm9vdC5uYW1lc3BhY2VVUkkgOiBnZXRDaGlsZE5hbWVzcGFjZShudWxsLCAnJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgY29udGFpbmVyID0gbm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSA/IHJvb3RDb250YWluZXJJbnN0YW5jZS5wYXJlbnROb2RlIDogcm9vdENvbnRhaW5lckluc3RhbmNlO1xuICAgICAgICAgIHZhciBvd25OYW1lc3BhY2UgPSBjb250YWluZXIubmFtZXNwYWNlVVJJIHx8IG51bGw7XG4gICAgICAgICAgdHlwZSA9IGNvbnRhaW5lci50YWdOYW1lO1xuICAgICAgICAgIG5hbWVzcGFjZSA9IGdldENoaWxkTmFtZXNwYWNlKG93bk5hbWVzcGFjZSwgdHlwZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAge1xuICAgICAgdmFyIHZhbGlkYXRlZFRhZyA9IHR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciBfYW5jZXN0b3JJbmZvID0gdXBkYXRlZEFuY2VzdG9ySW5mbyhudWxsLCB2YWxpZGF0ZWRUYWcsIG51bGwpO1xuICAgICAgcmV0dXJuIHsgbmFtZXNwYWNlOiBuYW1lc3BhY2UsIGFuY2VzdG9ySW5mbzogX2FuY2VzdG9ySW5mbyB9O1xuICAgIH1cbiAgICByZXR1cm4gbmFtZXNwYWNlO1xuICB9LFxuICBnZXRDaGlsZEhvc3RDb250ZXh0OiBmdW5jdGlvbiAocGFyZW50SG9zdENvbnRleHQsIHR5cGUpIHtcbiAgICB7XG4gICAgICB2YXIgcGFyZW50SG9zdENvbnRleHREZXYgPSBwYXJlbnRIb3N0Q29udGV4dDtcbiAgICAgIHZhciBfbmFtZXNwYWNlID0gZ2V0Q2hpbGROYW1lc3BhY2UocGFyZW50SG9zdENvbnRleHREZXYubmFtZXNwYWNlLCB0eXBlKTtcbiAgICAgIHZhciBfYW5jZXN0b3JJbmZvMiA9IHVwZGF0ZWRBbmNlc3RvckluZm8ocGFyZW50SG9zdENvbnRleHREZXYuYW5jZXN0b3JJbmZvLCB0eXBlLCBudWxsKTtcbiAgICAgIHJldHVybiB7IG5hbWVzcGFjZTogX25hbWVzcGFjZSwgYW5jZXN0b3JJbmZvOiBfYW5jZXN0b3JJbmZvMiB9O1xuICAgIH1cbiAgICB2YXIgcGFyZW50TmFtZXNwYWNlID0gcGFyZW50SG9zdENvbnRleHQ7XG4gICAgcmV0dXJuIGdldENoaWxkTmFtZXNwYWNlKHBhcmVudE5hbWVzcGFjZSwgdHlwZSk7XG4gIH0sXG4gIGdldFB1YmxpY0luc3RhbmNlOiBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0sXG4gIHByZXBhcmVGb3JDb21taXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBldmVudHNFbmFibGVkID0gaXNFbmFibGVkKCk7XG4gICAgc2VsZWN0aW9uSW5mb3JtYXRpb24gPSBnZXRTZWxlY3Rpb25JbmZvcm1hdGlvbigpO1xuICAgIHNldEVuYWJsZWQoZmFsc2UpO1xuICB9LFxuICByZXNldEFmdGVyQ29tbWl0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmVzdG9yZVNlbGVjdGlvbihzZWxlY3Rpb25JbmZvcm1hdGlvbik7XG4gICAgc2VsZWN0aW9uSW5mb3JtYXRpb24gPSBudWxsO1xuICAgIHNldEVuYWJsZWQoZXZlbnRzRW5hYmxlZCk7XG4gICAgZXZlbnRzRW5hYmxlZCA9IG51bGw7XG4gIH0sXG4gIGNyZWF0ZUluc3RhbmNlOiBmdW5jdGlvbiAodHlwZSwgcHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgaG9zdENvbnRleHQsIGludGVybmFsSW5zdGFuY2VIYW5kbGUpIHtcbiAgICB2YXIgcGFyZW50TmFtZXNwYWNlID0gdm9pZCAwO1xuICAgIHtcbiAgICAgIC8vIFRPRE86IHRha2UgbmFtZXNwYWNlIGludG8gYWNjb3VudCB3aGVuIHZhbGlkYXRpbmcuXG4gICAgICB2YXIgaG9zdENvbnRleHREZXYgPSBob3N0Q29udGV4dDtcbiAgICAgIHZhbGlkYXRlRE9NTmVzdGluZyQxKHR5cGUsIG51bGwsIGhvc3RDb250ZXh0RGV2LmFuY2VzdG9ySW5mbyk7XG4gICAgICBpZiAodHlwZW9mIHByb3BzLmNoaWxkcmVuID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgcHJvcHMuY2hpbGRyZW4gPT09ICdudW1iZXInKSB7XG4gICAgICAgIHZhciBzdHJpbmcgPSAnJyArIHByb3BzLmNoaWxkcmVuO1xuICAgICAgICB2YXIgb3duQW5jZXN0b3JJbmZvID0gdXBkYXRlZEFuY2VzdG9ySW5mbyhob3N0Q29udGV4dERldi5hbmNlc3RvckluZm8sIHR5cGUsIG51bGwpO1xuICAgICAgICB2YWxpZGF0ZURPTU5lc3RpbmckMShudWxsLCBzdHJpbmcsIG93bkFuY2VzdG9ySW5mbyk7XG4gICAgICB9XG4gICAgICBwYXJlbnROYW1lc3BhY2UgPSBob3N0Q29udGV4dERldi5uYW1lc3BhY2U7XG4gICAgfVxuICAgIHZhciBkb21FbGVtZW50ID0gY3JlYXRlRWxlbWVudCh0eXBlLCBwcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBwYXJlbnROYW1lc3BhY2UpO1xuICAgIHByZWNhY2hlRmliZXJOb2RlKGludGVybmFsSW5zdGFuY2VIYW5kbGUsIGRvbUVsZW1lbnQpO1xuICAgIHVwZGF0ZUZpYmVyUHJvcHMoZG9tRWxlbWVudCwgcHJvcHMpO1xuICAgIHJldHVybiBkb21FbGVtZW50O1xuICB9LFxuICBhcHBlbmRJbml0aWFsQ2hpbGQ6IGZ1bmN0aW9uIChwYXJlbnRJbnN0YW5jZSwgY2hpbGQpIHtcbiAgICBwYXJlbnRJbnN0YW5jZS5hcHBlbmRDaGlsZChjaGlsZCk7XG4gIH0sXG4gIGZpbmFsaXplSW5pdGlhbENoaWxkcmVuOiBmdW5jdGlvbiAoZG9tRWxlbWVudCwgdHlwZSwgcHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSkge1xuICAgIHNldEluaXRpYWxQcm9wZXJ0aWVzKGRvbUVsZW1lbnQsIHR5cGUsIHByb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpO1xuICAgIHJldHVybiBzaG91bGRBdXRvRm9jdXNIb3N0Q29tcG9uZW50KHR5cGUsIHByb3BzKTtcbiAgfSxcbiAgcHJlcGFyZVVwZGF0ZTogZnVuY3Rpb24gKGRvbUVsZW1lbnQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBob3N0Q29udGV4dCkge1xuICAgIHtcbiAgICAgIHZhciBob3N0Q29udGV4dERldiA9IGhvc3RDb250ZXh0O1xuICAgICAgaWYgKHR5cGVvZiBuZXdQcm9wcy5jaGlsZHJlbiAhPT0gdHlwZW9mIG9sZFByb3BzLmNoaWxkcmVuICYmICh0eXBlb2YgbmV3UHJvcHMuY2hpbGRyZW4gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBuZXdQcm9wcy5jaGlsZHJlbiA9PT0gJ251bWJlcicpKSB7XG4gICAgICAgIHZhciBzdHJpbmcgPSAnJyArIG5ld1Byb3BzLmNoaWxkcmVuO1xuICAgICAgICB2YXIgb3duQW5jZXN0b3JJbmZvID0gdXBkYXRlZEFuY2VzdG9ySW5mbyhob3N0Q29udGV4dERldi5hbmNlc3RvckluZm8sIHR5cGUsIG51bGwpO1xuICAgICAgICB2YWxpZGF0ZURPTU5lc3RpbmckMShudWxsLCBzdHJpbmcsIG93bkFuY2VzdG9ySW5mbyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkaWZmUHJvcGVydGllcyhkb21FbGVtZW50LCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSk7XG4gIH0sXG4gIHNob3VsZFNldFRleHRDb250ZW50OiBmdW5jdGlvbiAodHlwZSwgcHJvcHMpIHtcbiAgICByZXR1cm4gdHlwZSA9PT0gJ3RleHRhcmVhJyB8fCB0eXBlb2YgcHJvcHMuY2hpbGRyZW4gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBwcm9wcy5jaGlsZHJlbiA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID09PSAnb2JqZWN0JyAmJiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCAhPT0gbnVsbCAmJiB0eXBlb2YgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwuX19odG1sID09PSAnc3RyaW5nJztcbiAgfSxcbiAgc2hvdWxkRGVwcmlvcml0aXplU3VidHJlZTogZnVuY3Rpb24gKHR5cGUsIHByb3BzKSB7XG4gICAgcmV0dXJuICEhcHJvcHMuaGlkZGVuO1xuICB9LFxuICBjcmVhdGVUZXh0SW5zdGFuY2U6IGZ1bmN0aW9uICh0ZXh0LCByb290Q29udGFpbmVySW5zdGFuY2UsIGhvc3RDb250ZXh0LCBpbnRlcm5hbEluc3RhbmNlSGFuZGxlKSB7XG4gICAge1xuICAgICAgdmFyIGhvc3RDb250ZXh0RGV2ID0gaG9zdENvbnRleHQ7XG4gICAgICB2YWxpZGF0ZURPTU5lc3RpbmckMShudWxsLCB0ZXh0LCBob3N0Q29udGV4dERldi5hbmNlc3RvckluZm8pO1xuICAgIH1cbiAgICB2YXIgdGV4dE5vZGUgPSBjcmVhdGVUZXh0Tm9kZSh0ZXh0LCByb290Q29udGFpbmVySW5zdGFuY2UpO1xuICAgIHByZWNhY2hlRmliZXJOb2RlKGludGVybmFsSW5zdGFuY2VIYW5kbGUsIHRleHROb2RlKTtcbiAgICByZXR1cm4gdGV4dE5vZGU7XG4gIH0sXG5cblxuICBub3c6IG5vdyxcblxuICBtdXRhdGlvbjoge1xuICAgIGNvbW1pdE1vdW50OiBmdW5jdGlvbiAoZG9tRWxlbWVudCwgdHlwZSwgbmV3UHJvcHMsIGludGVybmFsSW5zdGFuY2VIYW5kbGUpIHtcbiAgICAgIGRvbUVsZW1lbnQuZm9jdXMoKTtcbiAgICB9LFxuICAgIGNvbW1pdFVwZGF0ZTogZnVuY3Rpb24gKGRvbUVsZW1lbnQsIHVwZGF0ZVBheWxvYWQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSkge1xuICAgICAgLy8gVXBkYXRlIHRoZSBwcm9wcyBoYW5kbGUgc28gdGhhdCB3ZSBrbm93IHdoaWNoIHByb3BzIGFyZSB0aGUgb25lcyB3aXRoXG4gICAgICAvLyB3aXRoIGN1cnJlbnQgZXZlbnQgaGFuZGxlcnMuXG4gICAgICB1cGRhdGVGaWJlclByb3BzKGRvbUVsZW1lbnQsIG5ld1Byb3BzKTtcbiAgICAgIC8vIEFwcGx5IHRoZSBkaWZmIHRvIHRoZSBET00gbm9kZS5cbiAgICAgIHVwZGF0ZVByb3BlcnRpZXMoZG9tRWxlbWVudCwgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzKTtcbiAgICB9LFxuICAgIHJlc2V0VGV4dENvbnRlbnQ6IGZ1bmN0aW9uIChkb21FbGVtZW50KSB7XG4gICAgICBkb21FbGVtZW50LnRleHRDb250ZW50ID0gJyc7XG4gICAgfSxcbiAgICBjb21taXRUZXh0VXBkYXRlOiBmdW5jdGlvbiAodGV4dEluc3RhbmNlLCBvbGRUZXh0LCBuZXdUZXh0KSB7XG4gICAgICB0ZXh0SW5zdGFuY2Uubm9kZVZhbHVlID0gbmV3VGV4dDtcbiAgICB9LFxuICAgIGFwcGVuZENoaWxkOiBmdW5jdGlvbiAocGFyZW50SW5zdGFuY2UsIGNoaWxkKSB7XG4gICAgICBwYXJlbnRJbnN0YW5jZS5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgfSxcbiAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyOiBmdW5jdGlvbiAoY29udGFpbmVyLCBjaGlsZCkge1xuICAgICAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFKSB7XG4gICAgICAgIGNvbnRhaW5lci5wYXJlbnROb2RlLmluc2VydEJlZm9yZShjaGlsZCwgY29udGFpbmVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBpbnNlcnRCZWZvcmU6IGZ1bmN0aW9uIChwYXJlbnRJbnN0YW5jZSwgY2hpbGQsIGJlZm9yZUNoaWxkKSB7XG4gICAgICBwYXJlbnRJbnN0YW5jZS5pbnNlcnRCZWZvcmUoY2hpbGQsIGJlZm9yZUNoaWxkKTtcbiAgICB9LFxuICAgIGluc2VydEluQ29udGFpbmVyQmVmb3JlOiBmdW5jdGlvbiAoY29udGFpbmVyLCBjaGlsZCwgYmVmb3JlQ2hpbGQpIHtcbiAgICAgIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSkge1xuICAgICAgICBjb250YWluZXIucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoY2hpbGQsIGJlZm9yZUNoaWxkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRhaW5lci5pbnNlcnRCZWZvcmUoY2hpbGQsIGJlZm9yZUNoaWxkKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbW92ZUNoaWxkOiBmdW5jdGlvbiAocGFyZW50SW5zdGFuY2UsIGNoaWxkKSB7XG4gICAgICBwYXJlbnRJbnN0YW5jZS5yZW1vdmVDaGlsZChjaGlsZCk7XG4gICAgfSxcbiAgICByZW1vdmVDaGlsZEZyb21Db250YWluZXI6IGZ1bmN0aW9uIChjb250YWluZXIsIGNoaWxkKSB7XG4gICAgICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUpIHtcbiAgICAgICAgY29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgaHlkcmF0aW9uOiB7XG4gICAgY2FuSHlkcmF0ZUluc3RhbmNlOiBmdW5jdGlvbiAoaW5zdGFuY2UsIHR5cGUsIHByb3BzKSB7XG4gICAgICBpZiAoaW5zdGFuY2Uubm9kZVR5cGUgIT09IEVMRU1FTlRfTk9ERSB8fCB0eXBlLnRvTG93ZXJDYXNlKCkgIT09IGluc3RhbmNlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICAvLyBUaGlzIGhhcyBub3cgYmVlbiByZWZpbmVkIHRvIGFuIGVsZW1lbnQgbm9kZS5cbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9LFxuICAgIGNhbkh5ZHJhdGVUZXh0SW5zdGFuY2U6IGZ1bmN0aW9uIChpbnN0YW5jZSwgdGV4dCkge1xuICAgICAgaWYgKHRleHQgPT09ICcnIHx8IGluc3RhbmNlLm5vZGVUeXBlICE9PSBURVhUX05PREUpIHtcbiAgICAgICAgLy8gRW1wdHkgc3RyaW5ncyBhcmUgbm90IHBhcnNlZCBieSBIVE1MIHNvIHRoZXJlIHdvbid0IGJlIGEgY29ycmVjdCBtYXRjaCBoZXJlLlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIC8vIFRoaXMgaGFzIG5vdyBiZWVuIHJlZmluZWQgdG8gYSB0ZXh0IG5vZGUuXG4gICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfSxcbiAgICBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmc6IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgICAgdmFyIG5vZGUgPSBpbnN0YW5jZS5uZXh0U2libGluZztcbiAgICAgIC8vIFNraXAgbm9uLWh5ZHJhdGFibGUgbm9kZXMuXG4gICAgICB3aGlsZSAobm9kZSAmJiBub2RlLm5vZGVUeXBlICE9PSBFTEVNRU5UX05PREUgJiYgbm9kZS5ub2RlVHlwZSAhPT0gVEVYVF9OT0RFKSB7XG4gICAgICAgIG5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSxcbiAgICBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZDogZnVuY3Rpb24gKHBhcmVudEluc3RhbmNlKSB7XG4gICAgICB2YXIgbmV4dCA9IHBhcmVudEluc3RhbmNlLmZpcnN0Q2hpbGQ7XG4gICAgICAvLyBTa2lwIG5vbi1oeWRyYXRhYmxlIG5vZGVzLlxuICAgICAgd2hpbGUgKG5leHQgJiYgbmV4dC5ub2RlVHlwZSAhPT0gRUxFTUVOVF9OT0RFICYmIG5leHQubm9kZVR5cGUgIT09IFRFWFRfTk9ERSkge1xuICAgICAgICBuZXh0ID0gbmV4dC5uZXh0U2libGluZztcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH0sXG4gICAgaHlkcmF0ZUluc3RhbmNlOiBmdW5jdGlvbiAoaW5zdGFuY2UsIHR5cGUsIHByb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGhvc3RDb250ZXh0LCBpbnRlcm5hbEluc3RhbmNlSGFuZGxlKSB7XG4gICAgICBwcmVjYWNoZUZpYmVyTm9kZShpbnRlcm5hbEluc3RhbmNlSGFuZGxlLCBpbnN0YW5jZSk7XG4gICAgICAvLyBUT0RPOiBQb3NzaWJseSBkZWZlciB0aGlzIHVudGlsIHRoZSBjb21taXQgcGhhc2Ugd2hlcmUgYWxsIHRoZSBldmVudHNcbiAgICAgIC8vIGdldCBhdHRhY2hlZC5cbiAgICAgIHVwZGF0ZUZpYmVyUHJvcHMoaW5zdGFuY2UsIHByb3BzKTtcbiAgICAgIHZhciBwYXJlbnROYW1lc3BhY2UgPSB2b2lkIDA7XG4gICAgICB7XG4gICAgICAgIHZhciBob3N0Q29udGV4dERldiA9IGhvc3RDb250ZXh0O1xuICAgICAgICBwYXJlbnROYW1lc3BhY2UgPSBob3N0Q29udGV4dERldi5uYW1lc3BhY2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGlmZkh5ZHJhdGVkUHJvcGVydGllcyhpbnN0YW5jZSwgdHlwZSwgcHJvcHMsIHBhcmVudE5hbWVzcGFjZSwgcm9vdENvbnRhaW5lckluc3RhbmNlKTtcbiAgICB9LFxuICAgIGh5ZHJhdGVUZXh0SW5zdGFuY2U6IGZ1bmN0aW9uICh0ZXh0SW5zdGFuY2UsIHRleHQsIGludGVybmFsSW5zdGFuY2VIYW5kbGUpIHtcbiAgICAgIHByZWNhY2hlRmliZXJOb2RlKGludGVybmFsSW5zdGFuY2VIYW5kbGUsIHRleHRJbnN0YW5jZSk7XG4gICAgICByZXR1cm4gZGlmZkh5ZHJhdGVkVGV4dCh0ZXh0SW5zdGFuY2UsIHRleHQpO1xuICAgIH0sXG4gICAgZGlkTm90TWF0Y2hIeWRyYXRlZENvbnRhaW5lclRleHRJbnN0YW5jZTogZnVuY3Rpb24gKHBhcmVudENvbnRhaW5lciwgdGV4dEluc3RhbmNlLCB0ZXh0KSB7XG4gICAgICB7XG4gICAgICAgIHdhcm5Gb3JVbm1hdGNoZWRUZXh0KHRleHRJbnN0YW5jZSwgdGV4dCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkaWROb3RNYXRjaEh5ZHJhdGVkVGV4dEluc3RhbmNlOiBmdW5jdGlvbiAocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCB0ZXh0SW5zdGFuY2UsIHRleHQpIHtcbiAgICAgIGlmICh0cnVlICYmIHBhcmVudFByb3BzW1NVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HXSAhPT0gdHJ1ZSkge1xuICAgICAgICB3YXJuRm9yVW5tYXRjaGVkVGV4dCh0ZXh0SW5zdGFuY2UsIHRleHQpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZGlkTm90SHlkcmF0ZUNvbnRhaW5lckluc3RhbmNlOiBmdW5jdGlvbiAocGFyZW50Q29udGFpbmVyLCBpbnN0YW5jZSkge1xuICAgICAge1xuICAgICAgICBpZiAoaW5zdGFuY2Uubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50KHBhcmVudENvbnRhaW5lciwgaW5zdGFuY2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZVRleHQocGFyZW50Q29udGFpbmVyLCBpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGRpZE5vdEh5ZHJhdGVJbnN0YW5jZTogZnVuY3Rpb24gKHBhcmVudFR5cGUsIHBhcmVudFByb3BzLCBwYXJlbnRJbnN0YW5jZSwgaW5zdGFuY2UpIHtcbiAgICAgIGlmICh0cnVlICYmIHBhcmVudFByb3BzW1NVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HXSAhPT0gdHJ1ZSkge1xuICAgICAgICBpZiAoaW5zdGFuY2Uubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50KHBhcmVudEluc3RhbmNlLCBpbnN0YW5jZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dChwYXJlbnRJbnN0YW5jZSwgaW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lckluc3RhbmNlOiBmdW5jdGlvbiAocGFyZW50Q29udGFpbmVyLCB0eXBlLCBwcm9wcykge1xuICAgICAge1xuICAgICAgICB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZEVsZW1lbnQocGFyZW50Q29udGFpbmVyLCB0eXBlLCBwcm9wcyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lclRleHRJbnN0YW5jZTogZnVuY3Rpb24gKHBhcmVudENvbnRhaW5lciwgdGV4dCkge1xuICAgICAge1xuICAgICAgICB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZFRleHQocGFyZW50Q29udGFpbmVyLCB0ZXh0KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlSW5zdGFuY2U6IGZ1bmN0aW9uIChwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIHR5cGUsIHByb3BzKSB7XG4gICAgICBpZiAodHJ1ZSAmJiBwYXJlbnRQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklOR10gIT09IHRydWUpIHtcbiAgICAgICAgd2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50KHBhcmVudEluc3RhbmNlLCB0eXBlLCBwcm9wcyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkaWROb3RGaW5kSHlkcmF0YWJsZVRleHRJbnN0YW5jZTogZnVuY3Rpb24gKHBhcmVudFR5cGUsIHBhcmVudFByb3BzLCBwYXJlbnRJbnN0YW5jZSwgdGV4dCkge1xuICAgICAgaWYgKHRydWUgJiYgcGFyZW50UHJvcHNbU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkddICE9PSB0cnVlKSB7XG4gICAgICAgIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dChwYXJlbnRJbnN0YW5jZSwgdGV4dCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHNjaGVkdWxlRGVmZXJyZWRDYWxsYmFjazogcklDLFxuICBjYW5jZWxEZWZlcnJlZENhbGxiYWNrOiBjSUMsXG5cbiAgdXNlU3luY1NjaGVkdWxpbmc6ICFlbmFibGVBc3luY1NjaGVkdWxpbmdCeURlZmF1bHRJblJlYWN0RE9NXG59KTtcblxuaW5qZWN0aW9uJDQuaW5qZWN0RmliZXJCYXRjaGVkVXBkYXRlcyhET01SZW5kZXJlci5iYXRjaGVkVXBkYXRlcyk7XG5cbnZhciB3YXJuZWRBYm91dEh5ZHJhdGVBUEkgPSBmYWxzZTtcblxuZnVuY3Rpb24gcmVuZGVyU3VidHJlZUludG9Db250YWluZXIocGFyZW50Q29tcG9uZW50LCBjaGlsZHJlbiwgY29udGFpbmVyLCBmb3JjZUh5ZHJhdGUsIGNhbGxiYWNrKSB7XG4gICFpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lcikgPyBpbnZhcmlhbnQoZmFsc2UsICdUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LicpIDogdm9pZCAwO1xuXG4gIHtcbiAgICBpZiAoY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXIgJiYgY29udGFpbmVyLm5vZGVUeXBlICE9PSBDT01NRU5UX05PREUpIHtcbiAgICAgIHZhciBob3N0SW5zdGFuY2UgPSBET01SZW5kZXJlci5maW5kSG9zdEluc3RhbmNlV2l0aE5vUG9ydGFscyhjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lci5jdXJyZW50KTtcbiAgICAgIGlmIChob3N0SW5zdGFuY2UpIHtcbiAgICAgICAgd2FybmluZyhob3N0SW5zdGFuY2UucGFyZW50Tm9kZSA9PT0gY29udGFpbmVyLCAncmVuZGVyKC4uLik6IEl0IGxvb2tzIGxpa2UgdGhlIFJlYWN0LXJlbmRlcmVkIGNvbnRlbnQgb2YgdGhpcyAnICsgJ2NvbnRhaW5lciB3YXMgcmVtb3ZlZCB3aXRob3V0IHVzaW5nIFJlYWN0LiBUaGlzIGlzIG5vdCAnICsgJ3N1cHBvcnRlZCBhbmQgd2lsbCBjYXVzZSBlcnJvcnMuIEluc3RlYWQsIGNhbGwgJyArICdSZWFjdERPTS51bm1vdW50Q29tcG9uZW50QXROb2RlIHRvIGVtcHR5IGEgY29udGFpbmVyLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBpc1Jvb3RSZW5kZXJlZEJ5U29tZVJlYWN0ID0gISFjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lcjtcbiAgICB2YXIgcm9vdEVsID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgdmFyIGhhc05vblJvb3RSZWFjdENoaWxkID0gISEocm9vdEVsICYmIGdldEluc3RhbmNlRnJvbU5vZGUkMShyb290RWwpKTtcblxuICAgIHdhcm5pbmcoIWhhc05vblJvb3RSZWFjdENoaWxkIHx8IGlzUm9vdFJlbmRlcmVkQnlTb21lUmVhY3QsICdyZW5kZXIoLi4uKTogUmVwbGFjaW5nIFJlYWN0LXJlbmRlcmVkIGNoaWxkcmVuIHdpdGggYSBuZXcgcm9vdCAnICsgJ2NvbXBvbmVudC4gSWYgeW91IGludGVuZGVkIHRvIHVwZGF0ZSB0aGUgY2hpbGRyZW4gb2YgdGhpcyBub2RlLCAnICsgJ3lvdSBzaG91bGQgaW5zdGVhZCBoYXZlIHRoZSBleGlzdGluZyBjaGlsZHJlbiB1cGRhdGUgdGhlaXIgc3RhdGUgJyArICdhbmQgcmVuZGVyIHRoZSBuZXcgY29tcG9uZW50cyBpbnN0ZWFkIG9mIGNhbGxpbmcgUmVhY3RET00ucmVuZGVyLicpO1xuXG4gICAgd2FybmluZyhjb250YWluZXIubm9kZVR5cGUgIT09IEVMRU1FTlRfTk9ERSB8fCAhY29udGFpbmVyLnRhZ05hbWUgfHwgY29udGFpbmVyLnRhZ05hbWUudG9VcHBlckNhc2UoKSAhPT0gJ0JPRFknLCAncmVuZGVyKCk6IFJlbmRlcmluZyBjb21wb25lbnRzIGRpcmVjdGx5IGludG8gZG9jdW1lbnQuYm9keSBpcyAnICsgJ2Rpc2NvdXJhZ2VkLCBzaW5jZSBpdHMgY2hpbGRyZW4gYXJlIG9mdGVuIG1hbmlwdWxhdGVkIGJ5IHRoaXJkLXBhcnR5ICcgKyAnc2NyaXB0cyBhbmQgYnJvd3NlciBleHRlbnNpb25zLiBUaGlzIG1heSBsZWFkIHRvIHN1YnRsZSAnICsgJ3JlY29uY2lsaWF0aW9uIGlzc3Vlcy4gVHJ5IHJlbmRlcmluZyBpbnRvIGEgY29udGFpbmVyIGVsZW1lbnQgY3JlYXRlZCAnICsgJ2ZvciB5b3VyIGFwcC4nKTtcbiAgfVxuXG4gIHZhciByb290ID0gY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXI7XG4gIGlmICghcm9vdCkge1xuICAgIHZhciBzaG91bGRIeWRyYXRlID0gZm9yY2VIeWRyYXRlIHx8IHNob3VsZEh5ZHJhdGVEdWVUb0xlZ2FjeUhldXJpc3RpYyhjb250YWluZXIpO1xuICAgIC8vIEZpcnN0IGNsZWFyIGFueSBleGlzdGluZyBjb250ZW50LlxuICAgIGlmICghc2hvdWxkSHlkcmF0ZSkge1xuICAgICAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICAgICAgdmFyIHJvb3RTaWJsaW5nID0gdm9pZCAwO1xuICAgICAgd2hpbGUgKHJvb3RTaWJsaW5nID0gY29udGFpbmVyLmxhc3RDaGlsZCkge1xuICAgICAgICB7XG4gICAgICAgICAgaWYgKCF3YXJuZWQgJiYgcm9vdFNpYmxpbmcubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSAmJiByb290U2libGluZy5oYXNBdHRyaWJ1dGUoUk9PVF9BVFRSSUJVVEVfTkFNRSkpIHtcbiAgICAgICAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAncmVuZGVyKCk6IFRhcmdldCBub2RlIGhhcyBtYXJrdXAgcmVuZGVyZWQgYnkgUmVhY3QsIGJ1dCB0aGVyZSAnICsgJ2FyZSB1bnJlbGF0ZWQgbm9kZXMgYXMgd2VsbC4gVGhpcyBpcyBtb3N0IGNvbW1vbmx5IGNhdXNlZCBieSAnICsgJ3doaXRlLXNwYWNlIGluc2VydGVkIGFyb3VuZCBzZXJ2ZXItcmVuZGVyZWQgbWFya3VwLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQocm9vdFNpYmxpbmcpO1xuICAgICAgfVxuICAgIH1cbiAgICB7XG4gICAgICBpZiAoc2hvdWxkSHlkcmF0ZSAmJiAhZm9yY2VIeWRyYXRlICYmICF3YXJuZWRBYm91dEh5ZHJhdGVBUEkpIHtcbiAgICAgICAgd2FybmVkQWJvdXRIeWRyYXRlQVBJID0gdHJ1ZTtcbiAgICAgICAgbG93UHJpb3JpdHlXYXJuaW5nJDEoZmFsc2UsICdyZW5kZXIoKTogQ2FsbGluZyBSZWFjdERPTS5yZW5kZXIoKSB0byBoeWRyYXRlIHNlcnZlci1yZW5kZXJlZCBtYXJrdXAgJyArICd3aWxsIHN0b3Agd29ya2luZyBpbiBSZWFjdCB2MTcuIFJlcGxhY2UgdGhlIFJlYWN0RE9NLnJlbmRlcigpIGNhbGwgJyArICd3aXRoIFJlYWN0RE9NLmh5ZHJhdGUoKSBpZiB5b3Ugd2FudCBSZWFjdCB0byBhdHRhY2ggdG8gdGhlIHNlcnZlciBIVE1MLicpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgbmV3Um9vdCA9IERPTVJlbmRlcmVyLmNyZWF0ZUNvbnRhaW5lcihjb250YWluZXIsIHNob3VsZEh5ZHJhdGUpO1xuICAgIHJvb3QgPSBjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lciA9IG5ld1Jvb3Q7XG4gICAgLy8gSW5pdGlhbCBtb3VudCBzaG91bGQgbm90IGJlIGJhdGNoZWQuXG4gICAgRE9NUmVuZGVyZXIudW5iYXRjaGVkVXBkYXRlcyhmdW5jdGlvbiAoKSB7XG4gICAgICBET01SZW5kZXJlci51cGRhdGVDb250YWluZXIoY2hpbGRyZW4sIG5ld1Jvb3QsIHBhcmVudENvbXBvbmVudCwgY2FsbGJhY2spO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIERPTVJlbmRlcmVyLnVwZGF0ZUNvbnRhaW5lcihjaGlsZHJlbiwgcm9vdCwgcGFyZW50Q29tcG9uZW50LCBjYWxsYmFjayk7XG4gIH1cbiAgcmV0dXJuIERPTVJlbmRlcmVyLmdldFB1YmxpY1Jvb3RJbnN0YW5jZShyb290KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUG9ydGFsKGNoaWxkcmVuLCBjb250YWluZXIpIHtcbiAgdmFyIGtleSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogbnVsbDtcblxuICAhaXNWYWxpZENvbnRhaW5lcihjb250YWluZXIpID8gaW52YXJpYW50KGZhbHNlLCAnVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgYSBET00gZWxlbWVudC4nKSA6IHZvaWQgMDtcbiAgLy8gVE9ETzogcGFzcyBSZWFjdERPTSBwb3J0YWwgaW1wbGVtZW50YXRpb24gYXMgdGhpcmQgYXJndW1lbnRcbiAgcmV0dXJuIGNyZWF0ZVBvcnRhbCQxKGNoaWxkcmVuLCBjb250YWluZXIsIG51bGwsIGtleSk7XG59XG5cbmZ1bmN0aW9uIFJlYWN0Um9vdChjb250YWluZXIsIGh5ZHJhdGUpIHtcbiAgdmFyIHJvb3QgPSBET01SZW5kZXJlci5jcmVhdGVDb250YWluZXIoY29udGFpbmVyLCBoeWRyYXRlKTtcbiAgdGhpcy5fcmVhY3RSb290Q29udGFpbmVyID0gcm9vdDtcbn1cblJlYWN0Um9vdC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKGNoaWxkcmVuLCBjYWxsYmFjaykge1xuICB2YXIgcm9vdCA9IHRoaXMuX3JlYWN0Um9vdENvbnRhaW5lcjtcbiAgRE9NUmVuZGVyZXIudXBkYXRlQ29udGFpbmVyKGNoaWxkcmVuLCByb290LCBudWxsLCBjYWxsYmFjayk7XG59O1xuUmVhY3RSb290LnByb3RvdHlwZS51bm1vdW50ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIHZhciByb290ID0gdGhpcy5fcmVhY3RSb290Q29udGFpbmVyO1xuICBET01SZW5kZXJlci51cGRhdGVDb250YWluZXIobnVsbCwgcm9vdCwgbnVsbCwgY2FsbGJhY2spO1xufTtcblxudmFyIFJlYWN0RE9NID0ge1xuICBjcmVhdGVQb3J0YWw6IGNyZWF0ZVBvcnRhbCxcblxuICBmaW5kRE9NTm9kZTogZnVuY3Rpb24gKGNvbXBvbmVudE9yRWxlbWVudCkge1xuICAgIHtcbiAgICAgIHZhciBvd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgICBpZiAob3duZXIgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHdhcm5lZEFib3V0UmVmc0luUmVuZGVyID0gb3duZXIuc3RhdGVOb2RlLl93YXJuZWRBYm91dFJlZnNJblJlbmRlcjtcbiAgICAgICAgd2FybmluZyh3YXJuZWRBYm91dFJlZnNJblJlbmRlciwgJyVzIGlzIGFjY2Vzc2luZyBmaW5kRE9NTm9kZSBpbnNpZGUgaXRzIHJlbmRlcigpLiAnICsgJ3JlbmRlcigpIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlLiBJdCBzaG91bGQgJyArICduZXZlciBhY2Nlc3Mgc29tZXRoaW5nIHRoYXQgcmVxdWlyZXMgc3RhbGUgZGF0YSBmcm9tIHRoZSBwcmV2aW91cyAnICsgJ3JlbmRlciwgc3VjaCBhcyByZWZzLiBNb3ZlIHRoaXMgbG9naWMgdG8gY29tcG9uZW50RGlkTW91bnQgYW5kICcgKyAnY29tcG9uZW50RGlkVXBkYXRlIGluc3RlYWQuJywgZ2V0Q29tcG9uZW50TmFtZShvd25lcikgfHwgJ0EgY29tcG9uZW50Jyk7XG4gICAgICAgIG93bmVyLnN0YXRlTm9kZS5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29tcG9uZW50T3JFbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoY29tcG9uZW50T3JFbGVtZW50Lm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUpIHtcbiAgICAgIHJldHVybiBjb21wb25lbnRPckVsZW1lbnQ7XG4gICAgfVxuXG4gICAgdmFyIGluc3QgPSBnZXQoY29tcG9uZW50T3JFbGVtZW50KTtcbiAgICBpZiAoaW5zdCkge1xuICAgICAgcmV0dXJuIERPTVJlbmRlcmVyLmZpbmRIb3N0SW5zdGFuY2UoaW5zdCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjb21wb25lbnRPckVsZW1lbnQucmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ0VsZW1lbnQgYXBwZWFycyB0byBiZSBuZWl0aGVyIFJlYWN0Q29tcG9uZW50IG5vciBET01Ob2RlLiBLZXlzOiAlcycsIE9iamVjdC5rZXlzKGNvbXBvbmVudE9yRWxlbWVudCkpO1xuICAgIH1cbiAgfSxcbiAgaHlkcmF0ZTogZnVuY3Rpb24gKGVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcbiAgICAvLyBUT0RPOiB0aHJvdyBvciB3YXJuIGlmIHdlIGNvdWxkbid0IGh5ZHJhdGU/XG4gICAgcmV0dXJuIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKG51bGwsIGVsZW1lbnQsIGNvbnRhaW5lciwgdHJ1ZSwgY2FsbGJhY2spO1xuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIChlbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKG51bGwsIGVsZW1lbnQsIGNvbnRhaW5lciwgZmFsc2UsIGNhbGxiYWNrKTtcbiAgfSxcbiAgdW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXI6IGZ1bmN0aW9uIChwYXJlbnRDb21wb25lbnQsIGVsZW1lbnQsIGNvbnRhaW5lck5vZGUsIGNhbGxiYWNrKSB7XG4gICAgIShwYXJlbnRDb21wb25lbnQgIT0gbnVsbCAmJiBoYXMocGFyZW50Q29tcG9uZW50KSkgPyBpbnZhcmlhbnQoZmFsc2UsICdwYXJlbnRDb21wb25lbnQgbXVzdCBiZSBhIHZhbGlkIFJlYWN0IENvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgIHJldHVybiByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihwYXJlbnRDb21wb25lbnQsIGVsZW1lbnQsIGNvbnRhaW5lck5vZGUsIGZhbHNlLCBjYWxsYmFjayk7XG4gIH0sXG4gIHVubW91bnRDb21wb25lbnRBdE5vZGU6IGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgICAhaXNWYWxpZENvbnRhaW5lcihjb250YWluZXIpID8gaW52YXJpYW50KGZhbHNlLCAndW5tb3VudENvbXBvbmVudEF0Tm9kZSguLi4pOiBUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LicpIDogdm9pZCAwO1xuXG4gICAgaWYgKGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyKSB7XG4gICAgICB7XG4gICAgICAgIHZhciByb290RWwgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgICAgICAgdmFyIHJlbmRlcmVkQnlEaWZmZXJlbnRSZWFjdCA9IHJvb3RFbCAmJiAhZ2V0SW5zdGFuY2VGcm9tTm9kZSQxKHJvb3RFbCk7XG4gICAgICAgIHdhcm5pbmcoIXJlbmRlcmVkQnlEaWZmZXJlbnRSZWFjdCwgXCJ1bm1vdW50Q29tcG9uZW50QXROb2RlKCk6IFRoZSBub2RlIHlvdSdyZSBhdHRlbXB0aW5nIHRvIHVubW91bnQgXCIgKyAnd2FzIHJlbmRlcmVkIGJ5IGFub3RoZXIgY29weSBvZiBSZWFjdC4nKTtcbiAgICAgIH1cblxuICAgICAgLy8gVW5tb3VudCBzaG91bGQgbm90IGJlIGJhdGNoZWQuXG4gICAgICBET01SZW5kZXJlci51bmJhdGNoZWRVcGRhdGVzKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVuZGVyU3VidHJlZUludG9Db250YWluZXIobnVsbCwgbnVsbCwgY29udGFpbmVyLCBmYWxzZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyID0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIC8vIElmIHlvdSBjYWxsIHVubW91bnRDb21wb25lbnRBdE5vZGUgdHdpY2UgaW4gcXVpY2sgc3VjY2Vzc2lvbiwgeW91J2xsXG4gICAgICAvLyBnZXQgYHRydWVgIHR3aWNlLiBUaGF0J3MgcHJvYmFibHkgZmluZT9cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB7XG4gICAgICAgIHZhciBfcm9vdEVsID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgICAgIHZhciBoYXNOb25Sb290UmVhY3RDaGlsZCA9ICEhKF9yb290RWwgJiYgZ2V0SW5zdGFuY2VGcm9tTm9kZSQxKF9yb290RWwpKTtcblxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgY29udGFpbmVyIGl0c2VsZiBpcyBhIFJlYWN0IHJvb3Qgbm9kZS5cbiAgICAgICAgdmFyIGlzQ29udGFpbmVyUmVhY3RSb290ID0gY29udGFpbmVyLm5vZGVUeXBlID09PSAxICYmIGlzVmFsaWRDb250YWluZXIoY29udGFpbmVyLnBhcmVudE5vZGUpICYmICEhY29udGFpbmVyLnBhcmVudE5vZGUuX3JlYWN0Um9vdENvbnRhaW5lcjtcblxuICAgICAgICB3YXJuaW5nKCFoYXNOb25Sb290UmVhY3RDaGlsZCwgXCJ1bm1vdW50Q29tcG9uZW50QXROb2RlKCk6IFRoZSBub2RlIHlvdSdyZSBhdHRlbXB0aW5nIHRvIHVubW91bnQgXCIgKyAnd2FzIHJlbmRlcmVkIGJ5IFJlYWN0IGFuZCBpcyBub3QgYSB0b3AtbGV2ZWwgY29udGFpbmVyLiAlcycsIGlzQ29udGFpbmVyUmVhY3RSb290ID8gJ1lvdSBtYXkgaGF2ZSBhY2NpZGVudGFsbHkgcGFzc2VkIGluIGEgUmVhY3Qgcm9vdCBub2RlIGluc3RlYWQgJyArICdvZiBpdHMgY29udGFpbmVyLicgOiAnSW5zdGVhZCwgaGF2ZSB0aGUgcGFyZW50IGNvbXBvbmVudCB1cGRhdGUgaXRzIHN0YXRlIGFuZCAnICsgJ3JlcmVuZGVyIGluIG9yZGVyIHRvIHJlbW92ZSB0aGlzIGNvbXBvbmVudC4nKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSxcblxuXG4gIC8vIFRlbXBvcmFyeSBhbGlhcyBzaW5jZSB3ZSBhbHJlYWR5IHNoaXBwZWQgUmVhY3QgMTYgUkMgd2l0aCBpdC5cbiAgLy8gVE9ETzogcmVtb3ZlIGluIFJlYWN0IDE3LlxuICB1bnN0YWJsZV9jcmVhdGVQb3J0YWw6IGNyZWF0ZVBvcnRhbCxcblxuICB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlczogYmF0Y2hlZFVwZGF0ZXMsXG5cbiAgdW5zdGFibGVfZGVmZXJyZWRVcGRhdGVzOiBET01SZW5kZXJlci5kZWZlcnJlZFVwZGF0ZXMsXG5cbiAgZmx1c2hTeW5jOiBET01SZW5kZXJlci5mbHVzaFN5bmMsXG5cbiAgX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ6IHtcbiAgICAvLyBGb3IgVGFwRXZlbnRQbHVnaW4gd2hpY2ggaXMgcG9wdWxhciBpbiBvcGVuIHNvdXJjZVxuICAgIEV2ZW50UGx1Z2luSHViOiBFdmVudFBsdWdpbkh1YixcbiAgICAvLyBVc2VkIGJ5IHRlc3QtdXRpbHNcbiAgICBFdmVudFBsdWdpblJlZ2lzdHJ5OiBFdmVudFBsdWdpblJlZ2lzdHJ5LFxuICAgIEV2ZW50UHJvcGFnYXRvcnM6IEV2ZW50UHJvcGFnYXRvcnMsXG4gICAgUmVhY3RDb250cm9sbGVkQ29tcG9uZW50OiBSZWFjdENvbnRyb2xsZWRDb21wb25lbnQsXG4gICAgUmVhY3RET01Db21wb25lbnRUcmVlOiBSZWFjdERPTUNvbXBvbmVudFRyZWUsXG4gICAgUmVhY3RET01FdmVudExpc3RlbmVyOiBSZWFjdERPTUV2ZW50TGlzdGVuZXJcbiAgfVxufTtcblxuaWYgKGVuYWJsZUNyZWF0ZVJvb3QpIHtcbiAgUmVhY3RET00uY3JlYXRlUm9vdCA9IGZ1bmN0aW9uIGNyZWF0ZVJvb3QoY29udGFpbmVyLCBvcHRpb25zKSB7XG4gICAgdmFyIGh5ZHJhdGUgPSBvcHRpb25zICE9IG51bGwgJiYgb3B0aW9ucy5oeWRyYXRlID09PSB0cnVlO1xuICAgIHJldHVybiBuZXcgUmVhY3RSb290KGNvbnRhaW5lciwgaHlkcmF0ZSk7XG4gIH07XG59XG5cbnZhciBmb3VuZERldlRvb2xzID0gRE9NUmVuZGVyZXIuaW5qZWN0SW50b0RldlRvb2xzKHtcbiAgZmluZEZpYmVyQnlIb3N0SW5zdGFuY2U6IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlLFxuICBidW5kbGVUeXBlOiAxLFxuICB2ZXJzaW9uOiBSZWFjdFZlcnNpb24sXG4gIHJlbmRlcmVyUGFja2FnZU5hbWU6ICdyZWFjdC1kb20nXG59KTtcblxue1xuICBpZiAoIWZvdW5kRGV2VG9vbHMgJiYgRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmIHdpbmRvdy50b3AgPT09IHdpbmRvdy5zZWxmKSB7XG4gICAgLy8gSWYgd2UncmUgaW4gQ2hyb21lIG9yIEZpcmVmb3gsIHByb3ZpZGUgYSBkb3dubG9hZCBsaW5rIGlmIG5vdCBpbnN0YWxsZWQuXG4gICAgaWYgKG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignQ2hyb21lJykgPiAtMSAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0VkZ2UnKSA9PT0gLTEgfHwgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdGaXJlZm94JykgPiAtMSkge1xuICAgICAgdmFyIHByb3RvY29sID0gd2luZG93LmxvY2F0aW9uLnByb3RvY29sO1xuICAgICAgLy8gRG9uJ3Qgd2FybiBpbiBleG90aWMgY2FzZXMgbGlrZSBjaHJvbWUtZXh0ZW5zaW9uOi8vLlxuICAgICAgaWYgKC9eKGh0dHBzP3xmaWxlKTokLy50ZXN0KHByb3RvY29sKSkge1xuICAgICAgICBjb25zb2xlLmluZm8oJyVjRG93bmxvYWQgdGhlIFJlYWN0IERldlRvb2xzICcgKyAnZm9yIGEgYmV0dGVyIGRldmVsb3BtZW50IGV4cGVyaWVuY2U6ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1kZXZ0b29scycgKyAocHJvdG9jb2wgPT09ICdmaWxlOicgPyAnXFxuWW91IG1pZ2h0IG5lZWQgdG8gdXNlIGEgbG9jYWwgSFRUUCBzZXJ2ZXIgKGluc3RlYWQgb2YgZmlsZTovLyk6ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1kZXZ0b29scy1mYXEnIDogJycpLCAnZm9udC13ZWlnaHQ6Ym9sZCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5cblxudmFyIFJlYWN0RE9NJDIgPSBPYmplY3QuZnJlZXplKHtcblx0ZGVmYXVsdDogUmVhY3RET01cbn0pO1xuXG52YXIgUmVhY3RET00kMyA9ICggUmVhY3RET00kMiAmJiBSZWFjdERPTSApIHx8IFJlYWN0RE9NJDI7XG5cbi8vIFRPRE86IGRlY2lkZSBvbiB0aGUgdG9wLWxldmVsIGV4cG9ydCBmb3JtLlxuLy8gVGhpcyBpcyBoYWNreSBidXQgbWFrZXMgaXQgd29yayB3aXRoIGJvdGggUm9sbHVwIGFuZCBKZXN0LlxudmFyIHJlYWN0RG9tID0gUmVhY3RET00kM1snZGVmYXVsdCddID8gUmVhY3RET00kM1snZGVmYXVsdCddIDogUmVhY3RET00kMztcblxubW9kdWxlLmV4cG9ydHMgPSByZWFjdERvbTtcbiAgfSkoKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vY2pzL3JlYWN0LWRvbS5kZXZlbG9wbWVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBoeXBoZW5hdGUgPSByZXF1aXJlKCcuL2h5cGhlbmF0ZScpO1xuXG52YXIgbXNQYXR0ZXJuID0gL15tcy0vO1xuXG4vKipcbiAqIEh5cGhlbmF0ZXMgYSBjYW1lbGNhc2VkIENTUyBwcm9wZXJ0eSBuYW1lLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdiYWNrZ3JvdW5kQ29sb3InKVxuICogICA8IFwiYmFja2dyb3VuZC1jb2xvclwiXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdNb3pUcmFuc2l0aW9uJylcbiAqICAgPCBcIi1tb3otdHJhbnNpdGlvblwiXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdtc1RyYW5zaXRpb24nKVxuICogICA8IFwiLW1zLXRyYW5zaXRpb25cIlxuICpcbiAqIEFzIE1vZGVybml6ciBzdWdnZXN0cyAoaHR0cDovL21vZGVybml6ci5jb20vZG9jcy8jcHJlZml4ZWQpLCBhbiBgbXNgIHByZWZpeFxuICogaXMgY29udmVydGVkIHRvIGAtbXMtYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGh5cGhlbmF0ZVN0eWxlTmFtZShzdHJpbmcpIHtcbiAgcmV0dXJuIGh5cGhlbmF0ZShzdHJpbmcpLnJlcGxhY2UobXNQYXR0ZXJuLCAnLW1zLScpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGh5cGhlbmF0ZVN0eWxlTmFtZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaHlwaGVuYXRlU3R5bGVOYW1lLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxudmFyIF91cHBlcmNhc2VQYXR0ZXJuID0gLyhbQS1aXSkvZztcblxuLyoqXG4gKiBIeXBoZW5hdGVzIGEgY2FtZWxjYXNlZCBzdHJpbmcsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBoeXBoZW5hdGUoJ2JhY2tncm91bmRDb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kLWNvbG9yXCJcbiAqXG4gKiBGb3IgQ1NTIHN0eWxlIG5hbWVzLCB1c2UgYGh5cGhlbmF0ZVN0eWxlTmFtZWAgaW5zdGVhZCB3aGljaCB3b3JrcyBwcm9wZXJseVxuICogd2l0aCBhbGwgdmVuZG9yIHByZWZpeGVzLCBpbmNsdWRpbmcgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGh5cGhlbmF0ZShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKF91cHBlcmNhc2VQYXR0ZXJuLCAnLSQxJykudG9Mb3dlckNhc2UoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoeXBoZW5hdGU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2h5cGhlbmF0ZS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjYW1lbGl6ZSA9IHJlcXVpcmUoJy4vY2FtZWxpemUnKTtcblxudmFyIG1zUGF0dGVybiA9IC9eLW1zLS87XG5cbi8qKlxuICogQ2FtZWxjYXNlcyBhIGh5cGhlbmF0ZWQgQ1NTIHByb3BlcnR5IG5hbWUsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBjYW1lbGl6ZVN0eWxlTmFtZSgnYmFja2dyb3VuZC1jb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kQ29sb3JcIlxuICogICA+IGNhbWVsaXplU3R5bGVOYW1lKCctbW96LXRyYW5zaXRpb24nKVxuICogICA8IFwiTW96VHJhbnNpdGlvblwiXG4gKiAgID4gY2FtZWxpemVTdHlsZU5hbWUoJy1tcy10cmFuc2l0aW9uJylcbiAqICAgPCBcIm1zVHJhbnNpdGlvblwiXG4gKlxuICogQXMgQW5kaSBTbWl0aCBzdWdnZXN0c1xuICogKGh0dHA6Ly93d3cuYW5kaXNtaXRoLmNvbS9ibG9nLzIwMTIvMDIvbW9kZXJuaXpyLXByZWZpeGVkLyksIGFuIGAtbXNgIHByZWZpeFxuICogaXMgY29udmVydGVkIHRvIGxvd2VyY2FzZSBgbXNgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gY2FtZWxpemVTdHlsZU5hbWUoc3RyaW5nKSB7XG4gIHJldHVybiBjYW1lbGl6ZShzdHJpbmcucmVwbGFjZShtc1BhdHRlcm4sICdtcy0nKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FtZWxpemVTdHlsZU5hbWU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2NhbWVsaXplU3R5bGVOYW1lLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG52YXIgX2h5cGhlblBhdHRlcm4gPSAvLSguKS9nO1xuXG4vKipcbiAqIENhbWVsY2FzZXMgYSBoeXBoZW5hdGVkIHN0cmluZywgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGNhbWVsaXplKCdiYWNrZ3JvdW5kLWNvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmRDb2xvclwiXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBjYW1lbGl6ZShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKF9oeXBoZW5QYXR0ZXJuLCBmdW5jdGlvbiAoXywgY2hhcmFjdGVyKSB7XG4gICAgcmV0dXJuIGNoYXJhY3Rlci50b1VwcGVyQ2FzZSgpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYW1lbGl6ZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvY2FtZWxpemUuanMiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9pbmRleC5jc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIFByZXBhcmUgY3NzVHJhbnNmb3JtYXRpb25cbnZhciB0cmFuc2Zvcm07XG5cbnZhciBvcHRpb25zID0ge1wiaG1yXCI6dHJ1ZX1cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcIikoY29udGVudCwgb3B0aW9ucyk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vaW5kZXguY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL2luZGV4LmNzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvaW5kZXguY3NzXG4vLyBtb2R1bGUgaWQgPSA1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKGZhbHNlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcImJvZHkge1xcbiAgbWFyZ2luOiAwO1xcbiAgcGFkZGluZzogMDtcXG4gIGZvbnQtZmFtaWx5OiBzYW5zLXNlcmlmO1xcbn1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyIS4vc3JjL2luZGV4LmNzc1xuLy8gbW9kdWxlIGlkID0gNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG4vKipcbiAqIFdoZW4gc291cmNlIG1hcHMgYXJlIGVuYWJsZWQsIGBzdHlsZS1sb2FkZXJgIHVzZXMgYSBsaW5rIGVsZW1lbnQgd2l0aCBhIGRhdGEtdXJpIHRvXG4gKiBlbWJlZCB0aGUgY3NzIG9uIHRoZSBwYWdlLiBUaGlzIGJyZWFrcyBhbGwgcmVsYXRpdmUgdXJscyBiZWNhdXNlIG5vdyB0aGV5IGFyZSByZWxhdGl2ZSB0byBhXG4gKiBidW5kbGUgaW5zdGVhZCBvZiB0aGUgY3VycmVudCBwYWdlLlxuICpcbiAqIE9uZSBzb2x1dGlvbiBpcyB0byBvbmx5IHVzZSBmdWxsIHVybHMsIGJ1dCB0aGF0IG1heSBiZSBpbXBvc3NpYmxlLlxuICpcbiAqIEluc3RlYWQsIHRoaXMgZnVuY3Rpb24gXCJmaXhlc1wiIHRoZSByZWxhdGl2ZSB1cmxzIHRvIGJlIGFic29sdXRlIGFjY29yZGluZyB0byB0aGUgY3VycmVudCBwYWdlIGxvY2F0aW9uLlxuICpcbiAqIEEgcnVkaW1lbnRhcnkgdGVzdCBzdWl0ZSBpcyBsb2NhdGVkIGF0IGB0ZXN0L2ZpeFVybHMuanNgIGFuZCBjYW4gYmUgcnVuIHZpYSB0aGUgYG5wbSB0ZXN0YCBjb21tYW5kLlxuICpcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjc3MpIHtcbiAgLy8gZ2V0IGN1cnJlbnQgbG9jYXRpb25cbiAgdmFyIGxvY2F0aW9uID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cubG9jYXRpb247XG5cbiAgaWYgKCFsb2NhdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImZpeFVybHMgcmVxdWlyZXMgd2luZG93LmxvY2F0aW9uXCIpO1xuICB9XG5cblx0Ly8gYmxhbmsgb3IgbnVsbD9cblx0aWYgKCFjc3MgfHwgdHlwZW9mIGNzcyAhPT0gXCJzdHJpbmdcIikge1xuXHQgIHJldHVybiBjc3M7XG4gIH1cblxuICB2YXIgYmFzZVVybCA9IGxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICsgbG9jYXRpb24uaG9zdDtcbiAgdmFyIGN1cnJlbnREaXIgPSBiYXNlVXJsICsgbG9jYXRpb24ucGF0aG5hbWUucmVwbGFjZSgvXFwvW15cXC9dKiQvLCBcIi9cIik7XG5cblx0Ly8gY29udmVydCBlYWNoIHVybCguLi4pXG5cdC8qXG5cdFRoaXMgcmVndWxhciBleHByZXNzaW9uIGlzIGp1c3QgYSB3YXkgdG8gcmVjdXJzaXZlbHkgbWF0Y2ggYnJhY2tldHMgd2l0aGluXG5cdGEgc3RyaW5nLlxuXG5cdCAvdXJsXFxzKlxcKCAgPSBNYXRjaCBvbiB0aGUgd29yZCBcInVybFwiIHdpdGggYW55IHdoaXRlc3BhY2UgYWZ0ZXIgaXQgYW5kIHRoZW4gYSBwYXJlbnNcblx0ICAgKCAgPSBTdGFydCBhIGNhcHR1cmluZyBncm91cFxuXHQgICAgICg/OiAgPSBTdGFydCBhIG5vbi1jYXB0dXJpbmcgZ3JvdXBcblx0ICAgICAgICAgW14pKF0gID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgIHwgID0gT1Jcblx0ICAgICAgICAgXFwoICA9IE1hdGNoIGEgc3RhcnQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICg/OiAgPSBTdGFydCBhbm90aGVyIG5vbi1jYXB0dXJpbmcgZ3JvdXBzXG5cdCAgICAgICAgICAgICAgICAgW14pKF0rICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgIHwgID0gT1Jcblx0ICAgICAgICAgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgICAgICBbXikoXSogID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgXFwpICA9IE1hdGNoIGEgZW5kIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICApICA9IEVuZCBHcm91cFxuICAgICAgICAgICAgICAqXFwpID0gTWF0Y2ggYW55dGhpbmcgYW5kIHRoZW4gYSBjbG9zZSBwYXJlbnNcbiAgICAgICAgICApICA9IENsb3NlIG5vbi1jYXB0dXJpbmcgZ3JvdXBcbiAgICAgICAgICAqICA9IE1hdGNoIGFueXRoaW5nXG4gICAgICAgKSAgPSBDbG9zZSBjYXB0dXJpbmcgZ3JvdXBcblx0IFxcKSAgPSBNYXRjaCBhIGNsb3NlIHBhcmVuc1xuXG5cdCAvZ2kgID0gR2V0IGFsbCBtYXRjaGVzLCBub3QgdGhlIGZpcnN0LiAgQmUgY2FzZSBpbnNlbnNpdGl2ZS5cblx0ICovXG5cdHZhciBmaXhlZENzcyA9IGNzcy5yZXBsYWNlKC91cmxcXHMqXFwoKCg/OlteKShdfFxcKCg/OlteKShdK3xcXChbXikoXSpcXCkpKlxcKSkqKVxcKS9naSwgZnVuY3Rpb24oZnVsbE1hdGNoLCBvcmlnVXJsKSB7XG5cdFx0Ly8gc3RyaXAgcXVvdGVzIChpZiB0aGV5IGV4aXN0KVxuXHRcdHZhciB1bnF1b3RlZE9yaWdVcmwgPSBvcmlnVXJsXG5cdFx0XHQudHJpbSgpXG5cdFx0XHQucmVwbGFjZSgvXlwiKC4qKVwiJC8sIGZ1bmN0aW9uKG8sICQxKXsgcmV0dXJuICQxOyB9KVxuXHRcdFx0LnJlcGxhY2UoL14nKC4qKSckLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pO1xuXG5cdFx0Ly8gYWxyZWFkeSBhIGZ1bGwgdXJsPyBubyBjaGFuZ2Vcblx0XHRpZiAoL14oI3xkYXRhOnxodHRwOlxcL1xcL3xodHRwczpcXC9cXC98ZmlsZTpcXC9cXC9cXC8pL2kudGVzdCh1bnF1b3RlZE9yaWdVcmwpKSB7XG5cdFx0ICByZXR1cm4gZnVsbE1hdGNoO1xuXHRcdH1cblxuXHRcdC8vIGNvbnZlcnQgdGhlIHVybCB0byBhIGZ1bGwgdXJsXG5cdFx0dmFyIG5ld1VybDtcblxuXHRcdGlmICh1bnF1b3RlZE9yaWdVcmwuaW5kZXhPZihcIi8vXCIpID09PSAwKSB7XG5cdFx0ICBcdC8vVE9ETzogc2hvdWxkIHdlIGFkZCBwcm90b2NvbD9cblx0XHRcdG5ld1VybCA9IHVucXVvdGVkT3JpZ1VybDtcblx0XHR9IGVsc2UgaWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiL1wiKSA9PT0gMCkge1xuXHRcdFx0Ly8gcGF0aCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlIGJhc2UgdXJsXG5cdFx0XHRuZXdVcmwgPSBiYXNlVXJsICsgdW5xdW90ZWRPcmlnVXJsOyAvLyBhbHJlYWR5IHN0YXJ0cyB3aXRoICcvJ1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byBjdXJyZW50IGRpcmVjdG9yeVxuXHRcdFx0bmV3VXJsID0gY3VycmVudERpciArIHVucXVvdGVkT3JpZ1VybC5yZXBsYWNlKC9eXFwuXFwvLywgXCJcIik7IC8vIFN0cmlwIGxlYWRpbmcgJy4vJ1xuXHRcdH1cblxuXHRcdC8vIHNlbmQgYmFjayB0aGUgZml4ZWQgdXJsKC4uLilcblx0XHRyZXR1cm4gXCJ1cmwoXCIgKyBKU09OLnN0cmluZ2lmeShuZXdVcmwpICsgXCIpXCI7XG5cdH0pO1xuXG5cdC8vIHNlbmQgYmFjayB0aGUgZml4ZWQgY3NzXG5cdHJldHVybiBmaXhlZENzcztcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi91cmxzLmpzIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vQ2hhdEFwcC5jc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIFByZXBhcmUgY3NzVHJhbnNmb3JtYXRpb25cbnZhciB0cmFuc2Zvcm07XG5cbnZhciBvcHRpb25zID0ge1wiaG1yXCI6dHJ1ZX1cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcIikoY29udGVudCwgb3B0aW9ucyk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vQ2hhdEFwcC5jc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vQ2hhdEFwcC5jc3NcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2NvbXBvbmVudHMvY2hhdC9DaGF0QXBwLmNzc1xuLy8gbW9kdWxlIGlkID0gNjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKShmYWxzZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIuQXBwIHtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG59XFxuXFxuLkFwcC1sb2dvIHtcXG4gIGFuaW1hdGlvbjogQXBwLWxvZ28tc3BpbiBpbmZpbml0ZSAyMHMgbGluZWFyO1xcbiAgaGVpZ2h0OiA4MHB4O1xcbn1cXG5cXG4uQXBwLWhlYWRlciB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMjIyO1xcbiAgaGVpZ2h0OiAxNTBweDtcXG4gIHBhZGRpbmc6IDIwcHg7XFxuICBjb2xvcjogd2hpdGU7XFxufVxcblxcbi5BcHAtdGl0bGUge1xcbiAgZm9udC1zaXplOiAxLjVlbTtcXG59XFxuXFxuLkFwcC1pbnRybyB7XFxuICBmb250LXNpemU6IGxhcmdlO1xcbn1cXG5cXG5Aa2V5ZnJhbWVzIEFwcC1sb2dvLXNwaW4ge1xcbiAgZnJvbSB7IHRyYW5zZm9ybTogcm90YXRlKDBkZWcpOyB9XFxuICB0byB7IHRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7IH1cXG59XFxuXFxuLm1haW4td3JhcCB7XFxuICB3aWR0aDogMTE3MHB4O1xcbn1cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyIS4vc3JjL2NvbXBvbmVudHMvY2hhdC9DaGF0QXBwLmNzc1xuLy8gbW9kdWxlIGlkID0gNjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vSGVhZGVyLmNzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gUHJlcGFyZSBjc3NUcmFuc2Zvcm1hdGlvblxudmFyIHRyYW5zZm9ybTtcblxudmFyIG9wdGlvbnMgPSB7XCJobXJcIjp0cnVlfVxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9IZWFkZXIuY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL0hlYWRlci5jc3NcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2NvbXBvbmVudHMvaGVhZGVyL0hlYWRlci5jc3Ncbi8vIG1vZHVsZSBpZCA9IDYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoZmFsc2UpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLmFwcC1sb2dvIHtcXG4gIHdpZHRoOiA1MHB4O1xcbiAgaGVpZ2h0OiA1MHB4O1xcbn1cXG5cXG4udXNlcm5hbWUge1xcbiAgbWFyZ2luLXRvcDogOHB4O1xcbn1cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyIS4vc3JjL2NvbXBvbmVudHMvaGVhZGVyL0hlYWRlci5jc3Ncbi8vIG1vZHVsZSBpZCA9IDY0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciB1cmwgPSByZXF1aXJlKCcuL3VybCcpO1xudmFyIHBhcnNlciA9IHJlcXVpcmUoJ3NvY2tldC5pby1wYXJzZXInKTtcbnZhciBNYW5hZ2VyID0gcmVxdWlyZSgnLi9tYW5hZ2VyJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NrZXQuaW8tY2xpZW50Jyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gbG9va3VwO1xuXG4vKipcbiAqIE1hbmFnZXJzIGNhY2hlLlxuICovXG5cbnZhciBjYWNoZSA9IGV4cG9ydHMubWFuYWdlcnMgPSB7fTtcblxuLyoqXG4gKiBMb29rcyB1cCBhbiBleGlzdGluZyBgTWFuYWdlcmAgZm9yIG11bHRpcGxleGluZy5cbiAqIElmIHRoZSB1c2VyIHN1bW1vbnM6XG4gKlxuICogICBgaW8oJ2h0dHA6Ly9sb2NhbGhvc3QvYScpO2BcbiAqICAgYGlvKCdodHRwOi8vbG9jYWxob3N0L2InKTtgXG4gKlxuICogV2UgcmV1c2UgdGhlIGV4aXN0aW5nIGluc3RhbmNlIGJhc2VkIG9uIHNhbWUgc2NoZW1lL3BvcnQvaG9zdCxcbiAqIGFuZCB3ZSBpbml0aWFsaXplIHNvY2tldHMgZm9yIGVhY2ggbmFtZXNwYWNlLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gbG9va3VwICh1cmksIG9wdHMpIHtcbiAgaWYgKHR5cGVvZiB1cmkgPT09ICdvYmplY3QnKSB7XG4gICAgb3B0cyA9IHVyaTtcbiAgICB1cmkgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICB2YXIgcGFyc2VkID0gdXJsKHVyaSk7XG4gIHZhciBzb3VyY2UgPSBwYXJzZWQuc291cmNlO1xuICB2YXIgaWQgPSBwYXJzZWQuaWQ7XG4gIHZhciBwYXRoID0gcGFyc2VkLnBhdGg7XG4gIHZhciBzYW1lTmFtZXNwYWNlID0gY2FjaGVbaWRdICYmIHBhdGggaW4gY2FjaGVbaWRdLm5zcHM7XG4gIHZhciBuZXdDb25uZWN0aW9uID0gb3B0cy5mb3JjZU5ldyB8fCBvcHRzWydmb3JjZSBuZXcgY29ubmVjdGlvbiddIHx8XG4gICAgICAgICAgICAgICAgICAgICAgZmFsc2UgPT09IG9wdHMubXVsdGlwbGV4IHx8IHNhbWVOYW1lc3BhY2U7XG5cbiAgdmFyIGlvO1xuXG4gIGlmIChuZXdDb25uZWN0aW9uKSB7XG4gICAgZGVidWcoJ2lnbm9yaW5nIHNvY2tldCBjYWNoZSBmb3IgJXMnLCBzb3VyY2UpO1xuICAgIGlvID0gTWFuYWdlcihzb3VyY2UsIG9wdHMpO1xuICB9IGVsc2Uge1xuICAgIGlmICghY2FjaGVbaWRdKSB7XG4gICAgICBkZWJ1ZygnbmV3IGlvIGluc3RhbmNlIGZvciAlcycsIHNvdXJjZSk7XG4gICAgICBjYWNoZVtpZF0gPSBNYW5hZ2VyKHNvdXJjZSwgb3B0cyk7XG4gICAgfVxuICAgIGlvID0gY2FjaGVbaWRdO1xuICB9XG4gIGlmIChwYXJzZWQucXVlcnkgJiYgIW9wdHMucXVlcnkpIHtcbiAgICBvcHRzLnF1ZXJ5ID0gcGFyc2VkLnF1ZXJ5O1xuICB9XG4gIHJldHVybiBpby5zb2NrZXQocGFyc2VkLnBhdGgsIG9wdHMpO1xufVxuXG4vKipcbiAqIFByb3RvY29sIHZlcnNpb24uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnByb3RvY29sID0gcGFyc2VyLnByb3RvY29sO1xuXG4vKipcbiAqIGBjb25uZWN0YC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJpXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuY29ubmVjdCA9IGxvb2t1cDtcblxuLyoqXG4gKiBFeHBvc2UgY29uc3RydWN0b3JzIGZvciBzdGFuZGFsb25lIGJ1aWxkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5NYW5hZ2VyID0gcmVxdWlyZSgnLi9tYW5hZ2VyJyk7XG5leHBvcnRzLlNvY2tldCA9IHJlcXVpcmUoJy4vc29ja2V0Jyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9saWIvaW5kZXguanMiLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgcGFyc2V1cmkgPSByZXF1aXJlKCdwYXJzZXVyaScpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2V0LmlvLWNsaWVudDp1cmwnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHVybDtcblxuLyoqXG4gKiBVUkwgcGFyc2VyLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7T2JqZWN0fSBBbiBvYmplY3QgbWVhbnQgdG8gbWltaWMgd2luZG93LmxvY2F0aW9uLlxuICogICAgICAgICAgICAgICAgIERlZmF1bHRzIHRvIHdpbmRvdy5sb2NhdGlvbi5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gdXJsICh1cmksIGxvYykge1xuICB2YXIgb2JqID0gdXJpO1xuXG4gIC8vIGRlZmF1bHQgdG8gd2luZG93LmxvY2F0aW9uXG4gIGxvYyA9IGxvYyB8fCBnbG9iYWwubG9jYXRpb247XG4gIGlmIChudWxsID09IHVyaSkgdXJpID0gbG9jLnByb3RvY29sICsgJy8vJyArIGxvYy5ob3N0O1xuXG4gIC8vIHJlbGF0aXZlIHBhdGggc3VwcG9ydFxuICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiB1cmkpIHtcbiAgICBpZiAoJy8nID09PSB1cmkuY2hhckF0KDApKSB7XG4gICAgICBpZiAoJy8nID09PSB1cmkuY2hhckF0KDEpKSB7XG4gICAgICAgIHVyaSA9IGxvYy5wcm90b2NvbCArIHVyaTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVyaSA9IGxvYy5ob3N0ICsgdXJpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghL14oaHR0cHM/fHdzcz8pOlxcL1xcLy8udGVzdCh1cmkpKSB7XG4gICAgICBkZWJ1ZygncHJvdG9jb2wtbGVzcyB1cmwgJXMnLCB1cmkpO1xuICAgICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgbG9jKSB7XG4gICAgICAgIHVyaSA9IGxvYy5wcm90b2NvbCArICcvLycgKyB1cmk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cmkgPSAnaHR0cHM6Ly8nICsgdXJpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHBhcnNlXG4gICAgZGVidWcoJ3BhcnNlICVzJywgdXJpKTtcbiAgICBvYmogPSBwYXJzZXVyaSh1cmkpO1xuICB9XG5cbiAgLy8gbWFrZSBzdXJlIHdlIHRyZWF0IGBsb2NhbGhvc3Q6ODBgIGFuZCBgbG9jYWxob3N0YCBlcXVhbGx5XG4gIGlmICghb2JqLnBvcnQpIHtcbiAgICBpZiAoL14oaHR0cHx3cykkLy50ZXN0KG9iai5wcm90b2NvbCkpIHtcbiAgICAgIG9iai5wb3J0ID0gJzgwJztcbiAgICB9IGVsc2UgaWYgKC9eKGh0dHB8d3MpcyQvLnRlc3Qob2JqLnByb3RvY29sKSkge1xuICAgICAgb2JqLnBvcnQgPSAnNDQzJztcbiAgICB9XG4gIH1cblxuICBvYmoucGF0aCA9IG9iai5wYXRoIHx8ICcvJztcblxuICB2YXIgaXB2NiA9IG9iai5ob3N0LmluZGV4T2YoJzonKSAhPT0gLTE7XG4gIHZhciBob3N0ID0gaXB2NiA/ICdbJyArIG9iai5ob3N0ICsgJ10nIDogb2JqLmhvc3Q7XG5cbiAgLy8gZGVmaW5lIHVuaXF1ZSBpZFxuICBvYmouaWQgPSBvYmoucHJvdG9jb2wgKyAnOi8vJyArIGhvc3QgKyAnOicgKyBvYmoucG9ydDtcbiAgLy8gZGVmaW5lIGhyZWZcbiAgb2JqLmhyZWYgPSBvYmoucHJvdG9jb2wgKyAnOi8vJyArIGhvc3QgKyAobG9jICYmIGxvYy5wb3J0ID09PSBvYmoucG9ydCA/ICcnIDogKCc6JyArIG9iai5wb3J0KSk7XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L2xpYi91cmwuanMiLCJcbi8qKlxuICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gY3JlYXRlRGVidWcuZGVidWcgPSBjcmVhdGVEZWJ1Z1snZGVmYXVsdCddID0gY3JlYXRlRGVidWc7XG5leHBvcnRzLmNvZXJjZSA9IGNvZXJjZTtcbmV4cG9ydHMuZGlzYWJsZSA9IGRpc2FibGU7XG5leHBvcnRzLmVuYWJsZSA9IGVuYWJsZTtcbmV4cG9ydHMuZW5hYmxlZCA9IGVuYWJsZWQ7XG5leHBvcnRzLmh1bWFuaXplID0gcmVxdWlyZSgnbXMnKTtcblxuLyoqXG4gKiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cbiAqL1xuXG5leHBvcnRzLm5hbWVzID0gW107XG5leHBvcnRzLnNraXBzID0gW107XG5cbi8qKlxuICogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuICpcbiAqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyIG9yIHVwcGVyLWNhc2UgbGV0dGVyLCBpLmUuIFwiblwiIGFuZCBcIk5cIi5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMgPSB7fTtcblxuLyoqXG4gKiBQcmV2aW91cyBsb2cgdGltZXN0YW1wLlxuICovXG5cbnZhciBwcmV2VGltZTtcblxuLyoqXG4gKiBTZWxlY3QgYSBjb2xvci5cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNlbGVjdENvbG9yKG5hbWVzcGFjZSkge1xuICB2YXIgaGFzaCA9IDAsIGk7XG5cbiAgZm9yIChpIGluIG5hbWVzcGFjZSkge1xuICAgIGhhc2ggID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgKyBuYW1lc3BhY2UuY2hhckNvZGVBdChpKTtcbiAgICBoYXNoIHw9IDA7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuICB9XG5cbiAgcmV0dXJuIGV4cG9ydHMuY29sb3JzW01hdGguYWJzKGhhc2gpICUgZXhwb3J0cy5jb2xvcnMubGVuZ3RoXTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlRGVidWcobmFtZXNwYWNlKSB7XG5cbiAgZnVuY3Rpb24gZGVidWcoKSB7XG4gICAgLy8gZGlzYWJsZWQ/XG4gICAgaWYgKCFkZWJ1Zy5lbmFibGVkKSByZXR1cm47XG5cbiAgICB2YXIgc2VsZiA9IGRlYnVnO1xuXG4gICAgLy8gc2V0IGBkaWZmYCB0aW1lc3RhbXBcbiAgICB2YXIgY3VyciA9ICtuZXcgRGF0ZSgpO1xuICAgIHZhciBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG4gICAgc2VsZi5kaWZmID0gbXM7XG4gICAgc2VsZi5wcmV2ID0gcHJldlRpbWU7XG4gICAgc2VsZi5jdXJyID0gY3VycjtcbiAgICBwcmV2VGltZSA9IGN1cnI7XG5cbiAgICAvLyB0dXJuIHRoZSBgYXJndW1lbnRzYCBpbnRvIGEgcHJvcGVyIEFycmF5XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIGFyZ3NbMF0gPSBleHBvcnRzLmNvZXJjZShhcmdzWzBdKTtcblxuICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIGFyZ3NbMF0pIHtcbiAgICAgIC8vIGFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVPXG4gICAgICBhcmdzLnVuc2hpZnQoJyVPJyk7XG4gICAgfVxuXG4gICAgLy8gYXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EtekEtWiVdKS9nLCBmdW5jdGlvbihtYXRjaCwgZm9ybWF0KSB7XG4gICAgICAvLyBpZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG4gICAgICBpZiAobWF0Y2ggPT09ICclJScpIHJldHVybiBtYXRjaDtcbiAgICAgIGluZGV4Kys7XG4gICAgICB2YXIgZm9ybWF0dGVyID0gZXhwb3J0cy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG4gICAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGZvcm1hdHRlcikge1xuICAgICAgICB2YXIgdmFsID0gYXJnc1tpbmRleF07XG4gICAgICAgIG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuICAgICAgICAvLyBub3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG4gICAgICAgIGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgaW5kZXgtLTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcblxuICAgIC8vIGFwcGx5IGVudi1zcGVjaWZpYyBmb3JtYXR0aW5nIChjb2xvcnMsIGV0Yy4pXG4gICAgZXhwb3J0cy5mb3JtYXRBcmdzLmNhbGwoc2VsZiwgYXJncyk7XG5cbiAgICB2YXIgbG9nRm4gPSBkZWJ1Zy5sb2cgfHwgZXhwb3J0cy5sb2cgfHwgY29uc29sZS5sb2cuYmluZChjb25zb2xlKTtcbiAgICBsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgfVxuXG4gIGRlYnVnLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcbiAgZGVidWcuZW5hYmxlZCA9IGV4cG9ydHMuZW5hYmxlZChuYW1lc3BhY2UpO1xuICBkZWJ1Zy51c2VDb2xvcnMgPSBleHBvcnRzLnVzZUNvbG9ycygpO1xuICBkZWJ1Zy5jb2xvciA9IHNlbGVjdENvbG9yKG5hbWVzcGFjZSk7XG5cbiAgLy8gZW52LXNwZWNpZmljIGluaXRpYWxpemF0aW9uIGxvZ2ljIGZvciBkZWJ1ZyBpbnN0YW5jZXNcbiAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBleHBvcnRzLmluaXQpIHtcbiAgICBleHBvcnRzLmluaXQoZGVidWcpO1xuICB9XG5cbiAgcmV0dXJuIGRlYnVnO1xufVxuXG4vKipcbiAqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcbiAqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcbiAgZXhwb3J0cy5zYXZlKG5hbWVzcGFjZXMpO1xuXG4gIGV4cG9ydHMubmFtZXMgPSBbXTtcbiAgZXhwb3J0cy5za2lwcyA9IFtdO1xuXG4gIHZhciBzcGxpdCA9ICh0eXBlb2YgbmFtZXNwYWNlcyA9PT0gJ3N0cmluZycgPyBuYW1lc3BhY2VzIDogJycpLnNwbGl0KC9bXFxzLF0rLyk7XG4gIHZhciBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGlmICghc3BsaXRbaV0pIGNvbnRpbnVlOyAvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuICAgIG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuICAgIGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcbiAgICAgIGV4cG9ydHMuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc3Vic3RyKDEpICsgJyQnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gIGV4cG9ydHMuZW5hYmxlKCcnKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuICB2YXIgaSwgbGVuO1xuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMubmFtZXNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBDb2VyY2UgYHZhbGAuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gdmFsXG4gKiBAcmV0dXJuIHtNaXhlZH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSByZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuICByZXR1cm4gdmFsO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9kZWJ1Zy5qcyIsIi8qKlxuICogSGVscGVycy5cbiAqL1xuXG52YXIgcyA9IDEwMDA7XG52YXIgbSA9IHMgKiA2MDtcbnZhciBoID0gbSAqIDYwO1xudmFyIGQgPSBoICogMjQ7XG52YXIgeSA9IGQgKiAzNjUuMjU7XG5cbi8qKlxuICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAdGhyb3dzIHtFcnJvcn0gdGhyb3cgYW4gZXJyb3IgaWYgdmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSBudW1iZXJcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWwubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBwYXJzZSh2YWwpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIGlzTmFOKHZhbCkgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMubG9uZyA/IGZtdExvbmcodmFsKSA6IGZtdFNob3J0KHZhbCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICd2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIHZhbGlkIG51bWJlci4gdmFsPScgK1xuICAgICAgSlNPTi5zdHJpbmdpZnkodmFsKVxuICApO1xufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gIHN0ciA9IFN0cmluZyhzdHIpO1xuICBpZiAoc3RyLmxlbmd0aCA+IDEwMCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbWF0Y2ggPSAvXigoPzpcXGQrKT9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKFxuICAgIHN0clxuICApO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKCk7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3llYXJzJzpcbiAgICBjYXNlICd5ZWFyJzpcbiAgICBjYXNlICd5cnMnOlxuICAgIGNhc2UgJ3lyJzpcbiAgICBjYXNlICd5JzpcbiAgICAgIHJldHVybiBuICogeTtcbiAgICBjYXNlICdkYXlzJzpcbiAgICBjYXNlICdkYXknOlxuICAgIGNhc2UgJ2QnOlxuICAgICAgcmV0dXJuIG4gKiBkO1xuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdob3VyJzpcbiAgICBjYXNlICdocnMnOlxuICAgIGNhc2UgJ2hyJzpcbiAgICBjYXNlICdoJzpcbiAgICAgIHJldHVybiBuICogaDtcbiAgICBjYXNlICdtaW51dGVzJzpcbiAgICBjYXNlICdtaW51dGUnOlxuICAgIGNhc2UgJ21pbnMnOlxuICAgIGNhc2UgJ21pbic6XG4gICAgY2FzZSAnbSc6XG4gICAgICByZXR1cm4gbiAqIG07XG4gICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgY2FzZSAnc2Vjb25kJzpcbiAgICBjYXNlICdzZWNzJzpcbiAgICBjYXNlICdzZWMnOlxuICAgIGNhc2UgJ3MnOlxuICAgICAgcmV0dXJuIG4gKiBzO1xuICAgIGNhc2UgJ21pbGxpc2Vjb25kcyc6XG4gICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgIGNhc2UgJ21zZWNzJzpcbiAgICBjYXNlICdtc2VjJzpcbiAgICBjYXNlICdtcyc6XG4gICAgICByZXR1cm4gbjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdFNob3J0KG1zKSB7XG4gIGlmIChtcyA+PSBkKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBkKSArICdkJztcbiAgfVxuICBpZiAobXMgPj0gaCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCc7XG4gIH1cbiAgaWYgKG1zID49IG0pIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG0pICsgJ20nO1xuICB9XG4gIGlmIChtcyA+PSBzKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBzKSArICdzJztcbiAgfVxuICByZXR1cm4gbXMgKyAnbXMnO1xufVxuXG4vKipcbiAqIExvbmcgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10TG9uZyhtcykge1xuICByZXR1cm4gcGx1cmFsKG1zLCBkLCAnZGF5JykgfHxcbiAgICBwbHVyYWwobXMsIGgsICdob3VyJykgfHxcbiAgICBwbHVyYWwobXMsIG0sICdtaW51dGUnKSB8fFxuICAgIHBsdXJhbChtcywgcywgJ3NlY29uZCcpIHx8XG4gICAgbXMgKyAnIG1zJztcbn1cblxuLyoqXG4gKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cbiAqL1xuXG5mdW5jdGlvbiBwbHVyYWwobXMsIG4sIG5hbWUpIHtcbiAgaWYgKG1zIDwgbikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAobXMgPCBuICogMS41KSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IobXMgLyBuKSArICcgJyArIG5hbWU7XG4gIH1cbiAgcmV0dXJuIE1hdGguY2VpbChtcyAvIG4pICsgJyAnICsgbmFtZSArICdzJztcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9tcy9pbmRleC5qcyIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2hhcy1iaW5hcnkyL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwiLypnbG9iYWwgQmxvYixGaWxlKi9cblxuLyoqXG4gKiBNb2R1bGUgcmVxdWlyZW1lbnRzXG4gKi9cblxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG52YXIgaXNCdWYgPSByZXF1aXJlKCcuL2lzLWJ1ZmZlcicpO1xudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciB3aXRoTmF0aXZlQmxvYiA9IHR5cGVvZiBnbG9iYWwuQmxvYiA9PT0gJ2Z1bmN0aW9uJyB8fCB0b1N0cmluZy5jYWxsKGdsb2JhbC5CbG9iKSA9PT0gJ1tvYmplY3QgQmxvYkNvbnN0cnVjdG9yXSc7XG52YXIgd2l0aE5hdGl2ZUZpbGUgPSB0eXBlb2YgZ2xvYmFsLkZpbGUgPT09ICdmdW5jdGlvbicgfHwgdG9TdHJpbmcuY2FsbChnbG9iYWwuRmlsZSkgPT09ICdbb2JqZWN0IEZpbGVDb25zdHJ1Y3Rvcl0nO1xuXG4vKipcbiAqIFJlcGxhY2VzIGV2ZXJ5IEJ1ZmZlciB8IEFycmF5QnVmZmVyIGluIHBhY2tldCB3aXRoIGEgbnVtYmVyZWQgcGxhY2Vob2xkZXIuXG4gKiBBbnl0aGluZyB3aXRoIGJsb2JzIG9yIGZpbGVzIHNob3VsZCBiZSBmZWQgdGhyb3VnaCByZW1vdmVCbG9icyBiZWZvcmUgY29taW5nXG4gKiBoZXJlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQgLSBzb2NrZXQuaW8gZXZlbnQgcGFja2V0XG4gKiBAcmV0dXJuIHtPYmplY3R9IHdpdGggZGVjb25zdHJ1Y3RlZCBwYWNrZXQgYW5kIGxpc3Qgb2YgYnVmZmVyc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmRlY29uc3RydWN0UGFja2V0ID0gZnVuY3Rpb24ocGFja2V0KSB7XG4gIHZhciBidWZmZXJzID0gW107XG4gIHZhciBwYWNrZXREYXRhID0gcGFja2V0LmRhdGE7XG4gIHZhciBwYWNrID0gcGFja2V0O1xuICBwYWNrLmRhdGEgPSBfZGVjb25zdHJ1Y3RQYWNrZXQocGFja2V0RGF0YSwgYnVmZmVycyk7XG4gIHBhY2suYXR0YWNobWVudHMgPSBidWZmZXJzLmxlbmd0aDsgLy8gbnVtYmVyIG9mIGJpbmFyeSAnYXR0YWNobWVudHMnXG4gIHJldHVybiB7cGFja2V0OiBwYWNrLCBidWZmZXJzOiBidWZmZXJzfTtcbn07XG5cbmZ1bmN0aW9uIF9kZWNvbnN0cnVjdFBhY2tldChkYXRhLCBidWZmZXJzKSB7XG4gIGlmICghZGF0YSkgcmV0dXJuIGRhdGE7XG5cbiAgaWYgKGlzQnVmKGRhdGEpKSB7XG4gICAgdmFyIHBsYWNlaG9sZGVyID0geyBfcGxhY2Vob2xkZXI6IHRydWUsIG51bTogYnVmZmVycy5sZW5ndGggfTtcbiAgICBidWZmZXJzLnB1c2goZGF0YSk7XG4gICAgcmV0dXJuIHBsYWNlaG9sZGVyO1xuICB9IGVsc2UgaWYgKGlzQXJyYXkoZGF0YSkpIHtcbiAgICB2YXIgbmV3RGF0YSA9IG5ldyBBcnJheShkYXRhLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBuZXdEYXRhW2ldID0gX2RlY29uc3RydWN0UGFja2V0KGRhdGFbaV0sIGJ1ZmZlcnMpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3RGF0YTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcgJiYgIShkYXRhIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICB2YXIgbmV3RGF0YSA9IHt9O1xuICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICBuZXdEYXRhW2tleV0gPSBfZGVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtrZXldLCBidWZmZXJzKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0RhdGE7XG4gIH1cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogUmVjb25zdHJ1Y3RzIGEgYmluYXJ5IHBhY2tldCBmcm9tIGl0cyBwbGFjZWhvbGRlciBwYWNrZXQgYW5kIGJ1ZmZlcnNcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0IC0gZXZlbnQgcGFja2V0IHdpdGggcGxhY2Vob2xkZXJzXG4gKiBAcGFyYW0ge0FycmF5fSBidWZmZXJzIC0gYmluYXJ5IGJ1ZmZlcnMgdG8gcHV0IGluIHBsYWNlaG9sZGVyIHBvc2l0aW9uc1xuICogQHJldHVybiB7T2JqZWN0fSByZWNvbnN0cnVjdGVkIHBhY2tldFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnJlY29uc3RydWN0UGFja2V0ID0gZnVuY3Rpb24ocGFja2V0LCBidWZmZXJzKSB7XG4gIHBhY2tldC5kYXRhID0gX3JlY29uc3RydWN0UGFja2V0KHBhY2tldC5kYXRhLCBidWZmZXJzKTtcbiAgcGFja2V0LmF0dGFjaG1lbnRzID0gdW5kZWZpbmVkOyAvLyBubyBsb25nZXIgdXNlZnVsXG4gIHJldHVybiBwYWNrZXQ7XG59O1xuXG5mdW5jdGlvbiBfcmVjb25zdHJ1Y3RQYWNrZXQoZGF0YSwgYnVmZmVycykge1xuICBpZiAoIWRhdGEpIHJldHVybiBkYXRhO1xuXG4gIGlmIChkYXRhICYmIGRhdGEuX3BsYWNlaG9sZGVyKSB7XG4gICAgcmV0dXJuIGJ1ZmZlcnNbZGF0YS5udW1dOyAvLyBhcHByb3ByaWF0ZSBidWZmZXIgKHNob3VsZCBiZSBuYXR1cmFsIG9yZGVyIGFueXdheSlcbiAgfSBlbHNlIGlmIChpc0FycmF5KGRhdGEpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkYXRhW2ldID0gX3JlY29uc3RydWN0UGFja2V0KGRhdGFbaV0sIGJ1ZmZlcnMpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgZGF0YVtrZXldID0gX3JlY29uc3RydWN0UGFja2V0KGRhdGFba2V5XSwgYnVmZmVycyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQXN5bmNocm9ub3VzbHkgcmVtb3ZlcyBCbG9icyBvciBGaWxlcyBmcm9tIGRhdGEgdmlhXG4gKiBGaWxlUmVhZGVyJ3MgcmVhZEFzQXJyYXlCdWZmZXIgbWV0aG9kLiBVc2VkIGJlZm9yZSBlbmNvZGluZ1xuICogZGF0YSBhcyBtc2dwYWNrLiBDYWxscyBjYWxsYmFjayB3aXRoIHRoZSBibG9ibGVzcyBkYXRhLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5yZW1vdmVCbG9icyA9IGZ1bmN0aW9uKGRhdGEsIGNhbGxiYWNrKSB7XG4gIGZ1bmN0aW9uIF9yZW1vdmVCbG9icyhvYmosIGN1cktleSwgY29udGFpbmluZ09iamVjdCkge1xuICAgIGlmICghb2JqKSByZXR1cm4gb2JqO1xuXG4gICAgLy8gY29udmVydCBhbnkgYmxvYlxuICAgIGlmICgod2l0aE5hdGl2ZUJsb2IgJiYgb2JqIGluc3RhbmNlb2YgQmxvYikgfHxcbiAgICAgICAgKHdpdGhOYXRpdmVGaWxlICYmIG9iaiBpbnN0YW5jZW9mIEZpbGUpKSB7XG4gICAgICBwZW5kaW5nQmxvYnMrKztcblxuICAgICAgLy8gYXN5bmMgZmlsZXJlYWRlclxuICAgICAgdmFyIGZpbGVSZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgZmlsZVJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbigpIHsgLy8gdGhpcy5yZXN1bHQgPT0gYXJyYXlidWZmZXJcbiAgICAgICAgaWYgKGNvbnRhaW5pbmdPYmplY3QpIHtcbiAgICAgICAgICBjb250YWluaW5nT2JqZWN0W2N1cktleV0gPSB0aGlzLnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBibG9ibGVzc0RhdGEgPSB0aGlzLnJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIG5vdGhpbmcgcGVuZGluZyBpdHMgY2FsbGJhY2sgdGltZVxuICAgICAgICBpZighIC0tcGVuZGluZ0Jsb2JzKSB7XG4gICAgICAgICAgY2FsbGJhY2soYmxvYmxlc3NEYXRhKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZmlsZVJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihvYmopOyAvLyBibG9iIC0+IGFycmF5YnVmZmVyXG4gICAgfSBlbHNlIGlmIChpc0FycmF5KG9iaikpIHsgLy8gaGFuZGxlIGFycmF5XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkrKykge1xuICAgICAgICBfcmVtb3ZlQmxvYnMob2JqW2ldLCBpLCBvYmopO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgIWlzQnVmKG9iaikpIHsgLy8gYW5kIG9iamVjdFxuICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBfcmVtb3ZlQmxvYnMob2JqW2tleV0sIGtleSwgb2JqKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgcGVuZGluZ0Jsb2JzID0gMDtcbiAgdmFyIGJsb2JsZXNzRGF0YSA9IGRhdGE7XG4gIF9yZW1vdmVCbG9icyhibG9ibGVzc0RhdGEpO1xuICBpZiAoIXBlbmRpbmdCbG9icykge1xuICAgIGNhbGxiYWNrKGJsb2JsZXNzRGF0YSk7XG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9iaW5hcnkuanMiLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tcGFyc2VyL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwiXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vc29ja2V0Jyk7XG5cbi8qKlxuICogRXhwb3J0cyBwYXJzZXJcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICpcbiAqL1xubW9kdWxlLmV4cG9ydHMucGFyc2VyID0gcmVxdWlyZSgnZW5naW5lLmlvLXBhcnNlcicpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL2luZGV4LmpzIiwiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciB0cmFuc3BvcnRzID0gcmVxdWlyZSgnLi90cmFuc3BvcnRzL2luZGV4Jyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdlbmdpbmUuaW8tY2xpZW50OnNvY2tldCcpO1xudmFyIGluZGV4ID0gcmVxdWlyZSgnaW5kZXhvZicpO1xudmFyIHBhcnNlciA9IHJlcXVpcmUoJ2VuZ2luZS5pby1wYXJzZXInKTtcbnZhciBwYXJzZXVyaSA9IHJlcXVpcmUoJ3BhcnNldXJpJyk7XG52YXIgcGFyc2VxcyA9IHJlcXVpcmUoJ3BhcnNlcXMnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNvY2tldDtcblxuLyoqXG4gKiBTb2NrZXQgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSB1cmkgb3Igb3B0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gU29ja2V0ICh1cmksIG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNvY2tldCkpIHJldHVybiBuZXcgU29ja2V0KHVyaSwgb3B0cyk7XG5cbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgaWYgKHVyaSAmJiAnb2JqZWN0JyA9PT0gdHlwZW9mIHVyaSkge1xuICAgIG9wdHMgPSB1cmk7XG4gICAgdXJpID0gbnVsbDtcbiAgfVxuXG4gIGlmICh1cmkpIHtcbiAgICB1cmkgPSBwYXJzZXVyaSh1cmkpO1xuICAgIG9wdHMuaG9zdG5hbWUgPSB1cmkuaG9zdDtcbiAgICBvcHRzLnNlY3VyZSA9IHVyaS5wcm90b2NvbCA9PT0gJ2h0dHBzJyB8fCB1cmkucHJvdG9jb2wgPT09ICd3c3MnO1xuICAgIG9wdHMucG9ydCA9IHVyaS5wb3J0O1xuICAgIGlmICh1cmkucXVlcnkpIG9wdHMucXVlcnkgPSB1cmkucXVlcnk7XG4gIH0gZWxzZSBpZiAob3B0cy5ob3N0KSB7XG4gICAgb3B0cy5ob3N0bmFtZSA9IHBhcnNldXJpKG9wdHMuaG9zdCkuaG9zdDtcbiAgfVxuXG4gIHRoaXMuc2VjdXJlID0gbnVsbCAhPSBvcHRzLnNlY3VyZSA/IG9wdHMuc2VjdXJlXG4gICAgOiAoZ2xvYmFsLmxvY2F0aW9uICYmICdodHRwczonID09PSBsb2NhdGlvbi5wcm90b2NvbCk7XG5cbiAgaWYgKG9wdHMuaG9zdG5hbWUgJiYgIW9wdHMucG9ydCkge1xuICAgIC8vIGlmIG5vIHBvcnQgaXMgc3BlY2lmaWVkIG1hbnVhbGx5LCB1c2UgdGhlIHByb3RvY29sIGRlZmF1bHRcbiAgICBvcHRzLnBvcnQgPSB0aGlzLnNlY3VyZSA/ICc0NDMnIDogJzgwJztcbiAgfVxuXG4gIHRoaXMuYWdlbnQgPSBvcHRzLmFnZW50IHx8IGZhbHNlO1xuICB0aGlzLmhvc3RuYW1lID0gb3B0cy5ob3N0bmFtZSB8fFxuICAgIChnbG9iYWwubG9jYXRpb24gPyBsb2NhdGlvbi5ob3N0bmFtZSA6ICdsb2NhbGhvc3QnKTtcbiAgdGhpcy5wb3J0ID0gb3B0cy5wb3J0IHx8IChnbG9iYWwubG9jYXRpb24gJiYgbG9jYXRpb24ucG9ydFxuICAgICAgPyBsb2NhdGlvbi5wb3J0XG4gICAgICA6ICh0aGlzLnNlY3VyZSA/IDQ0MyA6IDgwKSk7XG4gIHRoaXMucXVlcnkgPSBvcHRzLnF1ZXJ5IHx8IHt9O1xuICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiB0aGlzLnF1ZXJ5KSB0aGlzLnF1ZXJ5ID0gcGFyc2Vxcy5kZWNvZGUodGhpcy5xdWVyeSk7XG4gIHRoaXMudXBncmFkZSA9IGZhbHNlICE9PSBvcHRzLnVwZ3JhZGU7XG4gIHRoaXMucGF0aCA9IChvcHRzLnBhdGggfHwgJy9lbmdpbmUuaW8nKS5yZXBsYWNlKC9cXC8kLywgJycpICsgJy8nO1xuICB0aGlzLmZvcmNlSlNPTlAgPSAhIW9wdHMuZm9yY2VKU09OUDtcbiAgdGhpcy5qc29ucCA9IGZhbHNlICE9PSBvcHRzLmpzb25wO1xuICB0aGlzLmZvcmNlQmFzZTY0ID0gISFvcHRzLmZvcmNlQmFzZTY0O1xuICB0aGlzLmVuYWJsZXNYRFIgPSAhIW9wdHMuZW5hYmxlc1hEUjtcbiAgdGhpcy50aW1lc3RhbXBQYXJhbSA9IG9wdHMudGltZXN0YW1wUGFyYW0gfHwgJ3QnO1xuICB0aGlzLnRpbWVzdGFtcFJlcXVlc3RzID0gb3B0cy50aW1lc3RhbXBSZXF1ZXN0cztcbiAgdGhpcy50cmFuc3BvcnRzID0gb3B0cy50cmFuc3BvcnRzIHx8IFsncG9sbGluZycsICd3ZWJzb2NrZXQnXTtcbiAgdGhpcy50cmFuc3BvcnRPcHRpb25zID0gb3B0cy50cmFuc3BvcnRPcHRpb25zIHx8IHt9O1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnJztcbiAgdGhpcy53cml0ZUJ1ZmZlciA9IFtdO1xuICB0aGlzLnByZXZCdWZmZXJMZW4gPSAwO1xuICB0aGlzLnBvbGljeVBvcnQgPSBvcHRzLnBvbGljeVBvcnQgfHwgODQzO1xuICB0aGlzLnJlbWVtYmVyVXBncmFkZSA9IG9wdHMucmVtZW1iZXJVcGdyYWRlIHx8IGZhbHNlO1xuICB0aGlzLmJpbmFyeVR5cGUgPSBudWxsO1xuICB0aGlzLm9ubHlCaW5hcnlVcGdyYWRlcyA9IG9wdHMub25seUJpbmFyeVVwZ3JhZGVzO1xuICB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlID0gZmFsc2UgIT09IG9wdHMucGVyTWVzc2FnZURlZmxhdGUgPyAob3B0cy5wZXJNZXNzYWdlRGVmbGF0ZSB8fCB7fSkgOiBmYWxzZTtcblxuICBpZiAodHJ1ZSA9PT0gdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSkgdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSA9IHt9O1xuICBpZiAodGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSAmJiBudWxsID09IHRoaXMucGVyTWVzc2FnZURlZmxhdGUudGhyZXNob2xkKSB7XG4gICAgdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZS50aHJlc2hvbGQgPSAxMDI0O1xuICB9XG5cbiAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIHRoaXMucGZ4ID0gb3B0cy5wZnggfHwgbnVsbDtcbiAgdGhpcy5rZXkgPSBvcHRzLmtleSB8fCBudWxsO1xuICB0aGlzLnBhc3NwaHJhc2UgPSBvcHRzLnBhc3NwaHJhc2UgfHwgbnVsbDtcbiAgdGhpcy5jZXJ0ID0gb3B0cy5jZXJ0IHx8IG51bGw7XG4gIHRoaXMuY2EgPSBvcHRzLmNhIHx8IG51bGw7XG4gIHRoaXMuY2lwaGVycyA9IG9wdHMuY2lwaGVycyB8fCBudWxsO1xuICB0aGlzLnJlamVjdFVuYXV0aG9yaXplZCA9IG9wdHMucmVqZWN0VW5hdXRob3JpemVkID09PSB1bmRlZmluZWQgPyB0cnVlIDogb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQ7XG4gIHRoaXMuZm9yY2VOb2RlID0gISFvcHRzLmZvcmNlTm9kZTtcblxuICAvLyBvdGhlciBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT09ICdvYmplY3QnICYmIGdsb2JhbDtcbiAgaWYgKGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsKSB7XG4gICAgaWYgKG9wdHMuZXh0cmFIZWFkZXJzICYmIE9iamVjdC5rZXlzKG9wdHMuZXh0cmFIZWFkZXJzKS5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmV4dHJhSGVhZGVycyA9IG9wdHMuZXh0cmFIZWFkZXJzO1xuICAgIH1cblxuICAgIGlmIChvcHRzLmxvY2FsQWRkcmVzcykge1xuICAgICAgdGhpcy5sb2NhbEFkZHJlc3MgPSBvcHRzLmxvY2FsQWRkcmVzcztcbiAgICB9XG4gIH1cblxuICAvLyBzZXQgb24gaGFuZHNoYWtlXG4gIHRoaXMuaWQgPSBudWxsO1xuICB0aGlzLnVwZ3JhZGVzID0gbnVsbDtcbiAgdGhpcy5waW5nSW50ZXJ2YWwgPSBudWxsO1xuICB0aGlzLnBpbmdUaW1lb3V0ID0gbnVsbDtcblxuICAvLyBzZXQgb24gaGVhcnRiZWF0XG4gIHRoaXMucGluZ0ludGVydmFsVGltZXIgPSBudWxsO1xuICB0aGlzLnBpbmdUaW1lb3V0VGltZXIgPSBudWxsO1xuXG4gIHRoaXMub3BlbigpO1xufVxuXG5Tb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gZmFsc2U7XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKFNvY2tldC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIFByb3RvY29sIHZlcnNpb24uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG9jb2wgPSBwYXJzZXIucHJvdG9jb2w7IC8vIHRoaXMgaXMgYW4gaW50XG5cbi8qKlxuICogRXhwb3NlIGRlcHMgZm9yIGxlZ2FjeSBjb21wYXRpYmlsaXR5XG4gKiBhbmQgc3RhbmRhbG9uZSBicm93c2VyIGFjY2Vzcy5cbiAqL1xuXG5Tb2NrZXQuU29ja2V0ID0gU29ja2V0O1xuU29ja2V0LlRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0Jyk7XG5Tb2NrZXQudHJhbnNwb3J0cyA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0cy9pbmRleCcpO1xuU29ja2V0LnBhcnNlciA9IHJlcXVpcmUoJ2VuZ2luZS5pby1wYXJzZXInKTtcblxuLyoqXG4gKiBDcmVhdGVzIHRyYW5zcG9ydCBvZiB0aGUgZ2l2ZW4gdHlwZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHJhbnNwb3J0IG5hbWVcbiAqIEByZXR1cm4ge1RyYW5zcG9ydH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuY3JlYXRlVHJhbnNwb3J0ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgZGVidWcoJ2NyZWF0aW5nIHRyYW5zcG9ydCBcIiVzXCInLCBuYW1lKTtcbiAgdmFyIHF1ZXJ5ID0gY2xvbmUodGhpcy5xdWVyeSk7XG5cbiAgLy8gYXBwZW5kIGVuZ2luZS5pbyBwcm90b2NvbCBpZGVudGlmaWVyXG4gIHF1ZXJ5LkVJTyA9IHBhcnNlci5wcm90b2NvbDtcblxuICAvLyB0cmFuc3BvcnQgbmFtZVxuICBxdWVyeS50cmFuc3BvcnQgPSBuYW1lO1xuXG4gIC8vIHBlci10cmFuc3BvcnQgb3B0aW9uc1xuICB2YXIgb3B0aW9ucyA9IHRoaXMudHJhbnNwb3J0T3B0aW9uc1tuYW1lXSB8fCB7fTtcblxuICAvLyBzZXNzaW9uIGlkIGlmIHdlIGFscmVhZHkgaGF2ZSBvbmVcbiAgaWYgKHRoaXMuaWQpIHF1ZXJ5LnNpZCA9IHRoaXMuaWQ7XG5cbiAgdmFyIHRyYW5zcG9ydCA9IG5ldyB0cmFuc3BvcnRzW25hbWVdKHtcbiAgICBxdWVyeTogcXVlcnksXG4gICAgc29ja2V0OiB0aGlzLFxuICAgIGFnZW50OiBvcHRpb25zLmFnZW50IHx8IHRoaXMuYWdlbnQsXG4gICAgaG9zdG5hbWU6IG9wdGlvbnMuaG9zdG5hbWUgfHwgdGhpcy5ob3N0bmFtZSxcbiAgICBwb3J0OiBvcHRpb25zLnBvcnQgfHwgdGhpcy5wb3J0LFxuICAgIHNlY3VyZTogb3B0aW9ucy5zZWN1cmUgfHwgdGhpcy5zZWN1cmUsXG4gICAgcGF0aDogb3B0aW9ucy5wYXRoIHx8IHRoaXMucGF0aCxcbiAgICBmb3JjZUpTT05QOiBvcHRpb25zLmZvcmNlSlNPTlAgfHwgdGhpcy5mb3JjZUpTT05QLFxuICAgIGpzb25wOiBvcHRpb25zLmpzb25wIHx8IHRoaXMuanNvbnAsXG4gICAgZm9yY2VCYXNlNjQ6IG9wdGlvbnMuZm9yY2VCYXNlNjQgfHwgdGhpcy5mb3JjZUJhc2U2NCxcbiAgICBlbmFibGVzWERSOiBvcHRpb25zLmVuYWJsZXNYRFIgfHwgdGhpcy5lbmFibGVzWERSLFxuICAgIHRpbWVzdGFtcFJlcXVlc3RzOiBvcHRpb25zLnRpbWVzdGFtcFJlcXVlc3RzIHx8IHRoaXMudGltZXN0YW1wUmVxdWVzdHMsXG4gICAgdGltZXN0YW1wUGFyYW06IG9wdGlvbnMudGltZXN0YW1wUGFyYW0gfHwgdGhpcy50aW1lc3RhbXBQYXJhbSxcbiAgICBwb2xpY3lQb3J0OiBvcHRpb25zLnBvbGljeVBvcnQgfHwgdGhpcy5wb2xpY3lQb3J0LFxuICAgIHBmeDogb3B0aW9ucy5wZnggfHwgdGhpcy5wZngsXG4gICAga2V5OiBvcHRpb25zLmtleSB8fCB0aGlzLmtleSxcbiAgICBwYXNzcGhyYXNlOiBvcHRpb25zLnBhc3NwaHJhc2UgfHwgdGhpcy5wYXNzcGhyYXNlLFxuICAgIGNlcnQ6IG9wdGlvbnMuY2VydCB8fCB0aGlzLmNlcnQsXG4gICAgY2E6IG9wdGlvbnMuY2EgfHwgdGhpcy5jYSxcbiAgICBjaXBoZXJzOiBvcHRpb25zLmNpcGhlcnMgfHwgdGhpcy5jaXBoZXJzLFxuICAgIHJlamVjdFVuYXV0aG9yaXplZDogb3B0aW9ucy5yZWplY3RVbmF1dGhvcml6ZWQgfHwgdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQsXG4gICAgcGVyTWVzc2FnZURlZmxhdGU6IG9wdGlvbnMucGVyTWVzc2FnZURlZmxhdGUgfHwgdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSxcbiAgICBleHRyYUhlYWRlcnM6IG9wdGlvbnMuZXh0cmFIZWFkZXJzIHx8IHRoaXMuZXh0cmFIZWFkZXJzLFxuICAgIGZvcmNlTm9kZTogb3B0aW9ucy5mb3JjZU5vZGUgfHwgdGhpcy5mb3JjZU5vZGUsXG4gICAgbG9jYWxBZGRyZXNzOiBvcHRpb25zLmxvY2FsQWRkcmVzcyB8fCB0aGlzLmxvY2FsQWRkcmVzcyxcbiAgICByZXF1ZXN0VGltZW91dDogb3B0aW9ucy5yZXF1ZXN0VGltZW91dCB8fCB0aGlzLnJlcXVlc3RUaW1lb3V0LFxuICAgIHByb3RvY29sczogb3B0aW9ucy5wcm90b2NvbHMgfHwgdm9pZCAoMClcbiAgfSk7XG5cbiAgcmV0dXJuIHRyYW5zcG9ydDtcbn07XG5cbmZ1bmN0aW9uIGNsb25lIChvYmopIHtcbiAgdmFyIG8gPSB7fTtcbiAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICBvW2ldID0gb2JqW2ldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbztcbn1cblxuLyoqXG4gKiBJbml0aWFsaXplcyB0cmFuc3BvcnQgdG8gdXNlIGFuZCBzdGFydHMgcHJvYmUuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblNvY2tldC5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRyYW5zcG9ydDtcbiAgaWYgKHRoaXMucmVtZW1iZXJVcGdyYWRlICYmIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgJiYgdGhpcy50cmFuc3BvcnRzLmluZGV4T2YoJ3dlYnNvY2tldCcpICE9PSAtMSkge1xuICAgIHRyYW5zcG9ydCA9ICd3ZWJzb2NrZXQnO1xuICB9IGVsc2UgaWYgKDAgPT09IHRoaXMudHJhbnNwb3J0cy5sZW5ndGgpIHtcbiAgICAvLyBFbWl0IGVycm9yIG9uIG5leHQgdGljayBzbyBpdCBjYW4gYmUgbGlzdGVuZWQgdG9cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgJ05vIHRyYW5zcG9ydHMgYXZhaWxhYmxlJyk7XG4gICAgfSwgMCk7XG4gICAgcmV0dXJuO1xuICB9IGVsc2Uge1xuICAgIHRyYW5zcG9ydCA9IHRoaXMudHJhbnNwb3J0c1swXTtcbiAgfVxuICB0aGlzLnJlYWR5U3RhdGUgPSAnb3BlbmluZyc7XG5cbiAgLy8gUmV0cnkgd2l0aCB0aGUgbmV4dCB0cmFuc3BvcnQgaWYgdGhlIHRyYW5zcG9ydCBpcyBkaXNhYmxlZCAoanNvbnA6IGZhbHNlKVxuICB0cnkge1xuICAgIHRyYW5zcG9ydCA9IHRoaXMuY3JlYXRlVHJhbnNwb3J0KHRyYW5zcG9ydCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aGlzLnRyYW5zcG9ydHMuc2hpZnQoKTtcbiAgICB0aGlzLm9wZW4oKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB0cmFuc3BvcnQub3BlbigpO1xuICB0aGlzLnNldFRyYW5zcG9ydCh0cmFuc3BvcnQpO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBjdXJyZW50IHRyYW5zcG9ydC4gRGlzYWJsZXMgdGhlIGV4aXN0aW5nIG9uZSAoaWYgYW55KS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnNldFRyYW5zcG9ydCA9IGZ1bmN0aW9uICh0cmFuc3BvcnQpIHtcbiAgZGVidWcoJ3NldHRpbmcgdHJhbnNwb3J0ICVzJywgdHJhbnNwb3J0Lm5hbWUpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgaWYgKHRoaXMudHJhbnNwb3J0KSB7XG4gICAgZGVidWcoJ2NsZWFyaW5nIGV4aXN0aW5nIHRyYW5zcG9ydCAlcycsIHRoaXMudHJhbnNwb3J0Lm5hbWUpO1xuICAgIHRoaXMudHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB9XG5cbiAgLy8gc2V0IHVwIHRyYW5zcG9ydFxuICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcblxuICAvLyBzZXQgdXAgdHJhbnNwb3J0IGxpc3RlbmVyc1xuICB0cmFuc3BvcnRcbiAgLm9uKCdkcmFpbicsIGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLm9uRHJhaW4oKTtcbiAgfSlcbiAgLm9uKCdwYWNrZXQnLCBmdW5jdGlvbiAocGFja2V0KSB7XG4gICAgc2VsZi5vblBhY2tldChwYWNrZXQpO1xuICB9KVxuICAub24oJ2Vycm9yJywgZnVuY3Rpb24gKGUpIHtcbiAgICBzZWxmLm9uRXJyb3IoZSk7XG4gIH0pXG4gIC5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5vbkNsb3NlKCd0cmFuc3BvcnQgY2xvc2UnKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFByb2JlcyBhIHRyYW5zcG9ydC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHJhbnNwb3J0IG5hbWVcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUucHJvYmUgPSBmdW5jdGlvbiAobmFtZSkge1xuICBkZWJ1ZygncHJvYmluZyB0cmFuc3BvcnQgXCIlc1wiJywgbmFtZSk7XG4gIHZhciB0cmFuc3BvcnQgPSB0aGlzLmNyZWF0ZVRyYW5zcG9ydChuYW1lLCB7IHByb2JlOiAxIH0pO1xuICB2YXIgZmFpbGVkID0gZmFsc2U7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gb25UcmFuc3BvcnRPcGVuICgpIHtcbiAgICBpZiAoc2VsZi5vbmx5QmluYXJ5VXBncmFkZXMpIHtcbiAgICAgIHZhciB1cGdyYWRlTG9zZXNCaW5hcnkgPSAhdGhpcy5zdXBwb3J0c0JpbmFyeSAmJiBzZWxmLnRyYW5zcG9ydC5zdXBwb3J0c0JpbmFyeTtcbiAgICAgIGZhaWxlZCA9IGZhaWxlZCB8fCB1cGdyYWRlTG9zZXNCaW5hcnk7XG4gICAgfVxuICAgIGlmIChmYWlsZWQpIHJldHVybjtcblxuICAgIGRlYnVnKCdwcm9iZSB0cmFuc3BvcnQgXCIlc1wiIG9wZW5lZCcsIG5hbWUpO1xuICAgIHRyYW5zcG9ydC5zZW5kKFt7IHR5cGU6ICdwaW5nJywgZGF0YTogJ3Byb2JlJyB9XSk7XG4gICAgdHJhbnNwb3J0Lm9uY2UoJ3BhY2tldCcsIGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgIGlmIChmYWlsZWQpIHJldHVybjtcbiAgICAgIGlmICgncG9uZycgPT09IG1zZy50eXBlICYmICdwcm9iZScgPT09IG1zZy5kYXRhKSB7XG4gICAgICAgIGRlYnVnKCdwcm9iZSB0cmFuc3BvcnQgXCIlc1wiIHBvbmcnLCBuYW1lKTtcbiAgICAgICAgc2VsZi51cGdyYWRpbmcgPSB0cnVlO1xuICAgICAgICBzZWxmLmVtaXQoJ3VwZ3JhZGluZycsIHRyYW5zcG9ydCk7XG4gICAgICAgIGlmICghdHJhbnNwb3J0KSByZXR1cm47XG4gICAgICAgIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSAnd2Vic29ja2V0JyA9PT0gdHJhbnNwb3J0Lm5hbWU7XG5cbiAgICAgICAgZGVidWcoJ3BhdXNpbmcgY3VycmVudCB0cmFuc3BvcnQgXCIlc1wiJywgc2VsZi50cmFuc3BvcnQubmFtZSk7XG4gICAgICAgIHNlbGYudHJhbnNwb3J0LnBhdXNlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoZmFpbGVkKSByZXR1cm47XG4gICAgICAgICAgaWYgKCdjbG9zZWQnID09PSBzZWxmLnJlYWR5U3RhdGUpIHJldHVybjtcbiAgICAgICAgICBkZWJ1ZygnY2hhbmdpbmcgdHJhbnNwb3J0IGFuZCBzZW5kaW5nIHVwZ3JhZGUgcGFja2V0Jyk7XG5cbiAgICAgICAgICBjbGVhbnVwKCk7XG5cbiAgICAgICAgICBzZWxmLnNldFRyYW5zcG9ydCh0cmFuc3BvcnQpO1xuICAgICAgICAgIHRyYW5zcG9ydC5zZW5kKFt7IHR5cGU6ICd1cGdyYWRlJyB9XSk7XG4gICAgICAgICAgc2VsZi5lbWl0KCd1cGdyYWRlJywgdHJhbnNwb3J0KTtcbiAgICAgICAgICB0cmFuc3BvcnQgPSBudWxsO1xuICAgICAgICAgIHNlbGYudXBncmFkaW5nID0gZmFsc2U7XG4gICAgICAgICAgc2VsZi5mbHVzaCgpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlYnVnKCdwcm9iZSB0cmFuc3BvcnQgXCIlc1wiIGZhaWxlZCcsIG5hbWUpO1xuICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdwcm9iZSBlcnJvcicpO1xuICAgICAgICBlcnIudHJhbnNwb3J0ID0gdHJhbnNwb3J0Lm5hbWU7XG4gICAgICAgIHNlbGYuZW1pdCgndXBncmFkZUVycm9yJywgZXJyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZyZWV6ZVRyYW5zcG9ydCAoKSB7XG4gICAgaWYgKGZhaWxlZCkgcmV0dXJuO1xuXG4gICAgLy8gQW55IGNhbGxiYWNrIGNhbGxlZCBieSB0cmFuc3BvcnQgc2hvdWxkIGJlIGlnbm9yZWQgc2luY2Ugbm93XG4gICAgZmFpbGVkID0gdHJ1ZTtcblxuICAgIGNsZWFudXAoKTtcblxuICAgIHRyYW5zcG9ydC5jbG9zZSgpO1xuICAgIHRyYW5zcG9ydCA9IG51bGw7XG4gIH1cblxuICAvLyBIYW5kbGUgYW55IGVycm9yIHRoYXQgaGFwcGVucyB3aGlsZSBwcm9iaW5nXG4gIGZ1bmN0aW9uIG9uZXJyb3IgKGVycikge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcigncHJvYmUgZXJyb3I6ICcgKyBlcnIpO1xuICAgIGVycm9yLnRyYW5zcG9ydCA9IHRyYW5zcG9ydC5uYW1lO1xuXG4gICAgZnJlZXplVHJhbnNwb3J0KCk7XG5cbiAgICBkZWJ1ZygncHJvYmUgdHJhbnNwb3J0IFwiJXNcIiBmYWlsZWQgYmVjYXVzZSBvZiBlcnJvcjogJXMnLCBuYW1lLCBlcnIpO1xuXG4gICAgc2VsZi5lbWl0KCd1cGdyYWRlRXJyb3InLCBlcnJvcik7XG4gIH1cblxuICBmdW5jdGlvbiBvblRyYW5zcG9ydENsb3NlICgpIHtcbiAgICBvbmVycm9yKCd0cmFuc3BvcnQgY2xvc2VkJyk7XG4gIH1cblxuICAvLyBXaGVuIHRoZSBzb2NrZXQgaXMgY2xvc2VkIHdoaWxlIHdlJ3JlIHByb2JpbmdcbiAgZnVuY3Rpb24gb25jbG9zZSAoKSB7XG4gICAgb25lcnJvcignc29ja2V0IGNsb3NlZCcpO1xuICB9XG5cbiAgLy8gV2hlbiB0aGUgc29ja2V0IGlzIHVwZ3JhZGVkIHdoaWxlIHdlJ3JlIHByb2JpbmdcbiAgZnVuY3Rpb24gb251cGdyYWRlICh0bykge1xuICAgIGlmICh0cmFuc3BvcnQgJiYgdG8ubmFtZSAhPT0gdHJhbnNwb3J0Lm5hbWUpIHtcbiAgICAgIGRlYnVnKCdcIiVzXCIgd29ya3MgLSBhYm9ydGluZyBcIiVzXCInLCB0by5uYW1lLCB0cmFuc3BvcnQubmFtZSk7XG4gICAgICBmcmVlemVUcmFuc3BvcnQoKTtcbiAgICB9XG4gIH1cblxuICAvLyBSZW1vdmUgYWxsIGxpc3RlbmVycyBvbiB0aGUgdHJhbnNwb3J0IGFuZCBvbiBzZWxmXG4gIGZ1bmN0aW9uIGNsZWFudXAgKCkge1xuICAgIHRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcignb3BlbicsIG9uVHJhbnNwb3J0T3Blbik7XG4gICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIHRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvblRyYW5zcG9ydENsb3NlKTtcbiAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoJ3VwZ3JhZGluZycsIG9udXBncmFkZSk7XG4gIH1cblxuICB0cmFuc3BvcnQub25jZSgnb3BlbicsIG9uVHJhbnNwb3J0T3Blbik7XG4gIHRyYW5zcG9ydC5vbmNlKCdlcnJvcicsIG9uZXJyb3IpO1xuICB0cmFuc3BvcnQub25jZSgnY2xvc2UnLCBvblRyYW5zcG9ydENsb3NlKTtcblxuICB0aGlzLm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIHRoaXMub25jZSgndXBncmFkaW5nJywgb251cGdyYWRlKTtcblxuICB0cmFuc3BvcnQub3BlbigpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2hlbiBjb25uZWN0aW9uIGlzIGRlZW1lZCBvcGVuLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbk9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdzb2NrZXQgb3BlbicpO1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnb3Blbic7XG4gIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSAnd2Vic29ja2V0JyA9PT0gdGhpcy50cmFuc3BvcnQubmFtZTtcbiAgdGhpcy5lbWl0KCdvcGVuJyk7XG4gIHRoaXMuZmx1c2goKTtcblxuICAvLyB3ZSBjaGVjayBmb3IgYHJlYWR5U3RhdGVgIGluIGNhc2UgYW4gYG9wZW5gXG4gIC8vIGxpc3RlbmVyIGFscmVhZHkgY2xvc2VkIHRoZSBzb2NrZXRcbiAgaWYgKCdvcGVuJyA9PT0gdGhpcy5yZWFkeVN0YXRlICYmIHRoaXMudXBncmFkZSAmJiB0aGlzLnRyYW5zcG9ydC5wYXVzZSkge1xuICAgIGRlYnVnKCdzdGFydGluZyB1cGdyYWRlIHByb2JlcycpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy51cGdyYWRlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHRoaXMucHJvYmUodGhpcy51cGdyYWRlc1tpXSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEhhbmRsZXMgYSBwYWNrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vblBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgaWYgKCdvcGVuaW5nJyA9PT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdvcGVuJyA9PT0gdGhpcy5yZWFkeVN0YXRlIHx8XG4gICAgICAnY2xvc2luZycgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIGRlYnVnKCdzb2NrZXQgcmVjZWl2ZTogdHlwZSBcIiVzXCIsIGRhdGEgXCIlc1wiJywgcGFja2V0LnR5cGUsIHBhY2tldC5kYXRhKTtcblxuICAgIHRoaXMuZW1pdCgncGFja2V0JywgcGFja2V0KTtcblxuICAgIC8vIFNvY2tldCBpcyBsaXZlIC0gYW55IHBhY2tldCBjb3VudHNcbiAgICB0aGlzLmVtaXQoJ2hlYXJ0YmVhdCcpO1xuXG4gICAgc3dpdGNoIChwYWNrZXQudHlwZSkge1xuICAgICAgY2FzZSAnb3Blbic6XG4gICAgICAgIHRoaXMub25IYW5kc2hha2UoSlNPTi5wYXJzZShwYWNrZXQuZGF0YSkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAncG9uZyc6XG4gICAgICAgIHRoaXMuc2V0UGluZygpO1xuICAgICAgICB0aGlzLmVtaXQoJ3BvbmcnKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignc2VydmVyIGVycm9yJyk7XG4gICAgICAgIGVyci5jb2RlID0gcGFja2V0LmRhdGE7XG4gICAgICAgIHRoaXMub25FcnJvcihlcnIpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnbWVzc2FnZSc6XG4gICAgICAgIHRoaXMuZW1pdCgnZGF0YScsIHBhY2tldC5kYXRhKTtcbiAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgcGFja2V0LmRhdGEpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZGVidWcoJ3BhY2tldCByZWNlaXZlZCB3aXRoIHNvY2tldCByZWFkeVN0YXRlIFwiJXNcIicsIHRoaXMucmVhZHlTdGF0ZSk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gaGFuZHNoYWtlIGNvbXBsZXRpb24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGhhbmRzaGFrZSBvYmpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25IYW5kc2hha2UgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB0aGlzLmVtaXQoJ2hhbmRzaGFrZScsIGRhdGEpO1xuICB0aGlzLmlkID0gZGF0YS5zaWQ7XG4gIHRoaXMudHJhbnNwb3J0LnF1ZXJ5LnNpZCA9IGRhdGEuc2lkO1xuICB0aGlzLnVwZ3JhZGVzID0gdGhpcy5maWx0ZXJVcGdyYWRlcyhkYXRhLnVwZ3JhZGVzKTtcbiAgdGhpcy5waW5nSW50ZXJ2YWwgPSBkYXRhLnBpbmdJbnRlcnZhbDtcbiAgdGhpcy5waW5nVGltZW91dCA9IGRhdGEucGluZ1RpbWVvdXQ7XG4gIHRoaXMub25PcGVuKCk7XG4gIC8vIEluIGNhc2Ugb3BlbiBoYW5kbGVyIGNsb3NlcyBzb2NrZXRcbiAgaWYgKCdjbG9zZWQnID09PSB0aGlzLnJlYWR5U3RhdGUpIHJldHVybjtcbiAgdGhpcy5zZXRQaW5nKCk7XG5cbiAgLy8gUHJvbG9uZyBsaXZlbmVzcyBvZiBzb2NrZXQgb24gaGVhcnRiZWF0XG4gIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2hlYXJ0YmVhdCcsIHRoaXMub25IZWFydGJlYXQpO1xuICB0aGlzLm9uKCdoZWFydGJlYXQnLCB0aGlzLm9uSGVhcnRiZWF0KTtcbn07XG5cbi8qKlxuICogUmVzZXRzIHBpbmcgdGltZW91dC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uSGVhcnRiZWF0ID0gZnVuY3Rpb24gKHRpbWVvdXQpIHtcbiAgY2xlYXJUaW1lb3V0KHRoaXMucGluZ1RpbWVvdXRUaW1lcik7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgc2VsZi5waW5nVGltZW91dFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCdjbG9zZWQnID09PSBzZWxmLnJlYWR5U3RhdGUpIHJldHVybjtcbiAgICBzZWxmLm9uQ2xvc2UoJ3BpbmcgdGltZW91dCcpO1xuICB9LCB0aW1lb3V0IHx8IChzZWxmLnBpbmdJbnRlcnZhbCArIHNlbGYucGluZ1RpbWVvdXQpKTtcbn07XG5cbi8qKlxuICogUGluZ3Mgc2VydmVyIGV2ZXJ5IGB0aGlzLnBpbmdJbnRlcnZhbGAgYW5kIGV4cGVjdHMgcmVzcG9uc2VcbiAqIHdpdGhpbiBgdGhpcy5waW5nVGltZW91dGAgb3IgY2xvc2VzIGNvbm5lY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5zZXRQaW5nID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGNsZWFyVGltZW91dChzZWxmLnBpbmdJbnRlcnZhbFRpbWVyKTtcbiAgc2VsZi5waW5nSW50ZXJ2YWxUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGRlYnVnKCd3cml0aW5nIHBpbmcgcGFja2V0IC0gZXhwZWN0aW5nIHBvbmcgd2l0aGluICVzbXMnLCBzZWxmLnBpbmdUaW1lb3V0KTtcbiAgICBzZWxmLnBpbmcoKTtcbiAgICBzZWxmLm9uSGVhcnRiZWF0KHNlbGYucGluZ1RpbWVvdXQpO1xuICB9LCBzZWxmLnBpbmdJbnRlcnZhbCk7XG59O1xuXG4vKipcbiogU2VuZHMgYSBwaW5nIHBhY2tldC5cbipcbiogQGFwaSBwcml2YXRlXG4qL1xuXG5Tb2NrZXQucHJvdG90eXBlLnBpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5zZW5kUGFja2V0KCdwaW5nJywgZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuZW1pdCgncGluZycpO1xuICB9KTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIG9uIGBkcmFpbmAgZXZlbnRcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uRHJhaW4gPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMud3JpdGVCdWZmZXIuc3BsaWNlKDAsIHRoaXMucHJldkJ1ZmZlckxlbik7XG5cbiAgLy8gc2V0dGluZyBwcmV2QnVmZmVyTGVuID0gMCBpcyB2ZXJ5IGltcG9ydGFudFxuICAvLyBmb3IgZXhhbXBsZSwgd2hlbiB1cGdyYWRpbmcsIHVwZ3JhZGUgcGFja2V0IGlzIHNlbnQgb3ZlcixcbiAgLy8gYW5kIGEgbm9uemVybyBwcmV2QnVmZmVyTGVuIGNvdWxkIGNhdXNlIHByb2JsZW1zIG9uIGBkcmFpbmBcbiAgdGhpcy5wcmV2QnVmZmVyTGVuID0gMDtcblxuICBpZiAoMCA9PT0gdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpIHtcbiAgICB0aGlzLmVtaXQoJ2RyYWluJyk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5mbHVzaCgpO1xuICB9XG59O1xuXG4vKipcbiAqIEZsdXNoIHdyaXRlIGJ1ZmZlcnMuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCdjbG9zZWQnICE9PSB0aGlzLnJlYWR5U3RhdGUgJiYgdGhpcy50cmFuc3BvcnQud3JpdGFibGUgJiZcbiAgICAhdGhpcy51cGdyYWRpbmcgJiYgdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpIHtcbiAgICBkZWJ1ZygnZmx1c2hpbmcgJWQgcGFja2V0cyBpbiBzb2NrZXQnLCB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCk7XG4gICAgdGhpcy50cmFuc3BvcnQuc2VuZCh0aGlzLndyaXRlQnVmZmVyKTtcbiAgICAvLyBrZWVwIHRyYWNrIG9mIGN1cnJlbnQgbGVuZ3RoIG9mIHdyaXRlQnVmZmVyXG4gICAgLy8gc3BsaWNlIHdyaXRlQnVmZmVyIGFuZCBjYWxsYmFja0J1ZmZlciBvbiBgZHJhaW5gXG4gICAgdGhpcy5wcmV2QnVmZmVyTGVuID0gdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGg7XG4gICAgdGhpcy5lbWl0KCdmbHVzaCcpO1xuICB9XG59O1xuXG4vKipcbiAqIFNlbmRzIGEgbWVzc2FnZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuXG4gKiBAcmV0dXJuIHtTb2NrZXR9IGZvciBjaGFpbmluZy5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS53cml0ZSA9XG5Tb2NrZXQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAobXNnLCBvcHRpb25zLCBmbikge1xuICB0aGlzLnNlbmRQYWNrZXQoJ21lc3NhZ2UnLCBtc2csIG9wdGlvbnMsIGZuKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNlbmRzIGEgcGFja2V0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYWNrZXQgdHlwZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbi5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuc2VuZFBhY2tldCA9IGZ1bmN0aW9uICh0eXBlLCBkYXRhLCBvcHRpb25zLCBmbikge1xuICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGRhdGEpIHtcbiAgICBmbiA9IGRhdGE7XG4gICAgZGF0YSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2Ygb3B0aW9ucykge1xuICAgIGZuID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0gbnVsbDtcbiAgfVxuXG4gIGlmICgnY2xvc2luZycgPT09IHRoaXMucmVhZHlTdGF0ZSB8fCAnY2xvc2VkJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMuY29tcHJlc3MgPSBmYWxzZSAhPT0gb3B0aW9ucy5jb21wcmVzcztcblxuICB2YXIgcGFja2V0ID0ge1xuICAgIHR5cGU6IHR5cGUsXG4gICAgZGF0YTogZGF0YSxcbiAgICBvcHRpb25zOiBvcHRpb25zXG4gIH07XG4gIHRoaXMuZW1pdCgncGFja2V0Q3JlYXRlJywgcGFja2V0KTtcbiAgdGhpcy53cml0ZUJ1ZmZlci5wdXNoKHBhY2tldCk7XG4gIGlmIChmbikgdGhpcy5vbmNlKCdmbHVzaCcsIGZuKTtcbiAgdGhpcy5mbHVzaCgpO1xufTtcblxuLyoqXG4gKiBDbG9zZXMgdGhlIGNvbm5lY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCdvcGVuaW5nJyA9PT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdvcGVuJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NpbmcnO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKSB7XG4gICAgICB0aGlzLm9uY2UoJ2RyYWluJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy51cGdyYWRpbmcpIHtcbiAgICAgICAgICB3YWl0Rm9yVXBncmFkZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodGhpcy51cGdyYWRpbmcpIHtcbiAgICAgIHdhaXRGb3JVcGdyYWRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNsb3NlKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2xvc2UgKCkge1xuICAgIHNlbGYub25DbG9zZSgnZm9yY2VkIGNsb3NlJyk7XG4gICAgZGVidWcoJ3NvY2tldCBjbG9zaW5nIC0gdGVsbGluZyB0cmFuc3BvcnQgdG8gY2xvc2UnKTtcbiAgICBzZWxmLnRyYW5zcG9ydC5jbG9zZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xlYW51cEFuZENsb3NlICgpIHtcbiAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKCd1cGdyYWRlJywgY2xlYW51cEFuZENsb3NlKTtcbiAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKCd1cGdyYWRlRXJyb3InLCBjbGVhbnVwQW5kQ2xvc2UpO1xuICAgIGNsb3NlKCk7XG4gIH1cblxuICBmdW5jdGlvbiB3YWl0Rm9yVXBncmFkZSAoKSB7XG4gICAgLy8gd2FpdCBmb3IgdXBncmFkZSB0byBmaW5pc2ggc2luY2Ugd2UgY2FuJ3Qgc2VuZCBwYWNrZXRzIHdoaWxlIHBhdXNpbmcgYSB0cmFuc3BvcnRcbiAgICBzZWxmLm9uY2UoJ3VwZ3JhZGUnLCBjbGVhbnVwQW5kQ2xvc2UpO1xuICAgIHNlbGYub25jZSgndXBncmFkZUVycm9yJywgY2xlYW51cEFuZENsb3NlKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiB0cmFuc3BvcnQgZXJyb3JcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gIGRlYnVnKCdzb2NrZXQgZXJyb3IgJWonLCBlcnIpO1xuICBTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gZmFsc2U7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB0aGlzLm9uQ2xvc2UoJ3RyYW5zcG9ydCBlcnJvcicsIGVycik7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHRyYW5zcG9ydCBjbG9zZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uQ2xvc2UgPSBmdW5jdGlvbiAocmVhc29uLCBkZXNjKSB7XG4gIGlmICgnb3BlbmluZycgPT09IHRoaXMucmVhZHlTdGF0ZSB8fCAnb3BlbicgPT09IHRoaXMucmVhZHlTdGF0ZSB8fCAnY2xvc2luZycgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIGRlYnVnKCdzb2NrZXQgY2xvc2Ugd2l0aCByZWFzb246IFwiJXNcIicsIHJlYXNvbik7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gY2xlYXIgdGltZXJzXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMucGluZ0ludGVydmFsVGltZXIpO1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnBpbmdUaW1lb3V0VGltZXIpO1xuXG4gICAgLy8gc3RvcCBldmVudCBmcm9tIGZpcmluZyBhZ2FpbiBmb3IgdHJhbnNwb3J0XG4gICAgdGhpcy50cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCdjbG9zZScpO1xuXG4gICAgLy8gZW5zdXJlIHRyYW5zcG9ydCB3b24ndCBzdGF5IG9wZW5cbiAgICB0aGlzLnRyYW5zcG9ydC5jbG9zZSgpO1xuXG4gICAgLy8gaWdub3JlIGZ1cnRoZXIgdHJhbnNwb3J0IGNvbW11bmljYXRpb25cbiAgICB0aGlzLnRyYW5zcG9ydC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcblxuICAgIC8vIHNldCByZWFkeSBzdGF0ZVxuICAgIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuXG4gICAgLy8gY2xlYXIgc2Vzc2lvbiBpZFxuICAgIHRoaXMuaWQgPSBudWxsO1xuXG4gICAgLy8gZW1pdCBjbG9zZSBldmVudFxuICAgIHRoaXMuZW1pdCgnY2xvc2UnLCByZWFzb24sIGRlc2MpO1xuXG4gICAgLy8gY2xlYW4gYnVmZmVycyBhZnRlciwgc28gdXNlcnMgY2FuIHN0aWxsXG4gICAgLy8gZ3JhYiB0aGUgYnVmZmVycyBvbiBgY2xvc2VgIGV2ZW50XG4gICAgc2VsZi53cml0ZUJ1ZmZlciA9IFtdO1xuICAgIHNlbGYucHJldkJ1ZmZlckxlbiA9IDA7XG4gIH1cbn07XG5cbi8qKlxuICogRmlsdGVycyB1cGdyYWRlcywgcmV0dXJuaW5nIG9ubHkgdGhvc2UgbWF0Y2hpbmcgY2xpZW50IHRyYW5zcG9ydHMuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gc2VydmVyIHVwZ3JhZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5maWx0ZXJVcGdyYWRlcyA9IGZ1bmN0aW9uICh1cGdyYWRlcykge1xuICB2YXIgZmlsdGVyZWRVcGdyYWRlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgaiA9IHVwZ3JhZGVzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgIGlmICh+aW5kZXgodGhpcy50cmFuc3BvcnRzLCB1cGdyYWRlc1tpXSkpIGZpbHRlcmVkVXBncmFkZXMucHVzaCh1cGdyYWRlc1tpXSk7XG4gIH1cbiAgcmV0dXJuIGZpbHRlcmVkVXBncmFkZXM7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3NvY2tldC5qcyIsIlxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqXG4gKiBMb2dpYyBib3Jyb3dlZCBmcm9tIE1vZGVybml6cjpcbiAqXG4gKiAgIC0gaHR0cHM6Ly9naXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvYmxvYi9tYXN0ZXIvZmVhdHVyZS1kZXRlY3RzL2NvcnMuanNcbiAqL1xuXG50cnkge1xuICBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAnd2l0aENyZWRlbnRpYWxzJyBpbiBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbn0gY2F0Y2ggKGVycikge1xuICAvLyBpZiBYTUxIdHRwIHN1cHBvcnQgaXMgZGlzYWJsZWQgaW4gSUUgdGhlbiBpdCB3aWxsIHRocm93XG4gIC8vIHdoZW4gdHJ5aW5nIHRvIGNyZWF0ZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZhbHNlO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2hhcy1jb3JzL2luZGV4LmpzIiwiLyoqXG4gKiBNb2R1bGUgcmVxdWlyZW1lbnRzLlxuICovXG5cbnZhciBYTUxIdHRwUmVxdWVzdCA9IHJlcXVpcmUoJ3htbGh0dHByZXF1ZXN0LXNzbCcpO1xudmFyIFBvbGxpbmcgPSByZXF1aXJlKCcuL3BvbGxpbmcnKTtcbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcbnZhciBpbmhlcml0ID0gcmVxdWlyZSgnY29tcG9uZW50LWluaGVyaXQnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ2VuZ2luZS5pby1jbGllbnQ6cG9sbGluZy14aHInKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFhIUjtcbm1vZHVsZS5leHBvcnRzLlJlcXVlc3QgPSBSZXF1ZXN0O1xuXG4vKipcbiAqIEVtcHR5IGZ1bmN0aW9uXG4gKi9cblxuZnVuY3Rpb24gZW1wdHkgKCkge31cblxuLyoqXG4gKiBYSFIgUG9sbGluZyBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBYSFIgKG9wdHMpIHtcbiAgUG9sbGluZy5jYWxsKHRoaXMsIG9wdHMpO1xuICB0aGlzLnJlcXVlc3RUaW1lb3V0ID0gb3B0cy5yZXF1ZXN0VGltZW91dDtcbiAgdGhpcy5leHRyYUhlYWRlcnMgPSBvcHRzLmV4dHJhSGVhZGVycztcblxuICBpZiAoZ2xvYmFsLmxvY2F0aW9uKSB7XG4gICAgdmFyIGlzU1NMID0gJ2h0dHBzOicgPT09IGxvY2F0aW9uLnByb3RvY29sO1xuICAgIHZhciBwb3J0ID0gbG9jYXRpb24ucG9ydDtcblxuICAgIC8vIHNvbWUgdXNlciBhZ2VudHMgaGF2ZSBlbXB0eSBgbG9jYXRpb24ucG9ydGBcbiAgICBpZiAoIXBvcnQpIHtcbiAgICAgIHBvcnQgPSBpc1NTTCA/IDQ0MyA6IDgwO1xuICAgIH1cblxuICAgIHRoaXMueGQgPSBvcHRzLmhvc3RuYW1lICE9PSBnbG9iYWwubG9jYXRpb24uaG9zdG5hbWUgfHxcbiAgICAgIHBvcnQgIT09IG9wdHMucG9ydDtcbiAgICB0aGlzLnhzID0gb3B0cy5zZWN1cmUgIT09IGlzU1NMO1xuICB9XG59XG5cbi8qKlxuICogSW5oZXJpdHMgZnJvbSBQb2xsaW5nLlxuICovXG5cbmluaGVyaXQoWEhSLCBQb2xsaW5nKTtcblxuLyoqXG4gKiBYSFIgc3VwcG9ydHMgYmluYXJ5XG4gKi9cblxuWEhSLnByb3RvdHlwZS5zdXBwb3J0c0JpbmFyeSA9IHRydWU7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHJlcXVlc3QuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuWEhSLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIG9wdHMudXJpID0gdGhpcy51cmkoKTtcbiAgb3B0cy54ZCA9IHRoaXMueGQ7XG4gIG9wdHMueHMgPSB0aGlzLnhzO1xuICBvcHRzLmFnZW50ID0gdGhpcy5hZ2VudCB8fCBmYWxzZTtcbiAgb3B0cy5zdXBwb3J0c0JpbmFyeSA9IHRoaXMuc3VwcG9ydHNCaW5hcnk7XG4gIG9wdHMuZW5hYmxlc1hEUiA9IHRoaXMuZW5hYmxlc1hEUjtcblxuICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgb3B0cy5wZnggPSB0aGlzLnBmeDtcbiAgb3B0cy5rZXkgPSB0aGlzLmtleTtcbiAgb3B0cy5wYXNzcGhyYXNlID0gdGhpcy5wYXNzcGhyYXNlO1xuICBvcHRzLmNlcnQgPSB0aGlzLmNlcnQ7XG4gIG9wdHMuY2EgPSB0aGlzLmNhO1xuICBvcHRzLmNpcGhlcnMgPSB0aGlzLmNpcGhlcnM7XG4gIG9wdHMucmVqZWN0VW5hdXRob3JpemVkID0gdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQ7XG4gIG9wdHMucmVxdWVzdFRpbWVvdXQgPSB0aGlzLnJlcXVlc3RUaW1lb3V0O1xuXG4gIC8vIG90aGVyIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIG9wdHMuZXh0cmFIZWFkZXJzID0gdGhpcy5leHRyYUhlYWRlcnM7XG5cbiAgcmV0dXJuIG5ldyBSZXF1ZXN0KG9wdHMpO1xufTtcblxuLyoqXG4gKiBTZW5kcyBkYXRhLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhIHRvIHNlbmQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsZWQgdXBvbiBmbHVzaC5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblhIUi5wcm90b3R5cGUuZG9Xcml0ZSA9IGZ1bmN0aW9uIChkYXRhLCBmbikge1xuICB2YXIgaXNCaW5hcnkgPSB0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycgJiYgZGF0YSAhPT0gdW5kZWZpbmVkO1xuICB2YXIgcmVxID0gdGhpcy5yZXF1ZXN0KHsgbWV0aG9kOiAnUE9TVCcsIGRhdGE6IGRhdGEsIGlzQmluYXJ5OiBpc0JpbmFyeSB9KTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICByZXEub24oJ3N1Y2Nlc3MnLCBmbik7XG4gIHJlcS5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgc2VsZi5vbkVycm9yKCd4aHIgcG9zdCBlcnJvcicsIGVycik7XG4gIH0pO1xuICB0aGlzLnNlbmRYaHIgPSByZXE7XG59O1xuXG4vKipcbiAqIFN0YXJ0cyBhIHBvbGwgY3ljbGUuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuWEhSLnByb3RvdHlwZS5kb1BvbGwgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCd4aHIgcG9sbCcpO1xuICB2YXIgcmVxID0gdGhpcy5yZXF1ZXN0KCk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgcmVxLm9uKCdkYXRhJywgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBzZWxmLm9uRGF0YShkYXRhKTtcbiAgfSk7XG4gIHJlcS5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgc2VsZi5vbkVycm9yKCd4aHIgcG9sbCBlcnJvcicsIGVycik7XG4gIH0pO1xuICB0aGlzLnBvbGxYaHIgPSByZXE7XG59O1xuXG4vKipcbiAqIFJlcXVlc3QgY29uc3RydWN0b3JcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBSZXF1ZXN0IChvcHRzKSB7XG4gIHRoaXMubWV0aG9kID0gb3B0cy5tZXRob2QgfHwgJ0dFVCc7XG4gIHRoaXMudXJpID0gb3B0cy51cmk7XG4gIHRoaXMueGQgPSAhIW9wdHMueGQ7XG4gIHRoaXMueHMgPSAhIW9wdHMueHM7XG4gIHRoaXMuYXN5bmMgPSBmYWxzZSAhPT0gb3B0cy5hc3luYztcbiAgdGhpcy5kYXRhID0gdW5kZWZpbmVkICE9PSBvcHRzLmRhdGEgPyBvcHRzLmRhdGEgOiBudWxsO1xuICB0aGlzLmFnZW50ID0gb3B0cy5hZ2VudDtcbiAgdGhpcy5pc0JpbmFyeSA9IG9wdHMuaXNCaW5hcnk7XG4gIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSBvcHRzLnN1cHBvcnRzQmluYXJ5O1xuICB0aGlzLmVuYWJsZXNYRFIgPSBvcHRzLmVuYWJsZXNYRFI7XG4gIHRoaXMucmVxdWVzdFRpbWVvdXQgPSBvcHRzLnJlcXVlc3RUaW1lb3V0O1xuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB0aGlzLnBmeCA9IG9wdHMucGZ4O1xuICB0aGlzLmtleSA9IG9wdHMua2V5O1xuICB0aGlzLnBhc3NwaHJhc2UgPSBvcHRzLnBhc3NwaHJhc2U7XG4gIHRoaXMuY2VydCA9IG9wdHMuY2VydDtcbiAgdGhpcy5jYSA9IG9wdHMuY2E7XG4gIHRoaXMuY2lwaGVycyA9IG9wdHMuY2lwaGVycztcbiAgdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQgPSBvcHRzLnJlamVjdFVuYXV0aG9yaXplZDtcblxuICAvLyBvdGhlciBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB0aGlzLmV4dHJhSGVhZGVycyA9IG9wdHMuZXh0cmFIZWFkZXJzO1xuXG4gIHRoaXMuY3JlYXRlKCk7XG59XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKFJlcXVlc3QucHJvdG90eXBlKTtcblxuLyoqXG4gKiBDcmVhdGVzIHRoZSBYSFIgb2JqZWN0IGFuZCBzZW5kcyB0aGUgcmVxdWVzdC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBvcHRzID0geyBhZ2VudDogdGhpcy5hZ2VudCwgeGRvbWFpbjogdGhpcy54ZCwgeHNjaGVtZTogdGhpcy54cywgZW5hYmxlc1hEUjogdGhpcy5lbmFibGVzWERSIH07XG5cbiAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIG9wdHMucGZ4ID0gdGhpcy5wZng7XG4gIG9wdHMua2V5ID0gdGhpcy5rZXk7XG4gIG9wdHMucGFzc3BocmFzZSA9IHRoaXMucGFzc3BocmFzZTtcbiAgb3B0cy5jZXJ0ID0gdGhpcy5jZXJ0O1xuICBvcHRzLmNhID0gdGhpcy5jYTtcbiAgb3B0cy5jaXBoZXJzID0gdGhpcy5jaXBoZXJzO1xuICBvcHRzLnJlamVjdFVuYXV0aG9yaXplZCA9IHRoaXMucmVqZWN0VW5hdXRob3JpemVkO1xuXG4gIHZhciB4aHIgPSB0aGlzLnhociA9IG5ldyBYTUxIdHRwUmVxdWVzdChvcHRzKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRyeSB7XG4gICAgZGVidWcoJ3hociBvcGVuICVzOiAlcycsIHRoaXMubWV0aG9kLCB0aGlzLnVyaSk7XG4gICAgeGhyLm9wZW4odGhpcy5tZXRob2QsIHRoaXMudXJpLCB0aGlzLmFzeW5jKTtcbiAgICB0cnkge1xuICAgICAgaWYgKHRoaXMuZXh0cmFIZWFkZXJzKSB7XG4gICAgICAgIHhoci5zZXREaXNhYmxlSGVhZGVyQ2hlY2sgJiYgeGhyLnNldERpc2FibGVIZWFkZXJDaGVjayh0cnVlKTtcbiAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLmV4dHJhSGVhZGVycykge1xuICAgICAgICAgIGlmICh0aGlzLmV4dHJhSGVhZGVycy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoaSwgdGhpcy5leHRyYUhlYWRlcnNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHt9XG5cbiAgICBpZiAoJ1BPU1QnID09PSB0aGlzLm1ldGhvZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHRoaXMuaXNCaW5hcnkpIHtcbiAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LXR5cGUnLCAndGV4dC9wbGFpbjtjaGFyc2V0PVVURi04Jyk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdBY2NlcHQnLCAnKi8qJyk7XG4gICAgfSBjYXRjaCAoZSkge31cblxuICAgIC8vIGllNiBjaGVja1xuICAgIGlmICgnd2l0aENyZWRlbnRpYWxzJyBpbiB4aHIpIHtcbiAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnJlcXVlc3RUaW1lb3V0KSB7XG4gICAgICB4aHIudGltZW91dCA9IHRoaXMucmVxdWVzdFRpbWVvdXQ7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaGFzWERSKCkpIHtcbiAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYub25Mb2FkKCk7XG4gICAgICB9O1xuICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYub25FcnJvcih4aHIucmVzcG9uc2VUZXh0KTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gMikge1xuICAgICAgICAgIHZhciBjb250ZW50VHlwZTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29udGVudFR5cGUgPSB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ0NvbnRlbnQtVHlwZScpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgICAgaWYgKGNvbnRlbnRUeXBlID09PSAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJykge1xuICAgICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICg0ICE9PSB4aHIucmVhZHlTdGF0ZSkgcmV0dXJuO1xuICAgICAgICBpZiAoMjAwID09PSB4aHIuc3RhdHVzIHx8IDEyMjMgPT09IHhoci5zdGF0dXMpIHtcbiAgICAgICAgICBzZWxmLm9uTG9hZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgYGVycm9yYCBldmVudCBoYW5kbGVyIHRoYXQncyB1c2VyLXNldFxuICAgICAgICAgIC8vIGRvZXMgbm90IHRocm93IGluIHRoZSBzYW1lIHRpY2sgYW5kIGdldHMgY2F1Z2h0IGhlcmVcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNlbGYub25FcnJvcih4aHIuc3RhdHVzKTtcbiAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBkZWJ1ZygneGhyIGRhdGEgJXMnLCB0aGlzLmRhdGEpO1xuICAgIHhoci5zZW5kKHRoaXMuZGF0YSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBOZWVkIHRvIGRlZmVyIHNpbmNlIC5jcmVhdGUoKSBpcyBjYWxsZWQgZGlyZWN0bHkgZmhyb20gdGhlIGNvbnN0cnVjdG9yXG4gICAgLy8gYW5kIHRodXMgdGhlICdlcnJvcicgZXZlbnQgY2FuIG9ubHkgYmUgb25seSBib3VuZCAqYWZ0ZXIqIHRoaXMgZXhjZXB0aW9uXG4gICAgLy8gb2NjdXJzLiAgVGhlcmVmb3JlLCBhbHNvLCB3ZSBjYW5ub3QgdGhyb3cgaGVyZSBhdCBhbGwuXG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLm9uRXJyb3IoZSk7XG4gICAgfSwgMCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGdsb2JhbC5kb2N1bWVudCkge1xuICAgIHRoaXMuaW5kZXggPSBSZXF1ZXN0LnJlcXVlc3RzQ291bnQrKztcbiAgICBSZXF1ZXN0LnJlcXVlc3RzW3RoaXMuaW5kZXhdID0gdGhpcztcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBzdWNjZXNzZnVsIHJlc3BvbnNlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLm9uU3VjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5lbWl0KCdzdWNjZXNzJyk7XG4gIHRoaXMuY2xlYW51cCgpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgaWYgd2UgaGF2ZSBkYXRhLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuZW1pdCgnZGF0YScsIGRhdGEpO1xuICB0aGlzLm9uU3VjY2VzcygpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBlcnJvci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgdGhpcy5jbGVhbnVwKHRydWUpO1xufTtcblxuLyoqXG4gKiBDbGVhbnMgdXAgaG91c2UuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuY2xlYW51cCA9IGZ1bmN0aW9uIChmcm9tRXJyb3IpIHtcbiAgaWYgKCd1bmRlZmluZWQnID09PSB0eXBlb2YgdGhpcy54aHIgfHwgbnVsbCA9PT0gdGhpcy54aHIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8geG1saHR0cHJlcXVlc3RcbiAgaWYgKHRoaXMuaGFzWERSKCkpIHtcbiAgICB0aGlzLnhoci5vbmxvYWQgPSB0aGlzLnhoci5vbmVycm9yID0gZW1wdHk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy54aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZW1wdHk7XG4gIH1cblxuICBpZiAoZnJvbUVycm9yKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMueGhyLmFib3J0KCk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuXG4gIGlmIChnbG9iYWwuZG9jdW1lbnQpIHtcbiAgICBkZWxldGUgUmVxdWVzdC5yZXF1ZXN0c1t0aGlzLmluZGV4XTtcbiAgfVxuXG4gIHRoaXMueGhyID0gbnVsbDtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gbG9hZC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5vbkxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBkYXRhO1xuICB0cnkge1xuICAgIHZhciBjb250ZW50VHlwZTtcbiAgICB0cnkge1xuICAgICAgY29udGVudFR5cGUgPSB0aGlzLnhoci5nZXRSZXNwb25zZUhlYWRlcignQ29udGVudC1UeXBlJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICBpZiAoY29udGVudFR5cGUgPT09ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nKSB7XG4gICAgICBkYXRhID0gdGhpcy54aHIucmVzcG9uc2UgfHwgdGhpcy54aHIucmVzcG9uc2VUZXh0O1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhID0gdGhpcy54aHIucmVzcG9uc2VUZXh0O1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIHRoaXMub25FcnJvcihlKTtcbiAgfVxuICBpZiAobnVsbCAhPSBkYXRhKSB7XG4gICAgdGhpcy5vbkRhdGEoZGF0YSk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgaXQgaGFzIFhEb21haW5SZXF1ZXN0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmhhc1hEUiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICd1bmRlZmluZWQnICE9PSB0eXBlb2YgZ2xvYmFsLlhEb21haW5SZXF1ZXN0ICYmICF0aGlzLnhzICYmIHRoaXMuZW5hYmxlc1hEUjtcbn07XG5cbi8qKlxuICogQWJvcnRzIHRoZSByZXF1ZXN0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuY2xlYW51cCgpO1xufTtcblxuLyoqXG4gKiBBYm9ydHMgcGVuZGluZyByZXF1ZXN0cyB3aGVuIHVubG9hZGluZyB0aGUgd2luZG93LiBUaGlzIGlzIG5lZWRlZCB0byBwcmV2ZW50XG4gKiBtZW1vcnkgbGVha3MgKGUuZy4gd2hlbiB1c2luZyBJRSkgYW5kIHRvIGVuc3VyZSB0aGF0IG5vIHNwdXJpb3VzIGVycm9yIGlzXG4gKiBlbWl0dGVkLlxuICovXG5cblJlcXVlc3QucmVxdWVzdHNDb3VudCA9IDA7XG5SZXF1ZXN0LnJlcXVlc3RzID0ge307XG5cbmlmIChnbG9iYWwuZG9jdW1lbnQpIHtcbiAgaWYgKGdsb2JhbC5hdHRhY2hFdmVudCkge1xuICAgIGdsb2JhbC5hdHRhY2hFdmVudCgnb251bmxvYWQnLCB1bmxvYWRIYW5kbGVyKTtcbiAgfSBlbHNlIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCB1bmxvYWRIYW5kbGVyLCBmYWxzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdW5sb2FkSGFuZGxlciAoKSB7XG4gIGZvciAodmFyIGkgaW4gUmVxdWVzdC5yZXF1ZXN0cykge1xuICAgIGlmIChSZXF1ZXN0LnJlcXVlc3RzLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICBSZXF1ZXN0LnJlcXVlc3RzW2ldLmFib3J0KCk7XG4gICAgfVxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy9wb2xsaW5nLXhoci5qcyIsIlxuLyoqXG4gKiBHZXRzIHRoZSBrZXlzIGZvciBhbiBvYmplY3QuXG4gKlxuICogQHJldHVybiB7QXJyYXl9IGtleXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyAob2JqKXtcbiAgdmFyIGFyciA9IFtdO1xuICB2YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgIGlmIChoYXMuY2FsbChvYmosIGkpKSB7XG4gICAgICBhcnIucHVzaChpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFycjtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLXBhcnNlci9saWIva2V5cy5qcyIsIi8qKlxuICogQW4gYWJzdHJhY3Rpb24gZm9yIHNsaWNpbmcgYW4gYXJyYXlidWZmZXIgZXZlbiB3aGVuXG4gKiBBcnJheUJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgaXMgbm90IHN1cHBvcnRlZFxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcnJheWJ1ZmZlciwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBhcnJheWJ1ZmZlci5ieXRlTGVuZ3RoO1xuICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gIGVuZCA9IGVuZCB8fCBieXRlcztcblxuICBpZiAoYXJyYXlidWZmZXIuc2xpY2UpIHsgcmV0dXJuIGFycmF5YnVmZmVyLnNsaWNlKHN0YXJ0LCBlbmQpOyB9XG5cbiAgaWYgKHN0YXJ0IDwgMCkgeyBzdGFydCArPSBieXRlczsgfVxuICBpZiAoZW5kIDwgMCkgeyBlbmQgKz0gYnl0ZXM7IH1cbiAgaWYgKGVuZCA+IGJ5dGVzKSB7IGVuZCA9IGJ5dGVzOyB9XG5cbiAgaWYgKHN0YXJ0ID49IGJ5dGVzIHx8IHN0YXJ0ID49IGVuZCB8fCBieXRlcyA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgQXJyYXlCdWZmZXIoMCk7XG4gIH1cblxuICB2YXIgYWJ2ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlidWZmZXIpO1xuICB2YXIgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoZW5kIC0gc3RhcnQpO1xuICBmb3IgKHZhciBpID0gc3RhcnQsIGlpID0gMDsgaSA8IGVuZDsgaSsrLCBpaSsrKSB7XG4gICAgcmVzdWx0W2lpXSA9IGFidltpXTtcbiAgfVxuICByZXR1cm4gcmVzdWx0LmJ1ZmZlcjtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYXJyYXlidWZmZXIuc2xpY2UvaW5kZXguanMiLCJtb2R1bGUuZXhwb3J0cyA9IGFmdGVyXG5cbmZ1bmN0aW9uIGFmdGVyKGNvdW50LCBjYWxsYmFjaywgZXJyX2NiKSB7XG4gICAgdmFyIGJhaWwgPSBmYWxzZVxuICAgIGVycl9jYiA9IGVycl9jYiB8fCBub29wXG4gICAgcHJveHkuY291bnQgPSBjb3VudFxuXG4gICAgcmV0dXJuIChjb3VudCA9PT0gMCkgPyBjYWxsYmFjaygpIDogcHJveHlcblxuICAgIGZ1bmN0aW9uIHByb3h5KGVyciwgcmVzdWx0KSB7XG4gICAgICAgIGlmIChwcm94eS5jb3VudCA8PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FmdGVyIGNhbGxlZCB0b28gbWFueSB0aW1lcycpXG4gICAgICAgIH1cbiAgICAgICAgLS1wcm94eS5jb3VudFxuXG4gICAgICAgIC8vIGFmdGVyIGZpcnN0IGVycm9yLCByZXN0IGFyZSBwYXNzZWQgdG8gZXJyX2NiXG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGJhaWwgPSB0cnVlXG4gICAgICAgICAgICBjYWxsYmFjayhlcnIpXG4gICAgICAgICAgICAvLyBmdXR1cmUgZXJyb3IgY2FsbGJhY2tzIHdpbGwgZ28gdG8gZXJyb3IgaGFuZGxlclxuICAgICAgICAgICAgY2FsbGJhY2sgPSBlcnJfY2JcbiAgICAgICAgfSBlbHNlIGlmIChwcm94eS5jb3VudCA9PT0gMCAmJiAhYmFpbCkge1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0KVxuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBub29wKCkge31cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9hZnRlci9pbmRleC5qcyIsIi8qISBodHRwczovL210aHMuYmUvdXRmOGpzIHYyLjEuMiBieSBAbWF0aGlhcyAqL1xuOyhmdW5jdGlvbihyb290KSB7XG5cblx0Ly8gRGV0ZWN0IGZyZWUgdmFyaWFibGVzIGBleHBvcnRzYFxuXHR2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzO1xuXG5cdC8vIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgXG5cdHZhciBmcmVlTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiZcblx0XHRtb2R1bGUuZXhwb3J0cyA9PSBmcmVlRXhwb3J0cyAmJiBtb2R1bGU7XG5cblx0Ly8gRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAsIGZyb20gTm9kZS5qcyBvciBCcm93c2VyaWZpZWQgY29kZSxcblx0Ly8gYW5kIHVzZSBpdCBhcyBgcm9vdGBcblx0dmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcblx0aWYgKGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsKSB7XG5cdFx0cm9vdCA9IGZyZWVHbG9iYWw7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHR2YXIgc3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcblxuXHQvLyBUYWtlbiBmcm9tIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZVxuXHRmdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHRcdHZhciBvdXRwdXQgPSBbXTtcblx0XHR2YXIgY291bnRlciA9IDA7XG5cdFx0dmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG5cdFx0dmFyIHZhbHVlO1xuXHRcdHZhciBleHRyYTtcblx0XHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0dmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0aWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0XHQvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcblx0XHRcdFx0ZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gbG93IHN1cnJvZ2F0ZVxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcblx0XHRcdFx0XHQvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcblx0XHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHQvLyBUYWtlbiBmcm9tIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZVxuXHRmdW5jdGlvbiB1Y3MyZW5jb2RlKGFycmF5KSB7XG5cdFx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0XHR2YXIgaW5kZXggPSAtMTtcblx0XHR2YXIgdmFsdWU7XG5cdFx0dmFyIG91dHB1dCA9ICcnO1xuXHRcdHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IGFycmF5W2luZGV4XTtcblx0XHRcdGlmICh2YWx1ZSA+IDB4RkZGRikge1xuXHRcdFx0XHR2YWx1ZSAtPSAweDEwMDAwO1xuXHRcdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcblx0XHRcdFx0dmFsdWUgPSAweERDMDAgfCB2YWx1ZSAmIDB4M0ZGO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSk7XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHRmdW5jdGlvbiBjaGVja1NjYWxhclZhbHVlKGNvZGVQb2ludCwgc3RyaWN0KSB7XG5cdFx0aWYgKGNvZGVQb2ludCA+PSAweEQ4MDAgJiYgY29kZVBvaW50IDw9IDB4REZGRikge1xuXHRcdFx0aWYgKHN0cmljdCkge1xuXHRcdFx0XHR0aHJvdyBFcnJvcihcblx0XHRcdFx0XHQnTG9uZSBzdXJyb2dhdGUgVSsnICsgY29kZVBvaW50LnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpICtcblx0XHRcdFx0XHQnIGlzIG5vdCBhIHNjYWxhciB2YWx1ZSdcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0ZnVuY3Rpb24gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIHNoaWZ0KSB7XG5cdFx0cmV0dXJuIHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiBzaGlmdCkgJiAweDNGKSB8IDB4ODApO1xuXHR9XG5cblx0ZnVuY3Rpb24gZW5jb2RlQ29kZVBvaW50KGNvZGVQb2ludCwgc3RyaWN0KSB7XG5cdFx0aWYgKChjb2RlUG9pbnQgJiAweEZGRkZGRjgwKSA9PSAwKSB7IC8vIDEtYnl0ZSBzZXF1ZW5jZVxuXHRcdFx0cmV0dXJuIHN0cmluZ0Zyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xuXHRcdH1cblx0XHR2YXIgc3ltYm9sID0gJyc7XG5cdFx0aWYgKChjb2RlUG9pbnQgJiAweEZGRkZGODAwKSA9PSAwKSB7IC8vIDItYnl0ZSBzZXF1ZW5jZVxuXHRcdFx0c3ltYm9sID0gc3RyaW5nRnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IDYpICYgMHgxRikgfCAweEMwKTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoKGNvZGVQb2ludCAmIDB4RkZGRjAwMDApID09IDApIHsgLy8gMy1ieXRlIHNlcXVlbmNlXG5cdFx0XHRpZiAoIWNoZWNrU2NhbGFyVmFsdWUoY29kZVBvaW50LCBzdHJpY3QpKSB7XG5cdFx0XHRcdGNvZGVQb2ludCA9IDB4RkZGRDtcblx0XHRcdH1cblx0XHRcdHN5bWJvbCA9IHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiAxMikgJiAweDBGKSB8IDB4RTApO1xuXHRcdFx0c3ltYm9sICs9IGNyZWF0ZUJ5dGUoY29kZVBvaW50LCA2KTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoKGNvZGVQb2ludCAmIDB4RkZFMDAwMDApID09IDApIHsgLy8gNC1ieXRlIHNlcXVlbmNlXG5cdFx0XHRzeW1ib2wgPSBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gMTgpICYgMHgwNykgfCAweEYwKTtcblx0XHRcdHN5bWJvbCArPSBjcmVhdGVCeXRlKGNvZGVQb2ludCwgMTIpO1xuXHRcdFx0c3ltYm9sICs9IGNyZWF0ZUJ5dGUoY29kZVBvaW50LCA2KTtcblx0XHR9XG5cdFx0c3ltYm9sICs9IHN0cmluZ0Zyb21DaGFyQ29kZSgoY29kZVBvaW50ICYgMHgzRikgfCAweDgwKTtcblx0XHRyZXR1cm4gc3ltYm9sO1xuXHR9XG5cblx0ZnVuY3Rpb24gdXRmOGVuY29kZShzdHJpbmcsIG9wdHMpIHtcblx0XHRvcHRzID0gb3B0cyB8fCB7fTtcblx0XHR2YXIgc3RyaWN0ID0gZmFsc2UgIT09IG9wdHMuc3RyaWN0O1xuXG5cdFx0dmFyIGNvZGVQb2ludHMgPSB1Y3MyZGVjb2RlKHN0cmluZyk7XG5cdFx0dmFyIGxlbmd0aCA9IGNvZGVQb2ludHMubGVuZ3RoO1xuXHRcdHZhciBpbmRleCA9IC0xO1xuXHRcdHZhciBjb2RlUG9pbnQ7XG5cdFx0dmFyIGJ5dGVTdHJpbmcgPSAnJztcblx0XHR3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuXHRcdFx0Y29kZVBvaW50ID0gY29kZVBvaW50c1tpbmRleF07XG5cdFx0XHRieXRlU3RyaW5nICs9IGVuY29kZUNvZGVQb2ludChjb2RlUG9pbnQsIHN0cmljdCk7XG5cdFx0fVxuXHRcdHJldHVybiBieXRlU3RyaW5nO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0ZnVuY3Rpb24gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKSB7XG5cdFx0aWYgKGJ5dGVJbmRleCA+PSBieXRlQ291bnQpIHtcblx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGJ5dGUgaW5kZXgnKTtcblx0XHR9XG5cblx0XHR2YXIgY29udGludWF0aW9uQnl0ZSA9IGJ5dGVBcnJheVtieXRlSW5kZXhdICYgMHhGRjtcblx0XHRieXRlSW5kZXgrKztcblxuXHRcdGlmICgoY29udGludWF0aW9uQnl0ZSAmIDB4QzApID09IDB4ODApIHtcblx0XHRcdHJldHVybiBjb250aW51YXRpb25CeXRlICYgMHgzRjtcblx0XHR9XG5cblx0XHQvLyBJZiB3ZSBlbmQgdXAgaGVyZSwgaXTigJlzIG5vdCBhIGNvbnRpbnVhdGlvbiBieXRlXG5cdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgY29udGludWF0aW9uIGJ5dGUnKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGRlY29kZVN5bWJvbChzdHJpY3QpIHtcblx0XHR2YXIgYnl0ZTE7XG5cdFx0dmFyIGJ5dGUyO1xuXHRcdHZhciBieXRlMztcblx0XHR2YXIgYnl0ZTQ7XG5cdFx0dmFyIGNvZGVQb2ludDtcblxuXHRcdGlmIChieXRlSW5kZXggPiBieXRlQ291bnQpIHtcblx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGJ5dGUgaW5kZXgnKTtcblx0XHR9XG5cblx0XHRpZiAoYnl0ZUluZGV4ID09IGJ5dGVDb3VudCkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIFJlYWQgZmlyc3QgYnl0ZVxuXHRcdGJ5dGUxID0gYnl0ZUFycmF5W2J5dGVJbmRleF0gJiAweEZGO1xuXHRcdGJ5dGVJbmRleCsrO1xuXG5cdFx0Ly8gMS1ieXRlIHNlcXVlbmNlIChubyBjb250aW51YXRpb24gYnl0ZXMpXG5cdFx0aWYgKChieXRlMSAmIDB4ODApID09IDApIHtcblx0XHRcdHJldHVybiBieXRlMTtcblx0XHR9XG5cblx0XHQvLyAyLWJ5dGUgc2VxdWVuY2Vcblx0XHRpZiAoKGJ5dGUxICYgMHhFMCkgPT0gMHhDMCkge1xuXHRcdFx0Ynl0ZTIgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0Y29kZVBvaW50ID0gKChieXRlMSAmIDB4MUYpIDw8IDYpIHwgYnl0ZTI7XG5cdFx0XHRpZiAoY29kZVBvaW50ID49IDB4ODApIHtcblx0XHRcdFx0cmV0dXJuIGNvZGVQb2ludDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlJyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gMy1ieXRlIHNlcXVlbmNlIChtYXkgaW5jbHVkZSB1bnBhaXJlZCBzdXJyb2dhdGVzKVxuXHRcdGlmICgoYnl0ZTEgJiAweEYwKSA9PSAweEUwKSB7XG5cdFx0XHRieXRlMiA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRieXRlMyA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRjb2RlUG9pbnQgPSAoKGJ5dGUxICYgMHgwRikgPDwgMTIpIHwgKGJ5dGUyIDw8IDYpIHwgYnl0ZTM7XG5cdFx0XHRpZiAoY29kZVBvaW50ID49IDB4MDgwMCkge1xuXHRcdFx0XHRyZXR1cm4gY2hlY2tTY2FsYXJWYWx1ZShjb2RlUG9pbnQsIHN0cmljdCkgPyBjb2RlUG9pbnQgOiAweEZGRkQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBjb250aW51YXRpb24gYnl0ZScpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIDQtYnl0ZSBzZXF1ZW5jZVxuXHRcdGlmICgoYnl0ZTEgJiAweEY4KSA9PSAweEYwKSB7XG5cdFx0XHRieXRlMiA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRieXRlMyA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRieXRlNCA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRjb2RlUG9pbnQgPSAoKGJ5dGUxICYgMHgwNykgPDwgMHgxMikgfCAoYnl0ZTIgPDwgMHgwQykgfFxuXHRcdFx0XHQoYnl0ZTMgPDwgMHgwNikgfCBieXRlNDtcblx0XHRcdGlmIChjb2RlUG9pbnQgPj0gMHgwMTAwMDAgJiYgY29kZVBvaW50IDw9IDB4MTBGRkZGKSB7XG5cdFx0XHRcdHJldHVybiBjb2RlUG9pbnQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgVVRGLTggZGV0ZWN0ZWQnKTtcblx0fVxuXG5cdHZhciBieXRlQXJyYXk7XG5cdHZhciBieXRlQ291bnQ7XG5cdHZhciBieXRlSW5kZXg7XG5cdGZ1bmN0aW9uIHV0ZjhkZWNvZGUoYnl0ZVN0cmluZywgb3B0cykge1xuXHRcdG9wdHMgPSBvcHRzIHx8IHt9O1xuXHRcdHZhciBzdHJpY3QgPSBmYWxzZSAhPT0gb3B0cy5zdHJpY3Q7XG5cblx0XHRieXRlQXJyYXkgPSB1Y3MyZGVjb2RlKGJ5dGVTdHJpbmcpO1xuXHRcdGJ5dGVDb3VudCA9IGJ5dGVBcnJheS5sZW5ndGg7XG5cdFx0Ynl0ZUluZGV4ID0gMDtcblx0XHR2YXIgY29kZVBvaW50cyA9IFtdO1xuXHRcdHZhciB0bXA7XG5cdFx0d2hpbGUgKCh0bXAgPSBkZWNvZGVTeW1ib2woc3RyaWN0KSkgIT09IGZhbHNlKSB7XG5cdFx0XHRjb2RlUG9pbnRzLnB1c2godG1wKTtcblx0XHR9XG5cdFx0cmV0dXJuIHVjczJlbmNvZGUoY29kZVBvaW50cyk7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHR2YXIgdXRmOCA9IHtcblx0XHQndmVyc2lvbic6ICcyLjEuMicsXG5cdFx0J2VuY29kZSc6IHV0ZjhlbmNvZGUsXG5cdFx0J2RlY29kZSc6IHV0ZjhkZWNvZGVcblx0fTtcblxuXHQvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBzcGVjaWZpYyBjb25kaXRpb24gcGF0dGVybnNcblx0Ly8gbGlrZSB0aGUgZm9sbG93aW5nOlxuXHRpZiAoXG5cdFx0dHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiZcblx0XHRkZWZpbmUuYW1kXG5cdCkge1xuXHRcdGRlZmluZShmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB1dGY4O1xuXHRcdH0pO1xuXHR9XHRlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiAhZnJlZUV4cG9ydHMubm9kZVR5cGUpIHtcblx0XHRpZiAoZnJlZU1vZHVsZSkgeyAvLyBpbiBOb2RlLmpzIG9yIFJpbmdvSlMgdjAuOC4wK1xuXHRcdFx0ZnJlZU1vZHVsZS5leHBvcnRzID0gdXRmODtcblx0XHR9IGVsc2UgeyAvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxuXHRcdFx0dmFyIG9iamVjdCA9IHt9O1xuXHRcdFx0dmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0Lmhhc093blByb3BlcnR5O1xuXHRcdFx0Zm9yICh2YXIga2V5IGluIHV0ZjgpIHtcblx0XHRcdFx0aGFzT3duUHJvcGVydHkuY2FsbCh1dGY4LCBrZXkpICYmIChmcmVlRXhwb3J0c1trZXldID0gdXRmOFtrZXldKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7IC8vIGluIFJoaW5vIG9yIGEgd2ViIGJyb3dzZXJcblx0XHRyb290LnV0ZjggPSB1dGY4O1xuXHR9XG5cbn0odGhpcykpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1wYXJzZXIvbGliL3V0ZjguanMiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuXHRpZighbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xuXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxuXHRcdGlmKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xuXHR9XG5cdHJldHVybiBtb2R1bGU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vICh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsIi8qXG4gKiBiYXNlNjQtYXJyYXlidWZmZXJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9uaWtsYXN2aC9iYXNlNjQtYXJyYXlidWZmZXJcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgTmlrbGFzIHZvbiBIZXJ0emVuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKi9cbihmdW5jdGlvbigpe1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgY2hhcnMgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIjtcblxuICAvLyBVc2UgYSBsb29rdXAgdGFibGUgdG8gZmluZCB0aGUgaW5kZXguXG4gIHZhciBsb29rdXAgPSBuZXcgVWludDhBcnJheSgyNTYpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgbG9va3VwW2NoYXJzLmNoYXJDb2RlQXQoaSldID0gaTtcbiAgfVxuXG4gIGV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24oYXJyYXlidWZmZXIpIHtcbiAgICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheShhcnJheWJ1ZmZlciksXG4gICAgaSwgbGVuID0gYnl0ZXMubGVuZ3RoLCBiYXNlNjQgPSBcIlwiO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSs9Mykge1xuICAgICAgYmFzZTY0ICs9IGNoYXJzW2J5dGVzW2ldID4+IDJdO1xuICAgICAgYmFzZTY0ICs9IGNoYXJzWygoYnl0ZXNbaV0gJiAzKSA8PCA0KSB8IChieXRlc1tpICsgMV0gPj4gNCldO1xuICAgICAgYmFzZTY0ICs9IGNoYXJzWygoYnl0ZXNbaSArIDFdICYgMTUpIDw8IDIpIHwgKGJ5dGVzW2kgKyAyXSA+PiA2KV07XG4gICAgICBiYXNlNjQgKz0gY2hhcnNbYnl0ZXNbaSArIDJdICYgNjNdO1xuICAgIH1cblxuICAgIGlmICgobGVuICUgMykgPT09IDIpIHtcbiAgICAgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoMCwgYmFzZTY0Lmxlbmd0aCAtIDEpICsgXCI9XCI7XG4gICAgfSBlbHNlIGlmIChsZW4gJSAzID09PSAxKSB7XG4gICAgICBiYXNlNjQgPSBiYXNlNjQuc3Vic3RyaW5nKDAsIGJhc2U2NC5sZW5ndGggLSAyKSArIFwiPT1cIjtcbiAgICB9XG5cbiAgICByZXR1cm4gYmFzZTY0O1xuICB9O1xuXG4gIGV4cG9ydHMuZGVjb2RlID0gIGZ1bmN0aW9uKGJhc2U2NCkge1xuICAgIHZhciBidWZmZXJMZW5ndGggPSBiYXNlNjQubGVuZ3RoICogMC43NSxcbiAgICBsZW4gPSBiYXNlNjQubGVuZ3RoLCBpLCBwID0gMCxcbiAgICBlbmNvZGVkMSwgZW5jb2RlZDIsIGVuY29kZWQzLCBlbmNvZGVkNDtcblxuICAgIGlmIChiYXNlNjRbYmFzZTY0Lmxlbmd0aCAtIDFdID09PSBcIj1cIikge1xuICAgICAgYnVmZmVyTGVuZ3RoLS07XG4gICAgICBpZiAoYmFzZTY0W2Jhc2U2NC5sZW5ndGggLSAyXSA9PT0gXCI9XCIpIHtcbiAgICAgICAgYnVmZmVyTGVuZ3RoLS07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGFycmF5YnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGJ1ZmZlckxlbmd0aCksXG4gICAgYnl0ZXMgPSBuZXcgVWludDhBcnJheShhcnJheWJ1ZmZlcik7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKz00KSB7XG4gICAgICBlbmNvZGVkMSA9IGxvb2t1cFtiYXNlNjQuY2hhckNvZGVBdChpKV07XG4gICAgICBlbmNvZGVkMiA9IGxvb2t1cFtiYXNlNjQuY2hhckNvZGVBdChpKzEpXTtcbiAgICAgIGVuY29kZWQzID0gbG9va3VwW2Jhc2U2NC5jaGFyQ29kZUF0KGkrMildO1xuICAgICAgZW5jb2RlZDQgPSBsb29rdXBbYmFzZTY0LmNoYXJDb2RlQXQoaSszKV07XG5cbiAgICAgIGJ5dGVzW3ArK10gPSAoZW5jb2RlZDEgPDwgMikgfCAoZW5jb2RlZDIgPj4gNCk7XG4gICAgICBieXRlc1twKytdID0gKChlbmNvZGVkMiAmIDE1KSA8PCA0KSB8IChlbmNvZGVkMyA+PiAyKTtcbiAgICAgIGJ5dGVzW3ArK10gPSAoKGVuY29kZWQzICYgMykgPDwgNikgfCAoZW5jb2RlZDQgJiA2Myk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5YnVmZmVyO1xuICB9O1xufSkoKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9iYXNlNjQtYXJyYXlidWZmZXIvbGliL2Jhc2U2NC1hcnJheWJ1ZmZlci5qcyIsIi8qKlxuICogQ3JlYXRlIGEgYmxvYiBidWlsZGVyIGV2ZW4gd2hlbiB2ZW5kb3IgcHJlZml4ZXMgZXhpc3RcbiAqL1xuXG52YXIgQmxvYkJ1aWxkZXIgPSBnbG9iYWwuQmxvYkJ1aWxkZXJcbiAgfHwgZ2xvYmFsLldlYktpdEJsb2JCdWlsZGVyXG4gIHx8IGdsb2JhbC5NU0Jsb2JCdWlsZGVyXG4gIHx8IGdsb2JhbC5Nb3pCbG9iQnVpbGRlcjtcblxuLyoqXG4gKiBDaGVjayBpZiBCbG9iIGNvbnN0cnVjdG9yIGlzIHN1cHBvcnRlZFxuICovXG5cbnZhciBibG9iU3VwcG9ydGVkID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHZhciBhID0gbmV3IEJsb2IoWydoaSddKTtcbiAgICByZXR1cm4gYS5zaXplID09PSAyO1xuICB9IGNhdGNoKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn0pKCk7XG5cbi8qKlxuICogQ2hlY2sgaWYgQmxvYiBjb25zdHJ1Y3RvciBzdXBwb3J0cyBBcnJheUJ1ZmZlclZpZXdzXG4gKiBGYWlscyBpbiBTYWZhcmkgNiwgc28gd2UgbmVlZCB0byBtYXAgdG8gQXJyYXlCdWZmZXJzIHRoZXJlLlxuICovXG5cbnZhciBibG9iU3VwcG9ydHNBcnJheUJ1ZmZlclZpZXcgPSBibG9iU3VwcG9ydGVkICYmIChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYiA9IG5ldyBCbG9iKFtuZXcgVWludDhBcnJheShbMSwyXSldKTtcbiAgICByZXR1cm4gYi5zaXplID09PSAyO1xuICB9IGNhdGNoKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn0pKCk7XG5cbi8qKlxuICogQ2hlY2sgaWYgQmxvYkJ1aWxkZXIgaXMgc3VwcG9ydGVkXG4gKi9cblxudmFyIGJsb2JCdWlsZGVyU3VwcG9ydGVkID0gQmxvYkJ1aWxkZXJcbiAgJiYgQmxvYkJ1aWxkZXIucHJvdG90eXBlLmFwcGVuZFxuICAmJiBCbG9iQnVpbGRlci5wcm90b3R5cGUuZ2V0QmxvYjtcblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBtYXBzIEFycmF5QnVmZmVyVmlld3MgdG8gQXJyYXlCdWZmZXJzXG4gKiBVc2VkIGJ5IEJsb2JCdWlsZGVyIGNvbnN0cnVjdG9yIGFuZCBvbGQgYnJvd3NlcnMgdGhhdCBkaWRuJ3RcbiAqIHN1cHBvcnQgaXQgaW4gdGhlIEJsb2IgY29uc3RydWN0b3IuXG4gKi9cblxuZnVuY3Rpb24gbWFwQXJyYXlCdWZmZXJWaWV3cyhhcnkpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnkubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY2h1bmsgPSBhcnlbaV07XG4gICAgaWYgKGNodW5rLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICB2YXIgYnVmID0gY2h1bmsuYnVmZmVyO1xuXG4gICAgICAvLyBpZiB0aGlzIGlzIGEgc3ViYXJyYXksIG1ha2UgYSBjb3B5IHNvIHdlIG9ubHlcbiAgICAgIC8vIGluY2x1ZGUgdGhlIHN1YmFycmF5IHJlZ2lvbiBmcm9tIHRoZSB1bmRlcmx5aW5nIGJ1ZmZlclxuICAgICAgaWYgKGNodW5rLmJ5dGVMZW5ndGggIT09IGJ1Zi5ieXRlTGVuZ3RoKSB7XG4gICAgICAgIHZhciBjb3B5ID0gbmV3IFVpbnQ4QXJyYXkoY2h1bmsuYnl0ZUxlbmd0aCk7XG4gICAgICAgIGNvcHkuc2V0KG5ldyBVaW50OEFycmF5KGJ1ZiwgY2h1bmsuYnl0ZU9mZnNldCwgY2h1bmsuYnl0ZUxlbmd0aCkpO1xuICAgICAgICBidWYgPSBjb3B5LmJ1ZmZlcjtcbiAgICAgIH1cblxuICAgICAgYXJ5W2ldID0gYnVmO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBCbG9iQnVpbGRlckNvbnN0cnVjdG9yKGFyeSwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgYmIgPSBuZXcgQmxvYkJ1aWxkZXIoKTtcbiAgbWFwQXJyYXlCdWZmZXJWaWV3cyhhcnkpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgYmIuYXBwZW5kKGFyeVtpXSk7XG4gIH1cblxuICByZXR1cm4gKG9wdGlvbnMudHlwZSkgPyBiYi5nZXRCbG9iKG9wdGlvbnMudHlwZSkgOiBiYi5nZXRCbG9iKCk7XG59O1xuXG5mdW5jdGlvbiBCbG9iQ29uc3RydWN0b3IoYXJ5LCBvcHRpb25zKSB7XG4gIG1hcEFycmF5QnVmZmVyVmlld3MoYXJ5KTtcbiAgcmV0dXJuIG5ldyBCbG9iKGFyeSwgb3B0aW9ucyB8fCB7fSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcbiAgaWYgKGJsb2JTdXBwb3J0ZWQpIHtcbiAgICByZXR1cm4gYmxvYlN1cHBvcnRzQXJyYXlCdWZmZXJWaWV3ID8gZ2xvYmFsLkJsb2IgOiBCbG9iQ29uc3RydWN0b3I7XG4gIH0gZWxzZSBpZiAoYmxvYkJ1aWxkZXJTdXBwb3J0ZWQpIHtcbiAgICByZXR1cm4gQmxvYkJ1aWxkZXJDb25zdHJ1Y3RvcjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59KSgpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2Jsb2IvaW5kZXguanMiLCJcbi8qKlxuICogTW9kdWxlIHJlcXVpcmVtZW50cy5cbiAqL1xuXG52YXIgUG9sbGluZyA9IHJlcXVpcmUoJy4vcG9sbGluZycpO1xudmFyIGluaGVyaXQgPSByZXF1aXJlKCdjb21wb25lbnQtaW5oZXJpdCcpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gSlNPTlBQb2xsaW5nO1xuXG4vKipcbiAqIENhY2hlZCByZWd1bGFyIGV4cHJlc3Npb25zLlxuICovXG5cbnZhciByTmV3bGluZSA9IC9cXG4vZztcbnZhciByRXNjYXBlZE5ld2xpbmUgPSAvXFxcXG4vZztcblxuLyoqXG4gKiBHbG9iYWwgSlNPTlAgY2FsbGJhY2tzLlxuICovXG5cbnZhciBjYWxsYmFja3M7XG5cbi8qKlxuICogTm9vcC5cbiAqL1xuXG5mdW5jdGlvbiBlbXB0eSAoKSB7IH1cblxuLyoqXG4gKiBKU09OUCBQb2xsaW5nIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBKU09OUFBvbGxpbmcgKG9wdHMpIHtcbiAgUG9sbGluZy5jYWxsKHRoaXMsIG9wdHMpO1xuXG4gIHRoaXMucXVlcnkgPSB0aGlzLnF1ZXJ5IHx8IHt9O1xuXG4gIC8vIGRlZmluZSBnbG9iYWwgY2FsbGJhY2tzIGFycmF5IGlmIG5vdCBwcmVzZW50XG4gIC8vIHdlIGRvIHRoaXMgaGVyZSAobGF6aWx5KSB0byBhdm9pZCB1bm5lZWRlZCBnbG9iYWwgcG9sbHV0aW9uXG4gIGlmICghY2FsbGJhY2tzKSB7XG4gICAgLy8gd2UgbmVlZCB0byBjb25zaWRlciBtdWx0aXBsZSBlbmdpbmVzIGluIHRoZSBzYW1lIHBhZ2VcbiAgICBpZiAoIWdsb2JhbC5fX19laW8pIGdsb2JhbC5fX19laW8gPSBbXTtcbiAgICBjYWxsYmFja3MgPSBnbG9iYWwuX19fZWlvO1xuICB9XG5cbiAgLy8gY2FsbGJhY2sgaWRlbnRpZmllclxuICB0aGlzLmluZGV4ID0gY2FsbGJhY2tzLmxlbmd0aDtcblxuICAvLyBhZGQgY2FsbGJhY2sgdG8ganNvbnAgZ2xvYmFsXG4gIHZhciBzZWxmID0gdGhpcztcbiAgY2FsbGJhY2tzLnB1c2goZnVuY3Rpb24gKG1zZykge1xuICAgIHNlbGYub25EYXRhKG1zZyk7XG4gIH0pO1xuXG4gIC8vIGFwcGVuZCB0byBxdWVyeSBzdHJpbmdcbiAgdGhpcy5xdWVyeS5qID0gdGhpcy5pbmRleDtcblxuICAvLyBwcmV2ZW50IHNwdXJpb3VzIGVycm9ycyBmcm9tIGJlaW5nIGVtaXR0ZWQgd2hlbiB0aGUgd2luZG93IGlzIHVubG9hZGVkXG4gIGlmIChnbG9iYWwuZG9jdW1lbnQgJiYgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHNlbGYuc2NyaXB0KSBzZWxmLnNjcmlwdC5vbmVycm9yID0gZW1wdHk7XG4gICAgfSwgZmFsc2UpO1xuICB9XG59XG5cbi8qKlxuICogSW5oZXJpdHMgZnJvbSBQb2xsaW5nLlxuICovXG5cbmluaGVyaXQoSlNPTlBQb2xsaW5nLCBQb2xsaW5nKTtcblxuLypcbiAqIEpTT05QIG9ubHkgc3VwcG9ydHMgYmluYXJ5IGFzIGJhc2U2NCBlbmNvZGVkIHN0cmluZ3NcbiAqL1xuXG5KU09OUFBvbGxpbmcucHJvdG90eXBlLnN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG5cbi8qKlxuICogQ2xvc2VzIHRoZSBzb2NrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuSlNPTlBQb2xsaW5nLnByb3RvdHlwZS5kb0Nsb3NlID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5zY3JpcHQpIHtcbiAgICB0aGlzLnNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuc2NyaXB0KTtcbiAgICB0aGlzLnNjcmlwdCA9IG51bGw7XG4gIH1cblxuICBpZiAodGhpcy5mb3JtKSB7XG4gICAgdGhpcy5mb3JtLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5mb3JtKTtcbiAgICB0aGlzLmZvcm0gPSBudWxsO1xuICAgIHRoaXMuaWZyYW1lID0gbnVsbDtcbiAgfVxuXG4gIFBvbGxpbmcucHJvdG90eXBlLmRvQ2xvc2UuY2FsbCh0aGlzKTtcbn07XG5cbi8qKlxuICogU3RhcnRzIGEgcG9sbCBjeWNsZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5KU09OUFBvbGxpbmcucHJvdG90eXBlLmRvUG9sbCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG5cbiAgaWYgKHRoaXMuc2NyaXB0KSB7XG4gICAgdGhpcy5zY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnNjcmlwdCk7XG4gICAgdGhpcy5zY3JpcHQgPSBudWxsO1xuICB9XG5cbiAgc2NyaXB0LmFzeW5jID0gdHJ1ZTtcbiAgc2NyaXB0LnNyYyA9IHRoaXMudXJpKCk7XG4gIHNjcmlwdC5vbmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICBzZWxmLm9uRXJyb3IoJ2pzb25wIHBvbGwgZXJyb3InLCBlKTtcbiAgfTtcblxuICB2YXIgaW5zZXJ0QXQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2NyaXB0JylbMF07XG4gIGlmIChpbnNlcnRBdCkge1xuICAgIGluc2VydEF0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHNjcmlwdCwgaW5zZXJ0QXQpO1xuICB9IGVsc2Uge1xuICAgIChkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmJvZHkpLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gIH1cbiAgdGhpcy5zY3JpcHQgPSBzY3JpcHQ7XG5cbiAgdmFyIGlzVUFnZWNrbyA9ICd1bmRlZmluZWQnICE9PSB0eXBlb2YgbmF2aWdhdG9yICYmIC9nZWNrby9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbiAgaWYgKGlzVUFnZWNrbykge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICAgIH0sIDEwMCk7XG4gIH1cbn07XG5cbi8qKlxuICogV3JpdGVzIHdpdGggYSBoaWRkZW4gaWZyYW1lLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhIHRvIHNlbmRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxlZCB1cG9uIGZsdXNoLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuSlNPTlBQb2xsaW5nLnByb3RvdHlwZS5kb1dyaXRlID0gZnVuY3Rpb24gKGRhdGEsIGZuKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAoIXRoaXMuZm9ybSkge1xuICAgIHZhciBmb3JtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZm9ybScpO1xuICAgIHZhciBhcmVhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGV4dGFyZWEnKTtcbiAgICB2YXIgaWQgPSB0aGlzLmlmcmFtZUlkID0gJ2Vpb19pZnJhbWVfJyArIHRoaXMuaW5kZXg7XG4gICAgdmFyIGlmcmFtZTtcblxuICAgIGZvcm0uY2xhc3NOYW1lID0gJ3NvY2tldGlvJztcbiAgICBmb3JtLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICBmb3JtLnN0eWxlLnRvcCA9ICctMTAwMHB4JztcbiAgICBmb3JtLnN0eWxlLmxlZnQgPSAnLTEwMDBweCc7XG4gICAgZm9ybS50YXJnZXQgPSBpZDtcbiAgICBmb3JtLm1ldGhvZCA9ICdQT1NUJztcbiAgICBmb3JtLnNldEF0dHJpYnV0ZSgnYWNjZXB0LWNoYXJzZXQnLCAndXRmLTgnKTtcbiAgICBhcmVhLm5hbWUgPSAnZCc7XG4gICAgZm9ybS5hcHBlbmRDaGlsZChhcmVhKTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGZvcm0pO1xuXG4gICAgdGhpcy5mb3JtID0gZm9ybTtcbiAgICB0aGlzLmFyZWEgPSBhcmVhO1xuICB9XG5cbiAgdGhpcy5mb3JtLmFjdGlvbiA9IHRoaXMudXJpKCk7XG5cbiAgZnVuY3Rpb24gY29tcGxldGUgKCkge1xuICAgIGluaXRJZnJhbWUoKTtcbiAgICBmbigpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5pdElmcmFtZSAoKSB7XG4gICAgaWYgKHNlbGYuaWZyYW1lKSB7XG4gICAgICB0cnkge1xuICAgICAgICBzZWxmLmZvcm0ucmVtb3ZlQ2hpbGQoc2VsZi5pZnJhbWUpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBzZWxmLm9uRXJyb3IoJ2pzb25wIHBvbGxpbmcgaWZyYW1lIHJlbW92YWwgZXJyb3InLCBlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgLy8gaWU2IGR5bmFtaWMgaWZyYW1lcyB3aXRoIHRhcmdldD1cIlwiIHN1cHBvcnQgKHRoYW5rcyBDaHJpcyBMYW1iYWNoZXIpXG4gICAgICB2YXIgaHRtbCA9ICc8aWZyYW1lIHNyYz1cImphdmFzY3JpcHQ6MFwiIG5hbWU9XCInICsgc2VsZi5pZnJhbWVJZCArICdcIj4nO1xuICAgICAgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChodG1sKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICAgIGlmcmFtZS5uYW1lID0gc2VsZi5pZnJhbWVJZDtcbiAgICAgIGlmcmFtZS5zcmMgPSAnamF2YXNjcmlwdDowJztcbiAgICB9XG5cbiAgICBpZnJhbWUuaWQgPSBzZWxmLmlmcmFtZUlkO1xuXG4gICAgc2VsZi5mb3JtLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgc2VsZi5pZnJhbWUgPSBpZnJhbWU7XG4gIH1cblxuICBpbml0SWZyYW1lKCk7XG5cbiAgLy8gZXNjYXBlIFxcbiB0byBwcmV2ZW50IGl0IGZyb20gYmVpbmcgY29udmVydGVkIGludG8gXFxyXFxuIGJ5IHNvbWUgVUFzXG4gIC8vIGRvdWJsZSBlc2NhcGluZyBpcyByZXF1aXJlZCBmb3IgZXNjYXBlZCBuZXcgbGluZXMgYmVjYXVzZSB1bmVzY2FwaW5nIG9mIG5ldyBsaW5lcyBjYW4gYmUgZG9uZSBzYWZlbHkgb24gc2VydmVyLXNpZGVcbiAgZGF0YSA9IGRhdGEucmVwbGFjZShyRXNjYXBlZE5ld2xpbmUsICdcXFxcXFxuJyk7XG4gIHRoaXMuYXJlYS52YWx1ZSA9IGRhdGEucmVwbGFjZShyTmV3bGluZSwgJ1xcXFxuJyk7XG5cbiAgdHJ5IHtcbiAgICB0aGlzLmZvcm0uc3VibWl0KCk7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgaWYgKHRoaXMuaWZyYW1lLmF0dGFjaEV2ZW50KSB7XG4gICAgdGhpcy5pZnJhbWUub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHNlbGYuaWZyYW1lLnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcbiAgICAgICAgY29tcGxldGUoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHRoaXMuaWZyYW1lLm9ubG9hZCA9IGNvbXBsZXRlO1xuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvcG9sbGluZy1qc29ucC5qcyIsIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi4vdHJhbnNwb3J0Jyk7XG52YXIgcGFyc2VyID0gcmVxdWlyZSgnZW5naW5lLmlvLXBhcnNlcicpO1xudmFyIHBhcnNlcXMgPSByZXF1aXJlKCdwYXJzZXFzJyk7XG52YXIgaW5oZXJpdCA9IHJlcXVpcmUoJ2NvbXBvbmVudC1pbmhlcml0Jyk7XG52YXIgeWVhc3QgPSByZXF1aXJlKCd5ZWFzdCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnZW5naW5lLmlvLWNsaWVudDp3ZWJzb2NrZXQnKTtcbnZhciBCcm93c2VyV2ViU29ja2V0ID0gZ2xvYmFsLldlYlNvY2tldCB8fCBnbG9iYWwuTW96V2ViU29ja2V0O1xudmFyIE5vZGVXZWJTb2NrZXQ7XG5pZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgdHJ5IHtcbiAgICBOb2RlV2ViU29ja2V0ID0gcmVxdWlyZSgnd3MnKTtcbiAgfSBjYXRjaCAoZSkgeyB9XG59XG5cbi8qKlxuICogR2V0IGVpdGhlciB0aGUgYFdlYlNvY2tldGAgb3IgYE1veldlYlNvY2tldGAgZ2xvYmFsc1xuICogaW4gdGhlIGJyb3dzZXIgb3IgdHJ5IHRvIHJlc29sdmUgV2ViU29ja2V0LWNvbXBhdGlibGVcbiAqIGludGVyZmFjZSBleHBvc2VkIGJ5IGB3c2AgZm9yIE5vZGUtbGlrZSBlbnZpcm9ubWVudC5cbiAqL1xuXG52YXIgV2ViU29ja2V0ID0gQnJvd3NlcldlYlNvY2tldDtcbmlmICghV2ViU29ja2V0ICYmIHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gIFdlYlNvY2tldCA9IE5vZGVXZWJTb2NrZXQ7XG59XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBXUztcblxuLyoqXG4gKiBXZWJTb2NrZXQgdHJhbnNwb3J0IGNvbnN0cnVjdG9yLlxuICpcbiAqIEBhcGkge09iamVjdH0gY29ubmVjdGlvbiBvcHRpb25zXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFdTIChvcHRzKSB7XG4gIHZhciBmb3JjZUJhc2U2NCA9IChvcHRzICYmIG9wdHMuZm9yY2VCYXNlNjQpO1xuICBpZiAoZm9yY2VCYXNlNjQpIHtcbiAgICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG4gIH1cbiAgdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSA9IG9wdHMucGVyTWVzc2FnZURlZmxhdGU7XG4gIHRoaXMudXNpbmdCcm93c2VyV2ViU29ja2V0ID0gQnJvd3NlcldlYlNvY2tldCAmJiAhb3B0cy5mb3JjZU5vZGU7XG4gIHRoaXMucHJvdG9jb2xzID0gb3B0cy5wcm90b2NvbHM7XG4gIGlmICghdGhpcy51c2luZ0Jyb3dzZXJXZWJTb2NrZXQpIHtcbiAgICBXZWJTb2NrZXQgPSBOb2RlV2ViU29ja2V0O1xuICB9XG4gIFRyYW5zcG9ydC5jYWxsKHRoaXMsIG9wdHMpO1xufVxuXG4vKipcbiAqIEluaGVyaXRzIGZyb20gVHJhbnNwb3J0LlxuICovXG5cbmluaGVyaXQoV1MsIFRyYW5zcG9ydCk7XG5cbi8qKlxuICogVHJhbnNwb3J0IG5hbWUuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5XUy5wcm90b3R5cGUubmFtZSA9ICd3ZWJzb2NrZXQnO1xuXG4vKlxuICogV2ViU29ja2V0cyBzdXBwb3J0IGJpbmFyeVxuICovXG5cbldTLnByb3RvdHlwZS5zdXBwb3J0c0JpbmFyeSA9IHRydWU7XG5cbi8qKlxuICogT3BlbnMgc29ja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbldTLnByb3RvdHlwZS5kb09wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5jaGVjaygpKSB7XG4gICAgLy8gbGV0IHByb2JlIHRpbWVvdXRcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgdXJpID0gdGhpcy51cmkoKTtcbiAgdmFyIHByb3RvY29scyA9IHRoaXMucHJvdG9jb2xzO1xuICB2YXIgb3B0cyA9IHtcbiAgICBhZ2VudDogdGhpcy5hZ2VudCxcbiAgICBwZXJNZXNzYWdlRGVmbGF0ZTogdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZVxuICB9O1xuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICBvcHRzLnBmeCA9IHRoaXMucGZ4O1xuICBvcHRzLmtleSA9IHRoaXMua2V5O1xuICBvcHRzLnBhc3NwaHJhc2UgPSB0aGlzLnBhc3NwaHJhc2U7XG4gIG9wdHMuY2VydCA9IHRoaXMuY2VydDtcbiAgb3B0cy5jYSA9IHRoaXMuY2E7XG4gIG9wdHMuY2lwaGVycyA9IHRoaXMuY2lwaGVycztcbiAgb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQgPSB0aGlzLnJlamVjdFVuYXV0aG9yaXplZDtcbiAgaWYgKHRoaXMuZXh0cmFIZWFkZXJzKSB7XG4gICAgb3B0cy5oZWFkZXJzID0gdGhpcy5leHRyYUhlYWRlcnM7XG4gIH1cbiAgaWYgKHRoaXMubG9jYWxBZGRyZXNzKSB7XG4gICAgb3B0cy5sb2NhbEFkZHJlc3MgPSB0aGlzLmxvY2FsQWRkcmVzcztcbiAgfVxuXG4gIHRyeSB7XG4gICAgdGhpcy53cyA9IHRoaXMudXNpbmdCcm93c2VyV2ViU29ja2V0ID8gKHByb3RvY29scyA/IG5ldyBXZWJTb2NrZXQodXJpLCBwcm90b2NvbHMpIDogbmV3IFdlYlNvY2tldCh1cmkpKSA6IG5ldyBXZWJTb2NrZXQodXJpLCBwcm90b2NvbHMsIG9wdHMpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gIH1cblxuICBpZiAodGhpcy53cy5iaW5hcnlUeXBlID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG4gIH1cblxuICBpZiAodGhpcy53cy5zdXBwb3J0cyAmJiB0aGlzLndzLnN1cHBvcnRzLmJpbmFyeSkge1xuICAgIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSB0cnVlO1xuICAgIHRoaXMud3MuYmluYXJ5VHlwZSA9ICdub2RlYnVmZmVyJztcbiAgfSBlbHNlIHtcbiAgICB0aGlzLndzLmJpbmFyeVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICB9XG5cbiAgdGhpcy5hZGRFdmVudExpc3RlbmVycygpO1xufTtcblxuLyoqXG4gKiBBZGRzIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgc29ja2V0XG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdGhpcy53cy5vbm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5vbk9wZW4oKTtcbiAgfTtcbiAgdGhpcy53cy5vbmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIHNlbGYub25DbG9zZSgpO1xuICB9O1xuICB0aGlzLndzLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChldikge1xuICAgIHNlbGYub25EYXRhKGV2LmRhdGEpO1xuICB9O1xuICB0aGlzLndzLm9uZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgIHNlbGYub25FcnJvcignd2Vic29ja2V0IGVycm9yJywgZSk7XG4gIH07XG59O1xuXG4vKipcbiAqIFdyaXRlcyBkYXRhIHRvIHNvY2tldC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBvZiBwYWNrZXRzLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHBhY2tldHMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgLy8gZW5jb2RlUGFja2V0IGVmZmljaWVudCBhcyBpdCB1c2VzIFdTIGZyYW1pbmdcbiAgLy8gbm8gbmVlZCBmb3IgZW5jb2RlUGF5bG9hZFxuICB2YXIgdG90YWwgPSBwYWNrZXRzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB0b3RhbDsgaSA8IGw7IGkrKykge1xuICAgIChmdW5jdGlvbiAocGFja2V0KSB7XG4gICAgICBwYXJzZXIuZW5jb2RlUGFja2V0KHBhY2tldCwgc2VsZi5zdXBwb3J0c0JpbmFyeSwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgaWYgKCFzZWxmLnVzaW5nQnJvd3NlcldlYlNvY2tldCkge1xuICAgICAgICAgIC8vIGFsd2F5cyBjcmVhdGUgYSBuZXcgb2JqZWN0IChHSC00MzcpXG4gICAgICAgICAgdmFyIG9wdHMgPSB7fTtcbiAgICAgICAgICBpZiAocGFja2V0Lm9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdHMuY29tcHJlc3MgPSBwYWNrZXQub3B0aW9ucy5jb21wcmVzcztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VsZi5wZXJNZXNzYWdlRGVmbGF0ZSkge1xuICAgICAgICAgICAgdmFyIGxlbiA9ICdzdHJpbmcnID09PSB0eXBlb2YgZGF0YSA/IGdsb2JhbC5CdWZmZXIuYnl0ZUxlbmd0aChkYXRhKSA6IGRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGxlbiA8IHNlbGYucGVyTWVzc2FnZURlZmxhdGUudGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgIG9wdHMuY29tcHJlc3MgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTb21ldGltZXMgdGhlIHdlYnNvY2tldCBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZCBidXQgdGhlIGJyb3dzZXIgZGlkbid0XG4gICAgICAgIC8vIGhhdmUgYSBjaGFuY2Ugb2YgaW5mb3JtaW5nIHVzIGFib3V0IGl0IHlldCwgaW4gdGhhdCBjYXNlIHNlbmQgd2lsbFxuICAgICAgICAvLyB0aHJvdyBhbiBlcnJvclxuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChzZWxmLnVzaW5nQnJvd3NlcldlYlNvY2tldCkge1xuICAgICAgICAgICAgLy8gVHlwZUVycm9yIGlzIHRocm93biB3aGVuIHBhc3NpbmcgdGhlIHNlY29uZCBhcmd1bWVudCBvbiBTYWZhcmlcbiAgICAgICAgICAgIHNlbGYud3Muc2VuZChkYXRhKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi53cy5zZW5kKGRhdGEsIG9wdHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGRlYnVnKCd3ZWJzb2NrZXQgY2xvc2VkIGJlZm9yZSBvbmNsb3NlIGV2ZW50Jyk7XG4gICAgICAgIH1cblxuICAgICAgICAtLXRvdGFsIHx8IGRvbmUoKTtcbiAgICAgIH0pO1xuICAgIH0pKHBhY2tldHNbaV0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZG9uZSAoKSB7XG4gICAgc2VsZi5lbWl0KCdmbHVzaCcpO1xuXG4gICAgLy8gZmFrZSBkcmFpblxuICAgIC8vIGRlZmVyIHRvIG5leHQgdGljayB0byBhbGxvdyBTb2NrZXQgdG8gY2xlYXIgd3JpdGVCdWZmZXJcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYud3JpdGFibGUgPSB0cnVlO1xuICAgICAgc2VsZi5lbWl0KCdkcmFpbicpO1xuICAgIH0sIDApO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGNsb3NlXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLm9uQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIFRyYW5zcG9ydC5wcm90b3R5cGUub25DbG9zZS5jYWxsKHRoaXMpO1xufTtcblxuLyoqXG4gKiBDbG9zZXMgc29ja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbldTLnByb3RvdHlwZS5kb0Nsb3NlID0gZnVuY3Rpb24gKCkge1xuICBpZiAodHlwZW9mIHRoaXMud3MgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhpcy53cy5jbG9zZSgpO1xuICB9XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyB1cmkgZm9yIGNvbm5lY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLnVyaSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHF1ZXJ5ID0gdGhpcy5xdWVyeSB8fCB7fTtcbiAgdmFyIHNjaGVtYSA9IHRoaXMuc2VjdXJlID8gJ3dzcycgOiAnd3MnO1xuICB2YXIgcG9ydCA9ICcnO1xuXG4gIC8vIGF2b2lkIHBvcnQgaWYgZGVmYXVsdCBmb3Igc2NoZW1hXG4gIGlmICh0aGlzLnBvcnQgJiYgKCgnd3NzJyA9PT0gc2NoZW1hICYmIE51bWJlcih0aGlzLnBvcnQpICE9PSA0NDMpIHx8XG4gICAgKCd3cycgPT09IHNjaGVtYSAmJiBOdW1iZXIodGhpcy5wb3J0KSAhPT0gODApKSkge1xuICAgIHBvcnQgPSAnOicgKyB0aGlzLnBvcnQ7XG4gIH1cblxuICAvLyBhcHBlbmQgdGltZXN0YW1wIHRvIFVSSVxuICBpZiAodGhpcy50aW1lc3RhbXBSZXF1ZXN0cykge1xuICAgIHF1ZXJ5W3RoaXMudGltZXN0YW1wUGFyYW1dID0geWVhc3QoKTtcbiAgfVxuXG4gIC8vIGNvbW11bmljYXRlIGJpbmFyeSBzdXBwb3J0IGNhcGFiaWxpdGllc1xuICBpZiAoIXRoaXMuc3VwcG9ydHNCaW5hcnkpIHtcbiAgICBxdWVyeS5iNjQgPSAxO1xuICB9XG5cbiAgcXVlcnkgPSBwYXJzZXFzLmVuY29kZShxdWVyeSk7XG5cbiAgLy8gcHJlcGVuZCA/IHRvIHF1ZXJ5XG4gIGlmIChxdWVyeS5sZW5ndGgpIHtcbiAgICBxdWVyeSA9ICc/JyArIHF1ZXJ5O1xuICB9XG5cbiAgdmFyIGlwdjYgPSB0aGlzLmhvc3RuYW1lLmluZGV4T2YoJzonKSAhPT0gLTE7XG4gIHJldHVybiBzY2hlbWEgKyAnOi8vJyArIChpcHY2ID8gJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyA6IHRoaXMuaG9zdG5hbWUpICsgcG9ydCArIHRoaXMucGF0aCArIHF1ZXJ5O1xufTtcblxuLyoqXG4gKiBGZWF0dXJlIGRldGVjdGlvbiBmb3IgV2ViU29ja2V0LlxuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHdoZXRoZXIgdGhpcyB0cmFuc3BvcnQgaXMgYXZhaWxhYmxlLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5XUy5wcm90b3R5cGUuY2hlY2sgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhIVdlYlNvY2tldCAmJiAhKCdfX2luaXRpYWxpemUnIGluIFdlYlNvY2tldCAmJiB0aGlzLm5hbWUgPT09IFdTLnByb3RvdHlwZS5uYW1lKTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy93ZWJzb2NrZXQuanMiLCIvKiAoaWdub3JlZCkgKi9cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyB3cyAoaWdub3JlZClcbi8vIG1vZHVsZSBpZCA9IDg1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gdG9BcnJheVxuXG5mdW5jdGlvbiB0b0FycmF5KGxpc3QsIGluZGV4KSB7XG4gICAgdmFyIGFycmF5ID0gW11cblxuICAgIGluZGV4ID0gaW5kZXggfHwgMFxuXG4gICAgZm9yICh2YXIgaSA9IGluZGV4IHx8IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFycmF5W2kgLSBpbmRleF0gPSBsaXN0W2ldXG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvdG8tYXJyYXkvaW5kZXguanMiLCJcbi8qKlxuICogRXhwb3NlIGBCYWNrb2ZmYC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJhY2tvZmY7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBiYWNrb2ZmIHRpbWVyIHdpdGggYG9wdHNgLlxuICpcbiAqIC0gYG1pbmAgaW5pdGlhbCB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyBbMTAwXVxuICogLSBgbWF4YCBtYXggdGltZW91dCBbMTAwMDBdXG4gKiAtIGBqaXR0ZXJgIFswXVxuICogLSBgZmFjdG9yYCBbMl1cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBCYWNrb2ZmKG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIHRoaXMubXMgPSBvcHRzLm1pbiB8fCAxMDA7XG4gIHRoaXMubWF4ID0gb3B0cy5tYXggfHwgMTAwMDA7XG4gIHRoaXMuZmFjdG9yID0gb3B0cy5mYWN0b3IgfHwgMjtcbiAgdGhpcy5qaXR0ZXIgPSBvcHRzLmppdHRlciA+IDAgJiYgb3B0cy5qaXR0ZXIgPD0gMSA/IG9wdHMuaml0dGVyIDogMDtcbiAgdGhpcy5hdHRlbXB0cyA9IDA7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBiYWNrb2ZmIGR1cmF0aW9uLlxuICpcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQmFja29mZi5wcm90b3R5cGUuZHVyYXRpb24gPSBmdW5jdGlvbigpe1xuICB2YXIgbXMgPSB0aGlzLm1zICogTWF0aC5wb3codGhpcy5mYWN0b3IsIHRoaXMuYXR0ZW1wdHMrKyk7XG4gIGlmICh0aGlzLmppdHRlcikge1xuICAgIHZhciByYW5kID0gIE1hdGgucmFuZG9tKCk7XG4gICAgdmFyIGRldmlhdGlvbiA9IE1hdGguZmxvb3IocmFuZCAqIHRoaXMuaml0dGVyICogbXMpO1xuICAgIG1zID0gKE1hdGguZmxvb3IocmFuZCAqIDEwKSAmIDEpID09IDAgID8gbXMgLSBkZXZpYXRpb24gOiBtcyArIGRldmlhdGlvbjtcbiAgfVxuICByZXR1cm4gTWF0aC5taW4obXMsIHRoaXMubWF4KSB8IDA7XG59O1xuXG4vKipcbiAqIFJlc2V0IHRoZSBudW1iZXIgb2YgYXR0ZW1wdHMuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5CYWNrb2ZmLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMuYXR0ZW1wdHMgPSAwO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIG1pbmltdW0gZHVyYXRpb25cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkJhY2tvZmYucHJvdG90eXBlLnNldE1pbiA9IGZ1bmN0aW9uKG1pbil7XG4gIHRoaXMubXMgPSBtaW47XG59O1xuXG4vKipcbiAqIFNldCB0aGUgbWF4aW11bSBkdXJhdGlvblxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQmFja29mZi5wcm90b3R5cGUuc2V0TWF4ID0gZnVuY3Rpb24obWF4KXtcbiAgdGhpcy5tYXggPSBtYXg7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgaml0dGVyXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5CYWNrb2ZmLnByb3RvdHlwZS5zZXRKaXR0ZXIgPSBmdW5jdGlvbihqaXR0ZXIpe1xuICB0aGlzLmppdHRlciA9IGppdHRlcjtcbn07XG5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9iYWNrbzIvaW5kZXguanMiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9DaGF0QXJlYS5jc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIFByZXBhcmUgY3NzVHJhbnNmb3JtYXRpb25cbnZhciB0cmFuc2Zvcm07XG5cbnZhciBvcHRpb25zID0ge1wiaG1yXCI6dHJ1ZX1cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcIikoY29udGVudCwgb3B0aW9ucyk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vQ2hhdEFyZWEuY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL0NoYXRBcmVhLmNzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvY29tcG9uZW50cy9jaGF0L0NoYXRBcmVhLmNzc1xuLy8gbW9kdWxlIGlkID0gODhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKShmYWxzZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyIS4vc3JjL2NvbXBvbmVudHMvY2hhdC9DaGF0QXJlYS5jc3Ncbi8vIG1vZHVsZSBpZCA9IDg5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL0NoYXRMb2cuY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBQcmVwYXJlIGNzc1RyYW5zZm9ybWF0aW9uXG52YXIgdHJhbnNmb3JtO1xuXG52YXIgb3B0aW9ucyA9IHtcImhtclwiOnRydWV9XG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL0NoYXRMb2cuY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL0NoYXRMb2cuY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9jb21wb25lbnRzL2NoYXQvQ2hhdExvZy5jc3Ncbi8vIG1vZHVsZSBpZCA9IDkwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoZmFsc2UpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLmNoYXRsb2cge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcGFsZWdyZWVuO1xcbiAgb3ZlcmZsb3cteTogc2Nyb2xsO1xcbiAgaGVpZ2h0OiA3MHZoO1xcbn1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyIS4vc3JjL2NvbXBvbmVudHMvY2hhdC9DaGF0TG9nLmNzc1xuLy8gbW9kdWxlIGlkID0gOTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vQ2hhdFVzZXJzLmNzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gUHJlcGFyZSBjc3NUcmFuc2Zvcm1hdGlvblxudmFyIHRyYW5zZm9ybTtcblxudmFyIG9wdGlvbnMgPSB7XCJobXJcIjp0cnVlfVxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9DaGF0VXNlcnMuY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL0NoYXRVc2Vycy5jc3NcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2NvbXBvbmVudHMvY2hhdC9DaGF0VXNlcnMuY3NzXG4vLyBtb2R1bGUgaWQgPSA5MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKGZhbHNlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5jaGF0dXNlcnMge1xcbiAgb3ZlcmZsb3cteTogc2Nyb2xsO1xcbiAgaGVpZ2h0OiA3MHZoO1xcbn1cXG5cXG4uY2hhdHVzZXJzID4gdWx7XFxuICBsaXN0LXN0eWxlOiBub25lO1xcbiAgcGFkZGluZy1sZWZ0OiAwO1xcbiAgcGFkZGluZy10b3A6IDA7XFxufVxcblxcbi50bXBtZXNzYWdlIHtcXG4gIGJhY2tncm91bmQtY29sb3I6IGxpZ2h0Y29yYWw7XFxufVwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIhLi9zcmMvY29tcG9uZW50cy9jaGF0L0NoYXRVc2Vycy5jc3Ncbi8vIG1vZHVsZSBpZCA9IDkzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIE1lc3NhZ2VIb2xkZXIge1xuICBzdGF0aWMgYWRkTWVzc2FnZSAobmFtZSwgY29sb3JDb2RlLCBib2R5KSB7XG4gICAgTWVzc2FnZUhvbGRlci5saXN0LnB1c2goe1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIGNvbG9yQ29kZTogY29sb3JDb2RlLFxuICAgICAgYm9keTogYm9keVxuICAgIH0pXG4gIH1cblxuICBzdGF0aWMgZ2V0TWVzc2FnZXMgKCkge1xuICAgIHJldHVybiBNZXNzYWdlSG9sZGVyLmxpc3RcbiAgfVxufVxuXG5NZXNzYWdlSG9sZGVyLmxpc3QgPSBbXVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2RhdGEvTWVzc2FnZUhvbGRlci5qcyJdLCJzb3VyY2VSb290IjoiIn0=